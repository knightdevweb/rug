window.utils = {};

window.utils.loadLoaders = function() {
    let loaders = document.createElement("style");
    loaders.innerHTML = `.lds-dual-ring {
        color: #fff;
      }
      .lds-dual-ring,
      .lds-dual-ring:after {
        box-sizing: border-box;
      }
      .lds-dual-ring {
        display: inline-block;
        width: 80px;
        height: 80px;
      }
      .lds-dual-ring:after {
        content: " ";
        display: block;
        width: 64px;
        height: 64px;
        margin: 8px;
        border-radius: 50%;
        border: 6.4px solid currentColor;
        border-color: currentColor transparent currentColor transparent;
        animation: lds-dual-ring 1.2s linear infinite;
      }
      @keyframes lds-dual-ring {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }`;
    return document.head.appendChild(loaders);
};

window.utils.loadFont = function (url, fontName) {
    return new Promise((resolve, reject) => {
        let fontImport = document.createElement("style");
        fontImport.innerHTML = `@import url("${url}");`;
        document.head.appendChild(fontImport);

        let fontFace = new FontFace(fontName, `url(${url})`);
        fontFace.load().then(function(loadedFontFace) {
            document.fonts.add(loadedFontFace);
            return resolve({
                "success": true
            });
        }).catch(() => {
            return resolve({
                "success": false
            });
        });
    });
};

window.utils.loadMainImports = function(solanaName, tokenName) {

    (function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g[solanaName] = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({"@solana/web3.js":[function(require,module,exports){
    'use strict';
    
    Object.defineProperty(exports, '__esModule', { value: true });
    
    var buffer = require('buffer');
    var sha512 = require('@noble/hashes/sha512');
    var ed25519 = require('@noble/ed25519');
    var BN = require('bn.js');
    var bs58 = require('bs58');
    var sha256 = require('@noble/hashes/sha256');
    var borsh = require('borsh');
    var BufferLayout = require('@solana/buffer-layout');
    var bigintBuffer = require('bigint-buffer');
    var superstruct = require('superstruct');
    var rpcWebsockets = require('rpc-websockets');
    var RpcClient = require('jayson/lib/client/browser');
    var sha3 = require('@noble/hashes/sha3');
    var hmac = require('@noble/hashes/hmac');
    var secp256k1 = require('@noble/secp256k1');
    
    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }
    
    function _interopNamespace(e) {
      if (e && e.__esModule) return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function (k) {
          if (k !== 'default') {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function () { return e[k]; }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    
    var ed25519__namespace = /*#__PURE__*/_interopNamespace(ed25519);
    var BN__default = /*#__PURE__*/_interopDefaultLegacy(BN);
    var bs58__default = /*#__PURE__*/_interopDefaultLegacy(bs58);
    var BufferLayout__namespace = /*#__PURE__*/_interopNamespace(BufferLayout);
    var RpcClient__default = /*#__PURE__*/_interopDefaultLegacy(RpcClient);
    var secp256k1__namespace = /*#__PURE__*/_interopNamespace(secp256k1);
    
    /**
     * A 64 byte secret key, the first 32 bytes of which is the
     * private scalar and the last 32 bytes is the public key.
     * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
     */
    
    ed25519__namespace.utils.sha512Sync = (...m) => sha512.sha512(ed25519__namespace.utils.concatBytes(...m));
    
    const generatePrivateKey = ed25519__namespace.utils.randomPrivateKey;
    const generateKeypair = () => {
      const privateScalar = ed25519__namespace.utils.randomPrivateKey();
      const publicKey = getPublicKey(privateScalar);
      const secretKey = new Uint8Array(64);
      secretKey.set(privateScalar);
      secretKey.set(publicKey, 32);
      return {
        publicKey,
        secretKey
      };
    };
    const getPublicKey = ed25519__namespace.sync.getPublicKey;
    function isOnCurve(publicKey) {
      try {
        ed25519__namespace.Point.fromHex(publicKey, true
        /* strict */
        );
        return true;
      } catch {
        return false;
      }
    }
    const sign = (message, secretKey) => ed25519__namespace.sync.sign(message, secretKey.slice(0, 32));
    const verify = ed25519__namespace.sync.verify;
    
    const toBuffer = arr => {
      if (buffer.Buffer.isBuffer(arr)) {
        return arr;
      } else if (arr instanceof Uint8Array) {
        return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
      } else {
        return buffer.Buffer.from(arr);
      }
    };
    
    class Struct {
      constructor(properties) {
        Object.assign(this, properties);
      }
    
      encode() {
        return buffer.Buffer.from(borsh.serialize(SOLANA_SCHEMA, this));
      }
    
      static decode(data) {
        return borsh.deserialize(SOLANA_SCHEMA, this, data);
      }
    
      static decodeUnchecked(data) {
        return borsh.deserializeUnchecked(SOLANA_SCHEMA, this, data);
      }
    
    } // Class representing a Rust-compatible enum, since enums are only strings or
    // numbers in pure JS
    
    class Enum extends Struct {
      constructor(properties) {
        super(properties);
        this.enum = '';
    
        if (Object.keys(properties).length !== 1) {
          throw new Error('Enum can only take single value');
        }
    
        Object.keys(properties).map(key => {
          this.enum = key;
        });
      }
    
    }
    const SOLANA_SCHEMA = new Map();
    
    /**
     * Maximum length of derived pubkey seed
     */
    
    const MAX_SEED_LENGTH = 32;
    /**
     * Size of public key in bytes
     */
    
    const PUBLIC_KEY_LENGTH = 32;
    /**
     * Value to be converted into public key
     */
    
    function isPublicKeyData(value) {
      return value._bn !== undefined;
    } // local counter used by PublicKey.unique()
    
    
    let uniquePublicKeyCounter = 1;
    /**
     * A public key
     */
    
    class PublicKey extends Struct {
      /** @internal */
    
      /**
       * Create a new PublicKey object
       * @param value ed25519 public key as buffer or base-58 encoded string
       */
      constructor(value) {
        super({});
        this._bn = void 0;
    
        if (isPublicKeyData(value)) {
          this._bn = value._bn;
        } else {
          if (typeof value === 'string') {
            // assume base 58 encoding by default
            const decoded = bs58__default["default"].decode(value);
    
            if (decoded.length != PUBLIC_KEY_LENGTH) {
              throw new Error(`Invalid public key input`);
            }
    
            this._bn = new BN__default["default"](decoded);
          } else {
            this._bn = new BN__default["default"](value);
          }
    
          if (this._bn.byteLength() > 32) {
            throw new Error(`Invalid public key input`);
          }
        }
      }
      /**
       * Returns a unique PublicKey for tests and benchmarks using acounter
       */
    
    
      static unique() {
        const key = new PublicKey(uniquePublicKeyCounter);
        uniquePublicKeyCounter += 1;
        return new PublicKey(key.toBuffer());
      }
      /**
       * Default public key value. (All zeros)
       */
    
    
      /**
       * Checks if two publicKeys are equal
       */
      equals(publicKey) {
        return this._bn.eq(publicKey._bn);
      }
      /**
       * Return the base-58 representation of the public key
       */
    
    
      toBase58() {
        return bs58__default["default"].encode(this.toBytes());
      }
    
      toJSON() {
        return this.toBase58();
      }
      /**
       * Return the byte array representation of the public key
       */
    
    
      toBytes() {
        return this.toBuffer();
      }
      /**
       * Return the Buffer representation of the public key
       */
    
    
      toBuffer() {
        const b = this._bn.toArrayLike(buffer.Buffer);
    
        if (b.length === PUBLIC_KEY_LENGTH) {
          return b;
        }
    
        const zeroPad = buffer.Buffer.alloc(32);
        b.copy(zeroPad, 32 - b.length);
        return zeroPad;
      }
      /**
       * Return the base-58 representation of the public key
       */
    
    
      toString() {
        return this.toBase58();
      }
      /**
       * Derive a public key from another key, a seed, and a program ID.
       * The program ID will also serve as the owner of the public key, giving
       * it permission to write data to the account.
       */
    
      /* eslint-disable require-await */
    
    
      static async createWithSeed(fromPublicKey, seed, programId) {
        const buffer$1 = buffer.Buffer.concat([fromPublicKey.toBuffer(), buffer.Buffer.from(seed), programId.toBuffer()]);
        const publicKeyBytes = sha256.sha256(buffer$1);
        return new PublicKey(publicKeyBytes);
      }
      /**
       * Derive a program address from seeds and a program ID.
       */
    
      /* eslint-disable require-await */
    
    
      static createProgramAddressSync(seeds, programId) {
        let buffer$1 = buffer.Buffer.alloc(0);
        seeds.forEach(function (seed) {
          if (seed.length > MAX_SEED_LENGTH) {
            throw new TypeError(`Max seed length exceeded`);
          }
    
          buffer$1 = buffer.Buffer.concat([buffer$1, toBuffer(seed)]);
        });
        buffer$1 = buffer.Buffer.concat([buffer$1, programId.toBuffer(), buffer.Buffer.from('ProgramDerivedAddress')]);
        const publicKeyBytes = sha256.sha256(buffer$1);
    
        if (isOnCurve(publicKeyBytes)) {
          throw new Error(`Invalid seeds, address must fall off the curve`);
        }
    
        return new PublicKey(publicKeyBytes);
      }
      /**
       * Async version of createProgramAddressSync
       * For backwards compatibility
       */
    
      /* eslint-disable require-await */
    
    
      static async createProgramAddress(seeds, programId) {
        return this.createProgramAddressSync(seeds, programId);
      }
      /**
       * Find a valid program address
       *
       * Valid program addresses must fall off the ed25519 curve.  This function
       * iterates a nonce until it finds one that when combined with the seeds
       * results in a valid program address.
       */
    
    
      static findProgramAddressSync(seeds, programId) {
        let nonce = 255;
        let address;
    
        while (nonce != 0) {
          try {
            const seedsWithNonce = seeds.concat(buffer.Buffer.from([nonce]));
            address = this.createProgramAddressSync(seedsWithNonce, programId);
          } catch (err) {
            if (err instanceof TypeError) {
              throw err;
            }
    
            nonce--;
            continue;
          }
    
          return [address, nonce];
        }
    
        throw new Error(`Unable to find a viable program address nonce`);
      }
      /**
       * Async version of findProgramAddressSync
       * For backwards compatibility
       */
    
    
      static async findProgramAddress(seeds, programId) {
        return this.findProgramAddressSync(seeds, programId);
      }
      /**
       * Check that a pubkey is on the ed25519 curve.
       */
    
    
      static isOnCurve(pubkeyData) {
        const pubkey = new PublicKey(pubkeyData);
        return isOnCurve(pubkey.toBytes());
      }
    
    }
    PublicKey.default = new PublicKey('11111111111111111111111111111111');
    SOLANA_SCHEMA.set(PublicKey, {
      kind: 'struct',
      fields: [['_bn', 'u256']]
    });
    
    /**
     * An account key pair (public and secret keys).
     *
     * @deprecated since v1.10.0, please use {@link Keypair} instead.
     */
    
    class Account {
      /** @internal */
    
      /** @internal */
    
      /**
       * Create a new Account object
       *
       * If the secretKey parameter is not provided a new key pair is randomly
       * created for the account
       *
       * @param secretKey Secret key for the account
       */
      constructor(secretKey) {
        this._publicKey = void 0;
        this._secretKey = void 0;
    
        if (secretKey) {
          const secretKeyBuffer = toBuffer(secretKey);
    
          if (secretKey.length !== 64) {
            throw new Error('bad secret key size');
          }
    
          this._publicKey = secretKeyBuffer.slice(32, 64);
          this._secretKey = secretKeyBuffer.slice(0, 32);
        } else {
          this._secretKey = toBuffer(generatePrivateKey());
          this._publicKey = toBuffer(getPublicKey(this._secretKey));
        }
      }
      /**
       * The public key for this account
       */
    
    
      get publicKey() {
        return new PublicKey(this._publicKey);
      }
      /**
       * The **unencrypted** secret key for this account. The first 32 bytes
       * is the private scalar and the last 32 bytes is the public key.
       * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
       */
    
    
      get secretKey() {
        return buffer.Buffer.concat([this._secretKey, this._publicKey], 64);
      }
    
    }
    
    const BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey('BPFLoader1111111111111111111111111111111111');
    
    /**
     * Maximum over-the-wire size of a Transaction
     *
     * 1280 is IPv6 minimum MTU
     * 40 bytes is the size of the IPv6 header
     * 8 bytes is the size of the fragment header
     */
    const PACKET_DATA_SIZE = 1280 - 40 - 8;
    const VERSION_PREFIX_MASK = 0x7f;
    const SIGNATURE_LENGTH_IN_BYTES = 64;
    
    class TransactionExpiredBlockheightExceededError extends Error {
      constructor(signature) {
        super(`Signature ${signature} has expired: block height exceeded.`);
        this.signature = void 0;
        this.signature = signature;
      }
    
    }
    Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, 'name', {
      value: 'TransactionExpiredBlockheightExceededError'
    });
    class TransactionExpiredTimeoutError extends Error {
      constructor(signature, timeoutSeconds) {
        super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + 'unknown if it succeeded or failed. Check signature ' + `${signature} using the Solana Explorer or CLI tools.`);
        this.signature = void 0;
        this.signature = signature;
      }
    
    }
    Object.defineProperty(TransactionExpiredTimeoutError.prototype, 'name', {
      value: 'TransactionExpiredTimeoutError'
    });
    
    class MessageAccountKeys {
      constructor(staticAccountKeys, accountKeysFromLookups) {
        this.staticAccountKeys = void 0;
        this.accountKeysFromLookups = void 0;
        this.staticAccountKeys = staticAccountKeys;
        this.accountKeysFromLookups = accountKeysFromLookups;
      }
    
      keySegments() {
        const keySegments = [this.staticAccountKeys];
    
        if (this.accountKeysFromLookups) {
          keySegments.push(this.accountKeysFromLookups.writable);
          keySegments.push(this.accountKeysFromLookups.readonly);
        }
    
        return keySegments;
      }
    
      get(index) {
        for (const keySegment of this.keySegments()) {
          if (index < keySegment.length) {
            return keySegment[index];
          } else {
            index -= keySegment.length;
          }
        }
    
        return;
      }
    
      get length() {
        return this.keySegments().flat().length;
      }
    
      compileInstructions(instructions) {
        // Bail early if any account indexes would overflow a u8
        const U8_MAX = 255;
    
        if (this.length > U8_MAX + 1) {
          throw new Error('Account index overflow encountered during compilation');
        }
    
        const keyIndexMap = new Map();
        this.keySegments().flat().forEach((key, index) => {
          keyIndexMap.set(key.toBase58(), index);
        });
    
        const findKeyIndex = key => {
          const keyIndex = keyIndexMap.get(key.toBase58());
          if (keyIndex === undefined) throw new Error('Encountered an unknown instruction account key during compilation');
          return keyIndex;
        };
    
        return instructions.map(instruction => {
          return {
            programIdIndex: findKeyIndex(instruction.programId),
            accountKeyIndexes: instruction.keys.map(meta => findKeyIndex(meta.pubkey)),
            data: instruction.data
          };
        });
      }
    
    }
    
    /**
     * Layout for a public key
     */
    const publicKey = (property = 'publicKey') => {
      return BufferLayout__namespace.blob(32, property);
    };
    /**
     * Layout for a signature
     */
    
    const signature = (property = 'signature') => {
      return BufferLayout__namespace.blob(64, property);
    };
    
    /**
     * Layout for a Rust String type
     */
    const rustString = (property = 'string') => {
      const rsl = BufferLayout__namespace.struct([BufferLayout__namespace.u32('length'), BufferLayout__namespace.u32('lengthPadding'), BufferLayout__namespace.blob(BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'chars')], property);
    
      const _decode = rsl.decode.bind(rsl);
    
      const _encode = rsl.encode.bind(rsl);
    
      const rslShim = rsl;
    
      rslShim.decode = (b, offset) => {
        const data = _decode(b, offset);
    
        return data['chars'].toString();
      };
    
      rslShim.encode = (str, b, offset) => {
        const data = {
          chars: buffer.Buffer.from(str, 'utf8')
        };
        return _encode(data, b, offset);
      };
    
      rslShim.alloc = str => {
        return BufferLayout__namespace.u32().span + BufferLayout__namespace.u32().span + buffer.Buffer.from(str, 'utf8').length;
      };
    
      return rslShim;
    };
    /**
     * Layout for an Authorized object
     */
    
    const authorized = (property = 'authorized') => {
      return BufferLayout__namespace.struct([publicKey('staker'), publicKey('withdrawer')], property);
    };
    /**
     * Layout for a Lockup object
     */
    
    const lockup = (property = 'lockup') => {
      return BufferLayout__namespace.struct([BufferLayout__namespace.ns64('unixTimestamp'), BufferLayout__namespace.ns64('epoch'), publicKey('custodian')], property);
    };
    /**
     *  Layout for a VoteInit object
     */
    
    const voteInit = (property = 'voteInit') => {
      return BufferLayout__namespace.struct([publicKey('nodePubkey'), publicKey('authorizedVoter'), publicKey('authorizedWithdrawer'), BufferLayout__namespace.u8('commission')], property);
    };
    /**
     *  Layout for a VoteAuthorizeWithSeedArgs object
     */
    
    const voteAuthorizeWithSeedArgs = (property = 'voteAuthorizeWithSeedArgs') => {
      return BufferLayout__namespace.struct([BufferLayout__namespace.u32('voteAuthorizationType'), publicKey('currentAuthorityDerivedKeyOwnerPubkey'), rustString('currentAuthorityDerivedKeySeed'), publicKey('newAuthorized')], property);
    };
    function getAlloc(type, fields) {
      const getItemAlloc = item => {
        if (item.span >= 0) {
          return item.span;
        } else if (typeof item.alloc === 'function') {
          return item.alloc(fields[item.property]);
        } else if ('count' in item && 'elementLayout' in item) {
          const field = fields[item.property];
    
          if (Array.isArray(field)) {
            return field.length * getItemAlloc(item.elementLayout);
          }
        } else if ('fields' in item) {
          // This is a `Structure` whose size needs to be recursively measured.
          return getAlloc({
            layout: item
          }, fields[item.property]);
        } // Couldn't determine allocated size of layout
    
    
        return 0;
      };
    
      let alloc = 0;
      type.layout.fields.forEach(item => {
        alloc += getItemAlloc(item);
      });
      return alloc;
    }
    
    function decodeLength(bytes) {
      let len = 0;
      let size = 0;
    
      for (;;) {
        let elem = bytes.shift();
        len |= (elem & 0x7f) << size * 7;
        size += 1;
    
        if ((elem & 0x80) === 0) {
          break;
        }
      }
    
      return len;
    }
    function encodeLength(bytes, len) {
      let rem_len = len;
    
      for (;;) {
        let elem = rem_len & 0x7f;
        rem_len >>= 7;
    
        if (rem_len == 0) {
          bytes.push(elem);
          break;
        } else {
          elem |= 0x80;
          bytes.push(elem);
        }
      }
    }
    
    function assert (condition, message) {
      if (!condition) {
        throw new Error(message || 'Assertion failed');
      }
    }
    
    class CompiledKeys {
      constructor(payer, keyMetaMap) {
        this.payer = void 0;
        this.keyMetaMap = void 0;
        this.payer = payer;
        this.keyMetaMap = keyMetaMap;
      }
    
      static compile(instructions, payer) {
        const keyMetaMap = new Map();
    
        const getOrInsertDefault = pubkey => {
          const address = pubkey.toBase58();
          let keyMeta = keyMetaMap.get(address);
    
          if (keyMeta === undefined) {
            keyMeta = {
              isSigner: false,
              isWritable: false,
              isInvoked: false
            };
            keyMetaMap.set(address, keyMeta);
          }
    
          return keyMeta;
        };
    
        const payerKeyMeta = getOrInsertDefault(payer);
        payerKeyMeta.isSigner = true;
        payerKeyMeta.isWritable = true;
    
        for (const ix of instructions) {
          getOrInsertDefault(ix.programId).isInvoked = true;
    
          for (const accountMeta of ix.keys) {
            const keyMeta = getOrInsertDefault(accountMeta.pubkey);
            keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
            keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
          }
        }
    
        return new CompiledKeys(payer, keyMetaMap);
      }
    
      getMessageComponents() {
        const mapEntries = [...this.keyMetaMap.entries()];
        assert(mapEntries.length <= 256, 'Max static account keys length exceeded');
        const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
        const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
        const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
        const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
        const header = {
          numRequiredSignatures: writableSigners.length + readonlySigners.length,
          numReadonlySignedAccounts: readonlySigners.length,
          numReadonlyUnsignedAccounts: readonlyNonSigners.length
        }; // sanity checks
    
        {
          assert(writableSigners.length > 0, 'Expected at least one writable signer key');
          const [payerAddress] = writableSigners[0];
          assert(payerAddress === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');
        }
        const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];
        return [header, staticAccountKeys];
      }
    
      extractTableLookup(lookupTable) {
        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable); // Don't extract lookup if no keys were found
    
        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
          return;
        }
    
        return [{
          accountKey: lookupTable.key,
          writableIndexes,
          readonlyIndexes
        }, {
          writable: drainedWritableKeys,
          readonly: drainedReadonlyKeys
        }];
      }
      /** @internal */
    
    
      drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
        const lookupTableIndexes = new Array();
        const drainedKeys = new Array();
    
        for (const [address, keyMeta] of this.keyMetaMap.entries()) {
          if (keyMetaFilter(keyMeta)) {
            const key = new PublicKey(address);
            const lookupTableIndex = lookupTableEntries.findIndex(entry => entry.equals(key));
    
            if (lookupTableIndex >= 0) {
              assert(lookupTableIndex < 256, 'Max lookup table index exceeded');
              lookupTableIndexes.push(lookupTableIndex);
              drainedKeys.push(key);
              this.keyMetaMap.delete(address);
            }
          }
        }
    
        return [lookupTableIndexes, drainedKeys];
      }
    
    }
    
    /**
     * An instruction to execute by a program
     *
     * @property {number} programIdIndex
     * @property {number[]} accounts
     * @property {string} data
     */
    
    /**
     * List of instructions to be processed atomically
     */
    class Message {
      constructor(args) {
        this.header = void 0;
        this.accountKeys = void 0;
        this.recentBlockhash = void 0;
        this.instructions = void 0;
        this.indexToProgramIds = new Map();
        this.header = args.header;
        this.accountKeys = args.accountKeys.map(account => new PublicKey(account));
        this.recentBlockhash = args.recentBlockhash;
        this.instructions = args.instructions;
        this.instructions.forEach(ix => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
      }
    
      get version() {
        return 'legacy';
      }
    
      get staticAccountKeys() {
        return this.accountKeys;
      }
    
      get compiledInstructions() {
        return this.instructions.map(ix => ({
          programIdIndex: ix.programIdIndex,
          accountKeyIndexes: ix.accounts,
          data: bs58__default["default"].decode(ix.data)
        }));
      }
    
      get addressTableLookups() {
        return [];
      }
    
      getAccountKeys() {
        return new MessageAccountKeys(this.staticAccountKeys);
      }
    
      static compile(args) {
        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
        const accountKeys = new MessageAccountKeys(staticAccountKeys);
        const instructions = accountKeys.compileInstructions(args.instructions).map(ix => ({
          programIdIndex: ix.programIdIndex,
          accounts: ix.accountKeyIndexes,
          data: bs58__default["default"].encode(ix.data)
        }));
        return new Message({
          header,
          accountKeys: staticAccountKeys,
          recentBlockhash: args.recentBlockhash,
          instructions
        });
      }
    
      isAccountSigner(index) {
        return index < this.header.numRequiredSignatures;
      }
    
      isAccountWritable(index) {
        const numSignedAccounts = this.header.numRequiredSignatures;
    
        if (index >= this.header.numRequiredSignatures) {
          const unsignedAccountIndex = index - numSignedAccounts;
          const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
          const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
          return unsignedAccountIndex < numWritableUnsignedAccounts;
        } else {
          const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
          return index < numWritableSignedAccounts;
        }
      }
    
      isProgramId(index) {
        return this.indexToProgramIds.has(index);
      }
    
      programIds() {
        return [...this.indexToProgramIds.values()];
      }
    
      nonProgramIds() {
        return this.accountKeys.filter((_, index) => !this.isProgramId(index));
      }
    
      serialize() {
        const numKeys = this.accountKeys.length;
        let keyCount = [];
        encodeLength(keyCount, numKeys);
        const instructions = this.instructions.map(instruction => {
          const {
            accounts,
            programIdIndex
          } = instruction;
          const data = Array.from(bs58__default["default"].decode(instruction.data));
          let keyIndicesCount = [];
          encodeLength(keyIndicesCount, accounts.length);
          let dataCount = [];
          encodeLength(dataCount, data.length);
          return {
            programIdIndex,
            keyIndicesCount: buffer.Buffer.from(keyIndicesCount),
            keyIndices: accounts,
            dataLength: buffer.Buffer.from(dataCount),
            data
          };
        });
        let instructionCount = [];
        encodeLength(instructionCount, instructions.length);
        let instructionBuffer = buffer.Buffer.alloc(PACKET_DATA_SIZE);
        buffer.Buffer.from(instructionCount).copy(instructionBuffer);
        let instructionBufferLength = instructionCount.length;
        instructions.forEach(instruction => {
          const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8('programIdIndex'), BufferLayout__namespace.blob(instruction.keyIndicesCount.length, 'keyIndicesCount'), BufferLayout__namespace.seq(BufferLayout__namespace.u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), BufferLayout__namespace.blob(instruction.dataLength.length, 'dataLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8('userdatum'), instruction.data.length, 'data')]);
          const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
          instructionBufferLength += length;
        });
        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
        const signDataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(1, 'numRequiredSignatures'), BufferLayout__namespace.blob(1, 'numReadonlySignedAccounts'), BufferLayout__namespace.blob(1, 'numReadonlyUnsignedAccounts'), BufferLayout__namespace.blob(keyCount.length, 'keyCount'), BufferLayout__namespace.seq(publicKey('key'), numKeys, 'keys'), publicKey('recentBlockhash')]);
        const transaction = {
          numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),
          numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
          numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
          keyCount: buffer.Buffer.from(keyCount),
          keys: this.accountKeys.map(key => toBuffer(key.toBytes())),
          recentBlockhash: bs58__default["default"].decode(this.recentBlockhash)
        };
        let signData = buffer.Buffer.alloc(2048);
        const length = signDataLayout.encode(transaction, signData);
        instructionBuffer.copy(signData, length);
        return signData.slice(0, length + instructionBuffer.length);
      }
      /**
       * Decode a compiled message into a Message object.
       */
    
    
      static from(buffer$1) {
        // Slice up wire data
        let byteArray = [...buffer$1];
        const numRequiredSignatures = byteArray.shift();
    
        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
          throw new Error('Versioned messages must be deserialized with VersionedMessage.deserialize()');
        }
    
        const numReadonlySignedAccounts = byteArray.shift();
        const numReadonlyUnsignedAccounts = byteArray.shift();
        const accountCount = decodeLength(byteArray);
        let accountKeys = [];
    
        for (let i = 0; i < accountCount; i++) {
          const account = byteArray.slice(0, PUBLIC_KEY_LENGTH);
          byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
          accountKeys.push(new PublicKey(buffer.Buffer.from(account)));
        }
    
        const recentBlockhash = byteArray.slice(0, PUBLIC_KEY_LENGTH);
        byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
        const instructionCount = decodeLength(byteArray);
        let instructions = [];
    
        for (let i = 0; i < instructionCount; i++) {
          const programIdIndex = byteArray.shift();
          const accountCount = decodeLength(byteArray);
          const accounts = byteArray.slice(0, accountCount);
          byteArray = byteArray.slice(accountCount);
          const dataLength = decodeLength(byteArray);
          const dataSlice = byteArray.slice(0, dataLength);
          const data = bs58__default["default"].encode(buffer.Buffer.from(dataSlice));
          byteArray = byteArray.slice(dataLength);
          instructions.push({
            programIdIndex,
            accounts,
            data
          });
        }
    
        const messageArgs = {
          header: {
            numRequiredSignatures,
            numReadonlySignedAccounts,
            numReadonlyUnsignedAccounts
          },
          recentBlockhash: bs58__default["default"].encode(buffer.Buffer.from(recentBlockhash)),
          accountKeys,
          instructions
        };
        return new Message(messageArgs);
      }
    
    }
    
    /**
     * Message constructor arguments
     */
    
    class MessageV0 {
      constructor(args) {
        this.header = void 0;
        this.staticAccountKeys = void 0;
        this.recentBlockhash = void 0;
        this.compiledInstructions = void 0;
        this.addressTableLookups = void 0;
        this.header = args.header;
        this.staticAccountKeys = args.staticAccountKeys;
        this.recentBlockhash = args.recentBlockhash;
        this.compiledInstructions = args.compiledInstructions;
        this.addressTableLookups = args.addressTableLookups;
      }
    
      get version() {
        return 0;
      }
    
      get numAccountKeysFromLookups() {
        let count = 0;
    
        for (const lookup of this.addressTableLookups) {
          count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
        }
    
        return count;
      }
    
      getAccountKeys(args) {
        let accountKeysFromLookups;
    
        if (args && 'accountKeysFromLookups' in args) {
          if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
            throw new Error('Failed to get account keys because of a mismatch in the number of account keys from lookups');
          }
    
          accountKeysFromLookups = args.accountKeysFromLookups;
        } else if (args && 'addressLookupTableAccounts' in args) {
          accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
        } else if (this.addressTableLookups.length > 0) {
          throw new Error('Failed to get account keys because address table lookups were not resolved');
        }
    
        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
      }
    
      isAccountSigner(index) {
        return index < this.header.numRequiredSignatures;
      }
    
      isAccountWritable(index) {
        const numSignedAccounts = this.header.numRequiredSignatures;
        const numStaticAccountKeys = this.staticAccountKeys.length;
    
        if (index >= numStaticAccountKeys) {
          const lookupAccountKeysIndex = index - numStaticAccountKeys;
          const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);
          return lookupAccountKeysIndex < numWritableLookupAccountKeys;
        } else if (index >= this.header.numRequiredSignatures) {
          const unsignedAccountIndex = index - numSignedAccounts;
          const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
          const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
          return unsignedAccountIndex < numWritableUnsignedAccounts;
        } else {
          const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
          return index < numWritableSignedAccounts;
        }
      }
    
      resolveAddressTableLookups(addressLookupTableAccounts) {
        const accountKeysFromLookups = {
          writable: [],
          readonly: []
        };
    
        for (const tableLookup of this.addressTableLookups) {
          const tableAccount = addressLookupTableAccounts.find(account => account.key.equals(tableLookup.accountKey));
    
          if (!tableAccount) {
            throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
          }
    
          for (const index of tableLookup.writableIndexes) {
            if (index < tableAccount.state.addresses.length) {
              accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
            } else {
              throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
            }
          }
    
          for (const index of tableLookup.readonlyIndexes) {
            if (index < tableAccount.state.addresses.length) {
              accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
            } else {
              throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
            }
          }
        }
    
        return accountKeysFromLookups;
      }
    
      static compile(args) {
        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
        const addressTableLookups = new Array();
        const accountKeysFromLookups = {
          writable: new Array(),
          readonly: new Array()
        };
        const lookupTableAccounts = args.addressLookupTableAccounts || [];
    
        for (const lookupTable of lookupTableAccounts) {
          const extractResult = compiledKeys.extractTableLookup(lookupTable);
    
          if (extractResult !== undefined) {
            const [addressTableLookup, {
              writable,
              readonly
            }] = extractResult;
            addressTableLookups.push(addressTableLookup);
            accountKeysFromLookups.writable.push(...writable);
            accountKeysFromLookups.readonly.push(...readonly);
          }
        }
    
        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
        const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
        const compiledInstructions = accountKeys.compileInstructions(args.instructions);
        return new MessageV0({
          header,
          staticAccountKeys,
          recentBlockhash: args.recentBlockhash,
          compiledInstructions,
          addressTableLookups
        });
      }
    
      serialize() {
        const encodedStaticAccountKeysLength = Array();
        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
        const serializedInstructions = this.serializeInstructions();
        const encodedInstructionsLength = Array();
        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
        const serializedAddressTableLookups = this.serializeAddressTableLookups();
        const encodedAddressTableLookupsLength = Array();
        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
        const messageLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8('prefix'), BufferLayout__namespace.struct([BufferLayout__namespace.u8('numRequiredSignatures'), BufferLayout__namespace.u8('numReadonlySignedAccounts'), BufferLayout__namespace.u8('numReadonlyUnsignedAccounts')], 'header'), BufferLayout__namespace.blob(encodedStaticAccountKeysLength.length, 'staticAccountKeysLength'), BufferLayout__namespace.seq(publicKey(), this.staticAccountKeys.length, 'staticAccountKeys'), publicKey('recentBlockhash'), BufferLayout__namespace.blob(encodedInstructionsLength.length, 'instructionsLength'), BufferLayout__namespace.blob(serializedInstructions.length, 'serializedInstructions'), BufferLayout__namespace.blob(encodedAddressTableLookupsLength.length, 'addressTableLookupsLength'), BufferLayout__namespace.blob(serializedAddressTableLookups.length, 'serializedAddressTableLookups')]);
        const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
        const MESSAGE_VERSION_0_PREFIX = 1 << 7;
        const serializedMessageLength = messageLayout.encode({
          prefix: MESSAGE_VERSION_0_PREFIX,
          header: this.header,
          staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
          staticAccountKeys: this.staticAccountKeys.map(key => key.toBytes()),
          recentBlockhash: bs58__default["default"].decode(this.recentBlockhash),
          instructionsLength: new Uint8Array(encodedInstructionsLength),
          serializedInstructions,
          addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
          serializedAddressTableLookups
        }, serializedMessage);
        return serializedMessage.slice(0, serializedMessageLength);
      }
    
      serializeInstructions() {
        let serializedLength = 0;
        const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
    
        for (const instruction of this.compiledInstructions) {
          const encodedAccountKeyIndexesLength = Array();
          encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
          const encodedDataLength = Array();
          encodeLength(encodedDataLength, instruction.data.length);
          const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8('programIdIndex'), BufferLayout__namespace.blob(encodedAccountKeyIndexesLength.length, 'encodedAccountKeyIndexesLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), instruction.accountKeyIndexes.length, 'accountKeyIndexes'), BufferLayout__namespace.blob(encodedDataLength.length, 'encodedDataLength'), BufferLayout__namespace.blob(instruction.data.length, 'data')]);
          serializedLength += instructionLayout.encode({
            programIdIndex: instruction.programIdIndex,
            encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
            accountKeyIndexes: instruction.accountKeyIndexes,
            encodedDataLength: new Uint8Array(encodedDataLength),
            data: instruction.data
          }, serializedInstructions, serializedLength);
        }
    
        return serializedInstructions.slice(0, serializedLength);
      }
    
      serializeAddressTableLookups() {
        let serializedLength = 0;
        const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
    
        for (const lookup of this.addressTableLookups) {
          const encodedWritableIndexesLength = Array();
          encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
          const encodedReadonlyIndexesLength = Array();
          encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
          const addressTableLookupLayout = BufferLayout__namespace.struct([publicKey('accountKey'), BufferLayout__namespace.blob(encodedWritableIndexesLength.length, 'encodedWritableIndexesLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.writableIndexes.length, 'writableIndexes'), BufferLayout__namespace.blob(encodedReadonlyIndexesLength.length, 'encodedReadonlyIndexesLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.readonlyIndexes.length, 'readonlyIndexes')]);
          serializedLength += addressTableLookupLayout.encode({
            accountKey: lookup.accountKey.toBytes(),
            encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
            writableIndexes: lookup.writableIndexes,
            encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
            readonlyIndexes: lookup.readonlyIndexes
          }, serializedAddressTableLookups, serializedLength);
        }
    
        return serializedAddressTableLookups.slice(0, serializedLength);
      }
    
      static deserialize(serializedMessage) {
        let byteArray = [...serializedMessage];
        const prefix = byteArray.shift();
        const maskedPrefix = prefix & VERSION_PREFIX_MASK;
        assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
        const version = maskedPrefix;
        assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);
        const header = {
          numRequiredSignatures: byteArray.shift(),
          numReadonlySignedAccounts: byteArray.shift(),
          numReadonlyUnsignedAccounts: byteArray.shift()
        };
        const staticAccountKeys = [];
        const staticAccountKeysLength = decodeLength(byteArray);
    
        for (let i = 0; i < staticAccountKeysLength; i++) {
          staticAccountKeys.push(new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH)));
        }
    
        const recentBlockhash = bs58__default["default"].encode(byteArray.splice(0, PUBLIC_KEY_LENGTH));
        const instructionCount = decodeLength(byteArray);
        const compiledInstructions = [];
    
        for (let i = 0; i < instructionCount; i++) {
          const programIdIndex = byteArray.shift();
          const accountKeyIndexesLength = decodeLength(byteArray);
          const accountKeyIndexes = byteArray.splice(0, accountKeyIndexesLength);
          const dataLength = decodeLength(byteArray);
          const data = new Uint8Array(byteArray.splice(0, dataLength));
          compiledInstructions.push({
            programIdIndex,
            accountKeyIndexes,
            data
          });
        }
    
        const addressTableLookupsCount = decodeLength(byteArray);
        const addressTableLookups = [];
    
        for (let i = 0; i < addressTableLookupsCount; i++) {
          const accountKey = new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH));
          const writableIndexesLength = decodeLength(byteArray);
          const writableIndexes = byteArray.splice(0, writableIndexesLength);
          const readonlyIndexesLength = decodeLength(byteArray);
          const readonlyIndexes = byteArray.splice(0, readonlyIndexesLength);
          addressTableLookups.push({
            accountKey,
            writableIndexes,
            readonlyIndexes
          });
        }
    
        return new MessageV0({
          header,
          staticAccountKeys,
          recentBlockhash,
          compiledInstructions,
          addressTableLookups
        });
      }
    
    }
    
    // eslint-disable-next-line no-redeclare
    const VersionedMessage = {
      deserializeMessageVersion(serializedMessage) {
        const prefix = serializedMessage[0];
        const maskedPrefix = prefix & VERSION_PREFIX_MASK; // if the highest bit of the prefix is not set, the message is not versioned
    
        if (maskedPrefix === prefix) {
          return 'legacy';
        } // the lower 7 bits of the prefix indicate the message version
    
    
        return maskedPrefix;
      },
    
      deserialize: serializedMessage => {
        const version = VersionedMessage.deserializeMessageVersion(serializedMessage);
    
        if (version === 'legacy') {
          return Message.from(serializedMessage);
        }
    
        if (version === 0) {
          return MessageV0.deserialize(serializedMessage);
        } else {
          throw new Error(`Transaction message version ${version} deserialization is not supported`);
        }
      }
    };
    
    /**
     * Transaction signature as base-58 encoded string
     */
    
    exports.TransactionStatus = void 0;
    /**
     * Default (empty) signature
     */
    
    (function (TransactionStatus) {
      TransactionStatus[TransactionStatus["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
      TransactionStatus[TransactionStatus["PROCESSED"] = 1] = "PROCESSED";
      TransactionStatus[TransactionStatus["TIMED_OUT"] = 2] = "TIMED_OUT";
    })(exports.TransactionStatus || (exports.TransactionStatus = {}));
    
    const DEFAULT_SIGNATURE = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
    /**
     * Account metadata used to define instructions
     */
    
    /**
     * Transaction Instruction class
     */
    class TransactionInstruction {
      /**
       * Public keys to include in this transaction
       * Boolean represents whether this pubkey needs to sign the transaction
       */
    
      /**
       * Program Id to execute
       */
    
      /**
       * Program input
       */
      constructor(opts) {
        this.keys = void 0;
        this.programId = void 0;
        this.data = buffer.Buffer.alloc(0);
        this.programId = opts.programId;
        this.keys = opts.keys;
    
        if (opts.data) {
          this.data = opts.data;
        }
      }
      /**
       * @internal
       */
    
    
      toJSON() {
        return {
          keys: this.keys.map(({
            pubkey,
            isSigner,
            isWritable
          }) => ({
            pubkey: pubkey.toJSON(),
            isSigner,
            isWritable
          })),
          programId: this.programId.toJSON(),
          data: [...this.data]
        };
      }
    
    }
    /**
     * Pair of signature and corresponding public key
     */
    
    /**
     * Transaction class
     */
    class Transaction {
      /**
       * Signatures for the transaction.  Typically created by invoking the
       * `sign()` method
       */
    
      /**
       * The first (payer) Transaction signature
       */
      get signature() {
        if (this.signatures.length > 0) {
          return this.signatures[0].signature;
        }
    
        return null;
      }
      /**
       * The transaction fee payer
       */
    
    
      /**
       * Construct an empty Transaction
       */
      constructor(opts) {
        this.signatures = [];
        this.feePayer = void 0;
        this.instructions = [];
        this.recentBlockhash = void 0;
        this.lastValidBlockHeight = void 0;
        this.nonceInfo = void 0;
        this._message = void 0;
        this._json = void 0;
    
        if (!opts) {
          return;
        }
    
        if (opts.feePayer) {
          this.feePayer = opts.feePayer;
        }
    
        if (opts.signatures) {
          this.signatures = opts.signatures;
        }
    
        if (Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')) {
          const {
            blockhash,
            lastValidBlockHeight
          } = opts;
          this.recentBlockhash = blockhash;
          this.lastValidBlockHeight = lastValidBlockHeight;
        } else {
          const {
            recentBlockhash,
            nonceInfo
          } = opts;
    
          if (nonceInfo) {
            this.nonceInfo = nonceInfo;
          }
    
          this.recentBlockhash = recentBlockhash;
        }
      }
      /**
       * @internal
       */
    
    
      toJSON() {
        return {
          recentBlockhash: this.recentBlockhash || null,
          feePayer: this.feePayer ? this.feePayer.toJSON() : null,
          nonceInfo: this.nonceInfo ? {
            nonce: this.nonceInfo.nonce,
            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
          } : null,
          instructions: this.instructions.map(instruction => instruction.toJSON()),
          signers: this.signatures.map(({
            publicKey
          }) => {
            return publicKey.toJSON();
          })
        };
      }
      /**
       * Add one or more instructions to this Transaction
       */
    
    
      add(...items) {
        if (items.length === 0) {
          throw new Error('No instructions');
        }
    
        items.forEach(item => {
          if ('instructions' in item) {
            this.instructions = this.instructions.concat(item.instructions);
          } else if ('data' in item && 'programId' in item && 'keys' in item) {
            this.instructions.push(item);
          } else {
            this.instructions.push(new TransactionInstruction(item));
          }
        });
        return this;
      }
      /**
       * Compile transaction data
       */
    
    
      compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
          return this._message;
        }
    
        let recentBlockhash;
        let instructions;
    
        if (this.nonceInfo) {
          recentBlockhash = this.nonceInfo.nonce;
    
          if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
            instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
          } else {
            instructions = this.instructions;
          }
        } else {
          recentBlockhash = this.recentBlockhash;
          instructions = this.instructions;
        }
    
        if (!recentBlockhash) {
          throw new Error('Transaction recentBlockhash required');
        }
    
        if (instructions.length < 1) {
          console.warn('No instructions provided');
        }
    
        let feePayer;
    
        if (this.feePayer) {
          feePayer = this.feePayer;
        } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
          // Use implicit fee payer
          feePayer = this.signatures[0].publicKey;
        } else {
          throw new Error('Transaction fee payer required');
        }
    
        for (let i = 0; i < instructions.length; i++) {
          if (instructions[i].programId === undefined) {
            throw new Error(`Transaction instruction index ${i} has undefined program id`);
          }
        }
    
        const programIds = [];
        const accountMetas = [];
        instructions.forEach(instruction => {
          instruction.keys.forEach(accountMeta => {
            accountMetas.push({ ...accountMeta
            });
          });
          const programId = instruction.programId.toString();
    
          if (!programIds.includes(programId)) {
            programIds.push(programId);
          }
        }); // Append programID account metas
    
        programIds.forEach(programId => {
          accountMetas.push({
            pubkey: new PublicKey(programId),
            isSigner: false,
            isWritable: false
          });
        }); // Cull duplicate account metas
    
        const uniqueMetas = [];
        accountMetas.forEach(accountMeta => {
          const pubkeyString = accountMeta.pubkey.toString();
          const uniqueIndex = uniqueMetas.findIndex(x => {
            return x.pubkey.toString() === pubkeyString;
          });
    
          if (uniqueIndex > -1) {
            uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
            uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
          } else {
            uniqueMetas.push(accountMeta);
          }
        }); // Sort. Prioritizing first by signer, then by writable
    
        uniqueMetas.sort(function (x, y) {
          if (x.isSigner !== y.isSigner) {
            // Signers always come before non-signers
            return x.isSigner ? -1 : 1;
          }
    
          if (x.isWritable !== y.isWritable) {
            // Writable accounts always come before read-only accounts
            return x.isWritable ? -1 : 1;
          } // Otherwise, sort by pubkey, stringwise.
    
    
          return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58());
        }); // Move fee payer to the front
    
        const feePayerIndex = uniqueMetas.findIndex(x => {
          return x.pubkey.equals(feePayer);
        });
    
        if (feePayerIndex > -1) {
          const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
          payerMeta.isSigner = true;
          payerMeta.isWritable = true;
          uniqueMetas.unshift(payerMeta);
        } else {
          uniqueMetas.unshift({
            pubkey: feePayer,
            isSigner: true,
            isWritable: true
          });
        } // Disallow unknown signers
    
    
        for (const signature of this.signatures) {
          const uniqueIndex = uniqueMetas.findIndex(x => {
            return x.pubkey.equals(signature.publicKey);
          });
    
          if (uniqueIndex > -1) {
            if (!uniqueMetas[uniqueIndex].isSigner) {
              uniqueMetas[uniqueIndex].isSigner = true;
              console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');
            }
          } else {
            throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
          }
        }
    
        let numRequiredSignatures = 0;
        let numReadonlySignedAccounts = 0;
        let numReadonlyUnsignedAccounts = 0; // Split out signing from non-signing keys and count header values
    
        const signedKeys = [];
        const unsignedKeys = [];
        uniqueMetas.forEach(({
          pubkey,
          isSigner,
          isWritable
        }) => {
          if (isSigner) {
            signedKeys.push(pubkey.toString());
            numRequiredSignatures += 1;
    
            if (!isWritable) {
              numReadonlySignedAccounts += 1;
            }
          } else {
            unsignedKeys.push(pubkey.toString());
    
            if (!isWritable) {
              numReadonlyUnsignedAccounts += 1;
            }
          }
        });
        const accountKeys = signedKeys.concat(unsignedKeys);
        const compiledInstructions = instructions.map(instruction => {
          const {
            data,
            programId
          } = instruction;
          return {
            programIdIndex: accountKeys.indexOf(programId.toString()),
            accounts: instruction.keys.map(meta => accountKeys.indexOf(meta.pubkey.toString())),
            data: bs58__default["default"].encode(data)
          };
        });
        compiledInstructions.forEach(instruction => {
          assert(instruction.programIdIndex >= 0);
          instruction.accounts.forEach(keyIndex => assert(keyIndex >= 0));
        });
        return new Message({
          header: {
            numRequiredSignatures,
            numReadonlySignedAccounts,
            numReadonlyUnsignedAccounts
          },
          accountKeys,
          recentBlockhash,
          instructions: compiledInstructions
        });
      }
      /**
       * @internal
       */
    
    
      _compile() {
        const message = this.compileMessage();
        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    
        if (this.signatures.length === signedKeys.length) {
          const valid = this.signatures.every((pair, index) => {
            return signedKeys[index].equals(pair.publicKey);
          });
          if (valid) return message;
        }
    
        this.signatures = signedKeys.map(publicKey => ({
          signature: null,
          publicKey
        }));
        return message;
      }
      /**
       * Get a buffer of the Transaction data that need to be covered by signatures
       */
    
    
      serializeMessage() {
        return this._compile().serialize();
      }
      /**
       * Get the estimated fee associated with a transaction
       */
    
    
      async getEstimatedFee(connection) {
        return (await connection.getFeeForMessage(this.compileMessage())).value;
      }
      /**
       * Specify the public keys which will be used to sign the Transaction.
       * The first signer will be used as the transaction fee payer account.
       *
       * Signatures can be added with either `partialSign` or `addSignature`
       *
       * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
       * specified and it can be set in the Transaction constructor or with the
       * `feePayer` property.
       */
    
    
      setSigners(...signers) {
        if (signers.length === 0) {
          throw new Error('No signers');
        }
    
        const seen = new Set();
        this.signatures = signers.filter(publicKey => {
          const key = publicKey.toString();
    
          if (seen.has(key)) {
            return false;
          } else {
            seen.add(key);
            return true;
          }
        }).map(publicKey => ({
          signature: null,
          publicKey
        }));
      }
      /**
       * Sign the Transaction with the specified signers. Multiple signatures may
       * be applied to a Transaction. The first signature is considered "primary"
       * and is used identify and confirm transactions.
       *
       * If the Transaction `feePayer` is not set, the first signer will be used
       * as the transaction fee payer account.
       *
       * Transaction fields should not be modified after the first call to `sign`,
       * as doing so may invalidate the signature and cause the Transaction to be
       * rejected.
       *
       * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
       */
    
    
      sign(...signers) {
        if (signers.length === 0) {
          throw new Error('No signers');
        } // Dedupe signers
    
    
        const seen = new Set();
        const uniqueSigners = [];
    
        for (const signer of signers) {
          const key = signer.publicKey.toString();
    
          if (seen.has(key)) {
            continue;
          } else {
            seen.add(key);
            uniqueSigners.push(signer);
          }
        }
    
        this.signatures = uniqueSigners.map(signer => ({
          signature: null,
          publicKey: signer.publicKey
        }));
    
        const message = this._compile();
    
        this._partialSign(message, ...uniqueSigners);
      }
      /**
       * Partially sign a transaction with the specified accounts. All accounts must
       * correspond to either the fee payer or a signer account in the transaction
       * instructions.
       *
       * All the caveats from the `sign` method apply to `partialSign`
       */
    
    
      partialSign(...signers) {
        if (signers.length === 0) {
          throw new Error('No signers');
        } // Dedupe signers
    
    
        const seen = new Set();
        const uniqueSigners = [];
    
        for (const signer of signers) {
          const key = signer.publicKey.toString();
    
          if (seen.has(key)) {
            continue;
          } else {
            seen.add(key);
            uniqueSigners.push(signer);
          }
        }
    
        const message = this._compile();
    
        this._partialSign(message, ...uniqueSigners);
      }
      /**
       * @internal
       */
    
    
      _partialSign(message, ...signers) {
        const signData = message.serialize();
        signers.forEach(signer => {
          const signature = sign(signData, signer.secretKey);
    
          this._addSignature(signer.publicKey, toBuffer(signature));
        });
      }
      /**
       * Add an externally created signature to a transaction. The public key
       * must correspond to either the fee payer or a signer account in the transaction
       * instructions.
       */
    
    
      addSignature(pubkey, signature) {
        this._compile(); // Ensure signatures array is populated
    
    
        this._addSignature(pubkey, signature);
      }
      /**
       * @internal
       */
    
    
      _addSignature(pubkey, signature) {
        assert(signature.length === 64);
        const index = this.signatures.findIndex(sigpair => pubkey.equals(sigpair.publicKey));
    
        if (index < 0) {
          throw new Error(`unknown signer: ${pubkey.toString()}`);
        }
    
        this.signatures[index].signature = buffer.Buffer.from(signature);
      }
      /**
       * Verify signatures of a complete, signed Transaction
       */
    
    
      verifySignatures() {
        return this._verifySignatures(this.serializeMessage(), true);
      }
      /**
       * @internal
       */
    
    
      _verifySignatures(signData, requireAllSignatures) {
        for (const {
          signature,
          publicKey
        } of this.signatures) {
          if (signature === null) {
            if (requireAllSignatures) {
              return false;
            }
          } else {
            if (!verify(signature, signData, publicKey.toBuffer())) {
              return false;
            }
          }
        }
    
        return true;
      }
      /**
       * Serialize the Transaction in the wire format.
       */
    
    
      serialize(config) {
        const {
          requireAllSignatures,
          verifySignatures
        } = Object.assign({
          requireAllSignatures: true,
          verifySignatures: true
        }, config);
        const signData = this.serializeMessage();
    
        if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {
          throw new Error('Signature verification failed');
        }
    
        return this._serialize(signData);
      }
      /**
       * @internal
       */
    
    
      _serialize(signData) {
        const {
          signatures
        } = this;
        const signatureCount = [];
        encodeLength(signatureCount, signatures.length);
        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
        const wireTransaction = buffer.Buffer.alloc(transactionLength);
        assert(signatures.length < 256);
        buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);
        signatures.forEach(({
          signature
        }, index) => {
          if (signature !== null) {
            assert(signature.length === 64, `signature has invalid length`);
            buffer.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
          }
        });
        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
        assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
        return wireTransaction;
      }
      /**
       * Deprecated method
       * @internal
       */
    
    
      get keys() {
        assert(this.instructions.length === 1);
        return this.instructions[0].keys.map(keyObj => keyObj.pubkey);
      }
      /**
       * Deprecated method
       * @internal
       */
    
    
      get programId() {
        assert(this.instructions.length === 1);
        return this.instructions[0].programId;
      }
      /**
       * Deprecated method
       * @internal
       */
    
    
      get data() {
        assert(this.instructions.length === 1);
        return this.instructions[0].data;
      }
      /**
       * Parse a wire transaction into a Transaction object.
       */
    
    
      static from(buffer$1) {
        // Slice up wire data
        let byteArray = [...buffer$1];
        const signatureCount = decodeLength(byteArray);
        let signatures = [];
    
        for (let i = 0; i < signatureCount; i++) {
          const signature = byteArray.slice(0, SIGNATURE_LENGTH_IN_BYTES);
          byteArray = byteArray.slice(SIGNATURE_LENGTH_IN_BYTES);
          signatures.push(bs58__default["default"].encode(buffer.Buffer.from(signature)));
        }
    
        return Transaction.populate(Message.from(byteArray), signatures);
      }
      /**
       * Populate Transaction object from message and signatures
       */
    
    
      static populate(message, signatures = []) {
        const transaction = new Transaction();
        transaction.recentBlockhash = message.recentBlockhash;
    
        if (message.header.numRequiredSignatures > 0) {
          transaction.feePayer = message.accountKeys[0];
        }
    
        signatures.forEach((signature, index) => {
          const sigPubkeyPair = {
            signature: signature == bs58__default["default"].encode(DEFAULT_SIGNATURE) ? null : bs58__default["default"].decode(signature),
            publicKey: message.accountKeys[index]
          };
          transaction.signatures.push(sigPubkeyPair);
        });
        message.instructions.forEach(instruction => {
          const keys = instruction.accounts.map(account => {
            const pubkey = message.accountKeys[account];
            return {
              pubkey,
              isSigner: transaction.signatures.some(keyObj => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
              isWritable: message.isAccountWritable(account)
            };
          });
          transaction.instructions.push(new TransactionInstruction({
            keys,
            programId: message.accountKeys[instruction.programIdIndex],
            data: bs58__default["default"].decode(instruction.data)
          }));
        });
        transaction._message = message;
        transaction._json = transaction.toJSON();
        return transaction;
      }
    
    }
    
    class TransactionMessage {
      constructor(args) {
        this.payerKey = void 0;
        this.instructions = void 0;
        this.recentBlockhash = void 0;
        this.payerKey = args.payerKey;
        this.instructions = args.instructions;
        this.recentBlockhash = args.recentBlockhash;
      }
    
      static decompile(message, args) {
        const {
          header,
          compiledInstructions,
          recentBlockhash
        } = message;
        const {
          numRequiredSignatures,
          numReadonlySignedAccounts,
          numReadonlyUnsignedAccounts
        } = header;
        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
        assert(numWritableSignedAccounts > 0, 'Message header is invalid');
        const numWritableUnsignedAccounts = message.staticAccountKeys.length - numReadonlyUnsignedAccounts;
        assert(numWritableUnsignedAccounts >= 0, 'Message header is invalid');
        const accountKeys = message.getAccountKeys(args);
        const payerKey = accountKeys.get(0);
    
        if (payerKey === undefined) {
          throw new Error('Failed to decompile message because no account keys were found');
        }
    
        const instructions = [];
    
        for (const compiledIx of compiledInstructions) {
          const keys = [];
    
          for (const keyIndex of compiledIx.accountKeyIndexes) {
            const pubkey = accountKeys.get(keyIndex);
    
            if (pubkey === undefined) {
              throw new Error(`Failed to find key for account key index ${keyIndex}`);
            }
    
            const isSigner = keyIndex < numRequiredSignatures;
            let isWritable;
    
            if (isSigner) {
              isWritable = keyIndex < numWritableSignedAccounts;
            } else if (keyIndex < accountKeys.staticAccountKeys.length) {
              isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
            } else {
              isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
              accountKeys.accountKeysFromLookups.writable.length;
            }
    
            keys.push({
              pubkey,
              isSigner: keyIndex < header.numRequiredSignatures,
              isWritable
            });
          }
    
          const programId = accountKeys.get(compiledIx.programIdIndex);
    
          if (programId === undefined) {
            throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
          }
    
          instructions.push(new TransactionInstruction({
            programId,
            data: toBuffer(compiledIx.data),
            keys
          }));
        }
    
        return new TransactionMessage({
          payerKey,
          instructions,
          recentBlockhash
        });
      }
    
      compileToLegacyMessage() {
        return Message.compile({
          payerKey: this.payerKey,
          recentBlockhash: this.recentBlockhash,
          instructions: this.instructions
        });
      }
    
      compileToV0Message(addressLookupTableAccounts) {
        return MessageV0.compile({
          payerKey: this.payerKey,
          recentBlockhash: this.recentBlockhash,
          instructions: this.instructions,
          addressLookupTableAccounts
        });
      }
    
    }
    
    /**
     * Versioned transaction class
     */
    class VersionedTransaction {
      get version() {
        return this.message.version;
      }
    
      constructor(message, signatures) {
        this.signatures = void 0;
        this.message = void 0;
    
        if (signatures !== undefined) {
          assert(signatures.length === message.header.numRequiredSignatures, 'Expected signatures length to be equal to the number of required signatures');
          this.signatures = signatures;
        } else {
          const defaultSignatures = [];
    
          for (let i = 0; i < message.header.numRequiredSignatures; i++) {
            defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
          }
    
          this.signatures = defaultSignatures;
        }
    
        this.message = message;
      }
    
      serialize() {
        const serializedMessage = this.message.serialize();
        const encodedSignaturesLength = Array();
        encodeLength(encodedSignaturesLength, this.signatures.length);
        const transactionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(encodedSignaturesLength.length, 'encodedSignaturesLength'), BufferLayout__namespace.seq(signature(), this.signatures.length, 'signatures'), BufferLayout__namespace.blob(serializedMessage.length, 'serializedMessage')]);
        const serializedTransaction = new Uint8Array(2048);
        const serializedTransactionLength = transactionLayout.encode({
          encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
          signatures: this.signatures,
          serializedMessage
        }, serializedTransaction);
        return serializedTransaction.slice(0, serializedTransactionLength);
      }
    
      static deserialize(serializedTransaction) {
        let byteArray = [...serializedTransaction];
        const signatures = [];
        const signaturesLength = decodeLength(byteArray);
    
        for (let i = 0; i < signaturesLength; i++) {
          signatures.push(new Uint8Array(byteArray.splice(0, SIGNATURE_LENGTH_IN_BYTES)));
        }
    
        const message = VersionedMessage.deserialize(new Uint8Array(byteArray));
        return new VersionedTransaction(message, signatures);
      }
    
      sign(signers) {
        const messageData = this.message.serialize();
        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    
        for (const signer of signers) {
          const signerIndex = signerPubkeys.findIndex(pubkey => pubkey.equals(signer.publicKey));
          assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
          this.signatures[signerIndex] = sign(messageData, signer.secretKey);
        }
      }
    
    }
    
    const SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');
    const SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey('SysvarEpochSchedu1e111111111111111111111111');
    const SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');
    const SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');
    const SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');
    const SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');
    const SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey('SysvarS1otHashes111111111111111111111111111');
    const SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey('SysvarS1otHistory11111111111111111111111111');
    const SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');
    
    /**
     * Sign, send and confirm a transaction.
     *
     * If `commitment` option is not specified, defaults to 'max' commitment.
     *
     * @param {Connection} connection
     * @param {Transaction} transaction
     * @param {Array<Signer>} signers
     * @param {ConfirmOptions} [options]
     * @returns {Promise<TransactionSignature>}
     */
    async function sendAndConfirmTransaction(connection, transaction, signers, options) {
      const sendOptions = options && {
        skipPreflight: options.skipPreflight,
        preflightCommitment: options.preflightCommitment || options.commitment,
        maxRetries: options.maxRetries,
        minContextSlot: options.minContextSlot
      };
      const signature = await connection.sendTransaction(transaction, signers, sendOptions);
      const status = transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null ? (await connection.confirmTransaction({
        signature: signature,
        blockhash: transaction.recentBlockhash,
        lastValidBlockHeight: transaction.lastValidBlockHeight
      }, options && options.commitment)).value : (await connection.confirmTransaction(signature, options && options.commitment)).value;
    
      if (status.err) {
        throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
      }
    
      return signature;
    }
    
    // zzz
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    /**
     * Populate a buffer of instruction data using an InstructionType
     * @internal
     */
    function encodeData(type, fields) {
      const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);
      const data = buffer.Buffer.alloc(allocLength);
      const layoutFields = Object.assign({
        instruction: type.index
      }, fields);
      type.layout.encode(layoutFields, data);
      return data;
    }
    /**
     * Decode instruction data buffer using an InstructionType
     * @internal
     */
    
    function decodeData$1(type, buffer) {
      let data;
    
      try {
        data = type.layout.decode(buffer);
      } catch (err) {
        throw new Error('invalid instruction; ' + err);
      }
    
      if (data.instruction !== type.index) {
        throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);
      }
    
      return data;
    }
    
    /**
     * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11
     *
     * @internal
     */
    
    const FeeCalculatorLayout = BufferLayout__namespace.nu64('lamportsPerSignature');
    /**
     * Calculator for transaction fees.
     *
     * @deprecated Deprecated since Solana v1.8.0.
     */
    
    /**
     * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32
     *
     * @internal
     */
    
    const NonceAccountLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32('version'), BufferLayout__namespace.u32('state'), publicKey('authorizedPubkey'), publicKey('nonce'), BufferLayout__namespace.struct([FeeCalculatorLayout], 'feeCalculator')]);
    const NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
    
    /**
     * NonceAccount class
     */
    class NonceAccount {
      /**
       * @internal
       */
      constructor(args) {
        this.authorizedPubkey = void 0;
        this.nonce = void 0;
        this.feeCalculator = void 0;
        this.authorizedPubkey = args.authorizedPubkey;
        this.nonce = args.nonce;
        this.feeCalculator = args.feeCalculator;
      }
      /**
       * Deserialize NonceAccount from the account data.
       *
       * @param buffer account data
       * @return NonceAccount
       */
    
    
      static fromAccountData(buffer) {
        const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);
        return new NonceAccount({
          authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
          nonce: new PublicKey(nonceAccount.nonce).toString(),
          feeCalculator: nonceAccount.feeCalculator
        });
      }
    
    }
    
    const encodeDecode = layout => {
      const decode = layout.decode.bind(layout);
      const encode = layout.encode.bind(layout);
      return {
        decode,
        encode
      };
    };
    
    const bigInt = length => property => {
      const layout = BufferLayout.blob(length, property);
      const {
        encode,
        decode
      } = encodeDecode(layout);
      const bigIntLayout = layout;
    
      bigIntLayout.decode = (buffer$1, offset) => {
        const src = decode(buffer$1, offset);
        return bigintBuffer.toBigIntLE(buffer.Buffer.from(src));
      };
    
      bigIntLayout.encode = (bigInt, buffer, offset) => {
        const src = bigintBuffer.toBufferLE(bigInt, length);
        return encode(src, buffer, offset);
      };
    
      return bigIntLayout;
    };
    
    const u64 = bigInt(8);
    
    /**
     * Create account system transaction params
     */
    
    /**
     * System Instruction class
     */
    class SystemInstruction {
      /**
       * @internal
       */
      constructor() {}
      /**
       * Decode a system instruction and retrieve the instruction type.
       */
    
    
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout__namespace.u32('instruction');
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type;
    
        for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) {
          if (layout.index == typeIndex) {
            type = ixType;
            break;
          }
        }
    
        if (!type) {
          throw new Error('Instruction type incorrect; not a SystemInstruction');
        }
    
        return type;
      }
      /**
       * Decode a create account system instruction and retrieve the instruction params.
       */
    
    
      static decodeCreateAccount(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          lamports,
          space,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);
        return {
          fromPubkey: instruction.keys[0].pubkey,
          newAccountPubkey: instruction.keys[1].pubkey,
          lamports,
          space,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode a transfer system instruction and retrieve the instruction params.
       */
    
    
      static decodeTransfer(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          lamports
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);
        return {
          fromPubkey: instruction.keys[0].pubkey,
          toPubkey: instruction.keys[1].pubkey,
          lamports
        };
      }
      /**
       * Decode a transfer with seed system instruction and retrieve the instruction params.
       */
    
    
      static decodeTransferWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          lamports,
          seed,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);
        return {
          fromPubkey: instruction.keys[0].pubkey,
          basePubkey: instruction.keys[1].pubkey,
          toPubkey: instruction.keys[2].pubkey,
          lamports,
          seed,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode an allocate system instruction and retrieve the instruction params.
       */
    
    
      static decodeAllocate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const {
          space
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);
        return {
          accountPubkey: instruction.keys[0].pubkey,
          space
        };
      }
      /**
       * Decode an allocate with seed system instruction and retrieve the instruction params.
       */
    
    
      static decodeAllocateWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const {
          base,
          seed,
          space,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);
        return {
          accountPubkey: instruction.keys[0].pubkey,
          basePubkey: new PublicKey(base),
          seed,
          space,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode an assign system instruction and retrieve the instruction params.
       */
    
    
      static decodeAssign(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const {
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);
        return {
          accountPubkey: instruction.keys[0].pubkey,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode an assign with seed system instruction and retrieve the instruction params.
       */
    
    
      static decodeAssignWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);
        const {
          base,
          seed,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);
        return {
          accountPubkey: instruction.keys[0].pubkey,
          basePubkey: new PublicKey(base),
          seed,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode a create account with seed system instruction and retrieve the instruction params.
       */
    
    
      static decodeCreateWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          base,
          seed,
          lamports,
          space,
          programId
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);
        return {
          fromPubkey: instruction.keys[0].pubkey,
          newAccountPubkey: instruction.keys[1].pubkey,
          basePubkey: new PublicKey(base),
          seed,
          lamports,
          space,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode a nonce initialize system instruction and retrieve the instruction params.
       */
    
    
      static decodeNonceInitialize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          authorized
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);
        return {
          noncePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: new PublicKey(authorized)
        };
      }
      /**
       * Decode a nonce advance system instruction and retrieve the instruction params.
       */
    
    
      static decodeNonceAdvance(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
        return {
          noncePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey
        };
      }
      /**
       * Decode a nonce withdraw system instruction and retrieve the instruction params.
       */
    
    
      static decodeNonceWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 5);
        const {
          lamports
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);
        return {
          noncePubkey: instruction.keys[0].pubkey,
          toPubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[4].pubkey,
          lamports
        };
      }
      /**
       * Decode a nonce authorize system instruction and retrieve the instruction params.
       */
    
    
      static decodeNonceAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          authorized
        } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);
        return {
          noncePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[1].pubkey,
          newAuthorizedPubkey: new PublicKey(authorized)
        };
      }
      /**
       * @internal
       */
    
    
      static checkProgramId(programId) {
        if (!programId.equals(SystemProgram.programId)) {
          throw new Error('invalid instruction; programId is not SystemProgram');
        }
      }
      /**
       * @internal
       */
    
    
      static checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
        }
      }
    
    }
    /**
     * An enumeration of valid SystemInstructionType's
     */
    
    /**
     * An enumeration of valid system InstructionType's
     * @internal
     */
    const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
      Create: {
        index: 0,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports'), BufferLayout__namespace.ns64('space'), publicKey('programId')])
      },
      Assign: {
        index: 1,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('programId')])
      },
      Transfer: {
        index: 2,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64('lamports')])
      },
      CreateWithSeed: {
        index: 3,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout__namespace.ns64('lamports'), BufferLayout__namespace.ns64('space'), publicKey('programId')])
      },
      AdvanceNonceAccount: {
        index: 4,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
      },
      WithdrawNonceAccount: {
        index: 5,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])
      },
      InitializeNonceAccount: {
        index: 6,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('authorized')])
      },
      AuthorizeNonceAccount: {
        index: 7,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('authorized')])
      },
      Allocate: {
        index: 8,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('space')])
      },
      AllocateWithSeed: {
        index: 9,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout__namespace.ns64('space'), publicKey('programId')])
      },
      AssignWithSeed: {
        index: 10,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('base'), rustString('seed'), publicKey('programId')])
      },
      TransferWithSeed: {
        index: 11,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64('lamports'), rustString('seed'), publicKey('programId')])
      },
      UpgradeNonceAccount: {
        index: 12,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
      }
    });
    /**
     * Factory class for transactions to interact with the System program
     */
    
    class SystemProgram {
      /**
       * @internal
       */
      constructor() {}
      /**
       * Public key that identifies the System program
       */
    
    
      /**
       * Generate a transaction instruction that creates a new account
       */
      static createAccount(params) {
        const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;
        const data = encodeData(type, {
          lamports: params.lamports,
          space: params.space,
          programId: toBuffer(params.programId.toBuffer())
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: params.fromPubkey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: params.newAccountPubkey,
            isSigner: true,
            isWritable: true
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that transfers lamports from one account to another
       */
    
    
      static transfer(params) {
        let data;
        let keys;
    
        if ('basePubkey' in params) {
          const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
          data = encodeData(type, {
            lamports: BigInt(params.lamports),
            seed: params.seed,
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.fromPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: params.toPubkey,
            isSigner: false,
            isWritable: true
          }];
        } else {
          const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
          data = encodeData(type, {
            lamports: BigInt(params.lamports)
          });
          keys = [{
            pubkey: params.fromPubkey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: params.toPubkey,
            isSigner: false,
            isWritable: true
          }];
        }
    
        return new TransactionInstruction({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that assigns an account to a program
       */
    
    
      static assign(params) {
        let data;
        let keys;
    
        if ('basePubkey' in params) {
          const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
          data = encodeData(type, {
            base: toBuffer(params.basePubkey.toBuffer()),
            seed: params.seed,
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          }];
        } else {
          const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
          data = encodeData(type, {
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: true,
            isWritable: true
          }];
        }
    
        return new TransactionInstruction({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that creates a new account at
       *   an address generated with `from`, a seed, and programId
       */
    
    
      static createAccountWithSeed(params) {
        const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
        const data = encodeData(type, {
          base: toBuffer(params.basePubkey.toBuffer()),
          seed: params.seed,
          lamports: params.lamports,
          space: params.space,
          programId: toBuffer(params.programId.toBuffer())
        });
        let keys = [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.newAccountPubkey,
          isSigner: false,
          isWritable: true
        }];
    
        if (params.basePubkey != params.fromPubkey) {
          keys.push({
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          });
        }
    
        return new TransactionInstruction({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction that creates a new Nonce account
       */
    
    
      static createNonceAccount(params) {
        const transaction = new Transaction();
    
        if ('basePubkey' in params && 'seed' in params) {
          transaction.add(SystemProgram.createAccountWithSeed({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.noncePubkey,
            basePubkey: params.basePubkey,
            seed: params.seed,
            lamports: params.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
          }));
        } else {
          transaction.add(SystemProgram.createAccount({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.noncePubkey,
            lamports: params.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
          }));
        }
    
        const initParams = {
          noncePubkey: params.noncePubkey,
          authorizedPubkey: params.authorizedPubkey
        };
        transaction.add(this.nonceInitialize(initParams));
        return transaction;
      }
      /**
       * Generate an instruction to initialize a Nonce account
       */
    
    
      static nonceInitialize(params) {
        const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
        const data = encodeData(type, {
          authorized: toBuffer(params.authorizedPubkey.toBuffer())
        });
        const instructionData = {
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }],
          programId: this.programId,
          data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate an instruction to advance the nonce in a Nonce account
       */
    
    
      static nonceAdvance(params) {
        const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
        const data = encodeData(type);
        const instructionData = {
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: params.authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate a transaction instruction that withdraws lamports from a Nonce account
       */
    
    
      static nonceWithdraw(params) {
        const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
        const data = encodeData(type, {
          lamports: params.lamports
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.toPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: params.authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that authorizes a new PublicKey as the authority
       * on a Nonce account.
       */
    
    
      static nonceAuthorize(params) {
        const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
        const data = encodeData(type, {
          authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction instruction that allocates space in an account without funding
       */
    
    
      static allocate(params) {
        let data;
        let keys;
    
        if ('basePubkey' in params) {
          const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
          data = encodeData(type, {
            base: toBuffer(params.basePubkey.toBuffer()),
            seed: params.seed,
            space: params.space,
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          }];
        } else {
          const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
          data = encodeData(type, {
            space: params.space
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: true,
            isWritable: true
          }];
        }
    
        return new TransactionInstruction({
          keys,
          programId: this.programId,
          data
        });
      }
    
    }
    SystemProgram.programId = new PublicKey('11111111111111111111111111111111');
    
    // Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the
    // rest of the Transaction fields
    //
    // TODO: replace 300 with a proper constant for the size of the other
    // Transaction fields
    const CHUNK_SIZE = PACKET_DATA_SIZE - 300;
    /**
     * Program loader interface
     */
    
    class Loader {
      /**
       * @internal
       */
      constructor() {}
      /**
       * Amount of program data placed in each load Transaction
       */
    
    
      /**
       * Minimum number of signatures required to load a program not including
       * retries
       *
       * Can be used to calculate transaction fees
       */
      static getMinNumSignatures(dataLength) {
        return 2 * ( // Every transaction requires two signatures (payer + program)
        Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction
        1) // Add one for Finalize transaction
        ;
      }
      /**
       * Loads a generic program
       *
       * @param connection The connection to use
       * @param payer System account that pays to load the program
       * @param program Account to load the program into
       * @param programId Public key that identifies the loader
       * @param data Program octets
       * @return true if program was loaded successfully, false if program was already loaded
       */
    
    
      static async load(connection, payer, program, programId, data) {
        {
          const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length); // Fetch program account info to check if it has already been created
    
          const programInfo = await connection.getAccountInfo(program.publicKey, 'confirmed');
          let transaction = null;
    
          if (programInfo !== null) {
            if (programInfo.executable) {
              console.error('Program load failed, account is already executable');
              return false;
            }
    
            if (programInfo.data.length !== data.length) {
              transaction = transaction || new Transaction();
              transaction.add(SystemProgram.allocate({
                accountPubkey: program.publicKey,
                space: data.length
              }));
            }
    
            if (!programInfo.owner.equals(programId)) {
              transaction = transaction || new Transaction();
              transaction.add(SystemProgram.assign({
                accountPubkey: program.publicKey,
                programId
              }));
            }
    
            if (programInfo.lamports < balanceNeeded) {
              transaction = transaction || new Transaction();
              transaction.add(SystemProgram.transfer({
                fromPubkey: payer.publicKey,
                toPubkey: program.publicKey,
                lamports: balanceNeeded - programInfo.lamports
              }));
            }
          } else {
            transaction = new Transaction().add(SystemProgram.createAccount({
              fromPubkey: payer.publicKey,
              newAccountPubkey: program.publicKey,
              lamports: balanceNeeded > 0 ? balanceNeeded : 1,
              space: data.length,
              programId
            }));
          } // If the account is already created correctly, skip this step
          // and proceed directly to loading instructions
    
    
          if (transaction !== null) {
            await sendAndConfirmTransaction(connection, transaction, [payer, program], {
              commitment: 'confirmed'
            });
          }
        }
        const dataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.u32('offset'), BufferLayout__namespace.u32('bytesLength'), BufferLayout__namespace.u32('bytesLengthPadding'), BufferLayout__namespace.seq(BufferLayout__namespace.u8('byte'), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'bytes')]);
        const chunkSize = Loader.chunkSize;
        let offset = 0;
        let array = data;
        let transactions = [];
    
        while (array.length > 0) {
          const bytes = array.slice(0, chunkSize);
          const data = buffer.Buffer.alloc(chunkSize + 16);
          dataLayout.encode({
            instruction: 0,
            // Load instruction
            offset,
            bytes: bytes,
            bytesLength: 0,
            bytesLengthPadding: 0
          }, data);
          const transaction = new Transaction().add({
            keys: [{
              pubkey: program.publicKey,
              isSigner: true,
              isWritable: true
            }],
            programId,
            data
          });
          transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
            commitment: 'confirmed'
          })); // Delay between sends in an attempt to reduce rate limit errors
    
          if (connection._rpcEndpoint.includes('solana.com')) {
            const REQUESTS_PER_SECOND = 4;
            await sleep(1000 / REQUESTS_PER_SECOND);
          }
    
          offset += chunkSize;
          array = array.slice(chunkSize);
        }
    
        await Promise.all(transactions); // Finalize the account loaded with program data for execution
    
        {
          const dataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')]);
          const data = buffer.Buffer.alloc(dataLayout.span);
          dataLayout.encode({
            instruction: 1 // Finalize instruction
    
          }, data);
          const transaction = new Transaction().add({
            keys: [{
              pubkey: program.publicKey,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: SYSVAR_RENT_PUBKEY,
              isSigner: false,
              isWritable: false
            }],
            programId,
            data
          });
          await sendAndConfirmTransaction(connection, transaction, [payer, program], {
            commitment: 'confirmed'
          });
        } // success
    
        return true;
      }
    
    }
    Loader.chunkSize = CHUNK_SIZE;
    
    const BPF_LOADER_PROGRAM_ID = new PublicKey('BPFLoader2111111111111111111111111111111111');
    /**
     * Factory class for transactions to interact with a program loader
     */
    
    class BpfLoader {
      /**
       * Minimum number of signatures required to load a program not including
       * retries
       *
       * Can be used to calculate transaction fees
       */
      static getMinNumSignatures(dataLength) {
        return Loader.getMinNumSignatures(dataLength);
      }
      /**
       * Load a BPF program
       *
       * @param connection The connection to use
       * @param payer Account that will pay program loading fees
       * @param program Account to load the program into
       * @param elf The entire ELF containing the BPF program
       * @param loaderProgramId The program id of the BPF loader to use
       * @return true if program was loaded successfully, false if program was already loaded
       */
    
    
      static load(connection, payer, program, elf, loaderProgramId) {
        return Loader.load(connection, payer, program, loaderProgramId, elf);
      }
    
    }
    
    var objToString = Object.prototype.toString;
    var objKeys = Object.keys || function(obj) {
            var keys = [];
            for (var name in obj) {
                keys.push(name);
            }
            return keys;
        };
    
    function stringify(val, isArrayProp) {
        var i, max, str, keys, key, propVal, toStr;
        if (val === true) {
            return "true";
        }
        if (val === false) {
            return "false";
        }
        switch (typeof val) {
            case "object":
                if (val === null) {
                    return null;
                } else if (val.toJSON && typeof val.toJSON === "function") {
                    return stringify(val.toJSON(), isArrayProp);
                } else {
                    toStr = objToString.call(val);
                    if (toStr === "[object Array]") {
                        str = '[';
                        max = val.length - 1;
                        for(i = 0; i < max; i++) {
                            str += stringify(val[i], true) + ',';
                        }
                        if (max > -1) {
                            str += stringify(val[i], true);
                        }
                        return str + ']';
                    } else if (toStr === "[object Object]") {
                        // only object is left
                        keys = objKeys(val).sort();
                        max = keys.length;
                        str = "";
                        i = 0;
                        while (i < max) {
                            key = keys[i];
                            propVal = stringify(val[key], false);
                            if (propVal !== undefined) {
                                if (str) {
                                    str += ',';
                                }
                                str += JSON.stringify(key) + ':' + propVal;
                            }
                            i++;
                        }
                        return '{' + str + '}';
                    } else {
                        return JSON.stringify(val);
                    }
                }
            case "function":
            case "undefined":
                return isArrayProp ? null : undefined;
            case "string":
                return JSON.stringify(val);
            default:
                return isFinite(val) ? val : null;
        }
    }
    
    var fastStableStringify = function(val) {
        var returnVal = stringify(val, false);
        if (returnVal !== undefined) {
            return ''+ returnVal;
        }
    };
    
    var fastStableStringify$1 = fastStableStringify;
    
    const MINIMUM_SLOT_PER_EPOCH = 32; // Returns the number of trailing zeros in the binary representation of self.
    
    function trailingZeros(n) {
      let trailingZeros = 0;
    
      while (n > 1) {
        n /= 2;
        trailingZeros++;
      }
    
      return trailingZeros;
    } // Returns the smallest power of two greater than or equal to n
    
    
    function nextPowerOfTwo(n) {
      if (n === 0) return 1;
      n--;
      n |= n >> 1;
      n |= n >> 2;
      n |= n >> 4;
      n |= n >> 8;
      n |= n >> 16;
      n |= n >> 32;
      return n + 1;
    }
    /**
     * Epoch schedule
     * (see https://docs.solana.com/terminology#epoch)
     * Can be retrieved with the {@link connection.getEpochSchedule} method
     */
    
    
    class EpochSchedule {
      /** The maximum number of slots in each epoch */
    
      /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */
    
      /** Indicates whether epochs start short and grow */
    
      /** The first epoch with `slotsPerEpoch` slots */
    
      /** The first slot of `firstNormalEpoch` */
      constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
        this.slotsPerEpoch = void 0;
        this.leaderScheduleSlotOffset = void 0;
        this.warmup = void 0;
        this.firstNormalEpoch = void 0;
        this.firstNormalSlot = void 0;
        this.slotsPerEpoch = slotsPerEpoch;
        this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
        this.warmup = warmup;
        this.firstNormalEpoch = firstNormalEpoch;
        this.firstNormalSlot = firstNormalSlot;
      }
    
      getEpoch(slot) {
        return this.getEpochAndSlotIndex(slot)[0];
      }
    
      getEpochAndSlotIndex(slot) {
        if (slot < this.firstNormalSlot) {
          const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
          const epochLen = this.getSlotsInEpoch(epoch);
          const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
          return [epoch, slotIndex];
        } else {
          const normalSlotIndex = slot - this.firstNormalSlot;
          const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
          const epoch = this.firstNormalEpoch + normalEpochIndex;
          const slotIndex = normalSlotIndex % this.slotsPerEpoch;
          return [epoch, slotIndex];
        }
      }
    
      getFirstSlotInEpoch(epoch) {
        if (epoch <= this.firstNormalEpoch) {
          return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
        } else {
          return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
        }
      }
    
      getLastSlotInEpoch(epoch) {
        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
      }
    
      getSlotsInEpoch(epoch) {
        if (epoch < this.firstNormalEpoch) {
          return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
        } else {
          return this.slotsPerEpoch;
        }
      }
    
    }
    
    class SendTransactionError extends Error {
      constructor(message, logs) {
        super(message);
        this.logs = void 0;
        this.logs = logs;
      }
    
    } // Keep in sync with client/src/rpc_custom_errors.rs
    // Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/
    
    const SolanaJSONRPCErrorCode = {
      JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
      JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
      JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
      JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
      JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
      JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
      JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
      JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
      JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
      JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
      JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
      JSON_RPC_SCAN_ERROR: -32012,
      JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
      JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
      JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
      JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
    };
    class SolanaJSONRPCError extends Error {
      constructor({
        code,
        message,
        data
      }, customMessage) {
        super(customMessage != null ? `${customMessage}: ${message}` : message);
        this.code = void 0;
        this.data = void 0;
        this.code = code;
        this.data = data;
        this.name = 'SolanaJSONRPCError';
      }
    
    }
    
    var fetchImpl = globalThis.fetch;
    
    // TODO: These constants should be removed in favor of reading them out of a
    // Syscall account
    
    /**
     * @internal
     */
    const NUM_TICKS_PER_SECOND = 160;
    /**
     * @internal
     */
    
    const DEFAULT_TICKS_PER_SLOT = 64;
    /**
     * @internal
     */
    
    const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
    /**
     * @internal
     */
    
    const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;
    
    /**
     * @internal
     */
    
    /**
     * Decode account data buffer using an AccountType
     * @internal
     */
    function decodeData(type, data) {
      let decoded;
    
      try {
        decoded = type.layout.decode(data);
      } catch (err) {
        throw new Error('invalid instruction; ' + err);
      }
    
      if (decoded.typeIndex !== type.index) {
        throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);
      }
    
      return decoded;
    }
    
    /// The serialized size of lookup table metadata
    const LOOKUP_TABLE_META_SIZE = 56;
    class AddressLookupTableAccount {
      constructor(args) {
        this.key = void 0;
        this.state = void 0;
        this.key = args.key;
        this.state = args.state;
      }
    
      isActive() {
        const U64_MAX = 18446744073709551615n;
        return this.state.deactivationSlot === U64_MAX;
      }
    
      static deserialize(accountData) {
        const meta = decodeData(LookupTableMetaLayout, accountData);
        const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
        assert(serializedAddressesLen >= 0, 'lookup table is invalid');
        assert(serializedAddressesLen % 32 === 0, 'lookup table is invalid');
        const numSerializedAddresses = serializedAddressesLen / 32;
        const {
          addresses
        } = BufferLayout__namespace.struct([BufferLayout__namespace.seq(publicKey(), numSerializedAddresses, 'addresses')]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
        return {
          deactivationSlot: meta.deactivationSlot,
          lastExtendedSlot: meta.lastExtendedSlot,
          lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
          authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,
          addresses: addresses.map(address => new PublicKey(address))
        };
      }
    
    }
    const LookupTableMetaLayout = {
      index: 1,
      layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('typeIndex'), u64('deactivationSlot'), BufferLayout__namespace.nu64('lastExtendedSlot'), BufferLayout__namespace.u8('lastExtendedStartIndex'), BufferLayout__namespace.u8(), // option
      BufferLayout__namespace.seq(publicKey(), BufferLayout__namespace.offset(BufferLayout__namespace.u8(), -1), 'authority')])
    };
    
    const URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
    function makeWebsocketUrl(endpoint) {
      const matches = endpoint.match(URL_RE);
    
      if (matches == null) {
        throw TypeError(`Failed to validate endpoint URL \`${endpoint}\``);
      }
    
      const [_, // eslint-disable-line @typescript-eslint/no-unused-vars
      hostish, portWithColon, rest] = matches;
      const protocol = endpoint.startsWith('https:') ? 'wss:' : 'ws:';
      const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
      const websocketPort = // Only shift the port by +1 as a convention for ws(s) only if given endpoint
      // is explictly specifying the endpoint port (HTTP-based RPC), assuming
      // we're directly trying to connect to solana-validator's ws listening port.
      // When the endpoint omits the port, we're connecting to the protocol
      // default ports: http(80) or https(443) and it's assumed we're behind a reverse
      // proxy which manages WebSocket upgrade and backend port redirection.
      startPort == null ? '' : `:${startPort + 1}`;
      return `${protocol}//${hostish}${websocketPort}${rest}`;
    }
    
    var _process$env$npm_pack;
    const PublicKeyFromString = superstruct.coerce(superstruct.instance(PublicKey), superstruct.string(), value => new PublicKey(value));
    const RawAccountDataResult = superstruct.tuple([superstruct.string(), superstruct.literal('base64')]);
    const BufferFromRawAccountData = superstruct.coerce(superstruct.instance(buffer.Buffer), RawAccountDataResult, value => buffer.Buffer.from(value[0], 'base64'));
    /**
     * Attempt to use a recent blockhash for up to 30 seconds
     * @internal
     */
    
    const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;
    /**
     * HACK.
     * Copied from rpc-websockets/dist/lib/client.
     * Otherwise, `yarn build` fails with:
     * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d
     */
    
    /* @internal */
    function assertEndpointUrl(putativeUrl) {
      if (/^https?:/.test(putativeUrl) === false) {
        throw new TypeError('Endpoint URL must start with `http:` or `https:`.');
      }
    
      return putativeUrl;
    }
    /** @internal */
    
    
    function extractCommitmentFromConfig(commitmentOrConfig) {
      let commitment;
      let config;
    
      if (typeof commitmentOrConfig === 'string') {
        commitment = commitmentOrConfig;
      } else if (commitmentOrConfig) {
        const {
          commitment: specifiedCommitment,
          ...specifiedConfig
        } = commitmentOrConfig;
        commitment = specifiedCommitment;
        config = specifiedConfig;
      }
    
      return {
        commitment,
        config
      };
    }
    /**
     * @internal
     */
    
    
    function createRpcResult(result) {
      return superstruct.union([superstruct.type({
        jsonrpc: superstruct.literal('2.0'),
        id: superstruct.string(),
        result
      }), superstruct.type({
        jsonrpc: superstruct.literal('2.0'),
        id: superstruct.string(),
        error: superstruct.type({
          code: superstruct.unknown(),
          message: superstruct.string(),
          data: superstruct.optional(superstruct.any())
        })
      })]);
    }
    
    const UnknownRpcResult = createRpcResult(superstruct.unknown());
    /**
     * @internal
     */
    
    function jsonRpcResult(schema) {
      return superstruct.coerce(createRpcResult(schema), UnknownRpcResult, value => {
        if ('error' in value) {
          return value;
        } else {
          return { ...value,
            result: superstruct.create(value.result, schema)
          };
        }
      });
    }
    /**
     * @internal
     */
    
    
    function jsonRpcResultAndContext(value) {
      return jsonRpcResult(superstruct.type({
        context: superstruct.type({
          slot: superstruct.number()
        }),
        value
      }));
    }
    /**
     * @internal
     */
    
    
    function notificationResultAndContext(value) {
      return superstruct.type({
        context: superstruct.type({
          slot: superstruct.number()
        }),
        value
      });
    }
    /**
     * @internal
     */
    
    
    function versionedMessageFromResponse(version, response) {
      if (version === 0) {
        return new MessageV0({
          header: response.header,
          staticAccountKeys: response.accountKeys.map(accountKey => new PublicKey(accountKey)),
          recentBlockhash: response.recentBlockhash,
          compiledInstructions: response.instructions.map(ix => ({
            programIdIndex: ix.programIdIndex,
            accountKeyIndexes: ix.accounts,
            data: bs58__default["default"].decode(ix.data)
          })),
          addressTableLookups: response.addressTableLookups
        });
      } else {
        return new Message(response);
      }
    }
    /**
     * The level of commitment desired when querying state
     * <pre>
     *   'processed': Query the most recent block which has reached 1 confirmation by the connected node
     *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
     *   'finalized': Query the most recent block which has been finalized by the cluster
     * </pre>
     */
    
    
    const GetInflationGovernorResult = superstruct.type({
      foundation: superstruct.number(),
      foundationTerm: superstruct.number(),
      initial: superstruct.number(),
      taper: superstruct.number(),
      terminal: superstruct.number()
    });
    /**
     * The inflation reward for an epoch
     */
    
    /**
     * Expected JSON RPC response for the "getInflationReward" message
     */
    const GetInflationRewardResult = jsonRpcResult(superstruct.array(superstruct.nullable(superstruct.type({
      epoch: superstruct.number(),
      effectiveSlot: superstruct.number(),
      amount: superstruct.number(),
      postBalance: superstruct.number()
    }))));
    /**
     * Information about the current epoch
     */
    
    const GetEpochInfoResult = superstruct.type({
      epoch: superstruct.number(),
      slotIndex: superstruct.number(),
      slotsInEpoch: superstruct.number(),
      absoluteSlot: superstruct.number(),
      blockHeight: superstruct.optional(superstruct.number()),
      transactionCount: superstruct.optional(superstruct.number())
    });
    const GetEpochScheduleResult = superstruct.type({
      slotsPerEpoch: superstruct.number(),
      leaderScheduleSlotOffset: superstruct.number(),
      warmup: superstruct.boolean(),
      firstNormalEpoch: superstruct.number(),
      firstNormalSlot: superstruct.number()
    });
    /**
     * Leader schedule
     * (see https://docs.solana.com/terminology#leader-schedule)
     */
    
    const GetLeaderScheduleResult = superstruct.record(superstruct.string(), superstruct.array(superstruct.number()));
    /**
     * Transaction error or null
     */
    
    const TransactionErrorResult = superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()]));
    /**
     * Signature status for a transaction
     */
    
    const SignatureStatusResult = superstruct.type({
      err: TransactionErrorResult
    });
    /**
     * Transaction signature received notification
     */
    
    const SignatureReceivedResult = superstruct.literal('receivedSignature');
    /**
     * Version info for a node
     */
    
    const VersionResult = superstruct.type({
      'solana-core': superstruct.string(),
      'feature-set': superstruct.optional(superstruct.number())
    });
    const SimulatedTransactionResponseStruct = jsonRpcResultAndContext(superstruct.type({
      err: superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()])),
      logs: superstruct.nullable(superstruct.array(superstruct.string())),
      accounts: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.nullable(superstruct.type({
        executable: superstruct.boolean(),
        owner: superstruct.string(),
        lamports: superstruct.number(),
        data: superstruct.array(superstruct.string()),
        rentEpoch: superstruct.optional(superstruct.number())
      }))))),
      unitsConsumed: superstruct.optional(superstruct.number()),
      returnData: superstruct.optional(superstruct.nullable(superstruct.type({
        programId: superstruct.string(),
        data: superstruct.tuple([superstruct.string(), superstruct.literal('base64')])
      })))
    }));
    
    /**
     * Expected JSON RPC response for the "getBlockProduction" message
     */
    const BlockProductionResponseStruct = jsonRpcResultAndContext(superstruct.type({
      byIdentity: superstruct.record(superstruct.string(), superstruct.array(superstruct.number())),
      range: superstruct.type({
        firstSlot: superstruct.number(),
        lastSlot: superstruct.number()
      })
    }));
    /**
     * A performance sample
     */
    
    function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit) {
      const fetch = customFetch ? customFetch : fetchImpl;
    
      let fetchWithMiddleware;
    
      if (fetchMiddleware) {
        fetchWithMiddleware = async (info, init) => {
          const modifiedFetchArgs = await new Promise((resolve, reject) => {
            try {
              fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
            } catch (error) {
              reject(error);
            }
          });
          return await fetch(...modifiedFetchArgs);
        };
      }
    
      const clientBrowser = new RpcClient__default["default"](async (request, callback) => {
        const agent = undefined;
        const options = {
          method: 'POST',
          body: request,
          agent,
          headers: Object.assign({
            'Content-Type': 'application/json'
          }, httpHeaders || {}, COMMON_HTTP_HEADERS)
        };
    
        try {
          let too_many_requests_retries = 5;
          let res;
          let waitTime = 500;
    
          for (;;) {
            if (fetchWithMiddleware) {
              res = await fetchWithMiddleware(url, options);
            } else {
              res = await fetch(url, options);
            }
    
            if (res.status !== 429
            /* Too many requests */
            ) {
              break;
            }
    
            if (disableRetryOnRateLimit === true) {
              break;
            }
    
            too_many_requests_retries -= 1;
    
            if (too_many_requests_retries === 0) {
              break;
            }
    
            console.log(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
            await sleep(waitTime);
            waitTime *= 2;
          }
    
          const text = await res.text();
    
          if (res.ok) {
            callback(null, text);
          } else {
            callback(new Error(`${res.status} ${res.statusText}: ${text}`));
          }
        } catch (err) {
          if (err instanceof Error) callback(err);
        } finally {
        }
      }, {});
      return clientBrowser;
    }
    
    function createRpcRequest(client) {
      return (method, args) => {
        return new Promise((resolve, reject) => {
          client.request(method, args, (err, response) => {
            if (err) {
              reject(err);
              return;
            }
    
            resolve(response);
          });
        });
      };
    }
    
    function createRpcBatchRequest(client) {
      return requests => {
        return new Promise((resolve, reject) => {
          // Do nothing if requests is empty
          if (requests.length === 0) resolve([]);
          const batch = requests.map(params => {
            return client.request(params.methodName, params.args);
          });
          client.request(batch, (err, response) => {
            if (err) {
              reject(err);
              return;
            }
    
            resolve(response);
          });
        });
      };
    }
    /**
     * Expected JSON RPC response for the "getInflationGovernor" message
     */
    
    
    const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
    /**
     * Expected JSON RPC response for the "getEpochInfo" message
     */
    
    const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
    /**
     * Expected JSON RPC response for the "getEpochSchedule" message
     */
    
    const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
    /**
     * Expected JSON RPC response for the "getLeaderSchedule" message
     */
    
    const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
    /**
     * Expected JSON RPC response for the "minimumLedgerSlot" and "getFirstAvailableBlock" messages
     */
    
    const SlotRpcResult = jsonRpcResult(superstruct.number());
    /**
     * Supply
     */
    
    /**
     * Expected JSON RPC response for the "getSupply" message
     */
    const GetSupplyRpcResult = jsonRpcResultAndContext(superstruct.type({
      total: superstruct.number(),
      circulating: superstruct.number(),
      nonCirculating: superstruct.number(),
      nonCirculatingAccounts: superstruct.array(PublicKeyFromString)
    }));
    /**
     * Token amount object which returns a token amount in different formats
     * for various client use cases.
     */
    
    /**
     * Expected JSON RPC structure for token amounts
     */
    const TokenAmountResult = superstruct.type({
      amount: superstruct.string(),
      uiAmount: superstruct.nullable(superstruct.number()),
      decimals: superstruct.number(),
      uiAmountString: superstruct.optional(superstruct.string())
    });
    /**
     * Token address and balance.
     */
    
    /**
     * Expected JSON RPC response for the "getTokenLargestAccounts" message
     */
    const GetTokenLargestAccountsResult = jsonRpcResultAndContext(superstruct.array(superstruct.type({
      address: PublicKeyFromString,
      amount: superstruct.string(),
      uiAmount: superstruct.nullable(superstruct.number()),
      decimals: superstruct.number(),
      uiAmountString: superstruct.optional(superstruct.string())
    })));
    /**
     * Expected JSON RPC response for the "getTokenAccountsByOwner" message
     */
    
    const GetTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.array(superstruct.type({
      pubkey: PublicKeyFromString,
      account: superstruct.type({
        executable: superstruct.boolean(),
        owner: PublicKeyFromString,
        lamports: superstruct.number(),
        data: BufferFromRawAccountData,
        rentEpoch: superstruct.number()
      })
    })));
    const ParsedAccountDataResult = superstruct.type({
      program: superstruct.string(),
      parsed: superstruct.unknown(),
      space: superstruct.number()
    });
    /**
     * Expected JSON RPC response for the "getTokenAccountsByOwner" message with parsed data
     */
    
    const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.array(superstruct.type({
      pubkey: PublicKeyFromString,
      account: superstruct.type({
        executable: superstruct.boolean(),
        owner: PublicKeyFromString,
        lamports: superstruct.number(),
        data: ParsedAccountDataResult,
        rentEpoch: superstruct.number()
      })
    })));
    /**
     * Pair of an account address and its balance
     */
    
    /**
     * Expected JSON RPC response for the "getLargestAccounts" message
     */
    const GetLargestAccountsRpcResult = jsonRpcResultAndContext(superstruct.array(superstruct.type({
      lamports: superstruct.number(),
      address: PublicKeyFromString
    })));
    /**
     * @internal
     */
    
    const AccountInfoResult = superstruct.type({
      executable: superstruct.boolean(),
      owner: PublicKeyFromString,
      lamports: superstruct.number(),
      data: BufferFromRawAccountData,
      rentEpoch: superstruct.number()
    });
    /**
     * @internal
     */
    
    const KeyedAccountInfoResult = superstruct.type({
      pubkey: PublicKeyFromString,
      account: AccountInfoResult
    });
    const ParsedOrRawAccountData = superstruct.coerce(superstruct.union([superstruct.instance(buffer.Buffer), ParsedAccountDataResult]), superstruct.union([RawAccountDataResult, ParsedAccountDataResult]), value => {
      if (Array.isArray(value)) {
        return superstruct.create(value, BufferFromRawAccountData);
      } else {
        return value;
      }
    });
    /**
     * @internal
     */
    
    const ParsedAccountInfoResult = superstruct.type({
      executable: superstruct.boolean(),
      owner: PublicKeyFromString,
      lamports: superstruct.number(),
      data: ParsedOrRawAccountData,
      rentEpoch: superstruct.number()
    });
    const KeyedParsedAccountInfoResult = superstruct.type({
      pubkey: PublicKeyFromString,
      account: ParsedAccountInfoResult
    });
    /**
     * @internal
     */
    
    const StakeActivationResult = superstruct.type({
      state: superstruct.union([superstruct.literal('active'), superstruct.literal('inactive'), superstruct.literal('activating'), superstruct.literal('deactivating')]),
      active: superstruct.number(),
      inactive: superstruct.number()
    });
    /**
     * Expected JSON RPC response for the "getConfirmedSignaturesForAddress2" message
     */
    
    const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(superstruct.array(superstruct.type({
      signature: superstruct.string(),
      slot: superstruct.number(),
      err: TransactionErrorResult,
      memo: superstruct.nullable(superstruct.string()),
      blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))
    })));
    /**
     * Expected JSON RPC response for the "getSignaturesForAddress" message
     */
    
    const GetSignaturesForAddressRpcResult = jsonRpcResult(superstruct.array(superstruct.type({
      signature: superstruct.string(),
      slot: superstruct.number(),
      err: TransactionErrorResult,
      memo: superstruct.nullable(superstruct.string()),
      blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))
    })));
    /***
     * Expected JSON RPC response for the "accountNotification" message
     */
    
    const AccountNotificationResult = superstruct.type({
      subscription: superstruct.number(),
      result: notificationResultAndContext(AccountInfoResult)
    });
    /**
     * @internal
     */
    
    const ProgramAccountInfoResult = superstruct.type({
      pubkey: PublicKeyFromString,
      account: AccountInfoResult
    });
    /***
     * Expected JSON RPC response for the "programNotification" message
     */
    
    const ProgramAccountNotificationResult = superstruct.type({
      subscription: superstruct.number(),
      result: notificationResultAndContext(ProgramAccountInfoResult)
    });
    /**
     * @internal
     */
    
    const SlotInfoResult = superstruct.type({
      parent: superstruct.number(),
      slot: superstruct.number(),
      root: superstruct.number()
    });
    /**
     * Expected JSON RPC response for the "slotNotification" message
     */
    
    const SlotNotificationResult = superstruct.type({
      subscription: superstruct.number(),
      result: SlotInfoResult
    });
    /**
     * Slot updates which can be used for tracking the live progress of a cluster.
     * - `"firstShredReceived"`: connected node received the first shred of a block.
     * Indicates that a new block that is being produced.
     * - `"completed"`: connected node has received all shreds of a block. Indicates
     * a block was recently produced.
     * - `"optimisticConfirmation"`: block was optimistically confirmed by the
     * cluster. It is not guaranteed that an optimistic confirmation notification
     * will be sent for every finalized blocks.
     * - `"root"`: the connected node rooted this block.
     * - `"createdBank"`: the connected node has started validating this block.
     * - `"frozen"`: the connected node has validated this block.
     * - `"dead"`: the connected node failed to validate this block.
     */
    
    /**
     * @internal
     */
    const SlotUpdateResult = superstruct.union([superstruct.type({
      type: superstruct.union([superstruct.literal('firstShredReceived'), superstruct.literal('completed'), superstruct.literal('optimisticConfirmation'), superstruct.literal('root')]),
      slot: superstruct.number(),
      timestamp: superstruct.number()
    }), superstruct.type({
      type: superstruct.literal('createdBank'),
      parent: superstruct.number(),
      slot: superstruct.number(),
      timestamp: superstruct.number()
    }), superstruct.type({
      type: superstruct.literal('frozen'),
      slot: superstruct.number(),
      timestamp: superstruct.number(),
      stats: superstruct.type({
        numTransactionEntries: superstruct.number(),
        numSuccessfulTransactions: superstruct.number(),
        numFailedTransactions: superstruct.number(),
        maxTransactionsPerEntry: superstruct.number()
      })
    }), superstruct.type({
      type: superstruct.literal('dead'),
      slot: superstruct.number(),
      timestamp: superstruct.number(),
      err: superstruct.string()
    })]);
    /**
     * Expected JSON RPC response for the "slotsUpdatesNotification" message
     */
    
    const SlotUpdateNotificationResult = superstruct.type({
      subscription: superstruct.number(),
      result: SlotUpdateResult
    });
    /**
     * Expected JSON RPC response for the "signatureNotification" message
     */
    
    const SignatureNotificationResult = superstruct.type({
      subscription: superstruct.number(),
      result: notificationResultAndContext(superstruct.union([SignatureStatusResult, SignatureReceivedResult]))
    });
    /**
     * Expected JSON RPC response for the "rootNotification" message
     */
    
    const RootNotificationResult = superstruct.type({
      subscription: superstruct.number(),
      result: superstruct.number()
    });
    const ContactInfoResult = superstruct.type({
      pubkey: superstruct.string(),
      gossip: superstruct.nullable(superstruct.string()),
      tpu: superstruct.nullable(superstruct.string()),
      rpc: superstruct.nullable(superstruct.string()),
      version: superstruct.nullable(superstruct.string())
    });
    const VoteAccountInfoResult = superstruct.type({
      votePubkey: superstruct.string(),
      nodePubkey: superstruct.string(),
      activatedStake: superstruct.number(),
      epochVoteAccount: superstruct.boolean(),
      epochCredits: superstruct.array(superstruct.tuple([superstruct.number(), superstruct.number(), superstruct.number()])),
      commission: superstruct.number(),
      lastVote: superstruct.number(),
      rootSlot: superstruct.nullable(superstruct.number())
    });
    /**
     * Expected JSON RPC response for the "getVoteAccounts" message
     */
    
    const GetVoteAccounts = jsonRpcResult(superstruct.type({
      current: superstruct.array(VoteAccountInfoResult),
      delinquent: superstruct.array(VoteAccountInfoResult)
    }));
    const ConfirmationStatus = superstruct.union([superstruct.literal('processed'), superstruct.literal('confirmed'), superstruct.literal('finalized')]);
    const SignatureStatusResponse = superstruct.type({
      slot: superstruct.number(),
      confirmations: superstruct.nullable(superstruct.number()),
      err: TransactionErrorResult,
      confirmationStatus: superstruct.optional(ConfirmationStatus)
    });
    /**
     * Expected JSON RPC response for the "getSignatureStatuses" message
     */
    
    const GetSignatureStatusesRpcResult = jsonRpcResultAndContext(superstruct.array(superstruct.nullable(SignatureStatusResponse)));
    /**
     * Expected JSON RPC response for the "getMinimumBalanceForRentExemption" message
     */
    
    const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(superstruct.number());
    const AddressTableLookupStruct = superstruct.type({
      accountKey: PublicKeyFromString,
      writableIndexes: superstruct.array(superstruct.number()),
      readonlyIndexes: superstruct.array(superstruct.number())
    });
    const ConfirmedTransactionResult = superstruct.type({
      signatures: superstruct.array(superstruct.string()),
      message: superstruct.type({
        accountKeys: superstruct.array(superstruct.string()),
        header: superstruct.type({
          numRequiredSignatures: superstruct.number(),
          numReadonlySignedAccounts: superstruct.number(),
          numReadonlyUnsignedAccounts: superstruct.number()
        }),
        instructions: superstruct.array(superstruct.type({
          accounts: superstruct.array(superstruct.number()),
          data: superstruct.string(),
          programIdIndex: superstruct.number()
        })),
        recentBlockhash: superstruct.string(),
        addressTableLookups: superstruct.optional(superstruct.array(AddressTableLookupStruct))
      })
    });
    const ParsedInstructionResult = superstruct.type({
      parsed: superstruct.unknown(),
      program: superstruct.string(),
      programId: PublicKeyFromString
    });
    const RawInstructionResult = superstruct.type({
      accounts: superstruct.array(PublicKeyFromString),
      data: superstruct.string(),
      programId: PublicKeyFromString
    });
    const InstructionResult = superstruct.union([RawInstructionResult, ParsedInstructionResult]);
    const UnknownInstructionResult = superstruct.union([superstruct.type({
      parsed: superstruct.unknown(),
      program: superstruct.string(),
      programId: superstruct.string()
    }), superstruct.type({
      accounts: superstruct.array(superstruct.string()),
      data: superstruct.string(),
      programId: superstruct.string()
    })]);
    const ParsedOrRawInstruction = superstruct.coerce(InstructionResult, UnknownInstructionResult, value => {
      if ('accounts' in value) {
        return superstruct.create(value, RawInstructionResult);
      } else {
        return superstruct.create(value, ParsedInstructionResult);
      }
    });
    /**
     * @internal
     */
    
    const ParsedConfirmedTransactionResult = superstruct.type({
      signatures: superstruct.array(superstruct.string()),
      message: superstruct.type({
        accountKeys: superstruct.array(superstruct.type({
          pubkey: PublicKeyFromString,
          signer: superstruct.boolean(),
          writable: superstruct.boolean(),
          source: superstruct.optional(superstruct.union([superstruct.literal('transaction'), superstruct.literal('lookupTable')]))
        })),
        instructions: superstruct.array(ParsedOrRawInstruction),
        recentBlockhash: superstruct.string(),
        addressTableLookups: superstruct.optional(superstruct.nullable(superstruct.array(AddressTableLookupStruct)))
      })
    });
    const TokenBalanceResult = superstruct.type({
      accountIndex: superstruct.number(),
      mint: superstruct.string(),
      owner: superstruct.optional(superstruct.string()),
      uiTokenAmount: TokenAmountResult
    });
    const LoadedAddressesResult = superstruct.type({
      writable: superstruct.array(PublicKeyFromString),
      readonly: superstruct.array(PublicKeyFromString)
    });
    /**
     * @internal
     */
    
    const ConfirmedTransactionMetaResult = superstruct.type({
      err: TransactionErrorResult,
      fee: superstruct.number(),
      innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
        index: superstruct.number(),
        instructions: superstruct.array(superstruct.type({
          accounts: superstruct.array(superstruct.number()),
          data: superstruct.string(),
          programIdIndex: superstruct.number()
        }))
      })))),
      preBalances: superstruct.array(superstruct.number()),
      postBalances: superstruct.array(superstruct.number()),
      logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),
      preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
      postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
      loadedAddresses: superstruct.optional(LoadedAddressesResult),
      computeUnitsConsumed: superstruct.optional(superstruct.number())
    });
    /**
     * @internal
     */
    
    const ParsedConfirmedTransactionMetaResult = superstruct.type({
      err: TransactionErrorResult,
      fee: superstruct.number(),
      innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
        index: superstruct.number(),
        instructions: superstruct.array(ParsedOrRawInstruction)
      })))),
      preBalances: superstruct.array(superstruct.number()),
      postBalances: superstruct.array(superstruct.number()),
      logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),
      preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
      postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
      loadedAddresses: superstruct.optional(LoadedAddressesResult),
      computeUnitsConsumed: superstruct.optional(superstruct.number())
    });
    const TransactionVersionStruct = superstruct.union([superstruct.literal(0), superstruct.literal('legacy')]);
    /**
     * Expected JSON RPC response for the "getBlock" message
     */
    
    const GetBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
      blockhash: superstruct.string(),
      previousBlockhash: superstruct.string(),
      parentSlot: superstruct.number(),
      transactions: superstruct.array(superstruct.type({
        transaction: ConfirmedTransactionResult,
        meta: superstruct.nullable(ConfirmedTransactionMetaResult),
        version: superstruct.optional(TransactionVersionStruct)
      })),
      rewards: superstruct.optional(superstruct.array(superstruct.type({
        pubkey: superstruct.string(),
        lamports: superstruct.number(),
        postBalance: superstruct.nullable(superstruct.number()),
        rewardType: superstruct.nullable(superstruct.string())
      }))),
      blockTime: superstruct.nullable(superstruct.number()),
      blockHeight: superstruct.nullable(superstruct.number())
    })));
    /**
     * Expected JSON RPC response for the "getConfirmedBlock" message
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.
     */
    
    const GetConfirmedBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
      blockhash: superstruct.string(),
      previousBlockhash: superstruct.string(),
      parentSlot: superstruct.number(),
      transactions: superstruct.array(superstruct.type({
        transaction: ConfirmedTransactionResult,
        meta: superstruct.nullable(ConfirmedTransactionMetaResult)
      })),
      rewards: superstruct.optional(superstruct.array(superstruct.type({
        pubkey: superstruct.string(),
        lamports: superstruct.number(),
        postBalance: superstruct.nullable(superstruct.number()),
        rewardType: superstruct.nullable(superstruct.string())
      }))),
      blockTime: superstruct.nullable(superstruct.number())
    })));
    /**
     * Expected JSON RPC response for the "getBlock" message
     */
    
    const GetBlockSignaturesRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
      blockhash: superstruct.string(),
      previousBlockhash: superstruct.string(),
      parentSlot: superstruct.number(),
      signatures: superstruct.array(superstruct.string()),
      blockTime: superstruct.nullable(superstruct.number())
    })));
    /**
     * Expected JSON RPC response for the "getTransaction" message
     */
    
    const GetTransactionRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
      slot: superstruct.number(),
      meta: ConfirmedTransactionMetaResult,
      blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),
      transaction: ConfirmedTransactionResult,
      version: superstruct.optional(TransactionVersionStruct)
    })));
    /**
     * Expected parsed JSON RPC response for the "getTransaction" message
     */
    
    const GetParsedTransactionRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({
      slot: superstruct.number(),
      transaction: ParsedConfirmedTransactionResult,
      meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),
      blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),
      version: superstruct.optional(TransactionVersionStruct)
    })));
    /**
     * Expected JSON RPC response for the "getRecentBlockhash" message
     *
     * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.
     */
    
    const GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(superstruct.type({
      blockhash: superstruct.string(),
      feeCalculator: superstruct.type({
        lamportsPerSignature: superstruct.number()
      })
    }));
    /**
     * Expected JSON RPC response for the "getLatestBlockhash" message
     */
    
    const GetLatestBlockhashRpcResult = jsonRpcResultAndContext(superstruct.type({
      blockhash: superstruct.string(),
      lastValidBlockHeight: superstruct.number()
    }));
    const PerfSampleResult = superstruct.type({
      slot: superstruct.number(),
      numTransactions: superstruct.number(),
      numSlots: superstruct.number(),
      samplePeriodSecs: superstruct.number()
    });
    /*
     * Expected JSON RPC response for "getRecentPerformanceSamples" message
     */
    
    const GetRecentPerformanceSamplesRpcResult = jsonRpcResult(superstruct.array(PerfSampleResult));
    /**
     * Expected JSON RPC response for the "getFeeCalculatorForBlockhash" message
     */
    
    const GetFeeCalculatorRpcResult = jsonRpcResultAndContext(superstruct.nullable(superstruct.type({
      feeCalculator: superstruct.type({
        lamportsPerSignature: superstruct.number()
      })
    })));
    /**
     * Expected JSON RPC response for the "requestAirdrop" message
     */
    
    const RequestAirdropRpcResult = jsonRpcResult(superstruct.string());
    /**
     * Expected JSON RPC response for the "sendTransaction" message
     */
    
    const SendTransactionRpcResult = jsonRpcResult(superstruct.string());
    /**
     * Information about the latest slot being processed by a node
     */
    
    /**
     * @internal
     */
    const LogsResult = superstruct.type({
      err: TransactionErrorResult,
      logs: superstruct.array(superstruct.string()),
      signature: superstruct.string()
    });
    /**
     * Logs result.
     */
    
    /**
     * Expected JSON RPC response for the "logsNotification" message.
     */
    const LogsNotificationResult = superstruct.type({
      result: notificationResultAndContext(LogsResult),
      subscription: superstruct.number()
    });
    /**
     * Filter for log subscriptions.
     */
    
    /** @internal */
    const COMMON_HTTP_HEADERS = {
      'solana-client': `js/${(_process$env$npm_pack = "0.0.0-development") !== null && _process$env$npm_pack !== void 0 ? _process$env$npm_pack : 'UNKNOWN'}`
    };
    /**
     * A connection to a fullnode JSON RPC endpoint
     */
    
    class Connection {
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal
       * A number that we increment every time an active connection closes.
       * Used to determine whether the same socket connection that was open
       * when an async operation started is the same one that's active when
       * its continuation fires.
       *
       */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /** @internal */
    
      /**
       * Special case.
       * After a signature is processed, RPCs automatically dispose of the
       * subscription on the server side. We need to track which of these
       * subscriptions have been disposed in such a way, so that we know
       * whether the client is dealing with a not-yet-processed signature
       * (in which case we must tear down the server subscription) or an
       * already-processed signature (in which case the client can simply
       * clear out the subscription locally without telling the server).
       *
       * NOTE: There is a proposal to eliminate this special case, here:
       * https://github.com/solana-labs/solana/issues/18892
       */
    
      /** @internal */
    
      /**
       * Establish a JSON RPC connection
       *
       * @param endpoint URL to the fullnode JSON RPC endpoint
       * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
       */
      constructor(endpoint, commitmentOrConfig) {
        this._commitment = void 0;
        this._confirmTransactionInitialTimeout = void 0;
        this._rpcEndpoint = void 0;
        this._rpcWsEndpoint = void 0;
        this._rpcClient = void 0;
        this._rpcRequest = void 0;
        this._rpcBatchRequest = void 0;
        this._rpcWebSocket = void 0;
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketHeartbeat = null;
        this._rpcWebSocketIdleTimeout = null;
        this._rpcWebSocketGeneration = 0;
        this._disableBlockhashCaching = false;
        this._pollingBlockhash = false;
        this._blockhashInfo = {
          latestBlockhash: null,
          lastFetch: 0,
          transactionSignatures: [],
          simulatedSignatures: []
        };
        this._nextClientSubscriptionId = 0;
        this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
        this._subscriptionCallbacksByServerSubscriptionId = {};
        this._subscriptionsByHash = {};
        this._subscriptionsAutoDisposedByRpc = new Set();
        let wsEndpoint;
        let httpHeaders;
        let fetch;
        let fetchMiddleware;
        let disableRetryOnRateLimit;
    
        if (commitmentOrConfig && typeof commitmentOrConfig === 'string') {
          this._commitment = commitmentOrConfig;
        } else if (commitmentOrConfig) {
          this._commitment = commitmentOrConfig.commitment;
          this._confirmTransactionInitialTimeout = commitmentOrConfig.confirmTransactionInitialTimeout;
          wsEndpoint = commitmentOrConfig.wsEndpoint;
          httpHeaders = commitmentOrConfig.httpHeaders;
          fetch = commitmentOrConfig.fetch;
          fetchMiddleware = commitmentOrConfig.fetchMiddleware;
          disableRetryOnRateLimit = commitmentOrConfig.disableRetryOnRateLimit;
        }
    
        this._rpcEndpoint = assertEndpointUrl(endpoint);
        this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);
        this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit);
        this._rpcRequest = createRpcRequest(this._rpcClient);
        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
        this._rpcWebSocket = new rpcWebsockets.Client(this._rpcWsEndpoint, {
          autoconnect: false,
          max_reconnects: Infinity
        });
    
        this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));
    
        this._rpcWebSocket.on('error', this._wsOnError.bind(this));
    
        this._rpcWebSocket.on('close', this._wsOnClose.bind(this));
    
        this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));
    
        this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));
    
        this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));
    
        this._rpcWebSocket.on('slotsUpdatesNotification', this._wsOnSlotUpdatesNotification.bind(this));
    
        this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));
    
        this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this));
    
        this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));
      }
      /**
       * The default commitment used for requests
       */
    
    
      get commitment() {
        return this._commitment;
      }
      /**
       * The RPC endpoint
       */
    
    
      get rpcEndpoint() {
        return this._rpcEndpoint;
      }
      /**
       * Fetch the balance for the specified public key, return with context
       */
    
    
      async getBalanceAndContext(publicKey, commitmentOrConfig) {
        /** @internal */
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
    
        const args = this._buildArgs([publicKey.toBase58()], commitment, undefined
        /* encoding */
        , config);
    
        const unsafeRes = await this._rpcRequest('getBalance', args);
        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.number()));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);
        }
    
        return res.result;
      }
      /**
       * Fetch the balance for the specified public key
       */
    
    
      async getBalance(publicKey, commitmentOrConfig) {
        return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then(x => x.value).catch(e => {
          throw new Error('failed to get balance of account ' + publicKey.toBase58() + ': ' + e);
        });
      }
      /**
       * Fetch the estimated production time of a block
       */
    
    
      async getBlockTime(slot) {
        const unsafeRes = await this._rpcRequest('getBlockTime', [slot]);
        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.nullable(superstruct.number())));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
        }
    
        return res.result;
      }
      /**
       * Fetch the lowest slot that the node has information about in its ledger.
       * This value may increase over time if the node is configured to purge older ledger data
       */
    
    
      async getMinimumLedgerSlot() {
        const unsafeRes = await this._rpcRequest('minimumLedgerSlot', []);
        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get minimum ledger slot');
        }
    
        return res.result;
      }
      /**
       * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
       */
    
    
      async getFirstAvailableBlock() {
        const unsafeRes = await this._rpcRequest('getFirstAvailableBlock', []);
        const res = superstruct.create(unsafeRes, SlotRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get first available block');
        }
    
        return res.result;
      }
      /**
       * Fetch information about the current supply
       */
    
    
      async getSupply(config) {
        let configArg = {};
    
        if (typeof config === 'string') {
          configArg = {
            commitment: config
          };
        } else if (config) {
          configArg = { ...config,
            commitment: config && config.commitment || this.commitment
          };
        } else {
          configArg = {
            commitment: this.commitment
          };
        }
    
        const unsafeRes = await this._rpcRequest('getSupply', [configArg]);
        const res = superstruct.create(unsafeRes, GetSupplyRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get supply');
        }
    
        return res.result;
      }
      /**
       * Fetch the current supply of a token mint
       */
    
    
      async getTokenSupply(tokenMintAddress, commitment) {
        const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
    
        const unsafeRes = await this._rpcRequest('getTokenSupply', args);
        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get token supply');
        }
    
        return res.result;
      }
      /**
       * Fetch the current balance of a token account
       */
    
    
      async getTokenAccountBalance(tokenAddress, commitment) {
        const args = this._buildArgs([tokenAddress.toBase58()], commitment);
    
        const unsafeRes = await this._rpcRequest('getTokenAccountBalance', args);
        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get token account balance');
        }
    
        return res.result;
      }
      /**
       * Fetch all the token accounts owned by the specified account
       *
       * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>>}
       */
    
    
      async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        let _args = [ownerAddress.toBase58()];
    
        if ('mint' in filter) {
          _args.push({
            mint: filter.mint.toBase58()
          });
        } else {
          _args.push({
            programId: filter.programId.toBase58()
          });
        }
    
        const args = this._buildArgs(_args, commitment, 'base64', config);
    
        const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);
        const res = superstruct.create(unsafeRes, GetTokenAccountsByOwner);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
        }
    
        return res.result;
      }
      /**
       * Fetch parsed token accounts owned by the specified account
       *
       * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
       */
    
    
      async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
        let _args = [ownerAddress.toBase58()];
    
        if ('mint' in filter) {
          _args.push({
            mint: filter.mint.toBase58()
          });
        } else {
          _args.push({
            programId: filter.programId.toBase58()
          });
        }
    
        const args = this._buildArgs(_args, commitment, 'jsonParsed');
    
        const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);
        const res = superstruct.create(unsafeRes, GetParsedTokenAccountsByOwner);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
        }
    
        return res.result;
      }
      /**
       * Fetch the 20 largest accounts with their current balances
       */
    
    
      async getLargestAccounts(config) {
        const arg = { ...config,
          commitment: config && config.commitment || this.commitment
        };
        const args = arg.filter || arg.commitment ? [arg] : [];
        const unsafeRes = await this._rpcRequest('getLargestAccounts', args);
        const res = superstruct.create(unsafeRes, GetLargestAccountsRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get largest accounts');
        }
    
        return res.result;
      }
      /**
       * Fetch the 20 largest token accounts with their current balances
       * for a given mint.
       */
    
    
      async getTokenLargestAccounts(mintAddress, commitment) {
        const args = this._buildArgs([mintAddress.toBase58()], commitment);
    
        const unsafeRes = await this._rpcRequest('getTokenLargestAccounts', args);
        const res = superstruct.create(unsafeRes, GetTokenLargestAccountsResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get token largest accounts');
        }
    
        return res.result;
      }
      /**
       * Fetch all the account info for the specified public key, return with context
       */
    
    
      async getAccountInfoAndContext(publicKey, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
    
        const args = this._buildArgs([publicKey.toBase58()], commitment, 'base64', config);
    
        const unsafeRes = await this._rpcRequest('getAccountInfo', args);
        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(AccountInfoResult)));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);
        }
    
        return res.result;
      }
      /**
       * Fetch parsed account info for the specified public key
       */
    
    
      async getParsedAccountInfo(publicKey, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
    
        const args = this._buildArgs([publicKey.toBase58()], commitment, 'jsonParsed', config);
    
        const unsafeRes = await this._rpcRequest('getAccountInfo', args);
        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(ParsedAccountInfoResult)));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);
        }
    
        return res.result;
      }
      /**
       * Fetch all the account info for the specified public key
       */
    
    
      async getAccountInfo(publicKey, commitmentOrConfig) {
        try {
          const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);
          return res.value;
        } catch (e) {
          throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + e);
        }
      }
      /**
       * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
       */
    
    
      async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const keys = publicKeys.map(key => key.toBase58());
    
        const args = this._buildArgs([keys], commitment, 'base64', config);
    
        const unsafeRes = await this._rpcRequest('getMultipleAccounts', args);
        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.array(superstruct.nullable(AccountInfoResult))));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
        }
    
        return res.result;
      }
      /**
       * Fetch all the account info for multiple accounts specified by an array of public keys
       */
    
    
      async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
        const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
        return res.value;
      }
      /**
       * Returns epoch activation information for a stake account that has been delegated
       */
    
    
      async getStakeActivation(publicKey, commitmentOrConfig, epoch) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
    
        const args = this._buildArgs([publicKey.toBase58()], commitment, undefined
        /* encoding */
        , { ...config,
          epoch: epoch != null ? epoch : config === null || config === void 0 ? void 0 : config.epoch
        });
    
        const unsafeRes = await this._rpcRequest('getStakeActivation', args);
        const res = superstruct.create(unsafeRes, jsonRpcResult(StakeActivationResult));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);
        }
    
        return res.result;
      }
      /**
       * Fetch all the accounts owned by the specified program id
       *
       * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
       */
    
    
      async getProgramAccounts(programId, configOrCommitment) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(configOrCommitment);
        const {
          encoding,
          ...configWithoutEncoding
        } = config || {};
    
        const args = this._buildArgs([programId.toBase58()], commitment, encoding || 'base64', configWithoutEncoding);
    
        const unsafeRes = await this._rpcRequest('getProgramAccounts', args);
        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(KeyedAccountInfoResult)));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
        }
    
        return res.result;
      }
      /**
       * Fetch and parse all the accounts owned by the specified program id
       *
       * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
       */
    
    
      async getParsedProgramAccounts(programId, configOrCommitment) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(configOrCommitment);
    
        const args = this._buildArgs([programId.toBase58()], commitment, 'jsonParsed', config);
    
        const unsafeRes = await this._rpcRequest('getProgramAccounts', args);
        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(KeyedParsedAccountInfoResult)));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
        }
    
        return res.result;
      }
    
      // eslint-disable-next-line no-dupe-class-members
      async confirmTransaction(strategy, commitment) {
        let rawSignature;
    
        if (typeof strategy == 'string') {
          rawSignature = strategy;
        } else {
          const config = strategy;
          rawSignature = config.signature;
        }
    
        let decodedSignature;
    
        try {
          decodedSignature = bs58__default["default"].decode(rawSignature);
        } catch (err) {
          throw new Error('signature must be base58 encoded: ' + rawSignature);
        }
    
        assert(decodedSignature.length === 64, 'signature has invalid length');
        const subscriptionCommitment = commitment || this.commitment;
        let timeoutId;
        let subscriptionId;
        let done = false;
        const confirmationPromise = new Promise((resolve, reject) => {
          try {
            subscriptionId = this.onSignature(rawSignature, (result, context) => {
              subscriptionId = undefined;
              const response = {
                context,
                value: result
              };
              done = true;
              resolve({
                __type: exports.TransactionStatus.PROCESSED,
                response
              });
            }, subscriptionCommitment);
          } catch (err) {
            reject(err);
          }
        });
        const expiryPromise = new Promise(resolve => {
          if (typeof strategy === 'string') {
            let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;
    
            switch (subscriptionCommitment) {
              case 'processed':
              case 'recent':
              case 'single':
              case 'confirmed':
              case 'singleGossip':
                {
                  timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;
                  break;
                }
            }
    
            timeoutId = setTimeout(() => resolve({
              __type: exports.TransactionStatus.TIMED_OUT,
              timeoutMs
            }), timeoutMs);
          } else {
            let config = strategy;
    
            const checkBlockHeight = async () => {
              try {
                const blockHeight = await this.getBlockHeight(commitment);
                return blockHeight;
              } catch (_e) {
                return -1;
              }
            };
    
            (async () => {
              let currentBlockHeight = await checkBlockHeight();
              if (done) return;
    
              while (currentBlockHeight <= config.lastValidBlockHeight) {
                await sleep(1000);
                if (done) return;
                currentBlockHeight = await checkBlockHeight();
                if (done) return;
              }
    
              resolve({
                __type: exports.TransactionStatus.BLOCKHEIGHT_EXCEEDED
              });
            })();
          }
        });
        let result;
    
        try {
          const outcome = await Promise.race([confirmationPromise, expiryPromise]);
    
          switch (outcome.__type) {
            case exports.TransactionStatus.BLOCKHEIGHT_EXCEEDED:
              throw new TransactionExpiredBlockheightExceededError(rawSignature);
    
            case exports.TransactionStatus.PROCESSED:
              result = outcome.response;
              break;
    
            case exports.TransactionStatus.TIMED_OUT:
              throw new TransactionExpiredTimeoutError(rawSignature, outcome.timeoutMs / 1000);
          }
        } finally {
          clearTimeout(timeoutId);
    
          if (subscriptionId) {
            this.removeSignatureListener(subscriptionId);
          }
        }
    
        return result;
      }
      /**
       * Return the list of nodes that are currently participating in the cluster
       */
    
    
      async getClusterNodes() {
        const unsafeRes = await this._rpcRequest('getClusterNodes', []);
        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(ContactInfoResult)));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get cluster nodes');
        }
    
        return res.result;
      }
      /**
       * Return the list of nodes that are currently participating in the cluster
       */
    
    
      async getVoteAccounts(commitment) {
        const args = this._buildArgs([], commitment);
    
        const unsafeRes = await this._rpcRequest('getVoteAccounts', args);
        const res = superstruct.create(unsafeRes, GetVoteAccounts);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get vote accounts');
        }
    
        return res.result;
      }
      /**
       * Fetch the current slot that the node is processing
       */
    
    
      async getSlot(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
    
        const args = this._buildArgs([], commitment, undefined
        /* encoding */
        , config);
    
        const unsafeRes = await this._rpcRequest('getSlot', args);
        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get slot');
        }
    
        return res.result;
      }
      /**
       * Fetch the current slot leader of the cluster
       */
    
    
      async getSlotLeader(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
    
        const args = this._buildArgs([], commitment, undefined
        /* encoding */
        , config);
    
        const unsafeRes = await this._rpcRequest('getSlotLeader', args);
        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.string()));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get slot leader');
        }
    
        return res.result;
      }
      /**
       * Fetch `limit` number of slot leaders starting from `startSlot`
       *
       * @param startSlot fetch slot leaders starting from this slot
       * @param limit number of slot leaders to return
       */
    
    
      async getSlotLeaders(startSlot, limit) {
        const args = [startSlot, limit];
        const unsafeRes = await this._rpcRequest('getSlotLeaders', args);
        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(PublicKeyFromString)));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get slot leaders');
        }
    
        return res.result;
      }
      /**
       * Fetch the current status of a signature
       */
    
    
      async getSignatureStatus(signature, config) {
        const {
          context,
          value: values
        } = await this.getSignatureStatuses([signature], config);
        assert(values.length === 1);
        const value = values[0];
        return {
          context,
          value
        };
      }
      /**
       * Fetch the current statuses of a batch of signatures
       */
    
    
      async getSignatureStatuses(signatures, config) {
        const params = [signatures];
    
        if (config) {
          params.push(config);
        }
    
        const unsafeRes = await this._rpcRequest('getSignatureStatuses', params);
        const res = superstruct.create(unsafeRes, GetSignatureStatusesRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get signature status');
        }
    
        return res.result;
      }
      /**
       * Fetch the current transaction count of the cluster
       */
    
    
      async getTransactionCount(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
    
        const args = this._buildArgs([], commitment, undefined
        /* encoding */
        , config);
    
        const unsafeRes = await this._rpcRequest('getTransactionCount', args);
        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get transaction count');
        }
    
        return res.result;
      }
      /**
       * Fetch the current total currency supply of the cluster in lamports
       *
       * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.
       */
    
    
      async getTotalSupply(commitment) {
        const result = await this.getSupply({
          commitment,
          excludeNonCirculatingAccountsList: true
        });
        return result.value.total;
      }
      /**
       * Fetch the cluster InflationGovernor parameters
       */
    
    
      async getInflationGovernor(commitment) {
        const args = this._buildArgs([], commitment);
    
        const unsafeRes = await this._rpcRequest('getInflationGovernor', args);
        const res = superstruct.create(unsafeRes, GetInflationGovernorRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get inflation');
        }
    
        return res.result;
      }
      /**
       * Fetch the inflation reward for a list of addresses for an epoch
       */
    
    
      async getInflationReward(addresses, epoch, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
    
        const args = this._buildArgs([addresses.map(pubkey => pubkey.toBase58())], commitment, undefined
        /* encoding */
        , { ...config,
          epoch: epoch != null ? epoch : config === null || config === void 0 ? void 0 : config.epoch
        });
    
        const unsafeRes = await this._rpcRequest('getInflationReward', args);
        const res = superstruct.create(unsafeRes, GetInflationRewardResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get inflation reward');
        }
    
        return res.result;
      }
      /**
       * Fetch the Epoch Info parameters
       */
    
    
      async getEpochInfo(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
    
        const args = this._buildArgs([], commitment, undefined
        /* encoding */
        , config);
    
        const unsafeRes = await this._rpcRequest('getEpochInfo', args);
        const res = superstruct.create(unsafeRes, GetEpochInfoRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get epoch info');
        }
    
        return res.result;
      }
      /**
       * Fetch the Epoch Schedule parameters
       */
    
    
      async getEpochSchedule() {
        const unsafeRes = await this._rpcRequest('getEpochSchedule', []);
        const res = superstruct.create(unsafeRes, GetEpochScheduleRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get epoch schedule');
        }
    
        const epochSchedule = res.result;
        return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
      }
      /**
       * Fetch the leader schedule for the current epoch
       * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
       */
    
    
      async getLeaderSchedule() {
        const unsafeRes = await this._rpcRequest('getLeaderSchedule', []);
        const res = superstruct.create(unsafeRes, GetLeaderScheduleRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get leader schedule');
        }
    
        return res.result;
      }
      /**
       * Fetch the minimum balance needed to exempt an account of `dataLength`
       * size from rent
       */
    
    
      async getMinimumBalanceForRentExemption(dataLength, commitment) {
        const args = this._buildArgs([dataLength], commitment);
    
        const unsafeRes = await this._rpcRequest('getMinimumBalanceForRentExemption', args);
        const res = superstruct.create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
    
        if ('error' in res) {
          console.warn('Unable to fetch minimum balance for rent exemption');
          return 0;
        }
    
        return res.result;
      }
      /**
       * Fetch a recent blockhash from the cluster, return with context
       * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
       */
    
    
      async getRecentBlockhashAndContext(commitment) {
        const args = this._buildArgs([], commitment);
    
        const unsafeRes = await this._rpcRequest('getRecentBlockhash', args);
        const res = superstruct.create(unsafeRes, GetRecentBlockhashAndContextRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get recent blockhash');
        }
    
        return res.result;
      }
      /**
       * Fetch recent performance samples
       * @return {Promise<Array<PerfSample>>}
       */
    
    
      async getRecentPerformanceSamples(limit) {
        const unsafeRes = await this._rpcRequest('getRecentPerformanceSamples', limit ? [limit] : []);
        const res = superstruct.create(unsafeRes, GetRecentPerformanceSamplesRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get recent performance samples');
        }
    
        return res.result;
      }
      /**
       * Fetch the fee calculator for a recent blockhash from the cluster, return with context
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.
       */
    
    
      async getFeeCalculatorForBlockhash(blockhash, commitment) {
        const args = this._buildArgs([blockhash], commitment);
    
        const unsafeRes = await this._rpcRequest('getFeeCalculatorForBlockhash', args);
        const res = superstruct.create(unsafeRes, GetFeeCalculatorRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get fee calculator');
        }
    
        const {
          context,
          value
        } = res.result;
        return {
          context,
          value: value !== null ? value.feeCalculator : null
        };
      }
      /**
       * Fetch the fee for a message from the cluster, return with context
       */
    
    
      async getFeeForMessage(message, commitment) {
        const wireMessage = message.serialize().toString('base64');
    
        const args = this._buildArgs([wireMessage], commitment);
    
        const unsafeRes = await this._rpcRequest('getFeeForMessage', args);
        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(superstruct.number())));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get slot');
        }
    
        if (res.result === null) {
          throw new Error('invalid blockhash');
        }
    
        return res.result;
      }
      /**
       * Fetch a recent blockhash from the cluster
       * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
       */
    
    
      async getRecentBlockhash(commitment) {
        try {
          const res = await this.getRecentBlockhashAndContext(commitment);
          return res.value;
        } catch (e) {
          throw new Error('failed to get recent blockhash: ' + e);
        }
      }
      /**
       * Fetch the latest blockhash from the cluster
       * @return {Promise<BlockhashWithExpiryBlockHeight>}
       */
    
    
      async getLatestBlockhash(commitmentOrConfig) {
        try {
          const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
          return res.value;
        } catch (e) {
          throw new Error('failed to get recent blockhash: ' + e);
        }
      }
      /**
       * Fetch the latest blockhash from the cluster
       * @return {Promise<BlockhashWithExpiryBlockHeight>}
       */
    
    
      async getLatestBlockhashAndContext(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
    
        const args = this._buildArgs([], commitment, undefined
        /* encoding */
        , config);
    
        const unsafeRes = await this._rpcRequest('getLatestBlockhash', args);
        const res = superstruct.create(unsafeRes, GetLatestBlockhashRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get latest blockhash');
        }
    
        return res.result;
      }
      /**
       * Fetch the node version
       */
    
    
      async getVersion() {
        const unsafeRes = await this._rpcRequest('getVersion', []);
        const res = superstruct.create(unsafeRes, jsonRpcResult(VersionResult));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get version');
        }
    
        return res.result;
      }
      /**
       * Fetch the genesis hash
       */
    
    
      async getGenesisHash() {
        const unsafeRes = await this._rpcRequest('getGenesisHash', []);
        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.string()));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get genesis hash');
        }
    
        return res.result;
      }
      /**
       * Fetch a processed block from the cluster.
       *
       * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
       * setting the `maxSupportedTransactionVersion` property.
       */
    
    
      /**
       * Fetch a processed block from the cluster.
       */
      // eslint-disable-next-line no-dupe-class-members
      async getBlock(slot, rawConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(rawConfig);
    
        const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined
        /* encoding */
        , config);
    
        const unsafeRes = await this._rpcRequest('getBlock', args);
        const res = superstruct.create(unsafeRes, GetBlockRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');
        }
    
        const result = res.result;
        if (!result) return result;
        return { ...result,
          transactions: result.transactions.map(({
            transaction,
            meta,
            version
          }) => ({
            meta,
            transaction: { ...transaction,
              message: versionedMessageFromResponse(version, transaction.message)
            },
            version
          }))
        };
      }
      /*
       * Returns the current block height of the node
       */
    
    
      async getBlockHeight(commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
    
        const args = this._buildArgs([], commitment, undefined
        /* encoding */
        , config);
    
        const unsafeRes = await this._rpcRequest('getBlockHeight', args);
        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get block height information');
        }
    
        return res.result;
      }
      /*
       * Returns recent block production information from the current or previous epoch
       */
    
    
      async getBlockProduction(configOrCommitment) {
        let extra;
        let commitment;
    
        if (typeof configOrCommitment === 'string') {
          commitment = configOrCommitment;
        } else if (configOrCommitment) {
          const {
            commitment: c,
            ...rest
          } = configOrCommitment;
          commitment = c;
          extra = rest;
        }
    
        const args = this._buildArgs([], commitment, 'base64', extra);
    
        const unsafeRes = await this._rpcRequest('getBlockProduction', args);
        const res = superstruct.create(unsafeRes, BlockProductionResponseStruct);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get block production information');
        }
    
        return res.result;
      }
      /**
       * Fetch a confirmed or finalized transaction from the cluster.
       *
       * @deprecated Instead, call `getTransaction` using a
       * `GetVersionedTransactionConfig` by setting the
       * `maxSupportedTransactionVersion` property.
       */
    
    
      /**
       * Fetch a confirmed or finalized transaction from the cluster.
       */
      // eslint-disable-next-line no-dupe-class-members
      async getTransaction(signature, rawConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(rawConfig);
    
        const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined
        /* encoding */
        , config);
    
        const unsafeRes = await this._rpcRequest('getTransaction', args);
        const res = superstruct.create(unsafeRes, GetTransactionRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
        }
    
        const result = res.result;
        if (!result) return result;
        return { ...result,
          transaction: { ...result.transaction,
            message: versionedMessageFromResponse(result.version, result.transaction.message)
          }
        };
      }
      /**
       * Fetch parsed transaction details for a confirmed or finalized transaction
       */
    
    
      async getParsedTransaction(signature, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
    
        const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);
    
        const unsafeRes = await this._rpcRequest('getTransaction', args);
        const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
        }
    
        return res.result;
      }
      /**
       * Fetch parsed transaction details for a batch of confirmed transactions
       */
    
    
      async getParsedTransactions(signatures, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const batch = signatures.map(signature => {
          const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);
    
          return {
            methodName: 'getTransaction',
            args
          };
        });
        const unsafeRes = await this._rpcBatchRequest(batch);
        const res = unsafeRes.map(unsafeRes => {
          const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);
    
          if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, 'failed to get transactions');
          }
    
          return res.result;
        });
        return res;
      }
      /**
       * Fetch transaction details for a batch of confirmed transactions.
       * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
       *
       * @deprecated Instead, call `getTransactions` using a
       * `GetVersionedTransactionConfig` by setting the
       * `maxSupportedTransactionVersion` property.
       */
    
    
      /**
       * Fetch transaction details for a batch of confirmed transactions.
       * Similar to {@link getParsedTransactions} but returns a {@link
       * VersionedTransactionResponse}.
       */
      // eslint-disable-next-line no-dupe-class-members
      async getTransactions(signatures, commitmentOrConfig) {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const batch = signatures.map(signature => {
          const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined
          /* encoding */
          , config);
    
          return {
            methodName: 'getTransaction',
            args
          };
        });
        const unsafeRes = await this._rpcBatchRequest(batch);
        const res = unsafeRes.map(unsafeRes => {
          const res = superstruct.create(unsafeRes, GetTransactionRpcResult);
    
          if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, 'failed to get transactions');
          }
    
          const result = res.result;
          if (!result) return result;
          return { ...result,
            transaction: { ...result.transaction,
              message: versionedMessageFromResponse(result.version, result.transaction.message)
            }
          };
        });
        return res;
      }
      /**
       * Fetch a list of Transactions and transaction statuses from the cluster
       * for a confirmed block.
       *
       * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.
       */
    
    
      async getConfirmedBlock(slot, commitment) {
        const args = this._buildArgsAtLeastConfirmed([slot], commitment);
    
        const unsafeRes = await this._rpcRequest('getConfirmedBlock', args);
        const res = superstruct.create(unsafeRes, GetConfirmedBlockRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');
        }
    
        const result = res.result;
    
        if (!result) {
          throw new Error('Confirmed block ' + slot + ' not found');
        }
    
        const block = { ...result,
          transactions: result.transactions.map(({
            transaction,
            meta
          }) => {
            const message = new Message(transaction.message);
            return {
              meta,
              transaction: { ...transaction,
                message
              }
            };
          })
        };
        return { ...block,
          transactions: block.transactions.map(({
            transaction,
            meta
          }) => {
            return {
              meta,
              transaction: Transaction.populate(transaction.message, transaction.signatures)
            };
          })
        };
      }
      /**
       * Fetch confirmed blocks between two slots
       */
    
    
      async getBlocks(startSlot, endSlot, commitment) {
        const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [startSlot, endSlot] : [startSlot], commitment);
    
        const unsafeRes = await this._rpcRequest('getBlocks', args);
        const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(superstruct.number())));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get blocks');
        }
    
        return res.result;
      }
      /**
       * Fetch a list of Signatures from the cluster for a block, excluding rewards
       */
    
    
      async getBlockSignatures(slot, commitment) {
        const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
          transactionDetails: 'signatures',
          rewards: false
        });
    
        const unsafeRes = await this._rpcRequest('getBlock', args);
        const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get block');
        }
    
        const result = res.result;
    
        if (!result) {
          throw new Error('Block ' + slot + ' not found');
        }
    
        return result;
      }
      /**
       * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.
       */
    
    
      async getConfirmedBlockSignatures(slot, commitment) {
        const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
          transactionDetails: 'signatures',
          rewards: false
        });
    
        const unsafeRes = await this._rpcRequest('getConfirmedBlock', args);
        const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');
        }
    
        const result = res.result;
    
        if (!result) {
          throw new Error('Confirmed block ' + slot + ' not found');
        }
    
        return result;
      }
      /**
       * Fetch a transaction details for a confirmed transaction
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.
       */
    
    
      async getConfirmedTransaction(signature, commitment) {
        const args = this._buildArgsAtLeastConfirmed([signature], commitment);
    
        const unsafeRes = await this._rpcRequest('getConfirmedTransaction', args);
        const res = superstruct.create(unsafeRes, GetTransactionRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get transaction');
        }
    
        const result = res.result;
        if (!result) return result;
        const message = new Message(result.transaction.message);
        const signatures = result.transaction.signatures;
        return { ...result,
          transaction: Transaction.populate(message, signatures)
        };
      }
      /**
       * Fetch parsed transaction details for a confirmed transaction
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.
       */
    
    
      async getParsedConfirmedTransaction(signature, commitment) {
        const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');
    
        const unsafeRes = await this._rpcRequest('getConfirmedTransaction', args);
        const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transaction');
        }
    
        return res.result;
      }
      /**
       * Fetch parsed transaction details for a batch of confirmed transactions
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.
       */
    
    
      async getParsedConfirmedTransactions(signatures, commitment) {
        const batch = signatures.map(signature => {
          const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');
    
          return {
            methodName: 'getConfirmedTransaction',
            args
          };
        });
        const unsafeRes = await this._rpcBatchRequest(batch);
        const res = unsafeRes.map(unsafeRes => {
          const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);
    
          if ('error' in res) {
            throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transactions');
          }
    
          return res.result;
        });
        return res;
      }
      /**
       * Fetch a list of all the confirmed signatures for transactions involving an address
       * within a specified slot range. Max range allowed is 10,000 slots.
       *
       * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
       *
       * @param address queried address
       * @param startSlot start slot, inclusive
       * @param endSlot end slot, inclusive
       */
    
    
      async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
        let options = {};
        let firstAvailableBlock = await this.getFirstAvailableBlock();
    
        while (!('until' in options)) {
          startSlot--;
    
          if (startSlot <= 0 || startSlot < firstAvailableBlock) {
            break;
          }
    
          try {
            const block = await this.getConfirmedBlockSignatures(startSlot, 'finalized');
    
            if (block.signatures.length > 0) {
              options.until = block.signatures[block.signatures.length - 1].toString();
            }
          } catch (err) {
            if (err instanceof Error && err.message.includes('skipped')) {
              continue;
            } else {
              throw err;
            }
          }
        }
    
        let highestConfirmedRoot = await this.getSlot('finalized');
    
        while (!('before' in options)) {
          endSlot++;
    
          if (endSlot > highestConfirmedRoot) {
            break;
          }
    
          try {
            const block = await this.getConfirmedBlockSignatures(endSlot);
    
            if (block.signatures.length > 0) {
              options.before = block.signatures[block.signatures.length - 1].toString();
            }
          } catch (err) {
            if (err instanceof Error && err.message.includes('skipped')) {
              continue;
            } else {
              throw err;
            }
          }
        }
    
        const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
        return confirmedSignatureInfo.map(info => info.signature);
      }
      /**
       * Returns confirmed signatures for transactions involving an
       * address backwards in time from the provided signature or most recent confirmed block
       *
       *
       * @param address queried address
       * @param options
       */
    
    
      async getConfirmedSignaturesForAddress2(address, options, commitment) {
        const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
    
        const unsafeRes = await this._rpcRequest('getConfirmedSignaturesForAddress2', args);
        const res = superstruct.create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get confirmed signatures for address');
        }
    
        return res.result;
      }
      /**
       * Returns confirmed signatures for transactions involving an
       * address backwards in time from the provided signature or most recent confirmed block
       *
       *
       * @param address queried address
       * @param options
       */
    
    
      async getSignaturesForAddress(address, options, commitment) {
        const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
    
        const unsafeRes = await this._rpcRequest('getSignaturesForAddress', args);
        const res = superstruct.create(unsafeRes, GetSignaturesForAddressRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, 'failed to get signatures for address');
        }
    
        return res.result;
      }
    
      async getAddressLookupTable(accountKey, config) {
        const {
          context,
          value: accountInfo
        } = await this.getAccountInfoAndContext(accountKey, config);
        let value = null;
    
        if (accountInfo !== null) {
          value = new AddressLookupTableAccount({
            key: accountKey,
            state: AddressLookupTableAccount.deserialize(accountInfo.data)
          });
        }
    
        return {
          context,
          value
        };
      }
      /**
       * Fetch the contents of a Nonce account from the cluster, return with context
       */
    
    
      async getNonceAndContext(nonceAccount, commitment) {
        const {
          context,
          value: accountInfo
        } = await this.getAccountInfoAndContext(nonceAccount, commitment);
        let value = null;
    
        if (accountInfo !== null) {
          value = NonceAccount.fromAccountData(accountInfo.data);
        }
    
        return {
          context,
          value
        };
      }
      /**
       * Fetch the contents of a Nonce account from the cluster
       */
    
    
      async getNonce(nonceAccount, commitment) {
        return await this.getNonceAndContext(nonceAccount, commitment).then(x => x.value).catch(e => {
          throw new Error('failed to get nonce for account ' + nonceAccount.toBase58() + ': ' + e);
        });
      }
      /**
       * Request an allocation of lamports to the specified address
       *
       * ```typescript
       * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
       *
       * (async () => {
       *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
       *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
       *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
       *   await connection.confirmTransaction(signature);
       * })();
       * ```
       */
    
    
      async requestAirdrop(to, lamports) {
        const unsafeRes = await this._rpcRequest('requestAirdrop', [to.toBase58(), lamports]);
        const res = superstruct.create(unsafeRes, RequestAirdropRpcResult);
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
        }
    
        return res.result;
      }
      /**
       * @internal
       */
    
    
      async _blockhashWithExpiryBlockHeight(disableCache) {
        if (!disableCache) {
          // Wait for polling to finish
          while (this._pollingBlockhash) {
            await sleep(100);
          }
    
          const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
    
          const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
    
          if (this._blockhashInfo.latestBlockhash !== null && !expired) {
            return this._blockhashInfo.latestBlockhash;
          }
        }
    
        return await this._pollNewBlockhash();
      }
      /**
       * @internal
       */
    
    
      async _pollNewBlockhash() {
        this._pollingBlockhash = true;
    
        try {
          const startTime = Date.now();
          const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
          const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
    
          for (let i = 0; i < 50; i++) {
            const latestBlockhash = await this.getLatestBlockhash('finalized');
    
            if (cachedBlockhash !== latestBlockhash.blockhash) {
              this._blockhashInfo = {
                latestBlockhash,
                lastFetch: Date.now(),
                transactionSignatures: [],
                simulatedSignatures: []
              };
              return latestBlockhash;
            } // Sleep for approximately half a slot
    
    
            await sleep(MS_PER_SLOT / 2);
          }
    
          throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
        } finally {
          this._pollingBlockhash = false;
        }
      }
      /**
       * get the stake minimum delegation
       */
    
    
      async getStakeMinimumDelegation(config) {
        const {
          commitment,
          config: configArg
        } = extractCommitmentFromConfig(config);
    
        const args = this._buildArgs([], commitment, 'base64', configArg);
    
        const unsafeRes = await this._rpcRequest('getStakeMinimumDelegation', args);
        const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.number()));
    
        if ('error' in res) {
          throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
        }
    
        return res.result;
      }
      /**
       * Simulate a transaction
       *
       * @deprecated Instead, call {@link simulateTransaction} with {@link
       * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
       */
    
    
      /**
       * Simulate a transaction
       */
      // eslint-disable-next-line no-dupe-class-members
      async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
        if ('message' in transactionOrMessage) {
          const versionedTx = transactionOrMessage;
          const wireTransaction = versionedTx.serialize();
          const encodedTransaction = buffer.Buffer.from(wireTransaction).toString('base64');
    
          if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {
            throw new Error('Invalid arguments');
          }
    
          const config = configOrSigners || {};
          config.encoding = 'base64';
    
          if (!('commitment' in config)) {
            config.commitment = this.commitment;
          }
    
          const args = [encodedTransaction, config];
          const unsafeRes = await this._rpcRequest('simulateTransaction', args);
          const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct);
    
          if ('error' in res) {
            throw new Error('failed to simulate transaction: ' + res.error.message);
          }
    
          return res.result;
        }
    
        let transaction;
    
        if (transactionOrMessage instanceof Transaction) {
          let originalTx = transactionOrMessage;
          transaction = new Transaction();
          transaction.feePayer = originalTx.feePayer;
          transaction.instructions = transactionOrMessage.instructions;
          transaction.nonceInfo = originalTx.nonceInfo;
          transaction.signatures = originalTx.signatures;
        } else {
          transaction = Transaction.populate(transactionOrMessage); // HACK: this function relies on mutating the populated transaction
    
          transaction._message = transaction._json = undefined;
        }
    
        if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {
          throw new Error('Invalid arguments');
        }
    
        const signers = configOrSigners;
    
        if (transaction.nonceInfo && signers) {
          transaction.sign(...signers);
        } else {
          let disableCache = this._disableBlockhashCaching;
    
          for (;;) {
            const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
            transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
            transaction.recentBlockhash = latestBlockhash.blockhash;
            if (!signers) break;
            transaction.sign(...signers);
    
            if (!transaction.signature) {
              throw new Error('!signature'); // should never happen
            }
    
            const signature = transaction.signature.toString('base64');
    
            if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {
              // The signature of this transaction has not been seen before with the
              // current recentBlockhash, all done. Let's break
              this._blockhashInfo.simulatedSignatures.push(signature);
    
              break;
            } else {
              // This transaction would be treated as duplicate (its derived signature
              // matched to one of already recorded signatures).
              // So, we must fetch a new blockhash for a different signature by disabling
              // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
              disableCache = true;
            }
          }
        }
    
        const message = transaction._compile();
    
        const signData = message.serialize();
    
        const wireTransaction = transaction._serialize(signData);
    
        const encodedTransaction = wireTransaction.toString('base64');
        const config = {
          encoding: 'base64',
          commitment: this.commitment
        };
    
        if (includeAccounts) {
          const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map(key => key.toBase58());
          config['accounts'] = {
            encoding: 'base64',
            addresses
          };
        }
    
        if (signers) {
          config.sigVerify = true;
        }
    
        const args = [encodedTransaction, config];
        const unsafeRes = await this._rpcRequest('simulateTransaction', args);
        const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct);
    
        if ('error' in res) {
          let logs;
    
          if ('data' in res.error) {
            logs = res.error.data.logs;
    
            if (logs && Array.isArray(logs)) {
              const traceIndent = '\n    ';
              const logTrace = traceIndent + logs.join(traceIndent);
              console.error(res.error.message, logTrace);
            }
          }
    
          throw new SendTransactionError('failed to simulate transaction: ' + res.error.message, logs);
        }
    
        return res.result;
      }
      /**
       * Sign and send a transaction
       *
       * @deprecated Instead, call {@link sendTransaction} with a {@link
       * VersionedTransaction}
       */
    
    
      /**
       * Sign and send a transaction
       */
      // eslint-disable-next-line no-dupe-class-members
      async sendTransaction(transaction, signersOrOptions, options) {
        if ('version' in transaction) {
          if (signersOrOptions && Array.isArray(signersOrOptions)) {
            throw new Error('Invalid arguments');
          }
    
          const wireTransaction = transaction.serialize();
          return await this.sendRawTransaction(wireTransaction, options);
        }
    
        if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {
          throw new Error('Invalid arguments');
        }
    
        const signers = signersOrOptions;
    
        if (transaction.nonceInfo) {
          transaction.sign(...signers);
        } else {
          let disableCache = this._disableBlockhashCaching;
    
          for (;;) {
            const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
            transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
            transaction.recentBlockhash = latestBlockhash.blockhash;
            transaction.sign(...signers);
    
            if (!transaction.signature) {
              throw new Error('!signature'); // should never happen
            }
    
            const signature = transaction.signature.toString('base64');
    
            if (!this._blockhashInfo.transactionSignatures.includes(signature)) {
              // The signature of this transaction has not been seen before with the
              // current recentBlockhash, all done. Let's break
              this._blockhashInfo.transactionSignatures.push(signature);
    
              break;
            } else {
              // This transaction would be treated as duplicate (its derived signature
              // matched to one of already recorded signatures).
              // So, we must fetch a new blockhash for a different signature by disabling
              // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
              disableCache = true;
            }
          }
        }
    
        const wireTransaction = transaction.serialize();
        return await this.sendRawTransaction(wireTransaction, options);
      }
      /**
       * Send a transaction that has already been signed and serialized into the
       * wire format
       */
    
    
      async sendRawTransaction(rawTransaction, options) {
        const encodedTransaction = toBuffer(rawTransaction).toString('base64');
        const result = await this.sendEncodedTransaction(encodedTransaction, options);
        return result;
      }
      /**
       * Send a transaction that has already been signed, serialized into the
       * wire format, and encoded as a base64 string
       */
    
    
      async sendEncodedTransaction(encodedTransaction, options) {
        const config = {
          encoding: 'base64'
        };
        const skipPreflight = options && options.skipPreflight;
        const preflightCommitment = options && options.preflightCommitment || this.commitment;
    
        if (options && options.maxRetries != null) {
          config.maxRetries = options.maxRetries;
        }
    
        if (options && options.minContextSlot != null) {
          config.minContextSlot = options.minContextSlot;
        }
    
        if (skipPreflight) {
          config.skipPreflight = skipPreflight;
        }
    
        if (preflightCommitment) {
          config.preflightCommitment = preflightCommitment;
        }
    
        const args = [encodedTransaction, config];
        const unsafeRes = await this._rpcRequest('sendTransaction', args);
        const res = superstruct.create(unsafeRes, SendTransactionRpcResult);
    
        if ('error' in res) {
          let logs;
    
          if ('data' in res.error) {
            logs = res.error.data.logs;
          }
    
          throw new SendTransactionError('failed to send transaction: ' + res.error.message, logs);
        }
    
        return res.result;
      }
      /**
       * @internal
       */
    
    
      _wsOnOpen() {
        this._rpcWebSocketConnected = true;
        this._rpcWebSocketHeartbeat = setInterval(() => {
          // Ping server every 5s to prevent idle timeouts
          this._rpcWebSocket.notify('ping').catch(() => {});
        }, 5000);
    
        this._updateSubscriptions();
      }
      /**
       * @internal
       */
    
    
      _wsOnError(err) {
        this._rpcWebSocketConnected = false;
        console.error('ws error:', err.message);
      }
      /**
       * @internal
       */
    
    
      _wsOnClose(code) {
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketGeneration++;
    
        if (this._rpcWebSocketIdleTimeout) {
          clearTimeout(this._rpcWebSocketIdleTimeout);
          this._rpcWebSocketIdleTimeout = null;
        }
    
        if (this._rpcWebSocketHeartbeat) {
          clearInterval(this._rpcWebSocketHeartbeat);
          this._rpcWebSocketHeartbeat = null;
        }
    
        if (code === 1000) {
          // explicit close, check if any subscriptions have been made since close
          this._updateSubscriptions();
    
          return;
        } // implicit close, prepare subscriptions for auto-reconnect
    
    
        this._subscriptionCallbacksByServerSubscriptionId = {};
        Object.entries(this._subscriptionsByHash).forEach(([hash, subscription]) => {
          this._subscriptionsByHash[hash] = { ...subscription,
            state: 'pending'
          };
        });
      }
      /**
       * @internal
       */
    
    
      async _updateSubscriptions() {
        if (Object.keys(this._subscriptionsByHash).length === 0) {
          if (this._rpcWebSocketConnected) {
            this._rpcWebSocketConnected = false;
            this._rpcWebSocketIdleTimeout = setTimeout(() => {
              this._rpcWebSocketIdleTimeout = null;
    
              try {
                this._rpcWebSocket.close();
              } catch (err) {
                // swallow error if socket has already been closed.
                if (err instanceof Error) {
                  console.log(`Error when closing socket connection: ${err.message}`);
                }
              }
            }, 500);
          }
    
          return;
        }
    
        if (this._rpcWebSocketIdleTimeout !== null) {
          clearTimeout(this._rpcWebSocketIdleTimeout);
          this._rpcWebSocketIdleTimeout = null;
          this._rpcWebSocketConnected = true;
        }
    
        if (!this._rpcWebSocketConnected) {
          this._rpcWebSocket.connect();
    
          return;
        }
    
        const activeWebSocketGeneration = this._rpcWebSocketGeneration;
    
        const isCurrentConnectionStillActive = () => {
          return activeWebSocketGeneration === this._rpcWebSocketGeneration;
        };
    
        await Promise.all( // Don't be tempted to change this to `Object.entries`. We call
        // `_updateSubscriptions` recursively when processing the state,
        // so it's important that we look up the *current* version of
        // each subscription, every time we process a hash.
        Object.keys(this._subscriptionsByHash).map(async hash => {
          const subscription = this._subscriptionsByHash[hash];
    
          if (subscription === undefined) {
            // This entry has since been deleted. Skip.
            return;
          }
    
          switch (subscription.state) {
            case 'pending':
            case 'unsubscribed':
              if (subscription.callbacks.size === 0) {
                /**
                 * You can end up here when:
                 *
                 * - a subscription has recently unsubscribed
                 *   without having new callbacks added to it
                 *   while the unsubscribe was in flight, or
                 * - when a pending subscription has its
                 *   listeners removed before a request was
                 *   sent to the server.
                 *
                 * Being that nobody is interested in this
                 * subscription any longer, delete it.
                 */
                delete this._subscriptionsByHash[hash];
    
                if (subscription.state === 'unsubscribed') {
                  delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
                }
    
                await this._updateSubscriptions();
                return;
              }
    
              await (async () => {
                const {
                  args,
                  method
                } = subscription;
    
                try {
                  this._subscriptionsByHash[hash] = { ...subscription,
                    state: 'subscribing'
                  };
                  const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
                  this._subscriptionsByHash[hash] = { ...subscription,
                    serverSubscriptionId,
                    state: 'subscribed'
                  };
                  this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                  await this._updateSubscriptions();
                } catch (e) {
                  if (e instanceof Error) {
                    console.error(`${method} error for argument`, args, e.message);
                  }
    
                  if (!isCurrentConnectionStillActive()) {
                    return;
                  } // TODO: Maybe add an 'errored' state or a retry limit?
    
    
                  this._subscriptionsByHash[hash] = { ...subscription,
                    state: 'pending'
                  };
                  await this._updateSubscriptions();
                }
              })();
              break;
    
            case 'subscribed':
              if (subscription.callbacks.size === 0) {
                // By the time we successfully set up a subscription
                // with the server, the client stopped caring about it.
                // Tear it down now.
                await (async () => {
                  const {
                    serverSubscriptionId,
                    unsubscribeMethod
                  } = subscription;
    
                  if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                    /**
                     * Special case.
                     * If we're dealing with a subscription that has been auto-
                     * disposed by the RPC, then we can skip the RPC call to
                     * tear down the subscription here.
                     *
                     * NOTE: There is a proposal to eliminate this special case, here:
                     * https://github.com/solana-labs/solana/issues/18892
                     */
                    this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                  } else {
                    this._subscriptionsByHash[hash] = { ...subscription,
                      state: 'unsubscribing'
                    };
    
                    try {
                      await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                    } catch (e) {
                      if (e instanceof Error) {
                        console.error(`${unsubscribeMethod} error:`, e.message);
                      }
    
                      if (!isCurrentConnectionStillActive()) {
                        return;
                      } // TODO: Maybe add an 'errored' state or a retry limit?
    
    
                      this._subscriptionsByHash[hash] = { ...subscription,
                        state: 'subscribed'
                      };
                      await this._updateSubscriptions();
                      return;
                    }
                  }
    
                  this._subscriptionsByHash[hash] = { ...subscription,
                    state: 'unsubscribed'
                  };
                  await this._updateSubscriptions();
                })();
              }
    
              break;
          }
        }));
      }
      /**
       * @internal
       */
    
    
      _handleServerNotification(serverSubscriptionId, callbackArgs) {
        const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
    
        if (callbacks === undefined) {
          return;
        }
    
        callbacks.forEach(cb => {
          try {
            cb( // I failed to find a way to convince TypeScript that `cb` is of type
            // `TCallback` which is certainly compatible with `Parameters<TCallback>`.
            // See https://github.com/microsoft/TypeScript/issues/47615
            // @ts-ignore
            ...callbackArgs);
          } catch (e) {
            console.error(e);
          }
        });
      }
      /**
       * @internal
       */
    
    
      _wsOnAccountNotification(notification) {
        const {
          result,
          subscription
        } = superstruct.create(notification, AccountNotificationResult);
    
        this._handleServerNotification(subscription, [result.value, result.context]);
      }
      /**
       * @internal
       */
    
    
      _makeSubscription(subscriptionConfig,
      /**
       * When preparing `args` for a call to `_makeSubscription`, be sure
       * to carefully apply a default `commitment` property, if necessary.
       *
       * - If the user supplied a `commitment` use that.
       * - Otherwise, if the `Connection::commitment` is set, use that.
       * - Otherwise, set it to the RPC server default: `finalized`.
       *
       * This is extremely important to ensure that these two fundamentally
       * identical subscriptions produce the same identifying hash:
       *
       * - A subscription made without specifying a commitment.
       * - A subscription made where the commitment specified is the same
       *   as the default applied to the subscription above.
       *
       * Example; these two subscriptions must produce the same hash:
       *
       * - An `accountSubscribe` subscription for `'PUBKEY'`
       * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment
       *   `'finalized'`.
       *
       * See the 'making a subscription with defaulted params omitted' test
       * in `connection-subscriptions.ts` for more.
       */
      args) {
        const clientSubscriptionId = this._nextClientSubscriptionId++;
        const hash = fastStableStringify$1([subscriptionConfig.method, args], true
        /* isArrayProp */
        );
        const existingSubscription = this._subscriptionsByHash[hash];
    
        if (existingSubscription === undefined) {
          this._subscriptionsByHash[hash] = { ...subscriptionConfig,
            args,
            callbacks: new Set([subscriptionConfig.callback]),
            state: 'pending'
          };
        } else {
          existingSubscription.callbacks.add(subscriptionConfig.callback);
        }
    
        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
          delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
          const subscription = this._subscriptionsByHash[hash];
          assert(subscription !== undefined, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
          subscription.callbacks.delete(subscriptionConfig.callback);
          await this._updateSubscriptions();
        };
    
        this._updateSubscriptions();
    
        return clientSubscriptionId;
      }
      /**
       * Register a callback to be invoked whenever the specified account changes
       *
       * @param publicKey Public key of the account to monitor
       * @param callback Function to invoke whenever the account is changed
       * @param commitment Specify the commitment level account changes must reach before notification
       * @return subscription id
       */
    
    
      onAccountChange(publicKey, callback, commitment) {
        const args = this._buildArgs([publicKey.toBase58()], commitment || this._commitment || 'finalized', // Apply connection/server default.
        'base64');
    
        return this._makeSubscription({
          callback,
          method: 'accountSubscribe',
          unsubscribeMethod: 'accountUnsubscribe'
        }, args);
      }
      /**
       * Deregister an account notification callback
       *
       * @param id client subscription id to deregister
       */
    
    
      async removeAccountChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, 'account change');
      }
      /**
       * @internal
       */
    
    
      _wsOnProgramAccountNotification(notification) {
        const {
          result,
          subscription
        } = superstruct.create(notification, ProgramAccountNotificationResult);
    
        this._handleServerNotification(subscription, [{
          accountId: result.value.pubkey,
          accountInfo: result.value.account
        }, result.context]);
      }
      /**
       * Register a callback to be invoked whenever accounts owned by the
       * specified program change
       *
       * @param programId Public key of the program to monitor
       * @param callback Function to invoke whenever the account is changed
       * @param commitment Specify the commitment level account changes must reach before notification
       * @param filters The program account filters to pass into the RPC method
       * @return subscription id
       */
    
    
      onProgramAccountChange(programId, callback, commitment, filters) {
        const args = this._buildArgs([programId.toBase58()], commitment || this._commitment || 'finalized', // Apply connection/server default.
        'base64'
        /* encoding */
        , filters ? {
          filters: filters
        } : undefined
        /* extra */
        );
    
        return this._makeSubscription({
          callback,
          method: 'programSubscribe',
          unsubscribeMethod: 'programUnsubscribe'
        }, args);
      }
      /**
       * Deregister an account notification callback
       *
       * @param id client subscription id to deregister
       */
    
    
      async removeProgramAccountChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, 'program account change');
      }
      /**
       * Registers a callback to be invoked whenever logs are emitted.
       */
    
    
      onLogs(filter, callback, commitment) {
        const args = this._buildArgs([typeof filter === 'object' ? {
          mentions: [filter.toString()]
        } : filter], commitment || this._commitment || 'finalized' // Apply connection/server default.
        );
    
        return this._makeSubscription({
          callback,
          method: 'logsSubscribe',
          unsubscribeMethod: 'logsUnsubscribe'
        }, args);
      }
      /**
       * Deregister a logs callback.
       *
       * @param id client subscription id to deregister.
       */
    
    
      async removeOnLogsListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, 'logs');
      }
      /**
       * @internal
       */
    
    
      _wsOnLogsNotification(notification) {
        const {
          result,
          subscription
        } = superstruct.create(notification, LogsNotificationResult);
    
        this._handleServerNotification(subscription, [result.value, result.context]);
      }
      /**
       * @internal
       */
    
    
      _wsOnSlotNotification(notification) {
        const {
          result,
          subscription
        } = superstruct.create(notification, SlotNotificationResult);
    
        this._handleServerNotification(subscription, [result]);
      }
      /**
       * Register a callback to be invoked upon slot changes
       *
       * @param callback Function to invoke whenever the slot changes
       * @return subscription id
       */
    
    
      onSlotChange(callback) {
        return this._makeSubscription({
          callback,
          method: 'slotSubscribe',
          unsubscribeMethod: 'slotUnsubscribe'
        }, []
        /* args */
        );
      }
      /**
       * Deregister a slot notification callback
       *
       * @param id client subscription id to deregister
       */
    
    
      async removeSlotChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, 'slot change');
      }
      /**
       * @internal
       */
    
    
      _wsOnSlotUpdatesNotification(notification) {
        const {
          result,
          subscription
        } = superstruct.create(notification, SlotUpdateNotificationResult);
    
        this._handleServerNotification(subscription, [result]);
      }
      /**
       * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
       * may be useful to track live progress of a cluster.
       *
       * @param callback Function to invoke whenever the slot updates
       * @return subscription id
       */
    
    
      onSlotUpdate(callback) {
        return this._makeSubscription({
          callback,
          method: 'slotsUpdatesSubscribe',
          unsubscribeMethod: 'slotsUpdatesUnsubscribe'
        }, []
        /* args */
        );
      }
      /**
       * Deregister a slot update notification callback
       *
       * @param id client subscription id to deregister
       */
    
    
      async removeSlotUpdateListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, 'slot update');
      }
      /**
       * @internal
       */
    
    
      async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
        const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
    
        if (dispose) {
          await dispose();
        } else {
          console.warn('Ignored unsubscribe request because an active subscription with id ' + `\`${clientSubscriptionId}\` for '${subscriptionName}' events ` + 'could not be found.');
        }
      }
    
      _buildArgs(args, override, encoding, extra) {
        const commitment = override || this._commitment;
    
        if (commitment || encoding || extra) {
          let options = {};
    
          if (encoding) {
            options.encoding = encoding;
          }
    
          if (commitment) {
            options.commitment = commitment;
          }
    
          if (extra) {
            options = Object.assign(options, extra);
          }
    
          args.push(options);
        }
    
        return args;
      }
      /**
       * @internal
       */
    
    
      _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
        const commitment = override || this._commitment;
    
        if (commitment && !['confirmed', 'finalized'].includes(commitment)) {
          throw new Error('Using Connection with default commitment: `' + this._commitment + '`, but method requires at least `confirmed`');
        }
    
        return this._buildArgs(args, override, encoding, extra);
      }
      /**
       * @internal
       */
    
    
      _wsOnSignatureNotification(notification) {
        const {
          result,
          subscription
        } = superstruct.create(notification, SignatureNotificationResult);
    
        if (result.value !== 'receivedSignature') {
          /**
           * Special case.
           * After a signature is processed, RPCs automatically dispose of the
           * subscription on the server side. We need to track which of these
           * subscriptions have been disposed in such a way, so that we know
           * whether the client is dealing with a not-yet-processed signature
           * (in which case we must tear down the server subscription) or an
           * already-processed signature (in which case the client can simply
           * clear out the subscription locally without telling the server).
           *
           * NOTE: There is a proposal to eliminate this special case, here:
           * https://github.com/solana-labs/solana/issues/18892
           */
          this._subscriptionsAutoDisposedByRpc.add(subscription);
        }
    
        this._handleServerNotification(subscription, result.value === 'receivedSignature' ? [{
          type: 'received'
        }, result.context] : [{
          type: 'status',
          result: result.value
        }, result.context]);
      }
      /**
       * Register a callback to be invoked upon signature updates
       *
       * @param signature Transaction signature string in base 58
       * @param callback Function to invoke on signature notifications
       * @param commitment Specify the commitment level signature must reach before notification
       * @return subscription id
       */
    
    
      onSignature(signature, callback, commitment) {
        const args = this._buildArgs([signature], commitment || this._commitment || 'finalized' // Apply connection/server default.
        );
    
        const clientSubscriptionId = this._makeSubscription({
          callback: (notification, context) => {
            if (notification.type === 'status') {
              callback(notification.result, context); // Signatures subscriptions are auto-removed by the RPC service
              // so no need to explicitly send an unsubscribe message.
    
              try {
                this.removeSignatureListener(clientSubscriptionId); // eslint-disable-next-line no-empty
              } catch (_err) {// Already removed.
              }
            }
          },
          method: 'signatureSubscribe',
          unsubscribeMethod: 'signatureUnsubscribe'
        }, args);
    
        return clientSubscriptionId;
      }
      /**
       * Register a callback to be invoked when a transaction is
       * received and/or processed.
       *
       * @param signature Transaction signature string in base 58
       * @param callback Function to invoke on signature notifications
       * @param options Enable received notifications and set the commitment
       *   level that signature must reach before notification
       * @return subscription id
       */
    
    
      onSignatureWithOptions(signature, callback, options) {
        const {
          commitment,
          ...extra
        } = { ...options,
          commitment: options && options.commitment || this._commitment || 'finalized' // Apply connection/server default.
    
        };
    
        const args = this._buildArgs([signature], commitment, undefined
        /* encoding */
        , extra);
    
        const clientSubscriptionId = this._makeSubscription({
          callback: (notification, context) => {
            callback(notification, context); // Signatures subscriptions are auto-removed by the RPC service
            // so no need to explicitly send an unsubscribe message.
    
            try {
              this.removeSignatureListener(clientSubscriptionId); // eslint-disable-next-line no-empty
            } catch (_err) {// Already removed.
            }
          },
          method: 'signatureSubscribe',
          unsubscribeMethod: 'signatureUnsubscribe'
        }, args);
    
        return clientSubscriptionId;
      }
      /**
       * Deregister a signature notification callback
       *
       * @param id client subscription id to deregister
       */
    
    
      async removeSignatureListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, 'signature result');
      }
      /**
       * @internal
       */
    
    
      _wsOnRootNotification(notification) {
        const {
          result,
          subscription
        } = superstruct.create(notification, RootNotificationResult);
    
        this._handleServerNotification(subscription, [result]);
      }
      /**
       * Register a callback to be invoked upon root changes
       *
       * @param callback Function to invoke whenever the root changes
       * @return subscription id
       */
    
    
      onRootChange(callback) {
        return this._makeSubscription({
          callback,
          method: 'rootSubscribe',
          unsubscribeMethod: 'rootUnsubscribe'
        }, []
        /* args */
        );
      }
      /**
       * Deregister a root notification callback
       *
       * @param id client subscription id to deregister
       */
    
    
      async removeRootChangeListener(clientSubscriptionId) {
        await this._unsubscribeClientSubscription(clientSubscriptionId, 'root change');
      }
    
    }
    
    /**
     * Keypair signer interface
     */
    
    /**
     * An account keypair used for signing transactions.
     */
    class Keypair {
      /**
       * Create a new keypair instance.
       * Generate random keypair if no {@link Ed25519Keypair} is provided.
       *
       * @param keypair ed25519 keypair
       */
      constructor(keypair) {
        this._keypair = void 0;
        this._keypair = keypair !== null && keypair !== void 0 ? keypair : generateKeypair();
      }
      /**
       * Generate a new random keypair
       */
    
    
      static generate() {
        return new Keypair(generateKeypair());
      }
      /**
       * Create a keypair from a raw secret key byte array.
       *
       * This method should only be used to recreate a keypair from a previously
       * generated secret key. Generating keypairs from a random seed should be done
       * with the {@link Keypair.fromSeed} method.
       *
       * @throws error if the provided secret key is invalid and validation is not skipped.
       *
       * @param secretKey secret key byte array
       * @param options: skip secret key validation
       */
    
    
      static fromSecretKey(secretKey, options) {
        if (secretKey.byteLength !== 64) {
          throw new Error('bad secret key size');
        }
    
        const publicKey = secretKey.slice(32, 64);
    
        if (!options || !options.skipValidation) {
          const privateScalar = secretKey.slice(0, 32);
          const computedPublicKey = getPublicKey(privateScalar);
    
          for (let ii = 0; ii < 32; ii++) {
            if (publicKey[ii] !== computedPublicKey[ii]) {
              throw new Error('provided secretKey is invalid');
            }
          }
        }
    
        return new Keypair({
          publicKey,
          secretKey
        });
      }
      /**
       * Generate a keypair from a 32 byte seed.
       *
       * @param seed seed byte array
       */
    
    
      static fromSeed(seed) {
        const publicKey = getPublicKey(seed);
        const secretKey = new Uint8Array(64);
        secretKey.set(seed);
        secretKey.set(publicKey, 32);
        return new Keypair({
          publicKey,
          secretKey
        });
      }
      /**
       * The public key for this keypair
       */
    
    
      get publicKey() {
        return new PublicKey(this._keypair.publicKey);
      }
      /**
       * The raw secret key for this keypair
       */
    
    
      get secretKey() {
        return new Uint8Array(this._keypair.secretKey);
      }
    
    }
    
    /**
     * An enumeration of valid address lookup table InstructionType's
     * @internal
     */
    const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
      CreateLookupTable: {
        index: 0,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64('recentSlot'), BufferLayout__namespace.u8('bumpSeed')])
      },
      FreezeLookupTable: {
        index: 1,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
      },
      ExtendLookupTable: {
        index: 2,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64(), BufferLayout__namespace.seq(publicKey(), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'addresses')])
      },
      DeactivateLookupTable: {
        index: 3,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
      },
      CloseLookupTable: {
        index: 4,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
      }
    });
    class AddressLookupTableInstruction {
      /**
       * @internal
       */
      constructor() {}
    
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout__namespace.u32('instruction');
        const index = instructionTypeLayout.decode(instruction.data);
        let type;
    
        for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) {
          if (layout.index == index) {
            type = layoutType;
            break;
          }
        }
    
        if (!type) {
          throw new Error('Invalid Instruction. Should be a LookupTable Instruction');
        }
    
        return type;
      }
    
      static decodeCreateLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 4);
        const {
          recentSlot
        } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);
        return {
          authority: instruction.keys[1].pubkey,
          payer: instruction.keys[2].pubkey,
          recentSlot: Number(recentSlot)
        };
      }
    
      static decodeExtendLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
    
        if (instruction.keys.length < 2) {
          throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);
        }
    
        const {
          addresses
        } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey,
          payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,
          addresses: addresses.map(buffer => new PublicKey(buffer))
        };
      }
    
      static decodeCloseLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 3);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey,
          recipient: instruction.keys[2].pubkey
        };
      }
    
      static decodeFreezeLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 2);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey
        };
      }
    
      static decodeDeactivateLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 2);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey
        };
      }
      /**
       * @internal
       */
    
    
      static checkProgramId(programId) {
        if (!programId.equals(AddressLookupTableProgram.programId)) {
          throw new Error('invalid instruction; programId is not AddressLookupTable Program');
        }
      }
      /**
       * @internal
       */
    
    
      static checkKeysLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
        }
      }
    
    }
    class AddressLookupTableProgram {
      /**
       * @internal
       */
      constructor() {}
    
      static createLookupTable(params) {
        const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), bigintBuffer.toBufferLE(BigInt(params.recentSlot), 8)], this.programId);
        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
        const data = encodeData(type, {
          recentSlot: BigInt(params.recentSlot),
          bumpSeed: bumpSeed
        });
        const keys = [{
          pubkey: lookupTableAddress,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: params.payer,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SystemProgram.programId,
          isSigner: false,
          isWritable: false
        }];
        return [new TransactionInstruction({
          programId: this.programId,
          keys: keys,
          data: data
        }), lookupTableAddress];
      }
    
      static freezeLookupTable(params) {
        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
        const data = encodeData(type);
        const keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }];
        return new TransactionInstruction({
          programId: this.programId,
          keys: keys,
          data: data
        });
      }
    
      static extendLookupTable(params) {
        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
        const data = encodeData(type, {
          addresses: params.addresses.map(addr => addr.toBytes())
        });
        const keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }];
    
        if (params.payer) {
          keys.push({
            pubkey: params.payer,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false
          });
        }
    
        return new TransactionInstruction({
          programId: this.programId,
          keys: keys,
          data: data
        });
      }
    
      static deactivateLookupTable(params) {
        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
        const data = encodeData(type);
        const keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }];
        return new TransactionInstruction({
          programId: this.programId,
          keys: keys,
          data: data
        });
      }
    
      static closeLookupTable(params) {
        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
        const data = encodeData(type);
        const keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: params.recipient,
          isSigner: false,
          isWritable: true
        }];
        return new TransactionInstruction({
          programId: this.programId,
          keys: keys,
          data: data
        });
      }
    
    }
    AddressLookupTableProgram.programId = new PublicKey('AddressLookupTab1e1111111111111111111111111');
    
    /**
     * Compute Budget Instruction class
     */
    
    class ComputeBudgetInstruction {
      /**
       * @internal
       */
      constructor() {}
      /**
       * Decode a compute budget instruction and retrieve the instruction type.
       */
    
    
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout__namespace.u8('instruction');
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type;
    
        for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)) {
          if (layout.index == typeIndex) {
            type = ixType;
            break;
          }
        }
    
        if (!type) {
          throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');
        }
    
        return type;
      }
      /**
       * Decode request units compute budget instruction and retrieve the instruction params.
       */
    
    
      static decodeRequestUnits(instruction) {
        this.checkProgramId(instruction.programId);
        const {
          units,
          additionalFee
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);
        return {
          units,
          additionalFee
        };
      }
      /**
       * Decode request heap frame compute budget instruction and retrieve the instruction params.
       */
    
    
      static decodeRequestHeapFrame(instruction) {
        this.checkProgramId(instruction.programId);
        const {
          bytes
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);
        return {
          bytes
        };
      }
      /**
       * Decode set compute unit limit compute budget instruction and retrieve the instruction params.
       */
    
    
      static decodeSetComputeUnitLimit(instruction) {
        this.checkProgramId(instruction.programId);
        const {
          units
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);
        return {
          units
        };
      }
      /**
       * Decode set compute unit price compute budget instruction and retrieve the instruction params.
       */
    
    
      static decodeSetComputeUnitPrice(instruction) {
        this.checkProgramId(instruction.programId);
        const {
          microLamports
        } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);
        return {
          microLamports
        };
      }
      /**
       * @internal
       */
    
    
      static checkProgramId(programId) {
        if (!programId.equals(ComputeBudgetProgram.programId)) {
          throw new Error('invalid instruction; programId is not ComputeBudgetProgram');
        }
      }
    
    }
    /**
     * An enumeration of valid ComputeBudgetInstructionType's
     */
    
    /**
     * An enumeration of valid ComputeBudget InstructionType's
     * @internal
     */
    const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
      RequestUnits: {
        index: 0,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), BufferLayout__namespace.u32('units'), BufferLayout__namespace.u32('additionalFee')])
      },
      RequestHeapFrame: {
        index: 1,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), BufferLayout__namespace.u32('bytes')])
      },
      SetComputeUnitLimit: {
        index: 2,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), BufferLayout__namespace.u32('units')])
      },
      SetComputeUnitPrice: {
        index: 3,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), u64('microLamports')])
      }
    });
    /**
     * Factory class for transaction instructions to interact with the Compute Budget program
     */
    
    class ComputeBudgetProgram {
      /**
       * @internal
       */
      constructor() {}
      /**
       * Public key that identifies the Compute Budget program
       */
    
    
      /**
       * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
       */
      static requestUnits(params) {
        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
        const data = encodeData(type, params);
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data
        });
      }
    
      static requestHeapFrame(params) {
        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
        const data = encodeData(type, params);
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data
        });
      }
    
      static setComputeUnitLimit(params) {
        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
        const data = encodeData(type, params);
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data
        });
      }
    
      static setComputeUnitPrice(params) {
        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
        const data = encodeData(type, {
          microLamports: BigInt(params.microLamports)
        });
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data
        });
      }
    
    }
    ComputeBudgetProgram.programId = new PublicKey('ComputeBudget111111111111111111111111111111');
    
    const PRIVATE_KEY_BYTES$1 = 64;
    const PUBLIC_KEY_BYTES$1 = 32;
    const SIGNATURE_BYTES = 64;
    /**
     * Params for creating an ed25519 instruction using a public key
     */
    
    const ED25519_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8('numSignatures'), BufferLayout__namespace.u8('padding'), BufferLayout__namespace.u16('signatureOffset'), BufferLayout__namespace.u16('signatureInstructionIndex'), BufferLayout__namespace.u16('publicKeyOffset'), BufferLayout__namespace.u16('publicKeyInstructionIndex'), BufferLayout__namespace.u16('messageDataOffset'), BufferLayout__namespace.u16('messageDataSize'), BufferLayout__namespace.u16('messageInstructionIndex')]);
    class Ed25519Program {
      /**
       * @internal
       */
      constructor() {}
      /**
       * Public key that identifies the ed25519 program
       */
    
    
      /**
       * Create an ed25519 instruction with a public key and signature. The
       * public key must be a buffer that is 32 bytes long, and the signature
       * must be a buffer of 64 bytes.
       */
      static createInstructionWithPublicKey(params) {
        const {
          publicKey,
          message,
          signature,
          instructionIndex
        } = params;
        assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);
        assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);
        const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
        const signatureOffset = publicKeyOffset + publicKey.length;
        const messageDataOffset = signatureOffset + signature.length;
        const numSignatures = 1;
        const instructionData = buffer.Buffer.alloc(messageDataOffset + message.length);
        const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.
        : instructionIndex;
        ED25519_INSTRUCTION_LAYOUT.encode({
          numSignatures,
          padding: 0,
          signatureOffset,
          signatureInstructionIndex: index,
          publicKeyOffset,
          publicKeyInstructionIndex: index,
          messageDataOffset,
          messageDataSize: message.length,
          messageInstructionIndex: index
        }, instructionData);
        instructionData.fill(publicKey, publicKeyOffset);
        instructionData.fill(signature, signatureOffset);
        instructionData.fill(message, messageDataOffset);
        return new TransactionInstruction({
          keys: [],
          programId: Ed25519Program.programId,
          data: instructionData
        });
      }
      /**
       * Create an ed25519 instruction with a private key. The private key
       * must be a buffer that is 64 bytes long.
       */
    
    
      static createInstructionWithPrivateKey(params) {
        const {
          privateKey,
          message,
          instructionIndex
        } = params;
        assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
    
        try {
          const keypair = Keypair.fromSecretKey(privateKey);
          const publicKey = keypair.publicKey.toBytes();
          const signature = sign(message, keypair.secretKey);
          return this.createInstructionWithPublicKey({
            publicKey,
            message,
            signature,
            instructionIndex
          });
        } catch (error) {
          throw new Error(`Error creating instruction; ${error}`);
        }
      }
    
    }
    Ed25519Program.programId = new PublicKey('Ed25519SigVerify111111111111111111111111111');
    
    // library interoperable with the synchronous APIs in web3.js.
    
    secp256k1__namespace.utils.hmacSha256Sync = (key, ...msgs) => {
      const h = hmac.hmac.create(sha256.sha256, key);
      msgs.forEach(msg => h.update(msg));
      return h.digest();
    };
    
    const ecdsaSign = (msgHash, privKey) => secp256k1__namespace.signSync(msgHash, privKey, {
      der: false,
      recovered: true
    });
    secp256k1__namespace.utils.isValidPrivateKey;
    const publicKeyCreate = secp256k1__namespace.getPublicKey;
    
    const PRIVATE_KEY_BYTES = 32;
    const ETHEREUM_ADDRESS_BYTES = 20;
    const PUBLIC_KEY_BYTES = 64;
    const SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
    /**
     * Params for creating an secp256k1 instruction using a public key
     */
    
    const SECP256K1_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8('numSignatures'), BufferLayout__namespace.u16('signatureOffset'), BufferLayout__namespace.u8('signatureInstructionIndex'), BufferLayout__namespace.u16('ethAddressOffset'), BufferLayout__namespace.u8('ethAddressInstructionIndex'), BufferLayout__namespace.u16('messageDataOffset'), BufferLayout__namespace.u16('messageDataSize'), BufferLayout__namespace.u8('messageInstructionIndex'), BufferLayout__namespace.blob(20, 'ethAddress'), BufferLayout__namespace.blob(64, 'signature'), BufferLayout__namespace.u8('recoveryId')]);
    class Secp256k1Program {
      /**
       * @internal
       */
      constructor() {}
      /**
       * Public key that identifies the secp256k1 program
       */
    
    
      /**
       * Construct an Ethereum address from a secp256k1 public key buffer.
       * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
       */
      static publicKeyToEthAddress(publicKey) {
        assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);
    
        try {
          return buffer.Buffer.from(sha3.keccak_256(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);
        } catch (error) {
          throw new Error(`Error constructing Ethereum address: ${error}`);
        }
      }
      /**
       * Create an secp256k1 instruction with a public key. The public key
       * must be a buffer that is 64 bytes long.
       */
    
    
      static createInstructionWithPublicKey(params) {
        const {
          publicKey,
          message,
          signature,
          recoveryId,
          instructionIndex
        } = params;
        return Secp256k1Program.createInstructionWithEthAddress({
          ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),
          message,
          signature,
          recoveryId,
          instructionIndex
        });
      }
      /**
       * Create an secp256k1 instruction with an Ethereum address. The address
       * must be a hex string or a buffer that is 20 bytes long.
       */
    
    
      static createInstructionWithEthAddress(params) {
        const {
          ethAddress: rawAddress,
          message,
          signature,
          recoveryId,
          instructionIndex = 0
        } = params;
        let ethAddress;
    
        if (typeof rawAddress === 'string') {
          if (rawAddress.startsWith('0x')) {
            ethAddress = buffer.Buffer.from(rawAddress.substr(2), 'hex');
          } else {
            ethAddress = buffer.Buffer.from(rawAddress, 'hex');
          }
        } else {
          ethAddress = rawAddress;
        }
    
        assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
        const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
        const ethAddressOffset = dataStart;
        const signatureOffset = dataStart + ethAddress.length;
        const messageDataOffset = signatureOffset + signature.length + 1;
        const numSignatures = 1;
        const instructionData = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
        SECP256K1_INSTRUCTION_LAYOUT.encode({
          numSignatures,
          signatureOffset,
          signatureInstructionIndex: instructionIndex,
          ethAddressOffset,
          ethAddressInstructionIndex: instructionIndex,
          messageDataOffset,
          messageDataSize: message.length,
          messageInstructionIndex: instructionIndex,
          signature: toBuffer(signature),
          ethAddress: toBuffer(ethAddress),
          recoveryId
        }, instructionData);
        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
        return new TransactionInstruction({
          keys: [],
          programId: Secp256k1Program.programId,
          data: instructionData
        });
      }
      /**
       * Create an secp256k1 instruction with a private key. The private key
       * must be a buffer that is 32 bytes long.
       */
    
    
      static createInstructionWithPrivateKey(params) {
        const {
          privateKey: pkey,
          message,
          instructionIndex
        } = params;
        assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
    
        try {
          const privateKey = toBuffer(pkey);
          const publicKey = publicKeyCreate(privateKey, false
          /* isCompressed */
          ).slice(1); // throw away leading byte
    
          const messageHash = buffer.Buffer.from(sha3.keccak_256(toBuffer(message)));
          const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);
          return this.createInstructionWithPublicKey({
            publicKey,
            message,
            signature,
            recoveryId,
            instructionIndex
          });
        } catch (error) {
          throw new Error(`Error creating instruction; ${error}`);
        }
      }
    
    }
    Secp256k1Program.programId = new PublicKey('KeccakSecp256k11111111111111111111111111111');
    
    /**
     * Address of the stake config account which configures the rate
     * of stake warmup and cooldown as well as the slashing penalty.
     */
    
    const STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');
    /**
     * Stake account authority info
     */
    
    class Authorized {
      /** stake authority */
    
      /** withdraw authority */
    
      /**
       * Create a new Authorized object
       * @param staker the stake authority
       * @param withdrawer the withdraw authority
       */
      constructor(staker, withdrawer) {
        this.staker = void 0;
        this.withdrawer = void 0;
        this.staker = staker;
        this.withdrawer = withdrawer;
      }
    
    }
    
    /**
     * Stake account lockup info
     */
    class Lockup {
      /** Unix timestamp of lockup expiration */
    
      /** Epoch of lockup expiration */
    
      /** Lockup custodian authority */
    
      /**
       * Create a new Lockup object
       */
      constructor(unixTimestamp, epoch, custodian) {
        this.unixTimestamp = void 0;
        this.epoch = void 0;
        this.custodian = void 0;
        this.unixTimestamp = unixTimestamp;
        this.epoch = epoch;
        this.custodian = custodian;
      }
      /**
       * Default, inactive Lockup value
       */
    
    
    }
    Lockup.default = new Lockup(0, 0, PublicKey.default);
    
    /**
     * Stake Instruction class
     */
    class StakeInstruction {
      /**
       * @internal
       */
      constructor() {}
      /**
       * Decode a stake instruction and retrieve the instruction type.
       */
    
    
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout__namespace.u32('instruction');
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type;
    
        for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) {
          if (layout.index == typeIndex) {
            type = ixType;
            break;
          }
        }
    
        if (!type) {
          throw new Error('Instruction type incorrect; not a StakeInstruction');
        }
    
        return type;
      }
      /**
       * Decode a initialize stake instruction and retrieve the instruction params.
       */
    
    
      static decodeInitialize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          authorized,
          lockup
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),
          lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))
        };
      }
      /**
       * Decode a delegate stake instruction and retrieve the instruction params.
       */
    
    
      static decodeDelegate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 6);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          votePubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[5].pubkey
        };
      }
      /**
       * Decode an authorize stake instruction and retrieve the instruction params.
       */
    
    
      static decodeAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          newAuthorized,
          stakeAuthorizationType
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
        const o = {
          stakePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey,
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          stakeAuthorizationType: {
            index: stakeAuthorizationType
          }
        };
    
        if (instruction.keys.length > 3) {
          o.custodianPubkey = instruction.keys[3].pubkey;
        }
    
        return o;
      }
      /**
       * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
       */
    
    
      static decodeAuthorizeWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);
        const {
          newAuthorized,
          stakeAuthorizationType,
          authoritySeed,
          authorityOwner
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
        const o = {
          stakePubkey: instruction.keys[0].pubkey,
          authorityBase: instruction.keys[1].pubkey,
          authoritySeed: authoritySeed,
          authorityOwner: new PublicKey(authorityOwner),
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          stakeAuthorizationType: {
            index: stakeAuthorizationType
          }
        };
    
        if (instruction.keys.length > 3) {
          o.custodianPubkey = instruction.keys[3].pubkey;
        }
    
        return o;
      }
      /**
       * Decode a split stake instruction and retrieve the instruction params.
       */
    
    
      static decodeSplit(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          lamports
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          splitStakePubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey,
          lamports
        };
      }
      /**
       * Decode a merge stake instruction and retrieve the instruction params.
       */
    
    
      static decodeMerge(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          sourceStakePubKey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[4].pubkey
        };
      }
      /**
       * Decode a withdraw stake instruction and retrieve the instruction params.
       */
    
    
      static decodeWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 5);
        const {
          lamports
        } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
        const o = {
          stakePubkey: instruction.keys[0].pubkey,
          toPubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[4].pubkey,
          lamports
        };
    
        if (instruction.keys.length > 5) {
          o.custodianPubkey = instruction.keys[5].pubkey;
        }
    
        return o;
      }
      /**
       * Decode a deactivate stake instruction and retrieve the instruction params.
       */
    
    
      static decodeDeactivate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey
        };
      }
      /**
       * @internal
       */
    
    
      static checkProgramId(programId) {
        if (!programId.equals(StakeProgram.programId)) {
          throw new Error('invalid instruction; programId is not StakeProgram');
        }
      }
      /**
       * @internal
       */
    
    
      static checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
        }
      }
    
    }
    /**
     * An enumeration of valid StakeInstructionType's
     */
    
    /**
     * An enumeration of valid stake InstructionType's
     * @internal
     */
    const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
      Initialize: {
        index: 0,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), authorized(), lockup()])
      },
      Authorize: {
        index: 1,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('newAuthorized'), BufferLayout__namespace.u32('stakeAuthorizationType')])
      },
      Delegate: {
        index: 2,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
      },
      Split: {
        index: 3,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])
      },
      Withdraw: {
        index: 4,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])
      },
      Deactivate: {
        index: 5,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
      },
      Merge: {
        index: 7,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])
      },
      AuthorizeWithSeed: {
        index: 8,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('newAuthorized'), BufferLayout__namespace.u32('stakeAuthorizationType'), rustString('authoritySeed'), publicKey('authorityOwner')])
      }
    });
    /**
     * Stake authorization type
     */
    
    /**
     * An enumeration of valid StakeAuthorizationLayout's
     */
    const StakeAuthorizationLayout = Object.freeze({
      Staker: {
        index: 0
      },
      Withdrawer: {
        index: 1
      }
    });
    /**
     * Factory class for transactions to interact with the Stake program
     */
    
    class StakeProgram {
      /**
       * @internal
       */
      constructor() {}
      /**
       * Public key that identifies the Stake program
       */
    
    
      /**
       * Generate an Initialize instruction to add to a Stake Create transaction
       */
      static initialize(params) {
        const {
          stakePubkey,
          authorized,
          lockup: maybeLockup
        } = params;
        const lockup = maybeLockup || Lockup.default;
        const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;
        const data = encodeData(type, {
          authorized: {
            staker: toBuffer(authorized.staker.toBuffer()),
            withdrawer: toBuffer(authorized.withdrawer.toBuffer())
          },
          lockup: {
            unixTimestamp: lockup.unixTimestamp,
            epoch: lockup.epoch,
            custodian: toBuffer(lockup.custodian.toBuffer())
          }
        });
        const instructionData = {
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }],
          programId: this.programId,
          data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate a Transaction that creates a new Stake account at
       *   an address generated with `from`, a seed, and the Stake programId
       */
    
    
      static createAccountWithSeed(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccountWithSeed({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.stakePubkey,
          basePubkey: params.basePubkey,
          seed: params.seed,
          lamports: params.lamports,
          space: this.space,
          programId: this.programId
        }));
        const {
          stakePubkey,
          authorized,
          lockup
        } = params;
        return transaction.add(this.initialize({
          stakePubkey,
          authorized,
          lockup
        }));
      }
      /**
       * Generate a Transaction that creates a new Stake account
       */
    
    
      static createAccount(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.stakePubkey,
          lamports: params.lamports,
          space: this.space,
          programId: this.programId
        }));
        const {
          stakePubkey,
          authorized,
          lockup
        } = params;
        return transaction.add(this.initialize({
          stakePubkey,
          authorized,
          lockup
        }));
      }
      /**
       * Generate a Transaction that delegates Stake tokens to a validator
       * Vote PublicKey. This transaction can also be used to redelegate Stake
       * to a new validator Vote PublicKey.
       */
    
    
      static delegate(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          votePubkey
        } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;
        const data = encodeData(type);
        return new Transaction().add({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: votePubkey,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: STAKE_CONFIG_ID,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that authorizes a new PublicKey as Staker
       * or Withdrawer on the Stake account.
       */
    
    
      static authorize(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          newAuthorizedPubkey,
          stakeAuthorizationType,
          custodianPubkey
        } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;
        const data = encodeData(type, {
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          stakeAuthorizationType: stakeAuthorizationType.index
        });
        const keys = [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }];
    
        if (custodianPubkey) {
          keys.push({
            pubkey: custodianPubkey,
            isSigner: false,
            isWritable: false
          });
        }
    
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that authorizes a new PublicKey as Staker
       * or Withdrawer on the Stake account.
       */
    
    
      static authorizeWithSeed(params) {
        const {
          stakePubkey,
          authorityBase,
          authoritySeed,
          authorityOwner,
          newAuthorizedPubkey,
          stakeAuthorizationType,
          custodianPubkey
        } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
        const data = encodeData(type, {
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          stakeAuthorizationType: stakeAuthorizationType.index,
          authoritySeed: authoritySeed,
          authorityOwner: toBuffer(authorityOwner.toBuffer())
        });
        const keys = [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorityBase,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }];
    
        if (custodianPubkey) {
          keys.push({
            pubkey: custodianPubkey,
            isSigner: false,
            isWritable: false
          });
        }
    
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * @internal
       */
    
    
      static splitInstruction(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          splitStakePubkey,
          lamports
        } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.Split;
        const data = encodeData(type, {
          lamports
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: splitStakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that splits Stake tokens into another stake account
       */
    
    
      static split(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.authorizedPubkey,
          newAccountPubkey: params.splitStakePubkey,
          lamports: 0,
          space: this.space,
          programId: this.programId
        }));
        return transaction.add(this.splitInstruction(params));
      }
      /**
       * Generate a Transaction that splits Stake tokens into another account
       * derived from a base public key and seed
       */
    
    
      static splitWithSeed(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          splitStakePubkey,
          basePubkey,
          seed,
          lamports
        } = params;
        const transaction = new Transaction();
        transaction.add(SystemProgram.allocate({
          accountPubkey: splitStakePubkey,
          basePubkey,
          seed,
          space: this.space,
          programId: this.programId
        }));
        return transaction.add(this.splitInstruction({
          stakePubkey,
          authorizedPubkey,
          splitStakePubkey,
          lamports
        }));
      }
      /**
       * Generate a Transaction that merges Stake accounts.
       */
    
    
      static merge(params) {
        const {
          stakePubkey,
          sourceStakePubKey,
          authorizedPubkey
        } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.Merge;
        const data = encodeData(type);
        return new Transaction().add({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: sourceStakePubKey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that withdraws deactivated Stake tokens.
       */
    
    
      static withdraw(params) {
        const {
          stakePubkey,
          authorizedPubkey,
          toPubkey,
          lamports,
          custodianPubkey
        } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
        const data = encodeData(type, {
          lamports
        });
        const keys = [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }];
    
        if (custodianPubkey) {
          keys.push({
            pubkey: custodianPubkey,
            isSigner: false,
            isWritable: false
          });
        }
    
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a Transaction that deactivates Stake tokens.
       */
    
    
      static deactivate(params) {
        const {
          stakePubkey,
          authorizedPubkey
        } = params;
        const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
        const data = encodeData(type);
        return new Transaction().add({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        });
      }
    
    }
    StakeProgram.programId = new PublicKey('Stake11111111111111111111111111111111111111');
    StakeProgram.space = 200;
    
    /**
     * Vote account info
     */
    
    class VoteInit {
      /** [0, 100] */
      constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
        this.nodePubkey = void 0;
        this.authorizedVoter = void 0;
        this.authorizedWithdrawer = void 0;
        this.commission = void 0;
        this.nodePubkey = nodePubkey;
        this.authorizedVoter = authorizedVoter;
        this.authorizedWithdrawer = authorizedWithdrawer;
        this.commission = commission;
      }
    
    }
    /**
     * Create vote account transaction params
     */
    
    /**
     * Vote Instruction class
     */
    class VoteInstruction {
      /**
       * @internal
       */
      constructor() {}
      /**
       * Decode a vote instruction and retrieve the instruction type.
       */
    
    
      static decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        const instructionTypeLayout = BufferLayout__namespace.u32('instruction');
        const typeIndex = instructionTypeLayout.decode(instruction.data);
        let type;
    
        for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) {
          if (layout.index == typeIndex) {
            type = ixType;
            break;
          }
        }
    
        if (!type) {
          throw new Error('Instruction type incorrect; not a VoteInstruction');
        }
    
        return type;
      }
      /**
       * Decode an initialize vote instruction and retrieve the instruction params.
       */
    
    
      static decodeInitializeAccount(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 4);
        const {
          voteInit
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);
        return {
          votePubkey: instruction.keys[0].pubkey,
          nodePubkey: instruction.keys[3].pubkey,
          voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)
        };
      }
      /**
       * Decode an authorize instruction and retrieve the instruction params.
       */
    
    
      static decodeAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          newAuthorized,
          voteAuthorizationType
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
        return {
          votePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey,
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          voteAuthorizationType: {
            index: voteAuthorizationType
          }
        };
      }
      /**
       * Decode an authorize instruction and retrieve the instruction params.
       */
    
    
      static decodeAuthorizeWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          voteAuthorizeWithSeedArgs: {
            currentAuthorityDerivedKeyOwnerPubkey,
            currentAuthorityDerivedKeySeed,
            newAuthorized,
            voteAuthorizationType
          }
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
        return {
          currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
          currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),
          currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          voteAuthorizationType: {
            index: voteAuthorizationType
          },
          votePubkey: instruction.keys[0].pubkey
        };
      }
      /**
       * Decode a withdraw instruction and retrieve the instruction params.
       */
    
    
      static decodeWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        const {
          lamports
        } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
        return {
          votePubkey: instruction.keys[0].pubkey,
          authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
          lamports,
          toPubkey: instruction.keys[1].pubkey
        };
      }
      /**
       * @internal
       */
    
    
      static checkProgramId(programId) {
        if (!programId.equals(VoteProgram.programId)) {
          throw new Error('invalid instruction; programId is not VoteProgram');
        }
      }
      /**
       * @internal
       */
    
    
      static checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
        }
      }
    
    }
    /**
     * An enumeration of valid VoteInstructionType's
     */
    
    const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
      InitializeAccount: {
        index: 0,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), voteInit()])
      },
      Authorize: {
        index: 1,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('newAuthorized'), BufferLayout__namespace.u32('voteAuthorizationType')])
      },
      Withdraw: {
        index: 3,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])
      },
      AuthorizeWithSeed: {
        index: 10,
        layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), voteAuthorizeWithSeedArgs()])
      }
    });
    /**
     * VoteAuthorize type
     */
    
    /**
     * An enumeration of valid VoteAuthorization layouts.
     */
    const VoteAuthorizationLayout = Object.freeze({
      Voter: {
        index: 0
      },
      Withdrawer: {
        index: 1
      }
    });
    /**
     * Factory class for transactions to interact with the Vote program
     */
    
    class VoteProgram {
      /**
       * @internal
       */
      constructor() {}
      /**
       * Public key that identifies the Vote program
       */
    
    
      /**
       * Generate an Initialize instruction.
       */
      static initializeAccount(params) {
        const {
          votePubkey,
          nodePubkey,
          voteInit
        } = params;
        const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
        const data = encodeData(type, {
          voteInit: {
            nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),
            authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),
            authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),
            commission: voteInit.commission
          }
        });
        const instructionData = {
          keys: [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: nodePubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate a transaction that creates a new Vote account.
       */
    
    
      static createAccount(params) {
        const transaction = new Transaction();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.votePubkey,
          lamports: params.lamports,
          space: this.space,
          programId: this.programId
        }));
        return transaction.add(this.initializeAccount({
          votePubkey: params.votePubkey,
          nodePubkey: params.voteInit.nodePubkey,
          voteInit: params.voteInit
        }));
      }
      /**
       * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
       */
    
    
      static authorize(params) {
        const {
          votePubkey,
          authorizedPubkey,
          newAuthorizedPubkey,
          voteAuthorizationType
        } = params;
        const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;
        const data = encodeData(type, {
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          voteAuthorizationType: voteAuthorizationType.index
        });
        const keys = [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }];
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
       * where the current Voter or Withdrawer authority is a derived key.
       */
    
    
      static authorizeWithSeed(params) {
        const {
          currentAuthorityDerivedKeyBasePubkey,
          currentAuthorityDerivedKeyOwnerPubkey,
          currentAuthorityDerivedKeySeed,
          newAuthorizedPubkey,
          voteAuthorizationType,
          votePubkey
        } = params;
        const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
        const data = encodeData(type, {
          voteAuthorizeWithSeedArgs: {
            currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
            currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            voteAuthorizationType: voteAuthorizationType.index
          }
        });
        const keys = [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: currentAuthorityDerivedKeyBasePubkey,
          isSigner: true,
          isWritable: false
        }];
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction to withdraw from a Vote account.
       */
    
    
      static withdraw(params) {
        const {
          votePubkey,
          authorizedWithdrawerPubkey,
          lamports,
          toPubkey
        } = params;
        const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
        const data = encodeData(type, {
          lamports
        });
        const keys = [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedWithdrawerPubkey,
          isSigner: true,
          isWritable: false
        }];
        return new Transaction().add({
          keys,
          programId: this.programId,
          data
        });
      }
      /**
       * Generate a transaction to withdraw safely from a Vote account.
       *
       * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
       * checks that the withdraw amount will not exceed the specified balance while leaving enough left
       * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
       * `withdraw` method directly.
       */
    
    
      static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
          throw new Error('Withdraw will leave vote account with insuffcient funds.');
        }
    
        return VoteProgram.withdraw(params);
      }
    
    }
    VoteProgram.programId = new PublicKey('Vote111111111111111111111111111111111111111');
    VoteProgram.space = 3731;
    
    const VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');
    /**
     * @internal
     */
    
    const InfoString = superstruct.type({
      name: superstruct.string(),
      website: superstruct.optional(superstruct.string()),
      details: superstruct.optional(superstruct.string()),
      keybaseUsername: superstruct.optional(superstruct.string())
    });
    /**
     * ValidatorInfo class
     */
    
    class ValidatorInfo {
      /**
       * validator public key
       */
    
      /**
       * validator information
       */
    
      /**
       * Construct a valid ValidatorInfo
       *
       * @param key validator public key
       * @param info validator information
       */
      constructor(key, info) {
        this.key = void 0;
        this.info = void 0;
        this.key = key;
        this.info = info;
      }
      /**
       * Deserialize ValidatorInfo from the config account data. Exactly two config
       * keys are required in the data.
       *
       * @param buffer config account data
       * @return null if info was not found
       */
    
    
      static fromConfigData(buffer$1) {
        let byteArray = [...buffer$1];
        const configKeyCount = decodeLength(byteArray);
        if (configKeyCount !== 2) return null;
        const configKeys = [];
    
        for (let i = 0; i < 2; i++) {
          const publicKey = new PublicKey(byteArray.slice(0, PUBLIC_KEY_LENGTH));
          byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
          const isSigner = byteArray.slice(0, 1)[0] === 1;
          byteArray = byteArray.slice(1);
          configKeys.push({
            publicKey,
            isSigner
          });
        }
    
        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
          if (configKeys[1].isSigner) {
            const rawInfo = rustString().decode(buffer.Buffer.from(byteArray));
            const info = JSON.parse(rawInfo);
            superstruct.assert(info, InfoString);
            return new ValidatorInfo(configKeys[1].publicKey, info);
          }
        }
    
        return null;
      }
    
    }
    
    const VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');
    
    /**
     * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88
     *
     * @internal
     */
    const VoteAccountLayout = BufferLayout__namespace.struct([publicKey('nodePubkey'), publicKey('authorizedWithdrawer'), BufferLayout__namespace.u8('commission'), BufferLayout__namespace.nu64(), // votes.length
    BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64('slot'), BufferLayout__namespace.u32('confirmationCount')]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'votes'), BufferLayout__namespace.u8('rootSlotValid'), BufferLayout__namespace.nu64('rootSlot'), BufferLayout__namespace.nu64(), // authorizedVoters.length
    BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64('epoch'), publicKey('authorizedVoter')]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'authorizedVoters'), BufferLayout__namespace.struct([BufferLayout__namespace.seq(BufferLayout__namespace.struct([publicKey('authorizedPubkey'), BufferLayout__namespace.nu64('epochOfLastAuthorizedSwitch'), BufferLayout__namespace.nu64('targetEpoch')]), 32, 'buf'), BufferLayout__namespace.nu64('idx'), BufferLayout__namespace.u8('isEmpty')], 'priorVoters'), BufferLayout__namespace.nu64(), // epochCredits.length
    BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64('epoch'), BufferLayout__namespace.nu64('credits'), BufferLayout__namespace.nu64('prevCredits')]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'epochCredits'), BufferLayout__namespace.struct([BufferLayout__namespace.nu64('slot'), BufferLayout__namespace.nu64('timestamp')], 'lastTimestamp')]);
    
    /**
     * VoteAccount class
     */
    class VoteAccount {
      /**
       * @internal
       */
      constructor(args) {
        this.nodePubkey = void 0;
        this.authorizedWithdrawer = void 0;
        this.commission = void 0;
        this.rootSlot = void 0;
        this.votes = void 0;
        this.authorizedVoters = void 0;
        this.priorVoters = void 0;
        this.epochCredits = void 0;
        this.lastTimestamp = void 0;
        this.nodePubkey = args.nodePubkey;
        this.authorizedWithdrawer = args.authorizedWithdrawer;
        this.commission = args.commission;
        this.rootSlot = args.rootSlot;
        this.votes = args.votes;
        this.authorizedVoters = args.authorizedVoters;
        this.priorVoters = args.priorVoters;
        this.epochCredits = args.epochCredits;
        this.lastTimestamp = args.lastTimestamp;
      }
      /**
       * Deserialize VoteAccount from the account data.
       *
       * @param buffer account data
       * @return VoteAccount
       */
    
    
      static fromAccountData(buffer) {
        const versionOffset = 4;
        const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);
        let rootSlot = va.rootSlot;
    
        if (!va.rootSlotValid) {
          rootSlot = null;
        }
    
        return new VoteAccount({
          nodePubkey: new PublicKey(va.nodePubkey),
          authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),
          commission: va.commission,
          votes: va.votes,
          rootSlot,
          authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
          priorVoters: getPriorVoters(va.priorVoters),
          epochCredits: va.epochCredits,
          lastTimestamp: va.lastTimestamp
        });
      }
    
    }
    
    function parseAuthorizedVoter({
      authorizedVoter,
      epoch
    }) {
      return {
        epoch,
        authorizedVoter: new PublicKey(authorizedVoter)
      };
    }
    
    function parsePriorVoters({
      authorizedPubkey,
      epochOfLastAuthorizedSwitch,
      targetEpoch
    }) {
      return {
        authorizedPubkey: new PublicKey(authorizedPubkey),
        epochOfLastAuthorizedSwitch,
        targetEpoch
      };
    }
    
    function getPriorVoters({
      buf,
      idx,
      isEmpty
    }) {
      if (isEmpty) {
        return [];
      }
    
      return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx).map(parsePriorVoters)];
    }
    
    const endpoint = {
      http: {
        devnet: 'http://api.devnet.solana.com',
        testnet: 'http://api.testnet.solana.com',
        'mainnet-beta': 'http://api.mainnet-beta.solana.com/'
      },
      https: {
        devnet: 'https://api.devnet.solana.com',
        testnet: 'https://api.testnet.solana.com',
        'mainnet-beta': 'https://api.mainnet-beta.solana.com/'
      }
    };
    
    /**
     * Retrieves the RPC API URL for the specified cluster
     */
    function clusterApiUrl(cluster, tls) {
      const key = tls === false ? 'http' : 'https';
    
      if (!cluster) {
        return endpoint[key]['devnet'];
      }
    
      const url = endpoint[key][cluster];
    
      if (!url) {
        throw new Error(`Unknown ${key} cluster: ${cluster}`);
      }
    
      return url;
    }
    
    /**
     * Send and confirm a raw transaction
     *
     * If `commitment` option is not specified, defaults to 'max' commitment.
     *
     * @param {Connection} connection
     * @param {Buffer} rawTransaction
     * @param {BlockheightBasedTransactionConfirmationStrategy} confirmationStrategy
     * @param {ConfirmOptions} [options]
     * @returns {Promise<TransactionSignature>}
     */
    
    /**
     * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`
     * is no longer supported and will be removed in a future version.
     */
    // eslint-disable-next-line no-redeclare
    // eslint-disable-next-line no-redeclare
    async function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
      let confirmationStrategy;
      let options;
    
      if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'lastValidBlockHeight')) {
        confirmationStrategy = confirmationStrategyOrConfirmOptions;
        options = maybeConfirmOptions;
      } else {
        options = confirmationStrategyOrConfirmOptions;
      }
    
      const sendOptions = options && {
        skipPreflight: options.skipPreflight,
        preflightCommitment: options.preflightCommitment || options.commitment,
        minContextSlot: options.minContextSlot
      };
      const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);
      const commitment = options && options.commitment;
      const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);
      const status = (await confirmationPromise).value;
    
      if (status.err) {
        throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);
      }
    
      return signature;
    }
    
    /**
     * There are 1-billion lamports in one SOL
     */
    
    const LAMPORTS_PER_SOL = 1000000000;
    
    exports.Account = Account;
    exports.AddressLookupTableAccount = AddressLookupTableAccount;
    exports.AddressLookupTableInstruction = AddressLookupTableInstruction;
    exports.AddressLookupTableProgram = AddressLookupTableProgram;
    exports.Authorized = Authorized;
    exports.BLOCKHASH_CACHE_TIMEOUT_MS = BLOCKHASH_CACHE_TIMEOUT_MS;
    exports.BPF_LOADER_DEPRECATED_PROGRAM_ID = BPF_LOADER_DEPRECATED_PROGRAM_ID;
    exports.BPF_LOADER_PROGRAM_ID = BPF_LOADER_PROGRAM_ID;
    exports.BpfLoader = BpfLoader;
    exports.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS;
    exports.ComputeBudgetInstruction = ComputeBudgetInstruction;
    exports.ComputeBudgetProgram = ComputeBudgetProgram;
    exports.Connection = Connection;
    exports.Ed25519Program = Ed25519Program;
    exports.Enum = Enum;
    exports.EpochSchedule = EpochSchedule;
    exports.FeeCalculatorLayout = FeeCalculatorLayout;
    exports.Keypair = Keypair;
    exports.LAMPORTS_PER_SOL = LAMPORTS_PER_SOL;
    exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS = LOOKUP_TABLE_INSTRUCTION_LAYOUTS;
    exports.Loader = Loader;
    exports.Lockup = Lockup;
    exports.MAX_SEED_LENGTH = MAX_SEED_LENGTH;
    exports.Message = Message;
    exports.MessageAccountKeys = MessageAccountKeys;
    exports.MessageV0 = MessageV0;
    exports.NONCE_ACCOUNT_LENGTH = NONCE_ACCOUNT_LENGTH;
    exports.NonceAccount = NonceAccount;
    exports.PACKET_DATA_SIZE = PACKET_DATA_SIZE;
    exports.PUBLIC_KEY_LENGTH = PUBLIC_KEY_LENGTH;
    exports.PublicKey = PublicKey;
    exports.SIGNATURE_LENGTH_IN_BYTES = SIGNATURE_LENGTH_IN_BYTES;
    exports.SOLANA_SCHEMA = SOLANA_SCHEMA;
    exports.STAKE_CONFIG_ID = STAKE_CONFIG_ID;
    exports.STAKE_INSTRUCTION_LAYOUTS = STAKE_INSTRUCTION_LAYOUTS;
    exports.SYSTEM_INSTRUCTION_LAYOUTS = SYSTEM_INSTRUCTION_LAYOUTS;
    exports.SYSVAR_CLOCK_PUBKEY = SYSVAR_CLOCK_PUBKEY;
    exports.SYSVAR_EPOCH_SCHEDULE_PUBKEY = SYSVAR_EPOCH_SCHEDULE_PUBKEY;
    exports.SYSVAR_INSTRUCTIONS_PUBKEY = SYSVAR_INSTRUCTIONS_PUBKEY;
    exports.SYSVAR_RECENT_BLOCKHASHES_PUBKEY = SYSVAR_RECENT_BLOCKHASHES_PUBKEY;
    exports.SYSVAR_RENT_PUBKEY = SYSVAR_RENT_PUBKEY;
    exports.SYSVAR_REWARDS_PUBKEY = SYSVAR_REWARDS_PUBKEY;
    exports.SYSVAR_SLOT_HASHES_PUBKEY = SYSVAR_SLOT_HASHES_PUBKEY;
    exports.SYSVAR_SLOT_HISTORY_PUBKEY = SYSVAR_SLOT_HISTORY_PUBKEY;
    exports.SYSVAR_STAKE_HISTORY_PUBKEY = SYSVAR_STAKE_HISTORY_PUBKEY;
    exports.Secp256k1Program = Secp256k1Program;
    exports.SendTransactionError = SendTransactionError;
    exports.SolanaJSONRPCError = SolanaJSONRPCError;
    exports.SolanaJSONRPCErrorCode = SolanaJSONRPCErrorCode;
    exports.StakeAuthorizationLayout = StakeAuthorizationLayout;
    exports.StakeInstruction = StakeInstruction;
    exports.StakeProgram = StakeProgram;
    exports.Struct = Struct;
    exports.SystemInstruction = SystemInstruction;
    exports.SystemProgram = SystemProgram;
    exports.Transaction = Transaction;
    exports.TransactionExpiredBlockheightExceededError = TransactionExpiredBlockheightExceededError;
    exports.TransactionExpiredTimeoutError = TransactionExpiredTimeoutError;
    exports.TransactionInstruction = TransactionInstruction;
    exports.TransactionMessage = TransactionMessage;
    exports.VALIDATOR_INFO_KEY = VALIDATOR_INFO_KEY;
    exports.VERSION_PREFIX_MASK = VERSION_PREFIX_MASK;
    exports.VOTE_PROGRAM_ID = VOTE_PROGRAM_ID;
    exports.ValidatorInfo = ValidatorInfo;
    exports.VersionedMessage = VersionedMessage;
    exports.VersionedTransaction = VersionedTransaction;
    exports.VoteAccount = VoteAccount;
    exports.VoteAuthorizationLayout = VoteAuthorizationLayout;
    exports.VoteInit = VoteInit;
    exports.VoteInstruction = VoteInstruction;
    exports.VoteProgram = VoteProgram;
    exports.clusterApiUrl = clusterApiUrl;
    exports.sendAndConfirmRawTransaction = sendAndConfirmRawTransaction;
    exports.sendAndConfirmTransaction = sendAndConfirmTransaction;
    
    
    },{"@noble/ed25519":17,"@noble/hashes/hmac":22,"@noble/hashes/sha256":23,"@noble/hashes/sha3":24,"@noble/hashes/sha512":25,"@noble/secp256k1":27,"@solana/buffer-layout":28,"bigint-buffer":30,"bn.js":31,"borsh":32,"bs58":33,"buffer":3,"jayson/lib/client/browser":35,"rpc-websockets":37,"superstruct":41}],1:[function(require,module,exports){
    'use strict'
    
    exports.byteLength = byteLength
    exports.toByteArray = toByteArray
    exports.fromByteArray = fromByteArray
    
    var lookup = []
    var revLookup = []
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
    
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i]
      revLookup[code.charCodeAt(i)] = i
    }
    
    // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications
    revLookup['-'.charCodeAt(0)] = 62
    revLookup['_'.charCodeAt(0)] = 63
    
    function getLens (b64) {
      var len = b64.length
    
      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }
    
      // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42
      var validLen = b64.indexOf('=')
      if (validLen === -1) validLen = len
    
      var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4)
    
      return [validLen, placeHoldersLen]
    }
    
    // base64 is 4/3 + up to two characters of the original data
    function byteLength (b64) {
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }
    
    function _byteLength (b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }
    
    function toByteArray (b64) {
      var tmp
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]
    
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
    
      var curByte = 0
    
      // if there are placeholders, only get up to the last complete 4 chars
      var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen
    
      var i
      for (i = 0; i < len; i += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 18) |
          (revLookup[b64.charCodeAt(i + 1)] << 12) |
          (revLookup[b64.charCodeAt(i + 2)] << 6) |
          revLookup[b64.charCodeAt(i + 3)]
        arr[curByte++] = (tmp >> 16) & 0xFF
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }
    
      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 2) |
          (revLookup[b64.charCodeAt(i + 1)] >> 4)
        arr[curByte++] = tmp & 0xFF
      }
    
      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 10) |
          (revLookup[b64.charCodeAt(i + 1)] << 4) |
          (revLookup[b64.charCodeAt(i + 2)] >> 2)
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }
    
      return arr
    }
    
    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F]
    }
    
    function encodeChunk (uint8, start, end) {
      var tmp
      var output = []
      for (var i = start; i < end; i += 3) {
        tmp =
          ((uint8[i] << 16) & 0xFF0000) +
          ((uint8[i + 1] << 8) & 0xFF00) +
          (uint8[i + 2] & 0xFF)
        output.push(tripletToBase64(tmp))
      }
      return output.join('')
    }
    
    function fromByteArray (uint8) {
      var tmp
      var len = uint8.length
      var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
      var parts = []
      var maxChunkLength = 16383 // must be multiple of 3
    
      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
      }
    
      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1]
        parts.push(
          lookup[tmp >> 2] +
          lookup[(tmp << 4) & 0x3F] +
          '=='
        )
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1]
        parts.push(
          lookup[tmp >> 10] +
          lookup[(tmp >> 4) & 0x3F] +
          lookup[(tmp << 2) & 0x3F] +
          '='
        )
      }
    
      return parts.join('')
    }
    
    },{}],2:[function(require,module,exports){
    
    },{}],3:[function(require,module,exports){
    (function (Buffer){(function (){
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    /* eslint-disable no-proto */
    
    'use strict'
    
    var base64 = require('base64-js')
    var ieee754 = require('ieee754')
    
    exports.Buffer = Buffer
    exports.SlowBuffer = SlowBuffer
    exports.INSPECT_MAX_BYTES = 50
    
    var K_MAX_LENGTH = 0x7fffffff
    exports.kMaxLength = K_MAX_LENGTH
    
    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Print warning and recommend using `buffer` v4.x which has an Object
     *               implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * We report that the browser does not support typed arrays if the are not subclassable
     * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
     * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
     * for __proto__ and has a buggy typed array implementation.
     */
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()
    
    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
        typeof console.error === 'function') {
      console.error(
        'This browser lacks typed array (Uint8Array) support which is required by ' +
        '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
      )
    }
    
    function typedArraySupport () {
      // Can typed array instances can be augmented?
      try {
        var arr = new Uint8Array(1)
        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
        return arr.foo() === 42
      } catch (e) {
        return false
      }
    }
    
    Object.defineProperty(Buffer.prototype, 'parent', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined
        return this.buffer
      }
    })
    
    Object.defineProperty(Buffer.prototype, 'offset', {
      enumerable: true,
      get: function () {
        if (!Buffer.isBuffer(this)) return undefined
        return this.byteOffset
      }
    })
    
    function createBuffer (length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"')
      }
      // Return an augmented `Uint8Array` instance
      var buf = new Uint8Array(length)
      buf.__proto__ = Buffer.prototype
      return buf
    }
    
    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */
    
    function Buffer (arg, encodingOrOffset, length) {
      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          )
        }
        return allocUnsafe(arg)
      }
      return from(arg, encodingOrOffset, length)
    }
    
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    if (typeof Symbol !== 'undefined' && Symbol.species != null &&
        Buffer[Symbol.species] === Buffer) {
      Object.defineProperty(Buffer, Symbol.species, {
        value: null,
        configurable: true,
        enumerable: false,
        writable: false
      })
    }
    
    Buffer.poolSize = 8192 // not used by this implementation
    
    function from (value, encodingOrOffset, length) {
      if (typeof value === 'string') {
        return fromString(value, encodingOrOffset)
      }
    
      if (ArrayBuffer.isView(value)) {
        return fromArrayLike(value)
      }
    
      if (value == null) {
        throw TypeError(
          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
          'or Array-like Object. Received type ' + (typeof value)
        )
      }
    
      if (isInstance(value, ArrayBuffer) ||
          (value && isInstance(value.buffer, ArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length)
      }
    
      if (typeof value === 'number') {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        )
      }
    
      var valueOf = value.valueOf && value.valueOf()
      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length)
      }
    
      var b = fromObject(value)
      if (b) return b
    
      if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
          typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(
          value[Symbol.toPrimitive]('string'), encodingOrOffset, length
        )
      }
    
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
        'or Array-like Object. Received type ' + (typeof value)
      )
    }
    
    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length)
    }
    
    // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    // https://github.com/feross/buffer/pull/148
    Buffer.prototype.__proto__ = Uint8Array.prototype
    Buffer.__proto__ = Uint8Array
    
    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number')
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"')
      }
    }
    
    function alloc (size, fill, encoding) {
      assertSize(size)
      if (size <= 0) {
        return createBuffer(size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(size).fill(fill, encoding)
          : createBuffer(size).fill(fill)
      }
      return createBuffer(size)
    }
    
    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(size, fill, encoding)
    }
    
    function allocUnsafe (size) {
      assertSize(size)
      return createBuffer(size < 0 ? 0 : checked(size) | 0)
    }
    
    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(size)
    }
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(size)
    }
    
    function fromString (string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8'
      }
    
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    
      var length = byteLength(string, encoding) | 0
      var buf = createBuffer(length)
    
      var actual = buf.write(string, encoding)
    
      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual)
      }
    
      return buf
    }
    
    function fromArrayLike (array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0
      var buf = createBuffer(length)
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255
      }
      return buf
    }
    
    function fromArrayBuffer (array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds')
      }
    
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds')
      }
    
      var buf
      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array)
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset)
      } else {
        buf = new Uint8Array(array, byteOffset, length)
      }
    
      // Return an augmented `Uint8Array` instance
      buf.__proto__ = Buffer.prototype
      return buf
    }
    
    function fromObject (obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0
        var buf = createBuffer(len)
    
        if (buf.length === 0) {
          return buf
        }
    
        obj.copy(buf, 0, 0, len)
        return buf
      }
    
      if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
          return createBuffer(0)
        }
        return fromArrayLike(obj)
      }
    
      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data)
      }
    }
    
    function checked (length) {
      // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
      }
      return length | 0
    }
    
    function SlowBuffer (length) {
      if (+length != length) { // eslint-disable-line eqeqeq
        length = 0
      }
      return Buffer.alloc(+length)
    }
    
    Buffer.isBuffer = function isBuffer (b) {
      return b != null && b._isBuffer === true &&
        b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    }
    
    Buffer.compare = function compare (a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        )
      }
    
      if (a === b) return 0
    
      var x = a.length
      var y = b.length
    
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i]
          y = b[i]
          break
        }
      }
    
      if (x < y) return -1
      if (y < x) return 1
      return 0
    }
    
    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    }
    
    Buffer.concat = function concat (list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
    
      if (list.length === 0) {
        return Buffer.alloc(0)
      }
    
      var i
      if (length === undefined) {
        length = 0
        for (i = 0; i < list.length; ++i) {
          length += list[i].length
        }
      }
    
      var buffer = Buffer.allocUnsafe(length)
      var pos = 0
      for (i = 0; i < list.length; ++i) {
        var buf = list[i]
        if (isInstance(buf, Uint8Array)) {
          buf = Buffer.from(buf)
        }
        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos)
        pos += buf.length
      }
      return buffer
    }
    
    function byteLength (string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
          'Received type ' + typeof string
        )
      }
    
      var len = string.length
      var mustMatch = (arguments.length > 2 && arguments[2] === true)
      if (!mustMatch && len === 0) return 0
    
      // Use a for loop to avoid recursion
      var loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            }
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    Buffer.byteLength = byteLength
    
    function slowToString (encoding, start, end) {
      var loweredCase = false
    
      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.
    
      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }
    
      if (end === undefined || end > this.length) {
        end = this.length
      }
    
      if (end <= 0) {
        return ''
      }
    
      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0
      start >>>= 0
    
      if (end <= start) {
        return ''
      }
    
      if (!encoding) encoding = 'utf8'
    
      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)
    
          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)
    
          case 'ascii':
            return asciiSlice(this, start, end)
    
          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)
    
          case 'base64':
            return base64Slice(this, start, end)
    
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)
    
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase()
            loweredCase = true
        }
      }
    }
    
    // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    // reliably in a browserify context because there could be multiple different
    // copies of the 'buffer' package in use. This method works even for Buffer
    // instances that were created from another copy of the `buffer` package.
    // See: https://github.com/feross/buffer/issues/154
    Buffer.prototype._isBuffer = true
    
    function swap (b, n, m) {
      var i = b[n]
      b[n] = b[m]
      b[m] = i
    }
    
    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1)
      }
      return this
    }
    
    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3)
        swap(this, i + 1, i + 2)
      }
      return this
    }
    
    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7)
        swap(this, i + 1, i + 6)
        swap(this, i + 2, i + 5)
        swap(this, i + 3, i + 4)
      }
      return this
    }
    
    Buffer.prototype.toString = function toString () {
      var length = this.length
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    }
    
    Buffer.prototype.toLocaleString = Buffer.prototype.toString
    
    Buffer.prototype.equals = function equals (b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    }
    
    Buffer.prototype.inspect = function inspect () {
      var str = ''
      var max = exports.INSPECT_MAX_BYTES
      str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
      if (this.length > max) str += ' ... '
      return '<Buffer ' + str + '>'
    }
    
    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength)
      }
      if (!Buffer.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. ' +
          'Received type ' + (typeof target)
        )
      }
    
      if (start === undefined) {
        start = 0
      }
      if (end === undefined) {
        end = target ? target.length : 0
      }
      if (thisStart === undefined) {
        thisStart = 0
      }
      if (thisEnd === undefined) {
        thisEnd = this.length
      }
    
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }
    
      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }
    
      start >>>= 0
      end >>>= 0
      thisStart >>>= 0
      thisEnd >>>= 0
    
      if (this === target) return 0
    
      var x = thisEnd - thisStart
      var y = end - start
      var len = Math.min(x, y)
    
      var thisCopy = this.slice(thisStart, thisEnd)
      var targetCopy = target.slice(start, end)
    
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i]
          y = targetCopy[i]
          break
        }
      }
    
      if (x < y) return -1
      if (y < x) return 1
      return 0
    }
    
    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1
    
      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset
        byteOffset = 0
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000
      }
      byteOffset = +byteOffset // Coerce to Number.
      if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1)
      }
    
      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0
        else return -1
      }
    
      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding)
      }
    
      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        if (typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }
    
      throw new TypeError('val must be string, number or Buffer')
    }
    
    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1
      var arrLength = arr.length
      var valLength = val.length
    
      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase()
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2
          arrLength /= 2
          valLength /= 2
          byteOffset /= 2
        }
      }
    
      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }
    
      var i
      if (dir) {
        var foundIndex = -1
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex
            foundIndex = -1
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
        for (i = byteOffset; i >= 0; i--) {
          var found = true
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false
              break
            }
          }
          if (found) return i
        }
      }
    
      return -1
    }
    
    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    }
    
    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    }
    
    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    }
    
    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0
      var remaining = buf.length - offset
      if (!length) {
        length = remaining
      } else {
        length = Number(length)
        if (length > remaining) {
          length = remaining
        }
      }
    
      var strLen = string.length
    
      if (length > strLen / 2) {
        length = strLen / 2
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16)
        if (numberIsNaN(parsed)) return i
        buf[offset + i] = parsed
      }
      return i
    }
    
    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }
    
    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }
    
    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }
    
    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }
    
    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }
    
    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8'
        length = this.length
        offset = 0
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset
        length = this.length
        offset = 0
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset >>> 0
        if (isFinite(length)) {
          length = length >>> 0
          if (encoding === undefined) encoding = 'utf8'
        } else {
          encoding = length
          length = undefined
        }
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }
    
      var remaining = this.length - offset
      if (length === undefined || length > remaining) length = remaining
    
      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }
    
      if (!encoding) encoding = 'utf8'
    
      var loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)
    
          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)
    
          case 'ascii':
            return asciiWrite(this, string, offset, length)
    
          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)
    
          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)
    
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)
    
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    
    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    }
    
    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf)
      } else {
        return base64.fromByteArray(buf.slice(start, end))
      }
    }
    
    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end)
      var res = []
    
      var i = start
      while (i < end) {
        var firstByte = buf[i]
        var codePoint = null
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
            : (firstByte > 0xBF) ? 2
              : 1
    
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint
    
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte
              }
              break
            case 2:
              secondByte = buf[i + 1]
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 3:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 4:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              fourthByte = buf[i + 3]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint
                }
              }
          }
        }
    
        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD
          bytesPerSequence = 1
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000
          res.push(codePoint >>> 10 & 0x3FF | 0xD800)
          codePoint = 0xDC00 | codePoint & 0x3FF
        }
    
        res.push(codePoint)
        i += bytesPerSequence
      }
    
      return decodeCodePointsArray(res)
    }
    
    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000
    
    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }
    
      // Decode in chunks to avoid "call stack size exceeded".
      var res = ''
      var i = 0
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        )
      }
      return res
    }
    
    function asciiSlice (buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)
    
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F)
      }
      return ret
    }
    
    function latin1Slice (buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)
    
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i])
      }
      return ret
    }
    
    function hexSlice (buf, start, end) {
      var len = buf.length
    
      if (!start || start < 0) start = 0
      if (!end || end < 0 || end > len) end = len
    
      var out = ''
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i])
      }
      return out
    }
    
    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end)
      var res = ''
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
      }
      return res
    }
    
    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length
      start = ~~start
      end = end === undefined ? len : ~~end
    
      if (start < 0) {
        start += len
        if (start < 0) start = 0
      } else if (start > len) {
        start = len
      }
    
      if (end < 0) {
        end += len
        if (end < 0) end = 0
      } else if (end > len) {
        end = len
      }
    
      if (end < start) end = start
    
      var newBuf = this.subarray(start, end)
      // Return an augmented `Uint8Array` instance
      newBuf.__proto__ = Buffer.prototype
      return newBuf
    }
    
    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }
    
    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
    
      return val
    }
    
    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length)
      }
    
      var val = this[offset + --byteLength]
      var mul = 1
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul
      }
    
      return val
    }
    
    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 1, this.length)
      return this[offset]
    }
    
    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 2, this.length)
      return this[offset] | (this[offset + 1] << 8)
    }
    
    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 2, this.length)
      return (this[offset] << 8) | this[offset + 1]
    }
    
    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    }
    
    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    }
    
    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
      mul *= 0x80
    
      if (val >= mul) val -= Math.pow(2, 8 * byteLength)
    
      return val
    }
    
    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var i = byteLength
      var mul = 1
      var val = this[offset + --i]
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul
      }
      mul *= 0x80
    
      if (val >= mul) val -= Math.pow(2, 8 * byteLength)
    
      return val
    }
    
    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 1, this.length)
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    }
    
    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset] | (this[offset + 1] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }
    
    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset + 1] | (this[offset] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }
    
    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    }
    
    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    }
    
    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, true, 23, 4)
    }
    
    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, false, 23, 4)
    }
    
    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, true, 52, 8)
    }
    
    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      offset = offset >>> 0
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, false, 52, 8)
    }
    
    function checkInt (buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }
    
    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }
    
      var mul = 1
      var i = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset >>> 0
      byteLength = byteLength >>> 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }
    
      var i = byteLength - 1
      var mul = 1
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
      this[offset] = (value & 0xff)
      return offset + 1
    }
    
    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      this[offset] = (value & 0xff)
      this[offset + 1] = (value >>> 8)
      return offset + 2
    }
    
    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      this[offset] = (value >>> 8)
      this[offset + 1] = (value & 0xff)
      return offset + 2
    }
    
    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      this[offset + 3] = (value >>> 24)
      this[offset + 2] = (value >>> 16)
      this[offset + 1] = (value >>> 8)
      this[offset] = (value & 0xff)
      return offset + 4
    }
    
    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      this[offset] = (value >>> 24)
      this[offset + 1] = (value >>> 16)
      this[offset + 2] = (value >>> 8)
      this[offset + 3] = (value & 0xff)
      return offset + 4
    }
    
    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1)
    
        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }
    
      var i = 0
      var mul = 1
      var sub = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1)
    
        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }
    
      var i = byteLength - 1
      var mul = 1
      var sub = 0
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
      if (value < 0) value = 0xff + value + 1
      this[offset] = (value & 0xff)
      return offset + 1
    }
    
    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      this[offset] = (value & 0xff)
      this[offset + 1] = (value >>> 8)
      return offset + 2
    }
    
    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      this[offset] = (value >>> 8)
      this[offset + 1] = (value & 0xff)
      return offset + 2
    }
    
    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      this[offset] = (value & 0xff)
      this[offset + 1] = (value >>> 8)
      this[offset + 2] = (value >>> 16)
      this[offset + 3] = (value >>> 24)
      return offset + 4
    }
    
    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      if (value < 0) value = 0xffffffff + value + 1
      this[offset] = (value >>> 24)
      this[offset + 1] = (value >>> 16)
      this[offset + 2] = (value >>> 8)
      this[offset + 3] = (value & 0xff)
      return offset + 4
    }
    
    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }
    
    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4)
      return offset + 4
    }
    
    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    }
    
    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    }
    
    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      value = +value
      offset = offset >>> 0
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8)
      return offset + 8
    }
    
    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    }
    
    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    }
    
    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
      if (!start) start = 0
      if (!end && end !== 0) end = this.length
      if (targetStart >= target.length) targetStart = target.length
      if (!targetStart) targetStart = 0
      if (end > 0 && end < start) end = start
    
      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0
    
      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')
    
      // Are we oob?
      if (end > this.length) end = this.length
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start
      }
    
      var len = end - start
    
      if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end)
      } else if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (var i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start]
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        )
      }
    
      return len
    }
    
    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start
          start = 0
          end = this.length
        } else if (typeof end === 'string') {
          encoding = end
          end = this.length
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0)
          if ((encoding === 'utf8' && code < 128) ||
              encoding === 'latin1') {
            // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code
          }
        }
      } else if (typeof val === 'number') {
        val = val & 255
      }
    
      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }
    
      if (end <= start) {
        return this
      }
    
      start = start >>> 0
      end = end === undefined ? this.length : end >>> 0
    
      if (!val) val = 0
    
      var i
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val
        }
      } else {
        var bytes = Buffer.isBuffer(val)
          ? val
          : Buffer.from(val, encoding)
        var len = bytes.length
        if (len === 0) {
          throw new TypeError('The value "' + val +
            '" is invalid for argument "value"')
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len]
        }
      }
    
      return this
    }
    
    // HELPER FUNCTIONS
    // ================
    
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g
    
    function base64clean (str) {
      // Node takes equal signs as end of the Base64 encoding
      str = str.split('=')[0]
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = str.trim().replace(INVALID_BASE64_RE, '')
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '='
      }
      return str
    }
    
    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }
    
    function utf8ToBytes (string, units) {
      units = units || Infinity
      var codePoint
      var length = string.length
      var leadSurrogate = null
      var bytes = []
    
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i)
    
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            }
    
            // valid lead
            leadSurrogate = codePoint
    
            continue
          }
    
          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            leadSurrogate = codePoint
            continue
          }
    
          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        }
    
        leadSurrogate = null
    
        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint)
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else {
          throw new Error('Invalid code point')
        }
      }
    
      return bytes
    }
    
    function asciiToBytes (str) {
      var byteArray = []
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF)
      }
      return byteArray
    }
    
    function utf16leToBytes (str, units) {
      var c, hi, lo
      var byteArray = []
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break
    
        c = str.charCodeAt(i)
        hi = c >> 8
        lo = c % 256
        byteArray.push(lo)
        byteArray.push(hi)
      }
    
      return byteArray
    }
    
    function base64ToBytes (str) {
      return base64.toByteArray(base64clean(str))
    }
    
    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i]
      }
      return i
    }
    
    // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    // the `instanceof` check but they should be treated as of that type.
    // See: https://github.com/feross/buffer/issues/166
    function isInstance (obj, type) {
      return obj instanceof type ||
        (obj != null && obj.constructor != null && obj.constructor.name != null &&
          obj.constructor.name === type.name)
    }
    function numberIsNaN (obj) {
      // For IE11 support
      return obj !== obj // eslint-disable-line no-self-compare
    }
    
    }).call(this)}).call(this,require("buffer").Buffer)
    },{"base64-js":1,"buffer":3,"ieee754":4}],4:[function(require,module,exports){
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var nBits = -7
      var i = isLE ? (nBytes - 1) : 0
      var d = isLE ? -1 : 1
      var s = buffer[offset + i]
    
      i += d
    
      e = s & ((1 << (-nBits)) - 1)
      s >>= (-nBits)
      nBits += eLen
      for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}
    
      m = e & ((1 << (-nBits)) - 1)
      e >>= (-nBits)
      nBits += mLen
      for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}
    
      if (e === 0) {
        e = 1 - eBias
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen)
        e = e - eBias
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }
    
    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
      var i = isLE ? 0 : (nBytes - 1)
      var d = isLE ? 1 : -1
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
    
      value = Math.abs(value)
    
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0
        e = eMax
      } else {
        e = Math.floor(Math.log(value) / Math.LN2)
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--
          c *= 2
        }
        if (e + eBias >= 1) {
          value += rt / c
        } else {
          value += rt * Math.pow(2, 1 - eBias)
        }
        if (value * c >= 2) {
          e++
          c /= 2
        }
    
        if (e + eBias >= eMax) {
          m = 0
          e = eMax
        } else if (e + eBias >= 1) {
          m = ((value * c) - 1) * Math.pow(2, mLen)
          e = e + eBias
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
          e = 0
        }
      }
    
      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    
      e = (e << mLen) | m
      eLen += mLen
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    
      buffer[offset + i - d] |= s * 128
    }
    
    },{}],5:[function(require,module,exports){
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
    
      return self;
    }
    
    module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
    },{}],6:[function(require,module,exports){
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
    
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    
    function _asyncToGenerator(fn) {
      return function () {
        var self = this,
            args = arguments;
        return new Promise(function (resolve, reject) {
          var gen = fn.apply(self, args);
    
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
    
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
    
          _next(undefined);
        });
      };
    }
    
    module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
    },{}],7:[function(require,module,exports){
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    
    module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
    },{}],8:[function(require,module,exports){
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    
    module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
    },{}],9:[function(require,module,exports){
    function _getPrototypeOf(o) {
      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _getPrototypeOf(o);
    }
    
    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
    },{}],10:[function(require,module,exports){
    var setPrototypeOf = require("./setPrototypeOf.js");
    
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
    
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass) setPrototypeOf(subClass, superClass);
    }
    
    module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
    },{"./setPrototypeOf.js":14}],11:[function(require,module,exports){
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    
    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
    },{}],12:[function(require,module,exports){
    var _typeof = require("./typeof.js")["default"];
    
    var assertThisInitialized = require("./assertThisInitialized.js");
    
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
    
      return assertThisInitialized(self);
    }
    
    module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
    },{"./assertThisInitialized.js":5,"./typeof.js":15}],13:[function(require,module,exports){
    var _typeof = require("./typeof.js")["default"];
    
    function _regeneratorRuntime() {
      "use strict";
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    
      module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
        return exports;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports = {},
          Op = Object.prototype,
          hasOwn = Op.hasOwnProperty,
          $Symbol = "function" == typeof Symbol ? Symbol : {},
          iteratorSymbol = $Symbol.iterator || "@@iterator",
          asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
          toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    
      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value: value,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), obj[key];
      }
    
      try {
        define({}, "");
      } catch (err) {
        define = function define(obj, key, value) {
          return obj[key] = value;
        };
      }
    
      function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
            generator = Object.create(protoGenerator.prototype),
            context = new Context(tryLocsList || []);
        return generator._invoke = function (innerFn, self, context) {
          var state = "suspendedStart";
          return function (method, arg) {
            if ("executing" === state) throw new Error("Generator is already running");
    
            if ("completed" === state) {
              if ("throw" === method) throw arg;
              return doneResult();
            }
    
            for (context.method = method, context.arg = arg;;) {
              var delegate = context.delegate;
    
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
    
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }
    
              if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
                if ("suspendedStart" === state) throw state = "completed", context.arg;
                context.dispatchException(context.arg);
              } else "return" === context.method && context.abrupt("return", context.arg);
              state = "executing";
              var record = tryCatch(innerFn, self, context);
    
              if ("normal" === record.type) {
                if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                return {
                  value: record.arg,
                  done: context.done
                };
              }
    
              "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
            }
          };
        }(innerFn, self, context), generator;
      }
    
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
    
      exports.wrap = wrap;
      var ContinueSentinel = {};
    
      function Generator() {}
    
      function GeneratorFunction() {}
    
      function GeneratorFunctionPrototype() {}
    
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf,
          NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }
    
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
    
          if ("throw" !== record.type) {
            var result = record.arg,
                value = result.value;
            return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function (unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function (error) {
              return invoke("throw", error, resolve, reject);
            });
          }
    
          reject(record.arg);
        }
    
        var previousPromise;
    
        this._invoke = function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
    
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        };
      }
    
      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
    
        if (undefined === method) {
          if (context.delegate = null, "throw" === context.method) {
            if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
            context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
    
          return ContinueSentinel;
        }
    
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
    
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
    
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
    
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
      }
    
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next) return iterable;
    
          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              for (; ++i < iterable.length;) {
                if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              }
    
              return next.value = undefined, next.done = !0, next;
            };
    
            return next.next = next;
          }
        }
    
        return {
          next: doneResult
        };
      }
    
      function doneResult() {
        return {
          value: undefined,
          done: !0
        };
      }
    
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports.mark = function (genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports.awrap = function (arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
        return this;
      }), define(Gp, "toString", function () {
        return "[object Generator]";
      }), exports.keys = function (object) {
        var keys = [];
    
        for (var key in object) {
          keys.push(key);
        }
    
        return keys.reverse(), function next() {
          for (; keys.length;) {
            var key = keys.pop();
            if (key in object) return next.value = key, next.done = !1, next;
          }
    
          return next.done = !0, next;
        };
      }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
          }
        },
        stop: function stop() {
          this.done = !0;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type) throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) throw exception;
          var context = this;
    
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
          }
    
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i],
                record = entry.completion;
            if ("root" === entry.tryLoc) return handle("end");
    
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"),
                  hasFinally = hasOwn.call(entry, "finallyLoc");
    
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              } else {
                if (!hasFinally) throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
    
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
    
          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type) throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
    
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
    
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
    
              return thrown;
            }
          }
    
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
      }, exports;
    }
    
    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
    },{"./typeof.js":15}],14:[function(require,module,exports){
    function _setPrototypeOf(o, p) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _setPrototypeOf(o, p);
    }
    
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
    },{}],15:[function(require,module,exports){
    function _typeof(obj) {
      "@babel/helpers - typeof";
    
      return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
    }
    
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
    },{}],16:[function(require,module,exports){
    // TODO(Babel 8): Remove this file.
    
    var runtime = require("../helpers/regeneratorRuntime")();
    module.exports = runtime;
    
    // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
    
    },{"../helpers/regeneratorRuntime":13}],17:[function(require,module,exports){
    "use strict";
    /*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.curve25519 = exports.getSharedSecret = exports.sync = exports.verify = exports.sign = exports.getPublicKey = exports.Signature = exports.Point = exports.RistrettoPoint = exports.ExtendedPoint = exports.CURVE = void 0;
    const nodeCrypto = require("crypto");
    const _0n = BigInt(0);
    const _1n = BigInt(1);
    const _2n = BigInt(2);
    const CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');
    const CURVE = Object.freeze({
        a: BigInt(-1),
        d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
        P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),
        l: CU_O,
        n: CU_O,
        h: BigInt(8),
        Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
        Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),
    });
    exports.CURVE = CURVE;
    const POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
    const SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
    const SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');
    const SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');
    const INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');
    const ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');
    const D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');
    class ExtendedPoint {
        constructor(x, y, z, t) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.t = t;
        }
        static fromAffine(p) {
            if (!(p instanceof Point)) {
                throw new TypeError('ExtendedPoint#fromAffine: expected Point');
            }
            if (p.equals(Point.ZERO))
                return ExtendedPoint.ZERO;
            return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));
        }
        static toAffineBatch(points) {
            const toInv = invertBatch(points.map((p) => p.z));
            return points.map((p, i) => p.toAffine(toInv[i]));
        }
        static normalizeZ(points) {
            return this.toAffineBatch(points).map(this.fromAffine);
        }
        equals(other) {
            assertExtPoint(other);
            const { x: X1, y: Y1, z: Z1 } = this;
            const { x: X2, y: Y2, z: Z2 } = other;
            const X1Z2 = mod(X1 * Z2);
            const X2Z1 = mod(X2 * Z1);
            const Y1Z2 = mod(Y1 * Z2);
            const Y2Z1 = mod(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        negate() {
            return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));
        }
        double() {
            const { x: X1, y: Y1, z: Z1 } = this;
            const { a } = CURVE;
            const A = mod(X1 * X1);
            const B = mod(Y1 * Y1);
            const C = mod(_2n * mod(Z1 * Z1));
            const D = mod(a * A);
            const x1y1 = X1 + Y1;
            const E = mod(mod(x1y1 * x1y1) - A - B);
            const G = D + B;
            const F = G - C;
            const H = D - B;
            const X3 = mod(E * F);
            const Y3 = mod(G * H);
            const T3 = mod(E * H);
            const Z3 = mod(F * G);
            return new ExtendedPoint(X3, Y3, Z3, T3);
        }
        add(other) {
            assertExtPoint(other);
            const { x: X1, y: Y1, z: Z1, t: T1 } = this;
            const { x: X2, y: Y2, z: Z2, t: T2 } = other;
            const A = mod((Y1 - X1) * (Y2 + X2));
            const B = mod((Y1 + X1) * (Y2 - X2));
            const F = mod(B - A);
            if (F === _0n)
                return this.double();
            const C = mod(Z1 * _2n * T2);
            const D = mod(T1 * _2n * Z2);
            const E = D + C;
            const G = B + A;
            const H = D - C;
            const X3 = mod(E * F);
            const Y3 = mod(G * H);
            const T3 = mod(E * H);
            const Z3 = mod(F * G);
            return new ExtendedPoint(X3, Y3, Z3, T3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        precomputeWindow(W) {
            const windows = 1 + 256 / W;
            const points = [];
            let p = this;
            let base = p;
            for (let window = 0; window < windows; window++) {
                base = p;
                points.push(base);
                for (let i = 1; i < 2 ** (W - 1); i++) {
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        }
        wNAF(n, affinePoint) {
            if (!affinePoint && this.equals(ExtendedPoint.BASE))
                affinePoint = Point.BASE;
            const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;
            if (256 % W) {
                throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
            }
            let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
            if (!precomputes) {
                precomputes = this.precomputeWindow(W);
                if (affinePoint && W !== 1) {
                    precomputes = ExtendedPoint.normalizeZ(precomputes);
                    pointPrecomputes.set(affinePoint, precomputes);
                }
            }
            let p = ExtendedPoint.ZERO;
            let f = ExtendedPoint.ZERO;
            const windows = 1 + 256 / W;
            const windowSize = 2 ** (W - 1);
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window = 0; window < windows; window++) {
                const offset = window * windowSize;
                let wbits = Number(n & mask);
                n >>= shiftBy;
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                if (wbits === 0) {
                    let pr = precomputes[offset];
                    if (window % 2)
                        pr = pr.negate();
                    f = f.add(pr);
                }
                else {
                    let cached = precomputes[offset + Math.abs(wbits) - 1];
                    if (wbits < 0)
                        cached = cached.negate();
                    p = p.add(cached);
                }
            }
            return ExtendedPoint.normalizeZ([p, f])[0];
        }
        multiply(scalar, affinePoint) {
            return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
        }
        multiplyUnsafe(scalar) {
            let n = normalizeScalar(scalar, CURVE.l, false);
            const G = ExtendedPoint.BASE;
            const P0 = ExtendedPoint.ZERO;
            if (n === _0n)
                return P0;
            if (this.equals(P0) || n === _1n)
                return this;
            if (this.equals(G))
                return this.wNAF(n);
            let p = P0;
            let d = this;
            while (n > _0n) {
                if (n & _1n)
                    p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        }
        isSmallOrder() {
            return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
        }
        isTorsionFree() {
            return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);
        }
        toAffine(invZ = invert(this.z)) {
            const { x, y, z } = this;
            const ax = mod(x * invZ);
            const ay = mod(y * invZ);
            const zz = mod(z * invZ);
            if (zz !== _1n)
                throw new Error('invZ was invalid');
            return new Point(ax, ay);
        }
        fromRistrettoBytes() {
            legacyRist();
        }
        toRistrettoBytes() {
            legacyRist();
        }
        fromRistrettoHash() {
            legacyRist();
        }
    }
    exports.ExtendedPoint = ExtendedPoint;
    ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));
    ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
    function assertExtPoint(other) {
        if (!(other instanceof ExtendedPoint))
            throw new TypeError('ExtendedPoint expected');
    }
    function assertRstPoint(other) {
        if (!(other instanceof RistrettoPoint))
            throw new TypeError('RistrettoPoint expected');
    }
    function legacyRist() {
        throw new Error('Legacy method: switch to RistrettoPoint');
    }
    class RistrettoPoint {
        constructor(ep) {
            this.ep = ep;
        }
        static calcElligatorRistrettoMap(r0) {
            const { d } = CURVE;
            const r = mod(SQRT_M1 * r0 * r0);
            const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
            let c = BigInt(-1);
            const D = mod((c - d * r) * mod(r + d));
            let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
            let s_ = mod(s * r0);
            if (!edIsNegative(s_))
                s_ = mod(-s_);
            if (!Ns_D_is_sq)
                s = s_;
            if (!Ns_D_is_sq)
                c = r;
            const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
            const s2 = s * s;
            const W0 = mod((s + s) * D);
            const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
            const W2 = mod(_1n - s2);
            const W3 = mod(_1n + s2);
            return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
        }
        static hashToCurve(hex) {
            hex = ensureBytes(hex, 64);
            const r1 = bytes255ToNumberLE(hex.slice(0, 32));
            const R1 = this.calcElligatorRistrettoMap(r1);
            const r2 = bytes255ToNumberLE(hex.slice(32, 64));
            const R2 = this.calcElligatorRistrettoMap(r2);
            return new RistrettoPoint(R1.add(R2));
        }
        static fromHex(hex) {
            hex = ensureBytes(hex, 32);
            const { a, d } = CURVE;
            const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';
            const s = bytes255ToNumberLE(hex);
            if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))
                throw new Error(emsg);
            const s2 = mod(s * s);
            const u1 = mod(_1n + a * s2);
            const u2 = mod(_1n - a * s2);
            const u1_2 = mod(u1 * u1);
            const u2_2 = mod(u2 * u2);
            const v = mod(a * d * u1_2 - u2_2);
            const { isValid, value: I } = invertSqrt(mod(v * u2_2));
            const Dx = mod(I * u2);
            const Dy = mod(I * Dx * v);
            let x = mod((s + s) * Dx);
            if (edIsNegative(x))
                x = mod(-x);
            const y = mod(u1 * Dy);
            const t = mod(x * y);
            if (!isValid || edIsNegative(t) || y === _0n)
                throw new Error(emsg);
            return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));
        }
        toRawBytes() {
            let { x, y, z, t } = this.ep;
            const u1 = mod(mod(z + y) * mod(z - y));
            const u2 = mod(x * y);
            const u2sq = mod(u2 * u2);
            const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
            const D1 = mod(invsqrt * u1);
            const D2 = mod(invsqrt * u2);
            const zInv = mod(D1 * D2 * t);
            let D;
            if (edIsNegative(t * zInv)) {
                let _x = mod(y * SQRT_M1);
                let _y = mod(x * SQRT_M1);
                x = _x;
                y = _y;
                D = mod(D1 * INVSQRT_A_MINUS_D);
            }
            else {
                D = D2;
            }
            if (edIsNegative(x * zInv))
                y = mod(-y);
            let s = mod((z - y) * D);
            if (edIsNegative(s))
                s = mod(-s);
            return numberTo32BytesLE(s);
        }
        toHex() {
            return bytesToHex(this.toRawBytes());
        }
        toString() {
            return this.toHex();
        }
        equals(other) {
            assertRstPoint(other);
            const a = this.ep;
            const b = other.ep;
            const one = mod(a.x * b.y) === mod(a.y * b.x);
            const two = mod(a.y * b.y) === mod(a.x * b.x);
            return one || two;
        }
        add(other) {
            assertRstPoint(other);
            return new RistrettoPoint(this.ep.add(other.ep));
        }
        subtract(other) {
            assertRstPoint(other);
            return new RistrettoPoint(this.ep.subtract(other.ep));
        }
        multiply(scalar) {
            return new RistrettoPoint(this.ep.multiply(scalar));
        }
        multiplyUnsafe(scalar) {
            return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
        }
    }
    exports.RistrettoPoint = RistrettoPoint;
    RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
    RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
    const pointPrecomputes = new WeakMap();
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        }
        static fromHex(hex, strict = true) {
            const { d, P } = CURVE;
            hex = ensureBytes(hex, 32);
            const normed = hex.slice();
            normed[31] = hex[31] & ~0x80;
            const y = bytesToNumberLE(normed);
            if (strict && y >= P)
                throw new Error('Expected 0 < hex < P');
            if (!strict && y >= POW_2_256)
                throw new Error('Expected 0 < hex < 2**256');
            const y2 = mod(y * y);
            const u = mod(y2 - _1n);
            const v = mod(d * y2 + _1n);
            let { isValid, value: x } = uvRatio(u, v);
            if (!isValid)
                throw new Error('Point.fromHex: invalid y coordinate');
            const isXOdd = (x & _1n) === _1n;
            const isLastByteOdd = (hex[31] & 0x80) !== 0;
            if (isLastByteOdd !== isXOdd) {
                x = mod(-x);
            }
            return new Point(x, y);
        }
        static async fromPrivateKey(privateKey) {
            return (await getExtendedPublicKey(privateKey)).point;
        }
        toRawBytes() {
            const bytes = numberTo32BytesLE(this.y);
            bytes[31] |= this.x & _1n ? 0x80 : 0;
            return bytes;
        }
        toHex() {
            return bytesToHex(this.toRawBytes());
        }
        toX25519() {
            const { y } = this;
            const u = mod((_1n + y) * invert(_1n - y));
            return numberTo32BytesLE(u);
        }
        isTorsionFree() {
            return ExtendedPoint.fromAffine(this).isTorsionFree();
        }
        equals(other) {
            return this.x === other.x && this.y === other.y;
        }
        negate() {
            return new Point(mod(-this.x), this.y);
        }
        add(other) {
            return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
        }
        subtract(other) {
            return this.add(other.negate());
        }
        multiply(scalar) {
            return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
        }
    }
    exports.Point = Point;
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
    Point.ZERO = new Point(_0n, _1n);
    class Signature {
        constructor(r, s) {
            this.r = r;
            this.s = s;
            this.assertValidity();
        }
        static fromHex(hex) {
            const bytes = ensureBytes(hex, 64);
            const r = Point.fromHex(bytes.slice(0, 32), false);
            const s = bytesToNumberLE(bytes.slice(32, 64));
            return new Signature(r, s);
        }
        assertValidity() {
            const { r, s } = this;
            if (!(r instanceof Point))
                throw new Error('Expected Point instance');
            normalizeScalar(s, CURVE.l, false);
            return this;
        }
        toRawBytes() {
            const u8 = new Uint8Array(64);
            u8.set(this.r.toRawBytes());
            u8.set(numberTo32BytesLE(this.s), 32);
            return u8;
        }
        toHex() {
            return bytesToHex(this.toRawBytes());
        }
    }
    exports.Signature = Signature;
    function concatBytes(...arrays) {
        if (!arrays.every((a) => a instanceof Uint8Array))
            throw new Error('Expected Uint8Array list');
        if (arrays.length === 1)
            return arrays[0];
        const length = arrays.reduce((a, arr) => a + arr.length, 0);
        const result = new Uint8Array(length);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
            const arr = arrays[i];
            result.set(arr, pad);
            pad += arr.length;
        }
        return result;
    }
    const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
    function bytesToHex(uint8a) {
        if (!(uint8a instanceof Uint8Array))
            throw new Error('Uint8Array expected');
        let hex = '';
        for (let i = 0; i < uint8a.length; i++) {
            hex += hexes[uint8a[i]];
        }
        return hex;
    }
    function hexToBytes(hex) {
        if (typeof hex !== 'string') {
            throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
        }
        if (hex.length % 2)
            throw new Error('hexToBytes: received invalid unpadded hex');
        const array = new Uint8Array(hex.length / 2);
        for (let i = 0; i < array.length; i++) {
            const j = i * 2;
            const hexByte = hex.slice(j, j + 2);
            const byte = Number.parseInt(hexByte, 16);
            if (Number.isNaN(byte) || byte < 0)
                throw new Error('Invalid byte sequence');
            array[i] = byte;
        }
        return array;
    }
    function numberTo32BytesBE(num) {
        const length = 32;
        const hex = num.toString(16).padStart(length * 2, '0');
        return hexToBytes(hex);
    }
    function numberTo32BytesLE(num) {
        return numberTo32BytesBE(num).reverse();
    }
    function edIsNegative(num) {
        return (mod(num) & _1n) === _1n;
    }
    function bytesToNumberLE(uint8a) {
        if (!(uint8a instanceof Uint8Array))
            throw new Error('Expected Uint8Array');
        return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));
    }
    const MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
    function bytes255ToNumberLE(bytes) {
        return mod(bytesToNumberLE(bytes) & MAX_255B);
    }
    function mod(a, b = CURVE.P) {
        const res = a % b;
        return res >= _0n ? res : b + res;
    }
    function invert(number, modulo = CURVE.P) {
        if (number === _0n || modulo <= _0n) {
            throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod(number, modulo);
        let b = modulo;
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
            const q = b / a;
            const r = b % a;
            const m = x - u * q;
            const n = y - v * q;
            b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
            throw new Error('invert: does not exist');
        return mod(x, modulo);
    }
    function invertBatch(nums, p = CURVE.P) {
        const tmp = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num, i) => {
            if (num === _0n)
                return acc;
            tmp[i] = acc;
            return mod(acc * num, p);
        }, _1n);
        const inverted = invert(lastMultiplied, p);
        nums.reduceRight((acc, num, i) => {
            if (num === _0n)
                return acc;
            tmp[i] = mod(acc * tmp[i], p);
            return mod(acc * num, p);
        }, inverted);
        return tmp;
    }
    function pow2(x, power) {
        const { P } = CURVE;
        let res = x;
        while (power-- > _0n) {
            res *= res;
            res %= P;
        }
        return res;
    }
    function pow_2_252_3(x) {
        const { P } = CURVE;
        const _5n = BigInt(5);
        const _10n = BigInt(10);
        const _20n = BigInt(20);
        const _40n = BigInt(40);
        const _80n = BigInt(80);
        const x2 = (x * x) % P;
        const b2 = (x2 * x) % P;
        const b4 = (pow2(b2, _2n) * b2) % P;
        const b5 = (pow2(b4, _1n) * x) % P;
        const b10 = (pow2(b5, _5n) * b5) % P;
        const b20 = (pow2(b10, _10n) * b10) % P;
        const b40 = (pow2(b20, _20n) * b20) % P;
        const b80 = (pow2(b40, _40n) * b40) % P;
        const b160 = (pow2(b80, _80n) * b80) % P;
        const b240 = (pow2(b160, _80n) * b80) % P;
        const b250 = (pow2(b240, _10n) * b10) % P;
        const pow_p_5_8 = (pow2(b250, _2n) * x) % P;
        return { pow_p_5_8, b2 };
    }
    function uvRatio(u, v) {
        const v3 = mod(v * v * v);
        const v7 = mod(v3 * v3 * v);
        const pow = pow_2_252_3(u * v7).pow_p_5_8;
        let x = mod(u * v3 * pow);
        const vx2 = mod(v * x * x);
        const root1 = x;
        const root2 = mod(x * SQRT_M1);
        const useRoot1 = vx2 === u;
        const useRoot2 = vx2 === mod(-u);
        const noRoot = vx2 === mod(-u * SQRT_M1);
        if (useRoot1)
            x = root1;
        if (useRoot2 || noRoot)
            x = root2;
        if (edIsNegative(x))
            x = mod(-x);
        return { isValid: useRoot1 || useRoot2, value: x };
    }
    function invertSqrt(number) {
        return uvRatio(_1n, number);
    }
    function modlLE(hash) {
        return mod(bytesToNumberLE(hash), CURVE.l);
    }
    function equalBytes(b1, b2) {
        if (b1.length !== b2.length) {
            return false;
        }
        for (let i = 0; i < b1.length; i++) {
            if (b1[i] !== b2[i]) {
                return false;
            }
        }
        return true;
    }
    function ensureBytes(hex, expectedLength) {
        const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
        if (typeof expectedLength === 'number' && bytes.length !== expectedLength)
            throw new Error(`Expected ${expectedLength} bytes`);
        return bytes;
    }
    function normalizeScalar(num, max, strict = true) {
        if (!max)
            throw new TypeError('Specify max value');
        if (typeof num === 'number' && Number.isSafeInteger(num))
            num = BigInt(num);
        if (typeof num === 'bigint' && num < max) {
            if (strict) {
                if (_0n < num)
                    return num;
            }
            else {
                if (_0n <= num)
                    return num;
            }
        }
        throw new TypeError('Expected valid scalar: 0 < scalar < max');
    }
    function adjustBytes25519(bytes) {
        bytes[0] &= 248;
        bytes[31] &= 127;
        bytes[31] |= 64;
        return bytes;
    }
    function decodeScalar25519(n) {
        return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));
    }
    function checkPrivateKey(key) {
        key =
            typeof key === 'bigint' || typeof key === 'number'
                ? numberTo32BytesBE(normalizeScalar(key, POW_2_256))
                : ensureBytes(key);
        if (key.length !== 32)
            throw new Error(`Expected 32 bytes`);
        return key;
    }
    function getKeyFromHash(hashed) {
        const head = adjustBytes25519(hashed.slice(0, 32));
        const prefix = hashed.slice(32, 64);
        const scalar = modlLE(head);
        const point = Point.BASE.multiply(scalar);
        const pointBytes = point.toRawBytes();
        return { head, prefix, scalar, point, pointBytes };
    }
    let _sha512Sync;
    function sha512s(...m) {
        if (typeof _sha512Sync !== 'function')
            throw new Error('utils.sha512Sync must be set to use sync methods');
        return _sha512Sync(...m);
    }
    async function getExtendedPublicKey(key) {
        return getKeyFromHash(await exports.utils.sha512(checkPrivateKey(key)));
    }
    function getExtendedPublicKeySync(key) {
        return getKeyFromHash(sha512s(checkPrivateKey(key)));
    }
    async function getPublicKey(privateKey) {
        return (await getExtendedPublicKey(privateKey)).pointBytes;
    }
    exports.getPublicKey = getPublicKey;
    function getPublicKeySync(privateKey) {
        return getExtendedPublicKeySync(privateKey).pointBytes;
    }
    async function sign(message, privateKey) {
        message = ensureBytes(message);
        const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
        const r = modlLE(await exports.utils.sha512(prefix, message));
        const R = Point.BASE.multiply(r);
        const k = modlLE(await exports.utils.sha512(R.toRawBytes(), pointBytes, message));
        const s = mod(r + k * scalar, CURVE.l);
        return new Signature(R, s).toRawBytes();
    }
    exports.sign = sign;
    function signSync(message, privateKey) {
        message = ensureBytes(message);
        const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);
        const r = modlLE(sha512s(prefix, message));
        const R = Point.BASE.multiply(r);
        const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));
        const s = mod(r + k * scalar, CURVE.l);
        return new Signature(R, s).toRawBytes();
    }
    function prepareVerification(sig, message, publicKey) {
        message = ensureBytes(message);
        if (!(publicKey instanceof Point))
            publicKey = Point.fromHex(publicKey, false);
        const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);
        const SB = ExtendedPoint.BASE.multiplyUnsafe(s);
        return { r, s, SB, pub: publicKey, msg: message };
    }
    function finishVerification(publicKey, r, SB, hashed) {
        const k = modlLE(hashed);
        const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
        const RkA = ExtendedPoint.fromAffine(r).add(kA);
        return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
    }
    async function verify(sig, message, publicKey) {
        const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);
        const hashed = await exports.utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
        return finishVerification(pub, r, SB, hashed);
    }
    exports.verify = verify;
    function verifySync(sig, message, publicKey) {
        const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);
        const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);
        return finishVerification(pub, r, SB, hashed);
    }
    exports.sync = {
        getExtendedPublicKey: getExtendedPublicKeySync,
        getPublicKey: getPublicKeySync,
        sign: signSync,
        verify: verifySync,
    };
    async function getSharedSecret(privateKey, publicKey) {
        const { head } = await getExtendedPublicKey(privateKey);
        const u = Point.fromHex(publicKey).toX25519();
        return exports.curve25519.scalarMult(head, u);
    }
    exports.getSharedSecret = getSharedSecret;
    Point.BASE._setWindowSize(8);
    function cswap(swap, x_2, x_3) {
        const dummy = mod(swap * (x_2 - x_3));
        x_2 = mod(x_2 - dummy);
        x_3 = mod(x_3 + dummy);
        return [x_2, x_3];
    }
    function montgomeryLadder(pointU, scalar) {
        const { P } = CURVE;
        const u = normalizeScalar(pointU, P);
        const k = normalizeScalar(scalar, P);
        const a24 = BigInt(121665);
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        let sw;
        for (let t = BigInt(255 - 1); t >= _0n; t--) {
            const k_t = (k >> t) & _1n;
            swap ^= k_t;
            sw = cswap(swap, x_2, x_3);
            x_2 = sw[0];
            x_3 = sw[1];
            sw = cswap(swap, z_2, z_3);
            z_2 = sw[0];
            z_3 = sw[1];
            swap = k_t;
            const A = x_2 + z_2;
            const AA = mod(A * A);
            const B = x_2 - z_2;
            const BB = mod(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = mod(D * A);
            const CB = mod(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = mod(dacb * dacb);
            z_3 = mod(x_1 * mod(da_cb * da_cb));
            x_2 = mod(AA * BB);
            z_2 = mod(E * (AA + mod(a24 * E)));
        }
        sw = cswap(swap, x_2, x_3);
        x_2 = sw[0];
        x_3 = sw[1];
        sw = cswap(swap, z_2, z_3);
        z_2 = sw[0];
        z_3 = sw[1];
        const { pow_p_5_8, b2 } = pow_2_252_3(z_2);
        const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);
        return mod(x_2 * xp2);
    }
    function encodeUCoordinate(u) {
        return numberTo32BytesLE(mod(u, CURVE.P));
    }
    function decodeUCoordinate(uEnc) {
        const u = ensureBytes(uEnc, 32);
        u[31] &= 127;
        return bytesToNumberLE(u);
    }
    exports.curve25519 = {
        BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',
        scalarMult(privateKey, publicKey) {
            const u = decodeUCoordinate(publicKey);
            const p = decodeScalar25519(privateKey);
            const pu = montgomeryLadder(u, p);
            if (pu === _0n)
                throw new Error('Invalid private or public key received');
            return encodeUCoordinate(pu);
        },
        scalarMultBase(privateKey) {
            return exports.curve25519.scalarMult(privateKey, exports.curve25519.BASE_POINT_U);
        },
    };
    const crypto = {
        node: nodeCrypto,
        web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
    };
    exports.utils = {
        bytesToHex,
        hexToBytes,
        concatBytes,
        getExtendedPublicKey,
        mod,
        invert,
        TORSION_SUBGROUP: [
            '0100000000000000000000000000000000000000000000000000000000000000',
            'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',
            '0000000000000000000000000000000000000000000000000000000000000080',
            '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',
            'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',
            '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',
            '0000000000000000000000000000000000000000000000000000000000000000',
            'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',
        ],
        hashToPrivateScalar: (hash) => {
            hash = ensureBytes(hash);
            if (hash.length < 40 || hash.length > 1024)
                throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');
            return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;
        },
        randomBytes: (bytesLength = 32) => {
            if (crypto.web) {
                return crypto.web.getRandomValues(new Uint8Array(bytesLength));
            }
            else if (crypto.node) {
                const { randomBytes } = crypto.node;
                return new Uint8Array(randomBytes(bytesLength).buffer);
            }
            else {
                throw new Error("The environment doesn't have randomBytes function");
            }
        },
        randomPrivateKey: () => {
            return exports.utils.randomBytes(32);
        },
        sha512: async (...messages) => {
            const message = concatBytes(...messages);
            if (crypto.web) {
                const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);
                return new Uint8Array(buffer);
            }
            else if (crypto.node) {
                return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());
            }
            else {
                throw new Error("The environment doesn't have sha512 function");
            }
        },
        precompute(windowSize = 8, point = Point.BASE) {
            const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
            cached._setWindowSize(windowSize);
            cached.multiply(_2n);
            return cached;
        },
        sha512Sync: undefined,
    };
    Object.defineProperties(exports.utils, {
        sha512Sync: {
            configurable: false,
            get() {
                return _sha512Sync;
            },
            set(val) {
                if (!_sha512Sync)
                    _sha512Sync = val;
            },
        },
    });
    
    },{"crypto":2}],18:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
            throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b) {
        if (typeof b !== 'boolean')
            throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function bytes(b, ...lengths) {
        if (!(b instanceof Uint8Array))
            throw new TypeError('Expected Uint8Array');
        if (lengths.length > 0 && !lengths.includes(b.length))
            throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(hash) {
        if (typeof hash !== 'function' || typeof hash.create !== 'function')
            throw new Error('Hash should be wrapped by utils.wrapConstructor');
        number(hash.outputLen);
        number(hash.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
        if (instance.destroyed)
            throw new Error('Hash instance has been destroyed');
        if (checkFinished && instance.finished)
            throw new Error('Hash#digest() has already been called');
    }
    exports.exists = exists;
    function output(out, instance) {
        bytes(out);
        const min = instance.outputLen;
        if (out.length < min) {
            throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
    }
    exports.output = output;
    const assert = {
        number,
        bool,
        bytes,
        hash,
        exists,
        output,
    };
    exports.default = assert;
    
    },{}],19:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    const _assert_js_1 = require("./_assert.js");
    const utils_js_1 = require("./utils.js");
    // Polyfill for Safari 14
    function setBigUint64(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === 'function')
            return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(0xffffffff);
        const wh = Number((value >> _32n) & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
    }
    // Base SHA2 class (RFC 6234)
    class SHA2 extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
            super();
            this.blockLen = blockLen;
            this.outputLen = outputLen;
            this.padOffset = padOffset;
            this.isLE = isLE;
            this.finished = false;
            this.length = 0;
            this.pos = 0;
            this.destroyed = false;
            this.buffer = new Uint8Array(blockLen);
            this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data) {
            _assert_js_1.default.exists(this);
            const { view, buffer, blockLen } = this;
            data = (0, utils_js_1.toBytes)(data);
            const len = data.length;
            for (let pos = 0; pos < len;) {
                const take = Math.min(blockLen - this.pos, len - pos);
                // Fast path: we have at least one block in input, cast it to view and process
                if (take === blockLen) {
                    const dataView = (0, utils_js_1.createView)(data);
                    for (; blockLen <= len - pos; pos += blockLen)
                        this.process(dataView, pos);
                    continue;
                }
                buffer.set(data.subarray(pos, pos + take), this.pos);
                this.pos += take;
                pos += take;
                if (this.pos === blockLen) {
                    this.process(view, 0);
                    this.pos = 0;
                }
            }
            this.length += data.length;
            this.roundClean();
            return this;
        }
        digestInto(out) {
            _assert_js_1.default.exists(this);
            _assert_js_1.default.output(out, this);
            this.finished = true;
            // Padding
            // We can avoid allocation of buffer for padding completely if it
            // was previously not allocated here. But it won't change performance.
            const { buffer, view, blockLen, isLE } = this;
            let { pos } = this;
            // append the bit '1' to the message
            buffer[pos++] = 0b10000000;
            this.buffer.subarray(pos).fill(0);
            // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
            if (this.padOffset > blockLen - pos) {
                this.process(view, 0);
                pos = 0;
            }
            // Pad until full block byte with zeros
            for (let i = pos; i < blockLen; i++)
                buffer[i] = 0;
            // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
            // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
            // So we just write lowest 64 bits of that value.
            setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
            this.process(view, 0);
            const oview = (0, utils_js_1.createView)(out);
            this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));
        }
        digest() {
            const { buffer, outputLen } = this;
            this.digestInto(buffer);
            const res = buffer.slice(0, outputLen);
            this.destroy();
            return res;
        }
        _cloneInto(to) {
            to || (to = new this.constructor());
            to.set(...this.get());
            const { blockLen, buffer, length, finished, destroyed, pos } = this;
            to.length = length;
            to.pos = pos;
            to.finished = finished;
            to.destroyed = destroyed;
            if (length % blockLen)
                to.buffer.set(buffer);
            return to;
        }
    }
    exports.SHA2 = SHA2;
    
    },{"./_assert.js":18,"./utils.js":26}],20:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
    const U32_MASK64 = BigInt(2 ** 32 - 1);
    const _32n = BigInt(32);
    // We are not using BigUint64Array, because they are extremely slow as per 2022
    function fromBig(n, le = false) {
        if (le)
            return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
        return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
            const { h, l } = fromBig(lst[i], le);
            [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
    }
    exports.split = split;
    const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
    exports.toBig = toBig;
    // for Shift in [0, 32)
    const shrSH = (h, l, s) => h >>> s;
    const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
    // Right rotate for Shift in [1, 32)
    const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
    const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
    // Right rotate for Shift in (32, 64), NOTE: 32 is special case.
    const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
    const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
    // Right rotate for shift===32 (just swaps l&h)
    const rotr32H = (h, l) => l;
    const rotr32L = (h, l) => h;
    // Left rotate for Shift in [1, 32)
    const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
    const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
    // Left rotate for Shift in (32, 64), NOTE: 32 is special case.
    const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
    const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
    // JS uses 32-bit signed integers for bitwise operations which means we cannot
    // simple take carry out of low bit sum by shift, we need to use division.
    // Removing "export" has 5% perf penalty -_-
    function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
    }
    exports.add = add;
    // Addition with more than 2 elements
    const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
    const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
    const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
    // prettier-ignore
    const u64 = {
        fromBig, split, toBig: exports.toBig,
        shrSH, shrSL,
        rotrSH, rotrSL, rotrBH, rotrBL,
        rotr32H, rotr32L,
        rotlSH, rotlSL, rotlBH, rotlBL,
        add, add3L, add3H, add4L, add4H, add5H, add5L,
    };
    exports.default = u64;
    
    },{}],21:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = {
        node: undefined,
        web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
    };
    
    },{}],22:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = void 0;
    const _assert_js_1 = require("./_assert.js");
    const utils_js_1 = require("./utils.js");
    // HMAC (RFC 2104)
    class HMAC extends utils_js_1.Hash {
        constructor(hash, _key) {
            super();
            this.finished = false;
            this.destroyed = false;
            _assert_js_1.default.hash(hash);
            const key = (0, utils_js_1.toBytes)(_key);
            this.iHash = hash.create();
            if (!(this.iHash instanceof utils_js_1.Hash))
                throw new TypeError('Expected instance of class which extends utils.Hash');
            const blockLen = (this.blockLen = this.iHash.blockLen);
            this.outputLen = this.iHash.outputLen;
            const pad = new Uint8Array(blockLen);
            // blockLen can be bigger than outputLen
            pad.set(key.length > this.iHash.blockLen ? hash.create().update(key).digest() : key);
            for (let i = 0; i < pad.length; i++)
                pad[i] ^= 0x36;
            this.iHash.update(pad);
            // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
            this.oHash = hash.create();
            // Undo internal XOR && apply outer XOR
            for (let i = 0; i < pad.length; i++)
                pad[i] ^= 0x36 ^ 0x5c;
            this.oHash.update(pad);
            pad.fill(0);
        }
        update(buf) {
            _assert_js_1.default.exists(this);
            this.iHash.update(buf);
            return this;
        }
        digestInto(out) {
            _assert_js_1.default.exists(this);
            _assert_js_1.default.bytes(out, this.outputLen);
            this.finished = true;
            this.iHash.digestInto(out);
            this.oHash.update(out);
            this.oHash.digestInto(out);
            this.destroy();
        }
        digest() {
            const out = new Uint8Array(this.oHash.outputLen);
            this.digestInto(out);
            return out;
        }
        _cloneInto(to) {
            // Create new instance without calling constructor since key already in state and we don't know it.
            to || (to = Object.create(Object.getPrototypeOf(this), {}));
            const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
            to = to;
            to.finished = finished;
            to.destroyed = destroyed;
            to.blockLen = blockLen;
            to.outputLen = outputLen;
            to.oHash = oHash._cloneInto(to.oHash);
            to.iHash = iHash._cloneInto(to.iHash);
            return to;
        }
        destroy() {
            this.destroyed = true;
            this.oHash.destroy();
            this.iHash.destroy();
        }
    }
    /**
     * HMAC: RFC2104 message authentication code.
     * @param hash - function that would be used e.g. sha256
     * @param key - message key
     * @param message - message data
     */
    const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
    
    },{"./_assert.js":18,"./utils.js":26}],23:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = void 0;
    const _sha2_js_1 = require("./_sha2.js");
    const utils_js_1 = require("./utils.js");
    // Choice: a ? b : c
    const Chi = (a, b, c) => (a & b) ^ (~a & c);
    // Majority function, true if any two inpust is true
    const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
    // Round constants:
    // first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
    // prettier-ignore
    const SHA256_K = new Uint32Array([
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ]);
    // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
    // prettier-ignore
    const IV = new Uint32Array([
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    ]);
    // Temporary buffer, not used to store anything between runs
    // Named this way because it matches specification.
    const SHA256_W = new Uint32Array(64);
    class SHA256 extends _sha2_js_1.SHA2 {
        constructor() {
            super(64, 32, 8, false);
            // We cannot use array here since array allows indexing by variable
            // which means optimizer/compiler cannot use registers.
            this.A = IV[0] | 0;
            this.B = IV[1] | 0;
            this.C = IV[2] | 0;
            this.D = IV[3] | 0;
            this.E = IV[4] | 0;
            this.F = IV[5] | 0;
            this.G = IV[6] | 0;
            this.H = IV[7] | 0;
        }
        get() {
            const { A, B, C, D, E, F, G, H } = this;
            return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
            this.A = A | 0;
            this.B = B | 0;
            this.C = C | 0;
            this.D = D | 0;
            this.E = E | 0;
            this.F = F | 0;
            this.G = G | 0;
            this.H = H | 0;
        }
        process(view, offset) {
            // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
            for (let i = 0; i < 16; i++, offset += 4)
                SHA256_W[i] = view.getUint32(offset, false);
            for (let i = 16; i < 64; i++) {
                const W15 = SHA256_W[i - 15];
                const W2 = SHA256_W[i - 2];
                const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
                const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
                SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
            }
            // Compression function main loop, 64 rounds
            let { A, B, C, D, E, F, G, H } = this;
            for (let i = 0; i < 64; i++) {
                const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
                const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
                const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
                const T2 = (sigma0 + Maj(A, B, C)) | 0;
                H = G;
                G = F;
                F = E;
                E = (D + T1) | 0;
                D = C;
                C = B;
                B = A;
                A = (T1 + T2) | 0;
            }
            // Add the compressed chunk to the current hash value
            A = (A + this.A) | 0;
            B = (B + this.B) | 0;
            C = (C + this.C) | 0;
            D = (D + this.D) | 0;
            E = (E + this.E) | 0;
            F = (F + this.F) | 0;
            G = (G + this.G) | 0;
            H = (H + this.H) | 0;
            this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
            SHA256_W.fill(0);
        }
        destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0);
            this.buffer.fill(0);
        }
    }
    /**
     * SHA2-256 hash function
     * @param message - data that would be hashed
     */
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    
    },{"./_sha2.js":19,"./utils.js":26}],24:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    const _assert_js_1 = require("./_assert.js");
    const _u64_js_1 = require("./_u64.js");
    const utils_js_1 = require("./utils.js");
    // Various per round constants calculations
    const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    const _0n = BigInt(0);
    const _1n = BigInt(1);
    const _2n = BigInt(2);
    const _7n = BigInt(7);
    const _256n = BigInt(256);
    const _0x71n = BigInt(0x71);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
        // Pi
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI.push(2 * (5 * y + x));
        // Rotational
        SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
        // Iota
        let t = _0n;
        for (let j = 0; j < 7; j++) {
            R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
            if (R & _2n)
                t ^= _1n << ((_1n << BigInt(j)) - _1n);
        }
        _SHA3_IOTA.push(t);
    }
    const [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
    // Left rotation (without 0, 32, 64)
    const rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
    const rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
    // Same as keccakf1600, but allows to skip some rounds
    function keccakP(s, rounds = 24) {
        const B = new Uint32Array(5 * 2);
        // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
        for (let round = 24 - rounds; round < 24; round++) {
            // Theta 
            for (let x = 0; x < 10; x++)
                B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
            for (let x = 0; x < 10; x += 2) {
                const idx1 = (x + 8) % 10;
                const idx0 = (x + 2) % 10;
                const B0 = B[idx0];
                const B1 = B[idx0 + 1];
                const Th = rotlH(B0, B1, 1) ^ B[idx1];
                const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
                for (let y = 0; y < 50; y += 10) {
                    s[x + y] ^= Th;
                    s[x + y + 1] ^= Tl;
                }
            }
            // Rho () and Pi ()
            let curH = s[2];
            let curL = s[3];
            for (let t = 0; t < 24; t++) {
                const shift = SHA3_ROTL[t];
                const Th = rotlH(curH, curL, shift);
                const Tl = rotlL(curH, curL, shift);
                const PI = SHA3_PI[t];
                curH = s[PI];
                curL = s[PI + 1];
                s[PI] = Th;
                s[PI + 1] = Tl;
            }
            // Chi ()
            for (let y = 0; y < 50; y += 10) {
                for (let x = 0; x < 10; x++)
                    B[x] = s[y + x];
                for (let x = 0; x < 10; x++)
                    s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
            }
            // Iota ()
            s[0] ^= SHA3_IOTA_H[round];
            s[1] ^= SHA3_IOTA_L[round];
        }
        B.fill(0);
    }
    exports.keccakP = keccakP;
    class Keccak extends utils_js_1.Hash {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
            super();
            this.blockLen = blockLen;
            this.suffix = suffix;
            this.outputLen = outputLen;
            this.enableXOF = enableXOF;
            this.rounds = rounds;
            this.pos = 0;
            this.posOut = 0;
            this.finished = false;
            this.destroyed = false;
            // Can be passed from user as dkLen
            _assert_js_1.default.number(outputLen);
            // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
            if (0 >= this.blockLen || this.blockLen >= 200)
                throw new Error('Sha3 supports only keccak-f1600 function');
            this.state = new Uint8Array(200);
            this.state32 = (0, utils_js_1.u32)(this.state);
        }
        keccak() {
            keccakP(this.state32, this.rounds);
            this.posOut = 0;
            this.pos = 0;
        }
        update(data) {
            _assert_js_1.default.exists(this);
            const { blockLen, state } = this;
            data = (0, utils_js_1.toBytes)(data);
            const len = data.length;
            for (let pos = 0; pos < len;) {
                const take = Math.min(blockLen - this.pos, len - pos);
                for (let i = 0; i < take; i++)
                    state[this.pos++] ^= data[pos++];
                if (this.pos === blockLen)
                    this.keccak();
            }
            return this;
        }
        finish() {
            if (this.finished)
                return;
            this.finished = true;
            const { state, suffix, pos, blockLen } = this;
            // Do the padding
            state[pos] ^= suffix;
            if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
                this.keccak();
            state[blockLen - 1] ^= 0x80;
            this.keccak();
        }
        writeInto(out) {
            _assert_js_1.default.exists(this, false);
            _assert_js_1.default.bytes(out);
            this.finish();
            const bufferOut = this.state;
            const { blockLen } = this;
            for (let pos = 0, len = out.length; pos < len;) {
                if (this.posOut >= blockLen)
                    this.keccak();
                const take = Math.min(blockLen - this.posOut, len - pos);
                out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
                this.posOut += take;
                pos += take;
            }
            return out;
        }
        xofInto(out) {
            // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
            if (!this.enableXOF)
                throw new Error('XOF is not possible for this instance');
            return this.writeInto(out);
        }
        xof(bytes) {
            _assert_js_1.default.number(bytes);
            return this.xofInto(new Uint8Array(bytes));
        }
        digestInto(out) {
            _assert_js_1.default.output(out, this);
            if (this.finished)
                throw new Error('digest() was already called');
            this.writeInto(out);
            this.destroy();
            return out;
        }
        digest() {
            return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
            this.destroyed = true;
            this.state.fill(0);
        }
        _cloneInto(to) {
            const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
            to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
            to.state32.set(this.state32);
            to.pos = this.pos;
            to.posOut = this.posOut;
            to.finished = this.finished;
            to.rounds = rounds;
            // Suffix can change in cSHAKE
            to.suffix = suffix;
            to.outputLen = outputLen;
            to.enableXOF = enableXOF;
            to.destroyed = this.destroyed;
            return to;
        }
    }
    exports.Keccak = Keccak;
    const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(0x06, 144, 224 / 8);
    /**
     * SHA3-256 hash function
     * @param message - that would be hashed
     */
    exports.sha3_256 = gen(0x06, 136, 256 / 8);
    exports.sha3_384 = gen(0x06, 104, 384 / 8);
    exports.sha3_512 = gen(0x06, 72, 512 / 8);
    exports.keccak_224 = gen(0x01, 144, 224 / 8);
    /**
     * keccak-256 hash function. Different from SHA3-256.
     * @param message - that would be hashed
     */
    exports.keccak_256 = gen(0x01, 136, 256 / 8);
    exports.keccak_384 = gen(0x01, 104, 384 / 8);
    exports.keccak_512 = gen(0x01, 72, 512 / 8);
    const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(0x1f, 168, 128 / 8);
    exports.shake256 = genShake(0x1f, 136, 256 / 8);
    
    },{"./_assert.js":18,"./_u64.js":20,"./utils.js":26}],25:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha384 = exports.sha512_256 = exports.sha512 = exports.SHA512 = void 0;
    const _sha2_js_1 = require("./_sha2.js");
    const _u64_js_1 = require("./_u64.js");
    const utils_js_1 = require("./utils.js");
    // Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
    // prettier-ignore
    const [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split([
        '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
        '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
        '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
        '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
        '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
        '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
        '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
        '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
        '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
    ].map(n => BigInt(n)));
    // Temporary buffer, not used to store anything between runs
    const SHA512_W_H = new Uint32Array(80);
    const SHA512_W_L = new Uint32Array(80);
    class SHA512 extends _sha2_js_1.SHA2 {
        constructor() {
            super(128, 64, 16, false);
            // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
            // Also looks cleaner and easier to verify with spec.
            // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
            // h -- high 32 bits, l -- low 32 bits
            this.Ah = 0x6a09e667 | 0;
            this.Al = 0xf3bcc908 | 0;
            this.Bh = 0xbb67ae85 | 0;
            this.Bl = 0x84caa73b | 0;
            this.Ch = 0x3c6ef372 | 0;
            this.Cl = 0xfe94f82b | 0;
            this.Dh = 0xa54ff53a | 0;
            this.Dl = 0x5f1d36f1 | 0;
            this.Eh = 0x510e527f | 0;
            this.El = 0xade682d1 | 0;
            this.Fh = 0x9b05688c | 0;
            this.Fl = 0x2b3e6c1f | 0;
            this.Gh = 0x1f83d9ab | 0;
            this.Gl = 0xfb41bd6b | 0;
            this.Hh = 0x5be0cd19 | 0;
            this.Hl = 0x137e2179 | 0;
        }
        // prettier-ignore
        get() {
            const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
            return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
            this.Ah = Ah | 0;
            this.Al = Al | 0;
            this.Bh = Bh | 0;
            this.Bl = Bl | 0;
            this.Ch = Ch | 0;
            this.Cl = Cl | 0;
            this.Dh = Dh | 0;
            this.Dl = Dl | 0;
            this.Eh = Eh | 0;
            this.El = El | 0;
            this.Fh = Fh | 0;
            this.Fl = Fl | 0;
            this.Gh = Gh | 0;
            this.Gl = Gl | 0;
            this.Hh = Hh | 0;
            this.Hl = Hl | 0;
        }
        process(view, offset) {
            // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
            for (let i = 0; i < 16; i++, offset += 4) {
                SHA512_W_H[i] = view.getUint32(offset);
                SHA512_W_L[i] = view.getUint32((offset += 4));
            }
            for (let i = 16; i < 80; i++) {
                // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
                const W15h = SHA512_W_H[i - 15] | 0;
                const W15l = SHA512_W_L[i - 15] | 0;
                const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
                const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
                // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
                const W2h = SHA512_W_H[i - 2] | 0;
                const W2l = SHA512_W_L[i - 2] | 0;
                const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
                const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
                // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
                const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
                const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
                SHA512_W_H[i] = SUMh | 0;
                SHA512_W_L[i] = SUMl | 0;
            }
            let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
            // Compression function main loop, 80 rounds
            for (let i = 0; i < 80; i++) {
                // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
                const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
                const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
                //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
                const CHIh = (Eh & Fh) ^ (~Eh & Gh);
                const CHIl = (El & Fl) ^ (~El & Gl);
                // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
                // prettier-ignore
                const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
                const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
                const T1l = T1ll | 0;
                // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
                const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
                const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
                const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
                const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
                Hh = Gh | 0;
                Hl = Gl | 0;
                Gh = Fh | 0;
                Gl = Fl | 0;
                Fh = Eh | 0;
                Fl = El | 0;
                ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
                Dh = Ch | 0;
                Dl = Cl | 0;
                Ch = Bh | 0;
                Cl = Bl | 0;
                Bh = Ah | 0;
                Bl = Al | 0;
                const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
                Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
                Al = All | 0;
            }
            // Add the compressed chunk to the current hash value
            ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
            ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
            ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
            ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
            ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
            ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
            ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
            ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
            this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
            SHA512_W_H.fill(0);
            SHA512_W_L.fill(0);
        }
        destroy() {
            this.buffer.fill(0);
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
    }
    exports.SHA512 = SHA512;
    class SHA512_256 extends SHA512 {
        constructor() {
            super();
            // h -- high 32 bits, l -- low 32 bits
            this.Ah = 0x22312194 | 0;
            this.Al = 0xfc2bf72c | 0;
            this.Bh = 0x9f555fa3 | 0;
            this.Bl = 0xc84c64c2 | 0;
            this.Ch = 0x2393b86b | 0;
            this.Cl = 0x6f53b151 | 0;
            this.Dh = 0x96387719 | 0;
            this.Dl = 0x5940eabd | 0;
            this.Eh = 0x96283ee2 | 0;
            this.El = 0xa88effe3 | 0;
            this.Fh = 0xbe5e1e25 | 0;
            this.Fl = 0x53863992 | 0;
            this.Gh = 0x2b0199fc | 0;
            this.Gl = 0x2c85b8aa | 0;
            this.Hh = 0x0eb72ddc | 0;
            this.Hl = 0x81c52ca2 | 0;
            this.outputLen = 32;
        }
    }
    class SHA384 extends SHA512 {
        constructor() {
            super();
            // h -- high 32 bits, l -- low 32 bits
            this.Ah = 0xcbbb9d5d | 0;
            this.Al = 0xc1059ed8 | 0;
            this.Bh = 0x629a292a | 0;
            this.Bl = 0x367cd507 | 0;
            this.Ch = 0x9159015a | 0;
            this.Cl = 0x3070dd17 | 0;
            this.Dh = 0x152fecd8 | 0;
            this.Dl = 0xf70e5939 | 0;
            this.Eh = 0x67332667 | 0;
            this.El = 0xffc00b31 | 0;
            this.Fh = 0x8eb44a87 | 0;
            this.Fl = 0x68581511 | 0;
            this.Gh = 0xdb0c2e0d | 0;
            this.Gl = 0x64f98fa7 | 0;
            this.Hh = 0x47b5481d | 0;
            this.Hl = 0xbefa4fa4 | 0;
            this.outputLen = 48;
        }
    }
    exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
    exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
    exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
    
    },{"./_sha2.js":19,"./_u64.js":20,"./utils.js":26}],26:[function(require,module,exports){
    "use strict";
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    // The import here is via the package name. This is to ensure
    // that exports mapping/resolution does fall into place.
    const crypto_1 = require("@noble/hashes/crypto");
    // Cast array to different type
    const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    // Cast array to view
    const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    // The rotate right (circular right shift) operation for uint32
    const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
    // There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
    // So, just to be sure not to corrupt anything.
    if (!exports.isLE)
        throw new Error('Non little-endian hardware is not supported');
    const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
    /**
     * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))
     */
    function bytesToHex(uint8a) {
        // pre-caching improves the speed 6x
        if (!(uint8a instanceof Uint8Array))
            throw new Error('Uint8Array expected');
        let hex = '';
        for (let i = 0; i < uint8a.length; i++) {
            hex += hexes[uint8a[i]];
        }
        return hex;
    }
    exports.bytesToHex = bytesToHex;
    /**
     * @example hexToBytes('deadbeef')
     */
    function hexToBytes(hex) {
        if (typeof hex !== 'string') {
            throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
        }
        if (hex.length % 2)
            throw new Error('hexToBytes: received invalid unpadded hex');
        const array = new Uint8Array(hex.length / 2);
        for (let i = 0; i < array.length; i++) {
            const j = i * 2;
            const hexByte = hex.slice(j, j + 2);
            const byte = Number.parseInt(hexByte, 16);
            if (Number.isNaN(byte) || byte < 0)
                throw new Error('Invalid byte sequence');
            array[i] = byte;
        }
        return array;
    }
    exports.hexToBytes = hexToBytes;
    // There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise
    // which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.
    const nextTick = async () => { };
    exports.nextTick = nextTick;
    // Returns control to thread each 'tick' ms to avoid blocking
    async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
            cb(i);
            // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
            const diff = Date.now() - ts;
            if (diff >= 0 && diff < tick)
                continue;
            await (0, exports.nextTick)();
            ts += diff;
        }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
        if (typeof str !== 'string') {
            throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
        }
        return new TextEncoder().encode(str);
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
        if (typeof data === 'string')
            data = utf8ToBytes(data);
        if (!(data instanceof Uint8Array))
            throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
        return data;
    }
    exports.toBytes = toBytes;
    /**
     * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
     * @example concatBytes(buf1, buf2)
     */
    function concatBytes(...arrays) {
        if (!arrays.every((a) => a instanceof Uint8Array))
            throw new Error('Uint8Array list expected');
        if (arrays.length === 1)
            return arrays[0];
        const length = arrays.reduce((a, arr) => a + arr.length, 0);
        const result = new Uint8Array(length);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
            const arr = arrays[i];
            result.set(arr, pad);
            pad += arr.length;
        }
        return result;
    }
    exports.concatBytes = concatBytes;
    // For runtime check if class implements interface
    class Hash {
        // Safe version that clones internal state
        clone() {
            return this._cloneInto();
        }
    }
    exports.Hash = Hash;
    // Check if object doens't have custom constructor (like Uint8Array/Array)
    const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
    function checkOpts(defaults, opts) {
        if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
            throw new TypeError('Options should be object or undefined');
        const merged = Object.assign(defaults, opts);
        return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashConstructor) {
        const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
        const tmp = hashConstructor();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashConstructor();
        return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    /**
     * Secure PRNG
     */
    function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto.web) {
            return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
        }
        else if (crypto_1.crypto.node) {
            return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
        }
        else {
            throw new Error("The environment doesn't have randomBytes function");
        }
    }
    exports.randomBytes = randomBytes;
    
    },{"@noble/hashes/crypto":21}],27:[function(require,module,exports){
    "use strict";
    /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;
    const nodeCrypto = require("crypto");
    const _0n = BigInt(0);
    const _1n = BigInt(1);
    const _2n = BigInt(2);
    const _3n = BigInt(3);
    const _8n = BigInt(8);
    const CURVE = Object.freeze({
        a: _0n,
        b: BigInt(7),
        P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
        n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
        h: _1n,
        Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
        Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
    });
    exports.CURVE = CURVE;
    function weistrass(x) {
        const { a, b } = CURVE;
        const x2 = mod(x * x);
        const x3 = mod(x2 * x);
        return mod(x3 + a * x + b);
    }
    const USE_ENDOMORPHISM = CURVE.a === _0n;
    class ShaError extends Error {
        constructor(message) {
            super(message);
        }
    }
    class JacobianPoint {
        constructor(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        static fromAffine(p) {
            if (!(p instanceof Point)) {
                throw new TypeError('JacobianPoint#fromAffine: expected Point');
            }
            return new JacobianPoint(p.x, p.y, _1n);
        }
        static toAffineBatch(points) {
            const toInv = invertBatch(points.map((p) => p.z));
            return points.map((p, i) => p.toAffine(toInv[i]));
        }
        static normalizeZ(points) {
            return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
        }
        equals(other) {
            if (!(other instanceof JacobianPoint))
                throw new TypeError('JacobianPoint expected');
            const { x: X1, y: Y1, z: Z1 } = this;
            const { x: X2, y: Y2, z: Z2 } = other;
            const Z1Z1 = mod(Z1 * Z1);
            const Z2Z2 = mod(Z2 * Z2);
            const U1 = mod(X1 * Z2Z2);
            const U2 = mod(X2 * Z1Z1);
            const S1 = mod(mod(Y1 * Z2) * Z2Z2);
            const S2 = mod(mod(Y2 * Z1) * Z1Z1);
            return U1 === U2 && S1 === S2;
        }
        negate() {
            return new JacobianPoint(this.x, mod(-this.y), this.z);
        }
        double() {
            const { x: X1, y: Y1, z: Z1 } = this;
            const A = mod(X1 * X1);
            const B = mod(Y1 * Y1);
            const C = mod(B * B);
            const x1b = X1 + B;
            const D = mod(_2n * (mod(x1b * x1b) - A - C));
            const E = mod(_3n * A);
            const F = mod(E * E);
            const X3 = mod(F - _2n * D);
            const Y3 = mod(E * (D - X3) - _8n * C);
            const Z3 = mod(_2n * Y1 * Z1);
            return new JacobianPoint(X3, Y3, Z3);
        }
        add(other) {
            if (!(other instanceof JacobianPoint))
                throw new TypeError('JacobianPoint expected');
            const { x: X1, y: Y1, z: Z1 } = this;
            const { x: X2, y: Y2, z: Z2 } = other;
            if (X2 === _0n || Y2 === _0n)
                return this;
            if (X1 === _0n || Y1 === _0n)
                return other;
            const Z1Z1 = mod(Z1 * Z1);
            const Z2Z2 = mod(Z2 * Z2);
            const U1 = mod(X1 * Z2Z2);
            const U2 = mod(X2 * Z1Z1);
            const S1 = mod(mod(Y1 * Z2) * Z2Z2);
            const S2 = mod(mod(Y2 * Z1) * Z1Z1);
            const H = mod(U2 - U1);
            const r = mod(S2 - S1);
            if (H === _0n) {
                if (r === _0n) {
                    return this.double();
                }
                else {
                    return JacobianPoint.ZERO;
                }
            }
            const HH = mod(H * H);
            const HHH = mod(H * HH);
            const V = mod(U1 * HH);
            const X3 = mod(r * r - HHH - _2n * V);
            const Y3 = mod(r * (V - X3) - S1 * HHH);
            const Z3 = mod(Z1 * Z2 * H);
            return new JacobianPoint(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        multiplyUnsafe(scalar) {
            const P0 = JacobianPoint.ZERO;
            if (typeof scalar === 'bigint' && scalar === _0n)
                return P0;
            let n = normalizeScalar(scalar);
            if (n === _1n)
                return this;
            if (!USE_ENDOMORPHISM) {
                let p = P0;
                let d = this;
                while (n > _0n) {
                    if (n & _1n)
                        p = p.add(d);
                    d = d.double();
                    n >>= _1n;
                }
                return p;
            }
            let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
            let k1p = P0;
            let k2p = P0;
            let d = this;
            while (k1 > _0n || k2 > _0n) {
                if (k1 & _1n)
                    k1p = k1p.add(d);
                if (k2 & _1n)
                    k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg)
                k1p = k1p.negate();
            if (k2neg)
                k2p = k2p.negate();
            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
            return k1p.add(k2p);
        }
        precomputeWindow(W) {
            const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
            const points = [];
            let p = this;
            let base = p;
            for (let window = 0; window < windows; window++) {
                base = p;
                points.push(base);
                for (let i = 1; i < 2 ** (W - 1); i++) {
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        }
        wNAF(n, affinePoint) {
            if (!affinePoint && this.equals(JacobianPoint.BASE))
                affinePoint = Point.BASE;
            const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;
            if (256 % W) {
                throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
            }
            let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
            if (!precomputes) {
                precomputes = this.precomputeWindow(W);
                if (affinePoint && W !== 1) {
                    precomputes = JacobianPoint.normalizeZ(precomputes);
                    pointPrecomputes.set(affinePoint, precomputes);
                }
            }
            let p = JacobianPoint.ZERO;
            let f = JacobianPoint.ZERO;
            const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
            const windowSize = 2 ** (W - 1);
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window = 0; window < windows; window++) {
                const offset = window * windowSize;
                let wbits = Number(n & mask);
                n >>= shiftBy;
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                if (wbits === 0) {
                    let pr = precomputes[offset];
                    if (window % 2)
                        pr = pr.negate();
                    f = f.add(pr);
                }
                else {
                    let cached = precomputes[offset + Math.abs(wbits) - 1];
                    if (wbits < 0)
                        cached = cached.negate();
                    p = p.add(cached);
                }
            }
            return { p, f };
        }
        multiply(scalar, affinePoint) {
            let n = normalizeScalar(scalar);
            let point;
            let fake;
            if (USE_ENDOMORPHISM) {
                const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
                let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
                let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
                if (k1neg)
                    k1p = k1p.negate();
                if (k2neg)
                    k2p = k2p.negate();
                k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            }
            else {
                const { p, f } = this.wNAF(n, affinePoint);
                point = p;
                fake = f;
            }
            return JacobianPoint.normalizeZ([point, fake])[0];
        }
        toAffine(invZ = invert(this.z)) {
            const { x, y, z } = this;
            const iz1 = invZ;
            const iz2 = mod(iz1 * iz1);
            const iz3 = mod(iz2 * iz1);
            const ax = mod(x * iz2);
            const ay = mod(y * iz3);
            const zz = mod(z * iz1);
            if (zz !== _1n)
                throw new Error('invZ was invalid');
            return new Point(ax, ay);
        }
    }
    JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
    JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
    const pointPrecomputes = new WeakMap();
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        }
        hasEvenY() {
            return this.y % _2n === _0n;
        }
        static fromCompressedHex(bytes) {
            const isShort = bytes.length === 32;
            const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
            if (!isValidFieldElement(x))
                throw new Error('Point is not on curve');
            const y2 = weistrass(x);
            let y = sqrtMod(y2);
            const isYOdd = (y & _1n) === _1n;
            if (isShort) {
                if (isYOdd)
                    y = mod(-y);
            }
            else {
                const isFirstByteOdd = (bytes[0] & 1) === 1;
                if (isFirstByteOdd !== isYOdd)
                    y = mod(-y);
            }
            const point = new Point(x, y);
            point.assertValidity();
            return point;
        }
        static fromUncompressedHex(bytes) {
            const x = bytesToNumber(bytes.subarray(1, 33));
            const y = bytesToNumber(bytes.subarray(33, 65));
            const point = new Point(x, y);
            point.assertValidity();
            return point;
        }
        static fromHex(hex) {
            const bytes = ensureBytes(hex);
            const len = bytes.length;
            const header = bytes[0];
            if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {
                return this.fromCompressedHex(bytes);
            }
            if (len === 65 && header === 0x04)
                return this.fromUncompressedHex(bytes);
            throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);
        }
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normalizePrivateKey(privateKey));
        }
        static fromSignature(msgHash, signature, recovery) {
            msgHash = ensureBytes(msgHash);
            const h = truncateHash(msgHash);
            const { r, s } = normalizeSignature(signature);
            if (recovery !== 0 && recovery !== 1) {
                throw new Error('Cannot recover signature: invalid recovery bit');
            }
            const prefix = recovery & 1 ? '03' : '02';
            const R = Point.fromHex(prefix + numTo32bStr(r));
            const { n } = CURVE;
            const rinv = invert(r, n);
            const u1 = mod(-h * rinv, n);
            const u2 = mod(s * rinv, n);
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
            if (!Q)
                throw new Error('Cannot recover signature: point at infinify');
            Q.assertValidity();
            return Q;
        }
        toRawBytes(isCompressed = false) {
            return hexToBytes(this.toHex(isCompressed));
        }
        toHex(isCompressed = false) {
            const x = numTo32bStr(this.x);
            if (isCompressed) {
                const prefix = this.hasEvenY() ? '02' : '03';
                return `${prefix}${x}`;
            }
            else {
                return `04${x}${numTo32bStr(this.y)}`;
            }
        }
        toHexX() {
            return this.toHex(true).slice(2);
        }
        toRawX() {
            return this.toRawBytes(true).slice(1);
        }
        assertValidity() {
            const msg = 'Point is not on elliptic curve';
            const { x, y } = this;
            if (!isValidFieldElement(x) || !isValidFieldElement(y))
                throw new Error(msg);
            const left = mod(y * y);
            const right = weistrass(x);
            if (mod(left - right) !== _0n)
                throw new Error(msg);
        }
        equals(other) {
            return this.x === other.x && this.y === other.y;
        }
        negate() {
            return new Point(this.x, mod(-this.y));
        }
        double() {
            return JacobianPoint.fromAffine(this).double().toAffine();
        }
        add(other) {
            return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
        }
        subtract(other) {
            return this.add(other.negate());
        }
        multiply(scalar) {
            return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
        }
        multiplyAndAddUnsafe(Q, a, b) {
            const P = JacobianPoint.fromAffine(this);
            const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
            const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
            const sum = aP.add(bQ);
            return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
        }
    }
    exports.Point = Point;
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
    Point.ZERO = new Point(_0n, _0n);
    function sliceDER(s) {
        return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;
    }
    function parseDERInt(data) {
        if (data.length < 2 || data[0] !== 0x02) {
            throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
        }
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len) {
            throw new Error(`Invalid signature integer: wrong length`);
        }
        if (res[0] === 0x00 && res[1] <= 0x7f) {
            throw new Error('Invalid signature integer: trailing length');
        }
        return { data: bytesToNumber(res), left: data.subarray(len + 2) };
    }
    function parseDERSignature(data) {
        if (data.length < 2 || data[0] != 0x30) {
            throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
        }
        if (data[1] !== data.length - 2) {
            throw new Error('Invalid signature: incorrect length');
        }
        const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
        const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
        if (rBytesLeft.length) {
            throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
        }
        return { r, s };
    }
    class Signature {
        constructor(r, s) {
            this.r = r;
            this.s = s;
            this.assertValidity();
        }
        static fromCompact(hex) {
            const arr = hex instanceof Uint8Array;
            const name = 'Signature.fromCompact';
            if (typeof hex !== 'string' && !arr)
                throw new TypeError(`${name}: Expected string or Uint8Array`);
            const str = arr ? bytesToHex(hex) : hex;
            if (str.length !== 128)
                throw new Error(`${name}: Expected 64-byte hex`);
            return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
        }
        static fromDER(hex) {
            const arr = hex instanceof Uint8Array;
            if (typeof hex !== 'string' && !arr)
                throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
            const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
            return new Signature(r, s);
        }
        static fromHex(hex) {
            return this.fromDER(hex);
        }
        assertValidity() {
            const { r, s } = this;
            if (!isWithinCurveOrder(r))
                throw new Error('Invalid Signature: r must be 0 < r < n');
            if (!isWithinCurveOrder(s))
                throw new Error('Invalid Signature: s must be 0 < s < n');
        }
        hasHighS() {
            const HALF = CURVE.n >> _1n;
            return this.s > HALF;
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;
        }
        toDERRawBytes(isCompressed = false) {
            return hexToBytes(this.toDERHex(isCompressed));
        }
        toDERHex(isCompressed = false) {
            const sHex = sliceDER(numberToHexUnpadded(this.s));
            if (isCompressed)
                return sHex;
            const rHex = sliceDER(numberToHexUnpadded(this.r));
            const rLen = numberToHexUnpadded(rHex.length / 2);
            const sLen = numberToHexUnpadded(sHex.length / 2);
            const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);
            return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
        }
        toRawBytes() {
            return this.toDERRawBytes();
        }
        toHex() {
            return this.toDERHex();
        }
        toCompactRawBytes() {
            return hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
            return numTo32bStr(this.r) + numTo32bStr(this.s);
        }
    }
    exports.Signature = Signature;
    function concatBytes(...arrays) {
        if (!arrays.every((b) => b instanceof Uint8Array))
            throw new Error('Uint8Array list expected');
        if (arrays.length === 1)
            return arrays[0];
        const length = arrays.reduce((a, arr) => a + arr.length, 0);
        const result = new Uint8Array(length);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
            const arr = arrays[i];
            result.set(arr, pad);
            pad += arr.length;
        }
        return result;
    }
    const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
    function bytesToHex(uint8a) {
        if (!(uint8a instanceof Uint8Array))
            throw new Error('Expected Uint8Array');
        let hex = '';
        for (let i = 0; i < uint8a.length; i++) {
            hex += hexes[uint8a[i]];
        }
        return hex;
    }
    const POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
    function numTo32bStr(num) {
        if (typeof num !== 'bigint')
            throw new Error('Expected bigint');
        if (!(_0n <= num && num < POW_2_256))
            throw new Error('Expected number < 2^256');
        return num.toString(16).padStart(64, '0');
    }
    function numTo32b(num) {
        const b = hexToBytes(numTo32bStr(num));
        if (b.length !== 32)
            throw new Error('Error: expected 32 bytes');
        return b;
    }
    function numberToHexUnpadded(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
        if (typeof hex !== 'string') {
            throw new TypeError('hexToNumber: expected string, got ' + typeof hex);
        }
        return BigInt(`0x${hex}`);
    }
    function hexToBytes(hex) {
        if (typeof hex !== 'string') {
            throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
        }
        if (hex.length % 2)
            throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);
        const array = new Uint8Array(hex.length / 2);
        for (let i = 0; i < array.length; i++) {
            const j = i * 2;
            const hexByte = hex.slice(j, j + 2);
            const byte = Number.parseInt(hexByte, 16);
            if (Number.isNaN(byte) || byte < 0)
                throw new Error('Invalid byte sequence');
            array[i] = byte;
        }
        return array;
    }
    function bytesToNumber(bytes) {
        return hexToNumber(bytesToHex(bytes));
    }
    function ensureBytes(hex) {
        return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
    }
    function normalizeScalar(num) {
        if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)
            return BigInt(num);
        if (typeof num === 'bigint' && isWithinCurveOrder(num))
            return num;
        throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');
    }
    function mod(a, b = CURVE.P) {
        const result = a % b;
        return result >= _0n ? result : b + result;
    }
    function pow2(x, power) {
        const { P } = CURVE;
        let res = x;
        while (power-- > _0n) {
            res *= res;
            res %= P;
        }
        return res;
    }
    function sqrtMod(x) {
        const { P } = CURVE;
        const _6n = BigInt(6);
        const _11n = BigInt(11);
        const _22n = BigInt(22);
        const _23n = BigInt(23);
        const _44n = BigInt(44);
        const _88n = BigInt(88);
        const b2 = (x * x * x) % P;
        const b3 = (b2 * b2 * x) % P;
        const b6 = (pow2(b3, _3n) * b3) % P;
        const b9 = (pow2(b6, _3n) * b3) % P;
        const b11 = (pow2(b9, _2n) * b2) % P;
        const b22 = (pow2(b11, _11n) * b11) % P;
        const b44 = (pow2(b22, _22n) * b22) % P;
        const b88 = (pow2(b44, _44n) * b44) % P;
        const b176 = (pow2(b88, _88n) * b88) % P;
        const b220 = (pow2(b176, _44n) * b44) % P;
        const b223 = (pow2(b220, _3n) * b3) % P;
        const t1 = (pow2(b223, _23n) * b22) % P;
        const t2 = (pow2(t1, _6n) * b2) % P;
        return pow2(t2, _2n);
    }
    function invert(number, modulo = CURVE.P) {
        if (number === _0n || modulo <= _0n) {
            throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod(number, modulo);
        let b = modulo;
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
            const q = b / a;
            const r = b % a;
            const m = x - u * q;
            const n = y - v * q;
            b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
            throw new Error('invert: does not exist');
        return mod(x, modulo);
    }
    function invertBatch(nums, p = CURVE.P) {
        const scratch = new Array(nums.length);
        const lastMultiplied = nums.reduce((acc, num, i) => {
            if (num === _0n)
                return acc;
            scratch[i] = acc;
            return mod(acc * num, p);
        }, _1n);
        const inverted = invert(lastMultiplied, p);
        nums.reduceRight((acc, num, i) => {
            if (num === _0n)
                return acc;
            scratch[i] = mod(acc * scratch[i], p);
            return mod(acc * num, p);
        }, inverted);
        return scratch;
    }
    const divNearest = (a, b) => (a + b / _2n) / b;
    const ENDO = {
        a1: BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
        b1: -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3'),
        a2: BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'),
        b2: BigInt('0x3086d221a7d46bcde86c90e49284eb15'),
        POW_2_128: BigInt('0x100000000000000000000000000000000'),
    };
    function splitScalarEndo(k) {
        const { n } = CURVE;
        const { a1, b1, a2, b2, POW_2_128 } = ENDO;
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod(k - c1 * a1 - c2 * a2, n);
        let k2 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
            k1 = n - k1;
        if (k2neg)
            k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);
        }
        return { k1neg, k1, k2neg, k2 };
    }
    function truncateHash(hash) {
        const { n } = CURVE;
        const byteLength = hash.length;
        const delta = byteLength * 8 - 256;
        let h = bytesToNumber(hash);
        if (delta > 0)
            h = h >> BigInt(delta);
        if (h >= n)
            h -= n;
        return h;
    }
    let _sha256Sync;
    let _hmacSha256Sync;
    class HmacDrbg {
        constructor() {
            this.v = new Uint8Array(32).fill(1);
            this.k = new Uint8Array(32).fill(0);
            this.counter = 0;
        }
        hmac(...values) {
            return exports.utils.hmacSha256(this.k, ...values);
        }
        hmacSync(...values) {
            return _hmacSha256Sync(this.k, ...values);
        }
        checkSync() {
            if (typeof _hmacSha256Sync !== 'function')
                throw new ShaError('hmacSha256Sync needs to be set');
        }
        incr() {
            if (this.counter >= 1000)
                throw new Error('Tried 1,000 k values for sign(), all were invalid');
            this.counter += 1;
        }
        async reseed(seed = new Uint8Array()) {
            this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);
            this.v = await this.hmac(this.v);
            if (seed.length === 0)
                return;
            this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);
            this.v = await this.hmac(this.v);
        }
        reseedSync(seed = new Uint8Array()) {
            this.checkSync();
            this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);
            this.v = this.hmacSync(this.v);
            if (seed.length === 0)
                return;
            this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);
            this.v = this.hmacSync(this.v);
        }
        async generate() {
            this.incr();
            this.v = await this.hmac(this.v);
            return this.v;
        }
        generateSync() {
            this.checkSync();
            this.incr();
            this.v = this.hmacSync(this.v);
            return this.v;
        }
    }
    function isWithinCurveOrder(num) {
        return _0n < num && num < CURVE.n;
    }
    function isValidFieldElement(num) {
        return _0n < num && num < CURVE.P;
    }
    function kmdToSig(kBytes, m, d) {
        const k = bytesToNumber(kBytes);
        if (!isWithinCurveOrder(k))
            return;
        const { n } = CURVE;
        const q = Point.BASE.multiply(k);
        const r = mod(q.x, n);
        if (r === _0n)
            return;
        const s = mod(invert(k, n) * mod(m + d * r, n), n);
        if (s === _0n)
            return;
        const sig = new Signature(r, s);
        const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
        return { sig, recovery };
    }
    function normalizePrivateKey(key) {
        let num;
        if (typeof key === 'bigint') {
            num = key;
        }
        else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {
            num = BigInt(key);
        }
        else if (typeof key === 'string') {
            if (key.length !== 64)
                throw new Error('Expected 32 bytes of private key');
            num = hexToNumber(key);
        }
        else if (key instanceof Uint8Array) {
            if (key.length !== 32)
                throw new Error('Expected 32 bytes of private key');
            num = bytesToNumber(key);
        }
        else {
            throw new TypeError('Expected valid private key');
        }
        if (!isWithinCurveOrder(num))
            throw new Error('Expected private key: 0 < key < n');
        return num;
    }
    function normalizePublicKey(publicKey) {
        if (publicKey instanceof Point) {
            publicKey.assertValidity();
            return publicKey;
        }
        else {
            return Point.fromHex(publicKey);
        }
    }
    function normalizeSignature(signature) {
        if (signature instanceof Signature) {
            signature.assertValidity();
            return signature;
        }
        try {
            return Signature.fromDER(signature);
        }
        catch (error) {
            return Signature.fromCompact(signature);
        }
    }
    function getPublicKey(privateKey, isCompressed = false) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    exports.getPublicKey = getPublicKey;
    function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
        return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
    }
    exports.recoverPublicKey = recoverPublicKey;
    function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === 'string';
        const len = (arr || str) && item.length;
        if (arr)
            return len === 33 || len === 65;
        if (str)
            return len === 66 || len === 130;
        if (item instanceof Point)
            return true;
        return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = false) {
        if (isProbPub(privateA))
            throw new TypeError('getSharedSecret: first arg must be private key');
        if (!isProbPub(publicB))
            throw new TypeError('getSharedSecret: second arg must be public key');
        const b = normalizePublicKey(publicB);
        b.assertValidity();
        return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
    }
    exports.getSharedSecret = getSharedSecret;
    function bits2int(bytes) {
        const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;
        return bytesToNumber(slice);
    }
    function bits2octets(bytes) {
        const z1 = bits2int(bytes);
        const z2 = mod(z1, CURVE.n);
        return int2octets(z2 < _0n ? z1 : z2);
    }
    function int2octets(num) {
        return numTo32b(num);
    }
    function initSigArgs(msgHash, privateKey, extraEntropy) {
        if (msgHash == null)
            throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
        const h1 = ensureBytes(msgHash);
        const d = normalizePrivateKey(privateKey);
        const seedArgs = [int2octets(d), bits2octets(h1)];
        if (extraEntropy != null) {
            if (extraEntropy === true)
                extraEntropy = exports.utils.randomBytes(32);
            const e = ensureBytes(extraEntropy);
            if (e.length !== 32)
                throw new Error('sign: Expected 32 bytes of extra data');
            seedArgs.push(e);
        }
        const seed = concatBytes(...seedArgs);
        const m = bits2int(h1);
        return { seed, m, d };
    }
    function finalizeSig(recSig, opts) {
        let { sig, recovery } = recSig;
        const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);
        if (canonical && sig.hasHighS()) {
            sig = sig.normalizeS();
            recovery ^= 1;
        }
        const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
        return recovered ? [hashed, recovery] : hashed;
    }
    async function sign(msgHash, privKey, opts = {}) {
        const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
        let sig;
        const drbg = new HmacDrbg();
        await drbg.reseed(seed);
        while (!(sig = kmdToSig(await drbg.generate(), m, d)))
            await drbg.reseed();
        return finalizeSig(sig, opts);
    }
    exports.sign = sign;
    function signSync(msgHash, privKey, opts = {}) {
        const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
        let sig;
        const drbg = new HmacDrbg();
        drbg.reseedSync(seed);
        while (!(sig = kmdToSig(drbg.generateSync(), m, d)))
            drbg.reseedSync();
        return finalizeSig(sig, opts);
    }
    exports.signSync = signSync;
    const vopts = { strict: true };
    function verify(signature, msgHash, publicKey, opts = vopts) {
        let sig;
        try {
            sig = normalizeSignature(signature);
            msgHash = ensureBytes(msgHash);
        }
        catch (error) {
            return false;
        }
        const { r, s } = sig;
        if (opts.strict && sig.hasHighS())
            return false;
        const h = truncateHash(msgHash);
        let P;
        try {
            P = normalizePublicKey(publicKey);
        }
        catch (error) {
            return false;
        }
        const { n } = CURVE;
        const sinv = invert(s, n);
        const u1 = mod(h * sinv, n);
        const u2 = mod(r * sinv, n);
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
        if (!R)
            return false;
        const v = mod(R.x, n);
        return v === r;
    }
    exports.verify = verify;
    function schnorrChallengeFinalize(ch) {
        return mod(bytesToNumber(ch), CURVE.n);
    }
    class SchnorrSignature {
        constructor(r, s) {
            this.r = r;
            this.s = s;
            this.assertValidity();
        }
        static fromHex(hex) {
            const bytes = ensureBytes(hex);
            if (bytes.length !== 64)
                throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);
            const r = bytesToNumber(bytes.subarray(0, 32));
            const s = bytesToNumber(bytes.subarray(32, 64));
            return new SchnorrSignature(r, s);
        }
        assertValidity() {
            const { r, s } = this;
            if (!isValidFieldElement(r) || !isWithinCurveOrder(s))
                throw new Error('Invalid signature');
        }
        toHex() {
            return numTo32bStr(this.r) + numTo32bStr(this.s);
        }
        toRawBytes() {
            return hexToBytes(this.toHex());
        }
    }
    function schnorrGetPublicKey(privateKey) {
        return Point.fromPrivateKey(privateKey).toRawX();
    }
    class InternalSchnorrSignature {
        constructor(message, privateKey, auxRand = exports.utils.randomBytes()) {
            if (message == null)
                throw new TypeError(`sign: Expected valid message, not "${message}"`);
            this.m = ensureBytes(message);
            const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));
            this.px = x;
            this.d = scalar;
            this.rand = ensureBytes(auxRand);
            if (this.rand.length !== 32)
                throw new TypeError('sign: Expected 32 bytes of aux randomness');
        }
        getScalar(priv) {
            const point = Point.fromPrivateKey(priv);
            const scalar = point.hasEvenY() ? priv : CURVE.n - priv;
            return { point, scalar, x: point.toRawX() };
        }
        initNonce(d, t0h) {
            return numTo32b(d ^ bytesToNumber(t0h));
        }
        finalizeNonce(k0h) {
            const k0 = mod(bytesToNumber(k0h), CURVE.n);
            if (k0 === _0n)
                throw new Error('sign: Creation of signature failed. k is zero');
            const { point: R, x: rx, scalar: k } = this.getScalar(k0);
            return { R, rx, k };
        }
        finalizeSig(R, k, e, d) {
            return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();
        }
        error() {
            throw new Error('sign: Invalid signature produced');
        }
        async calc() {
            const { m, d, px, rand } = this;
            const tag = exports.utils.taggedHash;
            const t = this.initNonce(d, await tag(TAGS.aux, rand));
            const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));
            const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));
            const sig = this.finalizeSig(R, k, e, d);
            if (!(await schnorrVerify(sig, m, px)))
                this.error();
            return sig;
        }
        calcSync() {
            const { m, d, px, rand } = this;
            const tag = exports.utils.taggedHashSync;
            const t = this.initNonce(d, tag(TAGS.aux, rand));
            const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));
            const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));
            const sig = this.finalizeSig(R, k, e, d);
            if (!schnorrVerifySync(sig, m, px))
                this.error();
            return sig;
        }
    }
    async function schnorrSign(msg, privKey, auxRand) {
        return new InternalSchnorrSignature(msg, privKey, auxRand).calc();
    }
    function schnorrSignSync(msg, privKey, auxRand) {
        return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();
    }
    function initSchnorrVerify(signature, message, publicKey) {
        const raw = signature instanceof SchnorrSignature;
        const sig = raw ? signature : SchnorrSignature.fromHex(signature);
        if (raw)
            sig.assertValidity();
        return {
            ...sig,
            m: ensureBytes(message),
            P: normalizePublicKey(publicKey),
        };
    }
    function finalizeSchnorrVerify(r, P, s, e) {
        const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));
        if (!R || !R.hasEvenY() || R.x !== r)
            return false;
        return true;
    }
    async function schnorrVerify(signature, message, publicKey) {
        try {
            const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
            const e = schnorrChallengeFinalize(await exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));
            return finalizeSchnorrVerify(r, P, s, e);
        }
        catch (error) {
            return false;
        }
    }
    function schnorrVerifySync(signature, message, publicKey) {
        try {
            const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
            const e = schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));
            return finalizeSchnorrVerify(r, P, s, e);
        }
        catch (error) {
            if (error instanceof ShaError)
                throw error;
            return false;
        }
    }
    exports.schnorr = {
        Signature: SchnorrSignature,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        signSync: schnorrSignSync,
        verifySync: schnorrVerifySync,
    };
    Point.BASE._setWindowSize(8);
    const crypto = {
        node: nodeCrypto,
        web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
    };
    const TAGS = {
        challenge: 'BIP0340/challenge',
        aux: 'BIP0340/aux',
        nonce: 'BIP0340/nonce',
    };
    const TAGGED_HASH_PREFIXES = {};
    exports.utils = {
        bytesToHex,
        hexToBytes,
        concatBytes,
        mod,
        invert,
        isValidPrivateKey(privateKey) {
            try {
                normalizePrivateKey(privateKey);
                return true;
            }
            catch (error) {
                return false;
            }
        },
        _bigintTo32Bytes: numTo32b,
        _normalizePrivateKey: normalizePrivateKey,
        hashToPrivateKey: (hash) => {
            hash = ensureBytes(hash);
            if (hash.length < 40 || hash.length > 1024)
                throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');
            const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
            return numTo32b(num);
        },
        randomBytes: (bytesLength = 32) => {
            if (crypto.web) {
                return crypto.web.getRandomValues(new Uint8Array(bytesLength));
            }
            else if (crypto.node) {
                const { randomBytes } = crypto.node;
                return Uint8Array.from(randomBytes(bytesLength));
            }
            else {
                throw new Error("The environment doesn't have randomBytes function");
            }
        },
        randomPrivateKey: () => {
            return exports.utils.hashToPrivateKey(exports.utils.randomBytes(40));
        },
        sha256: async (...messages) => {
            if (crypto.web) {
                const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));
                return new Uint8Array(buffer);
            }
            else if (crypto.node) {
                const { createHash } = crypto.node;
                const hash = createHash('sha256');
                messages.forEach((m) => hash.update(m));
                return Uint8Array.from(hash.digest());
            }
            else {
                throw new Error("The environment doesn't have sha256 function");
            }
        },
        hmacSha256: async (key, ...messages) => {
            if (crypto.web) {
                const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);
                const message = concatBytes(...messages);
                const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);
                return new Uint8Array(buffer);
            }
            else if (crypto.node) {
                const { createHmac } = crypto.node;
                const hash = createHmac('sha256', key);
                messages.forEach((m) => hash.update(m));
                return Uint8Array.from(hash.digest());
            }
            else {
                throw new Error("The environment doesn't have hmac-sha256 function");
            }
        },
        sha256Sync: undefined,
        hmacSha256Sync: undefined,
        taggedHash: async (tag, ...messages) => {
            let tagP = TAGGED_HASH_PREFIXES[tag];
            if (tagP === undefined) {
                const tagH = await exports.utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
                tagP = concatBytes(tagH, tagH);
                TAGGED_HASH_PREFIXES[tag] = tagP;
            }
            return exports.utils.sha256(tagP, ...messages);
        },
        taggedHashSync: (tag, ...messages) => {
            if (typeof _sha256Sync !== 'function')
                throw new ShaError('sha256Sync is undefined, you need to set it');
            let tagP = TAGGED_HASH_PREFIXES[tag];
            if (tagP === undefined) {
                const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
                tagP = concatBytes(tagH, tagH);
                TAGGED_HASH_PREFIXES[tag] = tagP;
            }
            return _sha256Sync(tagP, ...messages);
        },
        precompute(windowSize = 8, point = Point.BASE) {
            const cached = point === Point.BASE ? point : new Point(point.x, point.y);
            cached._setWindowSize(windowSize);
            cached.multiply(_3n);
            return cached;
        },
    };
    Object.defineProperties(exports.utils, {
        sha256Sync: {
            configurable: false,
            get() {
                return _sha256Sync;
            },
            set(val) {
                if (!_sha256Sync)
                    _sha256Sync = val;
            },
        },
        hmacSha256Sync: {
            configurable: false,
            get() {
                return _hmacSha256Sync;
            },
            set(val) {
                if (!_hmacSha256Sync)
                    _hmacSha256Sync = val;
            },
        },
    });
    
    },{"crypto":2}],28:[function(require,module,exports){
    /* The MIT License (MIT)
     *
     * Copyright 2015-2018 Peter A. Bigot
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * Support for translating between Uint8Array instances and JavaScript
     * native types.
     *
     * {@link module:Layout~Layout|Layout} is the basis of a class
     * hierarchy that associates property names with sequences of encoded
     * bytes.
     *
     * Layouts are supported for these scalar (numeric) types:
     * * {@link module:Layout~UInt|Unsigned integers in little-endian
     *   format} with {@link module:Layout.u8|8-bit}, {@link
     *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
     *   {@link module:Layout.u32|32-bit}, {@link
     *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
     *   representation ranges;
     * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
     *   format} with {@link module:Layout.u16be|16-bit}, {@link
     *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
     *   {@link module:Layout.u40be|40-bit}, and {@link
     *   module:Layout.u48be|48-bit} representation ranges;
     * * {@link module:Layout~Int|Signed integers in little-endian
     *   format} with {@link module:Layout.s8|8-bit}, {@link
     *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
     *   {@link module:Layout.s32|32-bit}, {@link
     *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
     *   representation ranges;
     * * {@link module:Layout~IntBE|Signed integers in big-endian format}
     *   with {@link module:Layout.s16be|16-bit}, {@link
     *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
     *   {@link module:Layout.s40be|40-bit}, and {@link
     *   module:Layout.s48be|48-bit} representation ranges;
     * * 64-bit integral values that decode to an exact (if magnitude is
     *   less than 2^53) or nearby integral Number in {@link
     *   module:Layout.nu64|unsigned little-endian}, {@link
     *   module:Layout.nu64be|unsigned big-endian}, {@link
     *   module:Layout.ns64|signed little-endian}, and {@link
     *   module:Layout.ns64be|unsigned big-endian} encodings;
     * * 32-bit floating point values with {@link
     *   module:Layout.f32|little-endian} and {@link
     *   module:Layout.f32be|big-endian} representations;
     * * 64-bit floating point values with {@link
     *   module:Layout.f64|little-endian} and {@link
     *   module:Layout.f64be|big-endian} representations;
     * * {@link module:Layout.const|Constants} that take no space in the
     *   encoded expression.
     *
     * and for these aggregate types:
     * * {@link module:Layout.seq|Sequence}s of instances of a {@link
     *   module:Layout~Layout|Layout}, with JavaScript representation as
     *   an Array and constant or data-dependent {@link
     *   module:Layout~Sequence#count|length};
     * * {@link module:Layout.struct|Structure}s that aggregate a
     *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
     *   instances, with JavaScript representation as an Object;
     * * {@link module:Layout.union|Union}s that support multiple {@link
     *   module:Layout~VariantLayout|variant layouts} over a fixed
     *   (padded) or variable (not padded) span of bytes, using an
     *   unsigned integer at the start of the data or a separate {@link
     *   module:Layout.unionLayoutDiscriminator|layout element} to
     *   determine which layout to use when interpreting the buffer
     *   contents;
     * * {@link module:Layout.bits|BitStructure}s that contain a sequence
     *   of individual {@link
     *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
     *   16, 24, or 32-bit unsigned integer starting at the least- or
     *   most-significant bit;
     * * {@link module:Layout.cstr|C strings} of varying length;
     * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
     *   module:Layout~Blob#length|length} raw data.
     *
     * All {@link module:Layout~Layout|Layout} instances are immutable
     * after construction, to prevent internal state from becoming
     * inconsistent.
     *
     * @local Layout
     * @local ExternalLayout
     * @local GreedyCount
     * @local OffsetLayout
     * @local UInt
     * @local UIntBE
     * @local Int
     * @local IntBE
     * @local NearUInt64
     * @local NearUInt64BE
     * @local NearInt64
     * @local NearInt64BE
     * @local Float
     * @local FloatBE
     * @local Double
     * @local DoubleBE
     * @local Sequence
     * @local Structure
     * @local UnionDiscriminator
     * @local UnionLayoutDiscriminator
     * @local Union
     * @local VariantLayout
     * @local BitStructure
     * @local BitField
     * @local Boolean
     * @local Blob
     * @local CString
     * @local Constant
     * @local bindConstructorLayout
     * @module Layout
     * @license MIT
     * @author Peter A. Bigot
     * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
     */
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;
    exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;
    const buffer_1 = require("buffer");
    /* Check if a value is a Uint8Array.
     *
     * @ignore */
    function checkUint8Array(b) {
        if (!(b instanceof Uint8Array)) {
            throw new TypeError('b must be a Uint8Array');
        }
    }
    exports.checkUint8Array = checkUint8Array;
    /* Create a Buffer instance from a Uint8Array.
     *
     * @ignore */
    function uint8ArrayToBuffer(b) {
        checkUint8Array(b);
        return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
    }
    exports.uint8ArrayToBuffer = uint8ArrayToBuffer;
    /**
     * Base class for layout objects.
     *
     * **NOTE** This is an abstract base class; you can create instances
     * if it amuses you, but they won't support the {@link
     * Layout#encode|encode} or {@link Layout#decode|decode} functions.
     *
     * @param {Number} span - Initializer for {@link Layout#span|span}.  The
     * parameter must be an integer; a negative value signifies that the
     * span is {@link Layout#getSpan|value-specific}.
     *
     * @param {string} [property] - Initializer for {@link
     * Layout#property|property}.
     *
     * @abstract
     */
    class Layout {
        constructor(span, property) {
            if (!Number.isInteger(span)) {
                throw new TypeError('span must be an integer');
            }
            /** The span of the layout in bytes.
             *
             * Positive values are generally expected.
             *
             * Zero will only appear in {@link Constant}s and in {@link
             * Sequence}s where the {@link Sequence#count|count} is zero.
             *
             * A negative value indicates that the span is value-specific, and
             * must be obtained using {@link Layout#getSpan|getSpan}. */
            this.span = span;
            /** The property name used when this layout is represented in an
             * Object.
             *
             * Used only for layouts that {@link Layout#decode|decode} to Object
             * instances.  If left undefined the span of the unnamed layout will
             * be treated as padding: it will not be mutated by {@link
             * Layout#encode|encode} nor represented as a property in the
             * decoded Object. */
            this.property = property;
        }
        /** Function to create an Object into which decoded properties will
         * be written.
         *
         * Used only for layouts that {@link Layout#decode|decode} to Object
         * instances, which means:
         * * {@link Structure}
         * * {@link Union}
         * * {@link VariantLayout}
         * * {@link BitStructure}
         *
         * If left undefined the JavaScript representation of these layouts
         * will be Object instances.
         *
         * See {@link bindConstructorLayout}.
         */
        makeDestinationObject() {
            return {};
        }
        /**
         * Calculate the span of a specific instance of a layout.
         *
         * @param {Uint8Array} b - the buffer that contains an encoded instance.
         *
         * @param {Number} [offset] - the offset at which the encoded instance
         * starts.  If absent a zero offset is inferred.
         *
         * @return {Number} - the number of bytes covered by the layout
         * instance.  If this method is not overridden in a subclass the
         * definition-time constant {@link Layout#span|span} will be
         * returned.
         *
         * @throws {RangeError} - if the length of the value cannot be
         * determined.
         */
        getSpan(b, offset) {
            if (0 > this.span) {
                throw new RangeError('indeterminate span');
            }
            return this.span;
        }
        /**
         * Replicate the layout using a new property.
         *
         * This function must be used to get a structurally-equivalent layout
         * with a different name since all {@link Layout} instances are
         * immutable.
         *
         * **NOTE** This is a shallow copy.  All fields except {@link
         * Layout#property|property} are strictly equal to the origin layout.
         *
         * @param {String} property - the value for {@link
         * Layout#property|property} in the replica.
         *
         * @returns {Layout} - the copy with {@link Layout#property|property}
         * set to `property`.
         */
        replicate(property) {
            const rv = Object.create(this.constructor.prototype);
            Object.assign(rv, this);
            rv.property = property;
            return rv;
        }
        /**
         * Create an object from layout properties and an array of values.
         *
         * **NOTE** This function returns `undefined` if invoked on a layout
         * that does not return its value as an Object.  Objects are
         * returned for things that are a {@link Structure}, which includes
         * {@link VariantLayout|variant layouts} if they are structures, and
         * excludes {@link Union}s.  If you want this feature for a union
         * you must use {@link Union.getVariant|getVariant} to select the
         * desired layout.
         *
         * @param {Array} values - an array of values that correspond to the
         * default order for properties.  As with {@link Layout#decode|decode}
         * layout elements that have no property name are skipped when
         * iterating over the array values.  Only the top-level properties are
         * assigned; arguments are not assigned to properties of contained
         * layouts.  Any unused values are ignored.
         *
         * @return {(Object|undefined)}
         */
        fromArray(values) {
            return undefined;
        }
    }
    exports.Layout = Layout;
    /* Provide text that carries a name (such as for a function that will
     * be throwing an error) annotated with the property of a given layout
     * (such as one for which the value was unacceptable).
     *
     * @ignore */
    function nameWithProperty(name, lo) {
        if (lo.property) {
            return name + '[' + lo.property + ']';
        }
        return name;
    }
    exports.nameWithProperty = nameWithProperty;
    /**
     * Augment a class so that instances can be encoded/decoded using a
     * given layout.
     *
     * Calling this function couples `Class` with `layout` in several ways:
     *
     * * `Class.layout_` becomes a static member property equal to `layout`;
     * * `layout.boundConstructor_` becomes a static member property equal
     *    to `Class`;
     * * The {@link Layout#makeDestinationObject|makeDestinationObject()}
     *   property of `layout` is set to a function that returns a `new
     *   Class()`;
     * * `Class.decode(b, offset)` becomes a static member function that
     *   delegates to {@link Layout#decode|layout.decode}.  The
     *   synthesized function may be captured and extended.
     * * `Class.prototype.encode(b, offset)` provides an instance member
     *   function that delegates to {@link Layout#encode|layout.encode}
     *   with `src` set to `this`.  The synthesized function may be
     *   captured and extended, but when the extension is invoked `this`
     *   must be explicitly bound to the instance.
     *
     * @param {class} Class - a JavaScript class with a nullary
     * constructor.
     *
     * @param {Layout} layout - the {@link Layout} instance used to encode
     * instances of `Class`.
     */
    // `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function bindConstructorLayout(Class, layout) {
        if ('function' !== typeof Class) {
            throw new TypeError('Class must be constructor');
        }
        if (Object.prototype.hasOwnProperty.call(Class, 'layout_')) {
            throw new Error('Class is already bound to a layout');
        }
        if (!(layout && (layout instanceof Layout))) {
            throw new TypeError('layout must be a Layout');
        }
        if (Object.prototype.hasOwnProperty.call(layout, 'boundConstructor_')) {
            throw new Error('layout is already bound to a constructor');
        }
        Class.layout_ = layout;
        layout.boundConstructor_ = Class;
        layout.makeDestinationObject = (() => new Class());
        Object.defineProperty(Class.prototype, 'encode', {
            value(b, offset) {
                return layout.encode(this, b, offset);
            },
            writable: true,
        });
        Object.defineProperty(Class, 'decode', {
            value(b, offset) {
                return layout.decode(b, offset);
            },
            writable: true,
        });
    }
    exports.bindConstructorLayout = bindConstructorLayout;
    /**
     * An object that behaves like a layout but does not consume space
     * within its containing layout.
     *
     * This is primarily used to obtain metadata about a member, such as a
     * {@link OffsetLayout} that can provide data about a {@link
     * Layout#getSpan|value-specific span}.
     *
     * **NOTE** This is an abstract base class; you can create instances
     * if it amuses you, but they won't support {@link
     * ExternalLayout#isCount|isCount} or other {@link Layout} functions.
     *
     * @param {Number} span - initializer for {@link Layout#span|span}.
     * The parameter can range from 1 through 6.
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @abstract
     * @augments {Layout}
     */
    class ExternalLayout extends Layout {
        /**
         * Return `true` iff the external layout decodes to an unsigned
         * integer layout.
         *
         * In that case it can be used as the source of {@link
         * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
         * or as {@link UnionLayoutDiscriminator#layout|external union
         * discriminators}.
         *
         * @abstract
         */
        isCount() {
            throw new Error('ExternalLayout is abstract');
        }
    }
    exports.ExternalLayout = ExternalLayout;
    /**
     * An {@link ExternalLayout} that determines its {@link
     * Layout#decode|value} based on offset into and length of the buffer
     * on which it is invoked.
     *
     * *Factory*: {@link module:Layout.greedy|greedy}
     *
     * @param {Number} [elementSpan] - initializer for {@link
     * GreedyCount#elementSpan|elementSpan}.
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {ExternalLayout}
     */
    class GreedyCount extends ExternalLayout {
        constructor(elementSpan = 1, property) {
            if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {
                throw new TypeError('elementSpan must be a (positive) integer');
            }
            super(-1, property);
            /** The layout for individual elements of the sequence.  The value
             * must be a positive integer.  If not provided, the value will be
             * 1. */
            this.elementSpan = elementSpan;
        }
        /** @override */
        isCount() {
            return true;
        }
        /** @override */
        decode(b, offset = 0) {
            checkUint8Array(b);
            const rem = b.length - offset;
            return Math.floor(rem / this.elementSpan);
        }
        /** @override */
        encode(src, b, offset) {
            return 0;
        }
    }
    exports.GreedyCount = GreedyCount;
    /**
     * An {@link ExternalLayout} that supports accessing a {@link Layout}
     * at a fixed offset from the start of another Layout.  The offset may
     * be before, within, or after the base layout.
     *
     * *Factory*: {@link module:Layout.offset|offset}
     *
     * @param {Layout} layout - initializer for {@link
     * OffsetLayout#layout|layout}, modulo `property`.
     *
     * @param {Number} [offset] - Initializes {@link
     * OffsetLayout#offset|offset}.  Defaults to zero.
     *
     * @param {string} [property] - Optional new property name for a
     * {@link Layout#replicate| replica} of `layout` to be used as {@link
     * OffsetLayout#layout|layout}.  If not provided the `layout` is used
     * unchanged.
     *
     * @augments {Layout}
     */
    class OffsetLayout extends ExternalLayout {
        constructor(layout, offset = 0, property) {
            if (!(layout instanceof Layout)) {
                throw new TypeError('layout must be a Layout');
            }
            if (!Number.isInteger(offset)) {
                throw new TypeError('offset must be integer or undefined');
            }
            super(layout.span, property || layout.property);
            /** The subordinated layout. */
            this.layout = layout;
            /** The location of {@link OffsetLayout#layout} relative to the
             * start of another layout.
             *
             * The value may be positive or negative, but an error will thrown
             * if at the point of use it goes outside the span of the Uint8Array
             * being accessed.  */
            this.offset = offset;
        }
        /** @override */
        isCount() {
            return ((this.layout instanceof UInt)
                || (this.layout instanceof UIntBE));
        }
        /** @override */
        decode(b, offset = 0) {
            return this.layout.decode(b, offset + this.offset);
        }
        /** @override */
        encode(src, b, offset = 0) {
            return this.layout.encode(src, b, offset + this.offset);
        }
    }
    exports.OffsetLayout = OffsetLayout;
    /**
     * Represent an unsigned integer in little-endian format.
     *
     * *Factory*: {@link module:Layout.u8|u8}, {@link
     *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link
     *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link
     *  module:Layout.u48|u48}
     *
     * @param {Number} span - initializer for {@link Layout#span|span}.
     * The parameter can range from 1 through 6.
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class UInt extends Layout {
        constructor(span, property) {
            super(span, property);
            if (6 < this.span) {
                throw new RangeError('span must not exceed 6 bytes');
            }
        }
        /** @override */
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);
        }
        /** @override */
        encode(src, b, offset = 0) {
            uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);
            return this.span;
        }
    }
    exports.UInt = UInt;
    /**
     * Represent an unsigned integer in big-endian format.
     *
     * *Factory*: {@link module:Layout.u8be|u8be}, {@link
     * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},
     * {@link module:Layout.u32be|u32be}, {@link
     * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}
     *
     * @param {Number} span - initializer for {@link Layout#span|span}.
     * The parameter can range from 1 through 6.
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class UIntBE extends Layout {
        constructor(span, property) {
            super(span, property);
            if (6 < this.span) {
                throw new RangeError('span must not exceed 6 bytes');
            }
        }
        /** @override */
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);
        }
        /** @override */
        encode(src, b, offset = 0) {
            uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);
            return this.span;
        }
    }
    exports.UIntBE = UIntBE;
    /**
     * Represent a signed integer in little-endian format.
     *
     * *Factory*: {@link module:Layout.s8|s8}, {@link
     *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link
     *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link
     *  module:Layout.s48|s48}
     *
     * @param {Number} span - initializer for {@link Layout#span|span}.
     * The parameter can range from 1 through 6.
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class Int extends Layout {
        constructor(span, property) {
            super(span, property);
            if (6 < this.span) {
                throw new RangeError('span must not exceed 6 bytes');
            }
        }
        /** @override */
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readIntLE(offset, this.span);
        }
        /** @override */
        encode(src, b, offset = 0) {
            uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);
            return this.span;
        }
    }
    exports.Int = Int;
    /**
     * Represent a signed integer in big-endian format.
     *
     * *Factory*: {@link module:Layout.s8be|s8be}, {@link
     * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},
     * {@link module:Layout.s32be|s32be}, {@link
     * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}
     *
     * @param {Number} span - initializer for {@link Layout#span|span}.
     * The parameter can range from 1 through 6.
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class IntBE extends Layout {
        constructor(span, property) {
            super(span, property);
            if (6 < this.span) {
                throw new RangeError('span must not exceed 6 bytes');
            }
        }
        /** @override */
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readIntBE(offset, this.span);
        }
        /** @override */
        encode(src, b, offset = 0) {
            uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);
            return this.span;
        }
    }
    exports.IntBE = IntBE;
    const V2E32 = Math.pow(2, 32);
    /* True modulus high and low 32-bit words, where low word is always
     * non-negative. */
    function divmodInt64(src) {
        const hi32 = Math.floor(src / V2E32);
        const lo32 = src - (hi32 * V2E32);
        return { hi32, lo32 };
    }
    /* Reconstruct Number from quotient and non-negative remainder */
    function roundedInt64(hi32, lo32) {
        return hi32 * V2E32 + lo32;
    }
    /**
     * Represent an unsigned 64-bit integer in little-endian format when
     * encoded and as a near integral JavaScript Number when decoded.
     *
     * *Factory*: {@link module:Layout.nu64|nu64}
     *
     * **NOTE** Values with magnitude greater than 2^52 may not decode to
     * the exact value of the encoded representation.
     *
     * @augments {Layout}
     */
    class NearUInt64 extends Layout {
        constructor(property) {
            super(8, property);
        }
        /** @override */
        decode(b, offset = 0) {
            const buffer = uint8ArrayToBuffer(b);
            const lo32 = buffer.readUInt32LE(offset);
            const hi32 = buffer.readUInt32LE(offset + 4);
            return roundedInt64(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset = 0) {
            const split = divmodInt64(src);
            const buffer = uint8ArrayToBuffer(b);
            buffer.writeUInt32LE(split.lo32, offset);
            buffer.writeUInt32LE(split.hi32, offset + 4);
            return 8;
        }
    }
    exports.NearUInt64 = NearUInt64;
    /**
     * Represent an unsigned 64-bit integer in big-endian format when
     * encoded and as a near integral JavaScript Number when decoded.
     *
     * *Factory*: {@link module:Layout.nu64be|nu64be}
     *
     * **NOTE** Values with magnitude greater than 2^52 may not decode to
     * the exact value of the encoded representation.
     *
     * @augments {Layout}
     */
    class NearUInt64BE extends Layout {
        constructor(property) {
            super(8, property);
        }
        /** @override */
        decode(b, offset = 0) {
            const buffer = uint8ArrayToBuffer(b);
            const hi32 = buffer.readUInt32BE(offset);
            const lo32 = buffer.readUInt32BE(offset + 4);
            return roundedInt64(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset = 0) {
            const split = divmodInt64(src);
            const buffer = uint8ArrayToBuffer(b);
            buffer.writeUInt32BE(split.hi32, offset);
            buffer.writeUInt32BE(split.lo32, offset + 4);
            return 8;
        }
    }
    exports.NearUInt64BE = NearUInt64BE;
    /**
     * Represent a signed 64-bit integer in little-endian format when
     * encoded and as a near integral JavaScript Number when decoded.
     *
     * *Factory*: {@link module:Layout.ns64|ns64}
     *
     * **NOTE** Values with magnitude greater than 2^52 may not decode to
     * the exact value of the encoded representation.
     *
     * @augments {Layout}
     */
    class NearInt64 extends Layout {
        constructor(property) {
            super(8, property);
        }
        /** @override */
        decode(b, offset = 0) {
            const buffer = uint8ArrayToBuffer(b);
            const lo32 = buffer.readUInt32LE(offset);
            const hi32 = buffer.readInt32LE(offset + 4);
            return roundedInt64(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset = 0) {
            const split = divmodInt64(src);
            const buffer = uint8ArrayToBuffer(b);
            buffer.writeUInt32LE(split.lo32, offset);
            buffer.writeInt32LE(split.hi32, offset + 4);
            return 8;
        }
    }
    exports.NearInt64 = NearInt64;
    /**
     * Represent a signed 64-bit integer in big-endian format when
     * encoded and as a near integral JavaScript Number when decoded.
     *
     * *Factory*: {@link module:Layout.ns64be|ns64be}
     *
     * **NOTE** Values with magnitude greater than 2^52 may not decode to
     * the exact value of the encoded representation.
     *
     * @augments {Layout}
     */
    class NearInt64BE extends Layout {
        constructor(property) {
            super(8, property);
        }
        /** @override */
        decode(b, offset = 0) {
            const buffer = uint8ArrayToBuffer(b);
            const hi32 = buffer.readInt32BE(offset);
            const lo32 = buffer.readUInt32BE(offset + 4);
            return roundedInt64(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset = 0) {
            const split = divmodInt64(src);
            const buffer = uint8ArrayToBuffer(b);
            buffer.writeInt32BE(split.hi32, offset);
            buffer.writeUInt32BE(split.lo32, offset + 4);
            return 8;
        }
    }
    exports.NearInt64BE = NearInt64BE;
    /**
     * Represent a 32-bit floating point number in little-endian format.
     *
     * *Factory*: {@link module:Layout.f32|f32}
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class Float extends Layout {
        constructor(property) {
            super(4, property);
        }
        /** @override */
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readFloatLE(offset);
        }
        /** @override */
        encode(src, b, offset = 0) {
            uint8ArrayToBuffer(b).writeFloatLE(src, offset);
            return 4;
        }
    }
    exports.Float = Float;
    /**
     * Represent a 32-bit floating point number in big-endian format.
     *
     * *Factory*: {@link module:Layout.f32be|f32be}
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class FloatBE extends Layout {
        constructor(property) {
            super(4, property);
        }
        /** @override */
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readFloatBE(offset);
        }
        /** @override */
        encode(src, b, offset = 0) {
            uint8ArrayToBuffer(b).writeFloatBE(src, offset);
            return 4;
        }
    }
    exports.FloatBE = FloatBE;
    /**
     * Represent a 64-bit floating point number in little-endian format.
     *
     * *Factory*: {@link module:Layout.f64|f64}
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class Double extends Layout {
        constructor(property) {
            super(8, property);
        }
        /** @override */
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readDoubleLE(offset);
        }
        /** @override */
        encode(src, b, offset = 0) {
            uint8ArrayToBuffer(b).writeDoubleLE(src, offset);
            return 8;
        }
    }
    exports.Double = Double;
    /**
     * Represent a 64-bit floating point number in big-endian format.
     *
     * *Factory*: {@link module:Layout.f64be|f64be}
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class DoubleBE extends Layout {
        constructor(property) {
            super(8, property);
        }
        /** @override */
        decode(b, offset = 0) {
            return uint8ArrayToBuffer(b).readDoubleBE(offset);
        }
        /** @override */
        encode(src, b, offset = 0) {
            uint8ArrayToBuffer(b).writeDoubleBE(src, offset);
            return 8;
        }
    }
    exports.DoubleBE = DoubleBE;
    /**
     * Represent a contiguous sequence of a specific layout as an Array.
     *
     * *Factory*: {@link module:Layout.seq|seq}
     *
     * @param {Layout} elementLayout - initializer for {@link
     * Sequence#elementLayout|elementLayout}.
     *
     * @param {(Number|ExternalLayout)} count - initializer for {@link
     * Sequence#count|count}.  The parameter must be either a positive
     * integer or an instance of {@link ExternalLayout}.
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class Sequence extends Layout {
        constructor(elementLayout, count, property) {
            if (!(elementLayout instanceof Layout)) {
                throw new TypeError('elementLayout must be a Layout');
            }
            if (!(((count instanceof ExternalLayout) && count.isCount())
                || (Number.isInteger(count) && (0 <= count)))) {
                throw new TypeError('count must be non-negative integer '
                    + 'or an unsigned integer ExternalLayout');
            }
            let span = -1;
            if ((!(count instanceof ExternalLayout))
                && (0 < elementLayout.span)) {
                span = count * elementLayout.span;
            }
            super(span, property);
            /** The layout for individual elements of the sequence. */
            this.elementLayout = elementLayout;
            /** The number of elements in the sequence.
             *
             * This will be either a non-negative integer or an instance of
             * {@link ExternalLayout} for which {@link
             * ExternalLayout#isCount|isCount()} is `true`. */
            this.count = count;
        }
        /** @override */
        getSpan(b, offset = 0) {
            if (0 <= this.span) {
                return this.span;
            }
            let span = 0;
            let count = this.count;
            if (count instanceof ExternalLayout) {
                count = count.decode(b, offset);
            }
            if (0 < this.elementLayout.span) {
                span = count * this.elementLayout.span;
            }
            else {
                let idx = 0;
                while (idx < count) {
                    span += this.elementLayout.getSpan(b, offset + span);
                    ++idx;
                }
            }
            return span;
        }
        /** @override */
        decode(b, offset = 0) {
            const rv = [];
            let i = 0;
            let count = this.count;
            if (count instanceof ExternalLayout) {
                count = count.decode(b, offset);
            }
            while (i < count) {
                rv.push(this.elementLayout.decode(b, offset));
                offset += this.elementLayout.getSpan(b, offset);
                i += 1;
            }
            return rv;
        }
        /** Implement {@link Layout#encode|encode} for {@link Sequence}.
         *
         * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
         * the unused space in the buffer is left unchanged.  If `src` is
         * longer than {@link Sequence#count|count} the unneeded elements are
         * ignored.
         *
         * **NOTE** If {@link Layout#count|count} is an instance of {@link
         * ExternalLayout} then the length of `src` will be encoded as the
         * count after `src` is encoded. */
        encode(src, b, offset = 0) {
            const elo = this.elementLayout;
            const span = src.reduce((span, v) => {
                return span + elo.encode(v, b, offset + span);
            }, 0);
            if (this.count instanceof ExternalLayout) {
                this.count.encode(src.length, b, offset);
            }
            return span;
        }
    }
    exports.Sequence = Sequence;
    /**
     * Represent a contiguous sequence of arbitrary layout elements as an
     * Object.
     *
     * *Factory*: {@link module:Layout.struct|struct}
     *
     * **NOTE** The {@link Layout#span|span} of the structure is variable
     * if any layout in {@link Structure#fields|fields} has a variable
     * span.  When {@link Layout#encode|encoding} we must have a value for
     * all variable-length fields, or we wouldn't be able to figure out
     * how much space to use for storage.  We can only identify the value
     * for a field when it has a {@link Layout#property|property}.  As
     * such, although a structure may contain both unnamed fields and
     * variable-length fields, it cannot contain an unnamed
     * variable-length field.
     *
     * @param {Layout[]} fields - initializer for {@link
     * Structure#fields|fields}.  An error is raised if this contains a
     * variable-length field for which a {@link Layout#property|property}
     * is not defined.
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @param {Boolean} [decodePrefixes] - initializer for {@link
     * Structure#decodePrefixes|property}.
     *
     * @throws {Error} - if `fields` contains an unnamed variable-length
     * layout.
     *
     * @augments {Layout}
     */
    class Structure extends Layout {
        constructor(fields, property, decodePrefixes) {
            if (!(Array.isArray(fields)
                && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {
                throw new TypeError('fields must be array of Layout instances');
            }
            if (('boolean' === typeof property)
                && (undefined === decodePrefixes)) {
                decodePrefixes = property;
                property = undefined;
            }
            /* Verify absence of unnamed variable-length fields. */
            for (const fd of fields) {
                if ((0 > fd.span)
                    && (undefined === fd.property)) {
                    throw new Error('fields cannot contain unnamed variable-length layout');
                }
            }
            let span = -1;
            try {
                span = fields.reduce((span, fd) => span + fd.getSpan(), 0);
            }
            catch (e) {
                // ignore error
            }
            super(span, property);
            /** The sequence of {@link Layout} values that comprise the
             * structure.
             *
             * The individual elements need not be the same type, and may be
             * either scalar or aggregate layouts.  If a member layout leaves
             * its {@link Layout#property|property} undefined the
             * corresponding region of the buffer associated with the element
             * will not be mutated.
             *
             * @type {Layout[]} */
            this.fields = fields;
            /** Control behavior of {@link Layout#decode|decode()} given short
             * buffers.
             *
             * In some situations a structure many be extended with additional
             * fields over time, with older installations providing only a
             * prefix of the full structure.  If this property is `true`
             * decoding will accept those buffers and leave subsequent fields
             * undefined, as long as the buffer ends at a field boundary.
             * Defaults to `false`. */
            this.decodePrefixes = !!decodePrefixes;
        }
        /** @override */
        getSpan(b, offset = 0) {
            if (0 <= this.span) {
                return this.span;
            }
            let span = 0;
            try {
                span = this.fields.reduce((span, fd) => {
                    const fsp = fd.getSpan(b, offset);
                    offset += fsp;
                    return span + fsp;
                }, 0);
            }
            catch (e) {
                throw new RangeError('indeterminate span');
            }
            return span;
        }
        /** @override */
        decode(b, offset = 0) {
            checkUint8Array(b);
            const dest = this.makeDestinationObject();
            for (const fd of this.fields) {
                if (undefined !== fd.property) {
                    dest[fd.property] = fd.decode(b, offset);
                }
                offset += fd.getSpan(b, offset);
                if (this.decodePrefixes
                    && (b.length === offset)) {
                    break;
                }
            }
            return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link Structure}.
         *
         * If `src` is missing a property for a member with a defined {@link
         * Layout#property|property} the corresponding region of the buffer is
         * left unmodified. */
        encode(src, b, offset = 0) {
            const firstOffset = offset;
            let lastOffset = 0;
            let lastWrote = 0;
            for (const fd of this.fields) {
                let span = fd.span;
                lastWrote = (0 < span) ? span : 0;
                if (undefined !== fd.property) {
                    const fv = src[fd.property];
                    if (undefined !== fv) {
                        lastWrote = fd.encode(fv, b, offset);
                        if (0 > span) {
                            /* Read the as-encoded span, which is not necessarily the
                             * same as what we wrote. */
                            span = fd.getSpan(b, offset);
                        }
                    }
                }
                lastOffset = offset;
                offset += span;
            }
            /* Use (lastOffset + lastWrote) instead of offset because the last
             * item may have had a dynamic length and we don't want to include
             * the padding between it and the end of the space reserved for
             * it. */
            return (lastOffset + lastWrote) - firstOffset;
        }
        /** @override */
        fromArray(values) {
            const dest = this.makeDestinationObject();
            for (const fd of this.fields) {
                if ((undefined !== fd.property)
                    && (0 < values.length)) {
                    dest[fd.property] = values.shift();
                }
            }
            return dest;
        }
        /**
         * Get access to the layout of a given property.
         *
         * @param {String} property - the structure member of interest.
         *
         * @return {Layout} - the layout associated with `property`, or
         * undefined if there is no such property.
         */
        layoutFor(property) {
            if ('string' !== typeof property) {
                throw new TypeError('property must be string');
            }
            for (const fd of this.fields) {
                if (fd.property === property) {
                    return fd;
                }
            }
            return undefined;
        }
        /**
         * Get the offset of a structure member.
         *
         * @param {String} property - the structure member of interest.
         *
         * @return {Number} - the offset in bytes to the start of `property`
         * within the structure, or undefined if `property` is not a field
         * within the structure.  If the property is a member but follows a
         * variable-length structure member a negative number will be
         * returned.
         */
        offsetOf(property) {
            if ('string' !== typeof property) {
                throw new TypeError('property must be string');
            }
            let offset = 0;
            for (const fd of this.fields) {
                if (fd.property === property) {
                    return offset;
                }
                if (0 > fd.span) {
                    offset = -1;
                }
                else if (0 <= offset) {
                    offset += fd.span;
                }
            }
            return undefined;
        }
    }
    exports.Structure = Structure;
    /**
     * An object that can provide a {@link
     * Union#discriminator|discriminator} API for {@link Union}.
     *
     * **NOTE** This is an abstract base class; you can create instances
     * if it amuses you, but they won't support the {@link
     * UnionDiscriminator#encode|encode} or {@link
     * UnionDiscriminator#decode|decode} functions.
     *
     * @param {string} [property] - Default for {@link
     * UnionDiscriminator#property|property}.
     *
     * @abstract
     */
    class UnionDiscriminator {
        constructor(property) {
            /** The {@link Layout#property|property} to be used when the
             * discriminator is referenced in isolation (generally when {@link
             * Union#decode|Union decode} cannot delegate to a specific
             * variant). */
            this.property = property;
        }
        /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
         *
         * The implementation of this method need not reference the buffer if
         * variant information is available through other means. */
        decode(b, offset) {
            throw new Error('UnionDiscriminator is abstract');
        }
        /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
         *
         * The implementation of this method need not store the value if
         * variant information is maintained through other means. */
        encode(src, b, offset) {
            throw new Error('UnionDiscriminator is abstract');
        }
    }
    exports.UnionDiscriminator = UnionDiscriminator;
    /**
     * An object that can provide a {@link
     * UnionDiscriminator|discriminator API} for {@link Union} using an
     * unsigned integral {@link Layout} instance located either inside or
     * outside the union.
     *
     * @param {ExternalLayout} layout - initializes {@link
     * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link
     * ExternalLayout#isCount|isCount()}.
     *
     * @param {string} [property] - Default for {@link
     * UnionDiscriminator#property|property}, superseding the property
     * from `layout`, but defaulting to `variant` if neither `property`
     * nor layout provide a property name.
     *
     * @augments {UnionDiscriminator}
     */
    class UnionLayoutDiscriminator extends UnionDiscriminator {
        constructor(layout, property) {
            if (!((layout instanceof ExternalLayout)
                && layout.isCount())) {
                throw new TypeError('layout must be an unsigned integer ExternalLayout');
            }
            super(property || layout.property || 'variant');
            /** The {@link ExternalLayout} used to access the discriminator
             * value. */
            this.layout = layout;
        }
        /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
        decode(b, offset) {
            return this.layout.decode(b, offset);
        }
        /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
        encode(src, b, offset) {
            return this.layout.encode(src, b, offset);
        }
    }
    exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
    /**
     * Represent any number of span-compatible layouts.
     *
     * *Factory*: {@link module:Layout.union|union}
     *
     * If the union has a {@link Union#defaultLayout|default layout} that
     * layout must have a non-negative {@link Layout#span|span}.  The span
     * of a fixed-span union includes its {@link
     * Union#discriminator|discriminator} if the variant is a {@link
     * Union#usesPrefixDiscriminator|prefix of the union}, plus the span
     * of its {@link Union#defaultLayout|default layout}.
     *
     * If the union does not have a default layout then the encoded span
     * of the union depends on the encoded span of its variant (which may
     * be fixed or variable).
     *
     * {@link VariantLayout#layout|Variant layout}s are added through
     * {@link Union#addVariant|addVariant}.  If the union has a default
     * layout, the span of the {@link VariantLayout#layout|layout
     * contained by the variant} must not exceed the span of the {@link
     * Union#defaultLayout|default layout} (minus the span of a {@link
     * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The
     * span of the variant will equal the span of the union itself.
     *
     * The variant for a buffer can only be identified from the {@link
     * Union#discriminator|discriminator} {@link
     * UnionDiscriminator#property|property} (in the case of the {@link
     * Union#defaultLayout|default layout}), or by using {@link
     * Union#getVariant|getVariant} and examining the resulting {@link
     * VariantLayout} instance.
     *
     * A variant compatible with a JavaScript object can be identified
     * using {@link Union#getSourceVariant|getSourceVariant}.
     *
     * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to
     * identify the layout used to interpret the union contents.  The
     * parameter must be an instance of {@link UnionDiscriminator}, an
     * {@link ExternalLayout} that satisfies {@link
     * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link
     * UIntBE}).  When a non-external layout element is passed the layout
     * appears at the start of the union.  In all cases the (synthesized)
     * {@link UnionDiscriminator} instance is recorded as {@link
     * Union#discriminator|discriminator}.
     *
     * @param {(Layout|null)} defaultLayout - initializer for {@link
     * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.
     * If `null` there is no default layout: the union has data-dependent
     * length and attempts to decode or encode unrecognized variants will
     * throw an exception.  A {@link Layout} instance must have a
     * non-negative {@link Layout#span|span}, and if it lacks a {@link
     * Layout#property|property} the {@link
     * Union#defaultLayout|defaultLayout} will be a {@link
     * Layout#replicate|replica} with property `content`.
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class Union extends Layout {
        constructor(discr, defaultLayout, property) {
            let discriminator;
            if ((discr instanceof UInt)
                || (discr instanceof UIntBE)) {
                discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
            }
            else if ((discr instanceof ExternalLayout)
                && discr.isCount()) {
                discriminator = new UnionLayoutDiscriminator(discr);
            }
            else if (!(discr instanceof UnionDiscriminator)) {
                throw new TypeError('discr must be a UnionDiscriminator '
                    + 'or an unsigned integer layout');
            }
            else {
                discriminator = discr;
            }
            if (undefined === defaultLayout) {
                defaultLayout = null;
            }
            if (!((null === defaultLayout)
                || (defaultLayout instanceof Layout))) {
                throw new TypeError('defaultLayout must be null or a Layout');
            }
            if (null !== defaultLayout) {
                if (0 > defaultLayout.span) {
                    throw new Error('defaultLayout must have constant span');
                }
                if (undefined === defaultLayout.property) {
                    defaultLayout = defaultLayout.replicate('content');
                }
            }
            /* The union span can be estimated only if there's a default
             * layout.  The union spans its default layout, plus any prefix
             * variant layout.  By construction both layouts, if present, have
             * non-negative span. */
            let span = -1;
            if (defaultLayout) {
                span = defaultLayout.span;
                if ((0 <= span) && ((discr instanceof UInt)
                    || (discr instanceof UIntBE))) {
                    span += discriminator.layout.span;
                }
            }
            super(span, property);
            /** The interface for the discriminator value in isolation.
             *
             * This a {@link UnionDiscriminator} either passed to the
             * constructor or synthesized from the `discr` constructor
             * argument.  {@link
             * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be
             * `true` iff the `discr` parameter was a non-offset {@link
             * Layout} instance. */
            this.discriminator = discriminator;
            /** `true` if the {@link Union#discriminator|discriminator} is the
             * first field in the union.
             *
             * If `false` the discriminator is obtained from somewhere
             * else. */
            this.usesPrefixDiscriminator = (discr instanceof UInt)
                || (discr instanceof UIntBE);
            /** The layout for non-discriminator content when the value of the
             * discriminator is not recognized.
             *
             * This is the value passed to the constructor.  It is
             * structurally equivalent to the second component of {@link
             * Union#layout|layout} but may have a different property
             * name. */
            this.defaultLayout = defaultLayout;
            /** A registry of allowed variants.
             *
             * The keys are unsigned integers which should be compatible with
             * {@link Union.discriminator|discriminator}.  The property value
             * is the corresponding {@link VariantLayout} instances assigned
             * to this union by {@link Union#addVariant|addVariant}.
             *
             * **NOTE** The registry remains mutable so that variants can be
             * {@link Union#addVariant|added} at any time.  Users should not
             * manipulate the content of this property. */
            this.registry = {};
            /* Private variable used when invoking getSourceVariant */
            let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
            /** Function to infer the variant selected by a source object.
             *
             * Defaults to {@link
             * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may
             * be overridden using {@link
             * Union#configGetSourceVariant|configGetSourceVariant}.
             *
             * @param {Object} src - as with {@link
             * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
             *
             * @returns {(undefined|VariantLayout)} The default variant
             * (`undefined`) or first registered variant that uses a property
             * available in `src`. */
            this.getSourceVariant = function (src) {
                return boundGetSourceVariant(src);
            };
            /** Function to override the implementation of {@link
             * Union#getSourceVariant|getSourceVariant}.
             *
             * Use this if the desired variant cannot be identified using the
             * algorithm of {@link
             * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
             *
             * **NOTE** The provided function will be invoked bound to this
             * Union instance, providing local access to {@link
             * Union#registry|registry}.
             *
             * @param {Function} gsv - a function that follows the API of
             * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */
            this.configGetSourceVariant = function (gsv) {
                boundGetSourceVariant = gsv.bind(this);
            };
        }
        /** @override */
        getSpan(b, offset = 0) {
            if (0 <= this.span) {
                return this.span;
            }
            /* Default layouts always have non-negative span, so we don't have
             * one and we have to recognize the variant which will in turn
             * determine the span. */
            const vlo = this.getVariant(b, offset);
            if (!vlo) {
                throw new Error('unable to determine span for unrecognized variant');
            }
            return vlo.getSpan(b, offset);
        }
        /**
         * Method to infer a registered Union variant compatible with `src`.
         *
         * The first satisfied rule in the following sequence defines the
         * return value:
         * * If `src` has properties matching the Union discriminator and
         *   the default layout, `undefined` is returned regardless of the
         *   value of the discriminator property (this ensures the default
         *   layout will be used);
         * * If `src` has a property matching the Union discriminator, the
         *   value of the discriminator identifies a registered variant, and
         *   either (a) the variant has no layout, or (b) `src` has the
         *   variant's property, then the variant is returned (because the
         *   source satisfies the constraints of the variant it identifies);
         * * If `src` does not have a property matching the Union
         *   discriminator, but does have a property matching a registered
         *   variant, then the variant is returned (because the source
         *   matches a variant without an explicit conflict);
         * * An error is thrown (because we either can't identify a variant,
         *   or we were explicitly told the variant but can't satisfy it).
         *
         * @param {Object} src - an object presumed to be compatible with
         * the content of the Union.
         *
         * @return {(undefined|VariantLayout)} - as described above.
         *
         * @throws {Error} - if `src` cannot be associated with a default or
         * registered variant.
         */
        defaultGetSourceVariant(src) {
            if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
                if (this.defaultLayout && this.defaultLayout.property
                    && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
                    return undefined;
                }
                const vlo = this.registry[src[this.discriminator.property]];
                if (vlo
                    && ((!vlo.layout)
                        || (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)))) {
                    return vlo;
                }
            }
            else {
                for (const tag in this.registry) {
                    const vlo = this.registry[tag];
                    if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
                        return vlo;
                    }
                }
            }
            throw new Error('unable to infer src variant');
        }
        /** Implement {@link Layout#decode|decode} for {@link Union}.
         *
         * If the variant is {@link Union#addVariant|registered} the return
         * value is an instance of that variant, with no explicit
         * discriminator.  Otherwise the {@link Union#defaultLayout|default
         * layout} is used to decode the content. */
        decode(b, offset = 0) {
            let dest;
            const dlo = this.discriminator;
            const discr = dlo.decode(b, offset);
            const clo = this.registry[discr];
            if (undefined === clo) {
                const defaultLayout = this.defaultLayout;
                let contentOffset = 0;
                if (this.usesPrefixDiscriminator) {
                    contentOffset = dlo.layout.span;
                }
                dest = this.makeDestinationObject();
                dest[dlo.property] = discr;
                // defaultLayout.property can be undefined, but this is allowed by buffer-layout
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);
            }
            else {
                dest = clo.decode(b, offset);
            }
            return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link Union}.
         *
         * This API assumes the `src` object is consistent with the union's
         * {@link Union#defaultLayout|default layout}.  To encode variants
         * use the appropriate variant-specific {@link VariantLayout#encode}
         * method. */
        encode(src, b, offset = 0) {
            const vlo = this.getSourceVariant(src);
            if (undefined === vlo) {
                const dlo = this.discriminator;
                // this.defaultLayout is not undefined when vlo is undefined
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const clo = this.defaultLayout;
                let contentOffset = 0;
                if (this.usesPrefixDiscriminator) {
                    contentOffset = dlo.layout.span;
                }
                dlo.encode(src[dlo.property], b, offset);
                // clo.property is not undefined when vlo is undefined
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);
            }
            return vlo.encode(src, b, offset);
        }
        /** Register a new variant structure within a union.  The newly
         * created variant is returned.
         *
         * @param {Number} variant - initializer for {@link
         * VariantLayout#variant|variant}.
         *
         * @param {Layout} layout - initializer for {@link
         * VariantLayout#layout|layout}.
         *
         * @param {String} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {VariantLayout} */
        addVariant(variant, layout, property) {
            const rv = new VariantLayout(this, variant, layout, property);
            this.registry[variant] = rv;
            return rv;
        }
        /**
         * Get the layout associated with a registered variant.
         *
         * If `vb` does not produce a registered variant the function returns
         * `undefined`.
         *
         * @param {(Number|Uint8Array)} vb - either the variant number, or a
         * buffer from which the discriminator is to be read.
         *
         * @param {Number} offset - offset into `vb` for the start of the
         * union.  Used only when `vb` is an instance of {Uint8Array}.
         *
         * @return {({VariantLayout}|undefined)}
         */
        getVariant(vb, offset = 0) {
            let variant;
            if (vb instanceof Uint8Array) {
                variant = this.discriminator.decode(vb, offset);
            }
            else {
                variant = vb;
            }
            return this.registry[variant];
        }
    }
    exports.Union = Union;
    /**
     * Represent a specific variant within a containing union.
     *
     * **NOTE** The {@link Layout#span|span} of the variant may include
     * the span of the {@link Union#discriminator|discriminator} used to
     * identify it, but values read and written using the variant strictly
     * conform to the content of {@link VariantLayout#layout|layout}.
     *
     * **NOTE** User code should not invoke this constructor directly.  Use
     * the union {@link Union#addVariant|addVariant} helper method.
     *
     * @param {Union} union - initializer for {@link
     * VariantLayout#union|union}.
     *
     * @param {Number} variant - initializer for {@link
     * VariantLayout#variant|variant}.
     *
     * @param {Layout} [layout] - initializer for {@link
     * VariantLayout#layout|layout}.  If absent the variant carries no
     * data.
     *
     * @param {String} [property] - initializer for {@link
     * Layout#property|property}.  Unlike many other layouts, variant
     * layouts normally include a property name so they can be identified
     * within their containing {@link Union}.  The property identifier may
     * be absent only if `layout` is is absent.
     *
     * @augments {Layout}
     */
    class VariantLayout extends Layout {
        constructor(union, variant, layout, property) {
            if (!(union instanceof Union)) {
                throw new TypeError('union must be a Union');
            }
            if ((!Number.isInteger(variant)) || (0 > variant)) {
                throw new TypeError('variant must be a (non-negative) integer');
            }
            if (('string' === typeof layout)
                && (undefined === property)) {
                property = layout;
                layout = null;
            }
            if (layout) {
                if (!(layout instanceof Layout)) {
                    throw new TypeError('layout must be a Layout');
                }
                if ((null !== union.defaultLayout)
                    && (0 <= layout.span)
                    && (layout.span > union.defaultLayout.span)) {
                    throw new Error('variant span exceeds span of containing union');
                }
                if ('string' !== typeof property) {
                    throw new TypeError('variant must have a String property');
                }
            }
            let span = union.span;
            if (0 > union.span) {
                span = layout ? layout.span : 0;
                if ((0 <= span) && union.usesPrefixDiscriminator) {
                    span += union.discriminator.layout.span;
                }
            }
            super(span, property);
            /** The {@link Union} to which this variant belongs. */
            this.union = union;
            /** The unsigned integral value identifying this variant within
             * the {@link Union#discriminator|discriminator} of the containing
             * union. */
            this.variant = variant;
            /** The {@link Layout} to be used when reading/writing the
             * non-discriminator part of the {@link
             * VariantLayout#union|union}.  If `null` the variant carries no
             * data. */
            this.layout = layout || null;
        }
        /** @override */
        getSpan(b, offset = 0) {
            if (0 <= this.span) {
                /* Will be equal to the containing union span if that is not
                 * variable. */
                return this.span;
            }
            let contentOffset = 0;
            if (this.union.usesPrefixDiscriminator) {
                contentOffset = this.union.discriminator.layout.span;
            }
            /* Span is defined solely by the variant (and prefix discriminator) */
            let span = 0;
            if (this.layout) {
                span = this.layout.getSpan(b, offset + contentOffset);
            }
            return contentOffset + span;
        }
        /** @override */
        decode(b, offset = 0) {
            const dest = this.makeDestinationObject();
            if (this !== this.union.getVariant(b, offset)) {
                throw new Error('variant mismatch');
            }
            let contentOffset = 0;
            if (this.union.usesPrefixDiscriminator) {
                contentOffset = this.union.discriminator.layout.span;
            }
            if (this.layout) {
                dest[this.property] = this.layout.decode(b, offset + contentOffset);
            }
            else if (this.property) {
                dest[this.property] = true;
            }
            else if (this.union.usesPrefixDiscriminator) {
                dest[this.union.discriminator.property] = this.variant;
            }
            return dest;
        }
        /** @override */
        encode(src, b, offset = 0) {
            let contentOffset = 0;
            if (this.union.usesPrefixDiscriminator) {
                contentOffset = this.union.discriminator.layout.span;
            }
            if (this.layout
                && (!Object.prototype.hasOwnProperty.call(src, this.property))) {
                throw new TypeError('variant lacks property ' + this.property);
            }
            this.union.discriminator.encode(this.variant, b, offset);
            let span = contentOffset;
            if (this.layout) {
                this.layout.encode(src[this.property], b, offset + contentOffset);
                span += this.layout.getSpan(b, offset + contentOffset);
                if ((0 <= this.union.span)
                    && (span > this.union.span)) {
                    throw new Error('encoded variant overruns containing union');
                }
            }
            return span;
        }
        /** Delegate {@link Layout#fromArray|fromArray} to {@link
         * VariantLayout#layout|layout}. */
        fromArray(values) {
            if (this.layout) {
                return this.layout.fromArray(values);
            }
            return undefined;
        }
    }
    exports.VariantLayout = VariantLayout;
    /** JavaScript chose to define bitwise operations as operating on
     * signed 32-bit values in 2's complement form, meaning any integer
     * with bit 31 set is going to look negative.  For right shifts that's
     * not a problem, because `>>>` is a logical shift, but for every
     * other bitwise operator we have to compensate for possible negative
     * results. */
    function fixBitwiseResult(v) {
        if (0 > v) {
            v += 0x100000000;
        }
        return v;
    }
    /**
     * Contain a sequence of bit fields as an unsigned integer.
     *
     * *Factory*: {@link module:Layout.bits|bits}
     *
     * This is a container element; within it there are {@link BitField}
     * instances that provide the extracted properties.  The container
     * simply defines the aggregate representation and its bit ordering.
     * The representation is an object containing properties with numeric
     * or {@link Boolean} values.
     *
     * {@link BitField}s are added with the {@link
     * BitStructure#addField|addField} and {@link
     * BitStructure#addBoolean|addBoolean} methods.
    
     * @param {Layout} word - initializer for {@link
     * BitStructure#word|word}.  The parameter must be an instance of
     * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.
     *
     * @param {bool} [msb] - `true` if the bit numbering starts at the
     * most significant bit of the containing word; `false` (default) if
     * it starts at the least significant bit of the containing word.  If
     * the parameter at this position is a string and `property` is
     * `undefined` the value of this argument will instead be used as the
     * value of `property`.
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class BitStructure extends Layout {
        constructor(word, msb, property) {
            if (!((word instanceof UInt)
                || (word instanceof UIntBE))) {
                throw new TypeError('word must be a UInt or UIntBE layout');
            }
            if (('string' === typeof msb)
                && (undefined === property)) {
                property = msb;
                msb = false;
            }
            if (4 < word.span) {
                throw new RangeError('word cannot exceed 32 bits');
            }
            super(word.span, property);
            /** The layout used for the packed value.  {@link BitField}
             * instances are packed sequentially depending on {@link
             * BitStructure#msb|msb}. */
            this.word = word;
            /** Whether the bit sequences are packed starting at the most
             * significant bit growing down (`true`), or the least significant
             * bit growing up (`false`).
             *
             * **NOTE** Regardless of this value, the least significant bit of
             * any {@link BitField} value is the least significant bit of the
             * corresponding section of the packed value. */
            this.msb = !!msb;
            /** The sequence of {@link BitField} layouts that comprise the
             * packed structure.
             *
             * **NOTE** The array remains mutable to allow fields to be {@link
             * BitStructure#addField|added} after construction.  Users should
             * not manipulate the content of this property.*/
            this.fields = [];
            /* Storage for the value.  Capture a variable instead of using an
             * instance property because we don't want anything to change the
             * value without going through the mutator. */
            let value = 0;
            this._packedSetValue = function (v) {
                value = fixBitwiseResult(v);
                return this;
            };
            this._packedGetValue = function () {
                return value;
            };
        }
        /** @override */
        decode(b, offset = 0) {
            const dest = this.makeDestinationObject();
            const value = this.word.decode(b, offset);
            this._packedSetValue(value);
            for (const fd of this.fields) {
                if (undefined !== fd.property) {
                    dest[fd.property] = fd.decode(b);
                }
            }
            return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
         *
         * If `src` is missing a property for a member with a defined {@link
         * Layout#property|property} the corresponding region of the packed
         * value is left unmodified.  Unused bits are also left unmodified. */
        encode(src, b, offset = 0) {
            const value = this.word.decode(b, offset);
            this._packedSetValue(value);
            for (const fd of this.fields) {
                if (undefined !== fd.property) {
                    const fv = src[fd.property];
                    if (undefined !== fv) {
                        fd.encode(fv);
                    }
                }
            }
            return this.word.encode(this._packedGetValue(), b, offset);
        }
        /** Register a new bitfield with a containing bit structure.  The
         * resulting bitfield is returned.
         *
         * @param {Number} bits - initializer for {@link BitField#bits|bits}.
         *
         * @param {string} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {BitField} */
        addField(bits, property) {
            const bf = new BitField(this, bits, property);
            this.fields.push(bf);
            return bf;
        }
        /** As with {@link BitStructure#addField|addField} for single-bit
         * fields with `boolean` value representation.
         *
         * @param {string} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {Boolean} */
        // `Boolean` conflicts with the native primitive type
        // eslint-disable-next-line @typescript-eslint/ban-types
        addBoolean(property) {
            // This is my Boolean, not the Javascript one.
            const bf = new Boolean(this, property);
            this.fields.push(bf);
            return bf;
        }
        /**
         * Get access to the bit field for a given property.
         *
         * @param {String} property - the bit field of interest.
         *
         * @return {BitField} - the field associated with `property`, or
         * undefined if there is no such property.
         */
        fieldFor(property) {
            if ('string' !== typeof property) {
                throw new TypeError('property must be string');
            }
            for (const fd of this.fields) {
                if (fd.property === property) {
                    return fd;
                }
            }
            return undefined;
        }
    }
    exports.BitStructure = BitStructure;
    /**
     * Represent a sequence of bits within a {@link BitStructure}.
     *
     * All bit field values are represented as unsigned integers.
     *
     * **NOTE** User code should not invoke this constructor directly.
     * Use the container {@link BitStructure#addField|addField} helper
     * method.
     *
     * **NOTE** BitField instances are not instances of {@link Layout}
     * since {@link Layout#span|span} measures 8-bit units.
     *
     * @param {BitStructure} container - initializer for {@link
     * BitField#container|container}.
     *
     * @param {Number} bits - initializer for {@link BitField#bits|bits}.
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     */
    class BitField {
        constructor(container, bits, property) {
            if (!(container instanceof BitStructure)) {
                throw new TypeError('container must be a BitStructure');
            }
            if ((!Number.isInteger(bits)) || (0 >= bits)) {
                throw new TypeError('bits must be positive integer');
            }
            const totalBits = 8 * container.span;
            const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
            if ((bits + usedBits) > totalBits) {
                throw new Error('bits too long for span remainder ('
                    + (totalBits - usedBits) + ' of '
                    + totalBits + ' remain)');
            }
            /** The {@link BitStructure} instance to which this bit field
             * belongs. */
            this.container = container;
            /** The span of this value in bits. */
            this.bits = bits;
            /** A mask of {@link BitField#bits|bits} bits isolating value bits
             * that fit within the field.
             *
             * That is, it masks a value that has not yet been shifted into
             * position within its containing packed integer. */
            this.valueMask = (1 << bits) - 1;
            if (32 === bits) { // shifted value out of range
                this.valueMask = 0xFFFFFFFF;
            }
            /** The offset of the value within the containing packed unsigned
             * integer.  The least significant bit of the packed value is at
             * offset zero, regardless of bit ordering used. */
            this.start = usedBits;
            if (this.container.msb) {
                this.start = totalBits - usedBits - bits;
            }
            /** A mask of {@link BitField#bits|bits} isolating the field value
             * within the containing packed unsigned integer. */
            this.wordMask = fixBitwiseResult(this.valueMask << this.start);
            /** The property name used when this bitfield is represented in an
             * Object.
             *
             * Intended to be functionally equivalent to {@link
             * Layout#property}.
             *
             * If left undefined the corresponding span of bits will be
             * treated as padding: it will not be mutated by {@link
             * Layout#encode|encode} nor represented as a property in the
             * decoded Object. */
            this.property = property;
        }
        /** Store a value into the corresponding subsequence of the containing
         * bit field. */
        decode(b, offset) {
            const word = this.container._packedGetValue();
            const wordValue = fixBitwiseResult(word & this.wordMask);
            const value = wordValue >>> this.start;
            return value;
        }
        /** Store a value into the corresponding subsequence of the containing
         * bit field.
         *
         * **NOTE** This is not a specialization of {@link
         * Layout#encode|Layout.encode} and there is no return value. */
        encode(value) {
            if ('number' !== typeof value
                || !Number.isInteger(value)
                || (value !== fixBitwiseResult(value & this.valueMask))) {
                throw new TypeError(nameWithProperty('BitField.encode', this)
                    + ' value must be integer not exceeding ' + this.valueMask);
            }
            const word = this.container._packedGetValue();
            const wordValue = fixBitwiseResult(value << this.start);
            this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)
                | wordValue);
        }
    }
    exports.BitField = BitField;
    /**
     * Represent a single bit within a {@link BitStructure} as a
     * JavaScript boolean.
     *
     * **NOTE** User code should not invoke this constructor directly.
     * Use the container {@link BitStructure#addBoolean|addBoolean} helper
     * method.
     *
     * @param {BitStructure} container - initializer for {@link
     * BitField#container|container}.
     *
     * @param {string} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {BitField}
     */
    /* eslint-disable no-extend-native */
    class Boolean extends BitField {
        constructor(container, property) {
            super(container, 1, property);
        }
        /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
         *
         * @returns {boolean} */
        decode(b, offset) {
            return !!super.decode(b, offset);
        }
        /** @override */
        encode(value) {
            if ('boolean' === typeof value) {
                // BitField requires integer values
                value = +value;
            }
            super.encode(value);
        }
    }
    exports.Boolean = Boolean;
    /* eslint-enable no-extend-native */
    /**
     * Contain a fixed-length block of arbitrary data, represented as a
     * Uint8Array.
     *
     * *Factory*: {@link module:Layout.blob|blob}
     *
     * @param {(Number|ExternalLayout)} length - initializes {@link
     * Blob#length|length}.
     *
     * @param {String} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class Blob extends Layout {
        constructor(length, property) {
            if (!(((length instanceof ExternalLayout) && length.isCount())
                || (Number.isInteger(length) && (0 <= length)))) {
                throw new TypeError('length must be positive integer '
                    + 'or an unsigned integer ExternalLayout');
            }
            let span = -1;
            if (!(length instanceof ExternalLayout)) {
                span = length;
            }
            super(span, property);
            /** The number of bytes in the blob.
             *
             * This may be a non-negative integer, or an instance of {@link
             * ExternalLayout} that satisfies {@link
             * ExternalLayout#isCount|isCount()}. */
            this.length = length;
        }
        /** @override */
        getSpan(b, offset) {
            let span = this.span;
            if (0 > span) {
                span = this.length.decode(b, offset);
            }
            return span;
        }
        /** @override */
        decode(b, offset = 0) {
            let span = this.span;
            if (0 > span) {
                span = this.length.decode(b, offset);
            }
            return uint8ArrayToBuffer(b).slice(offset, offset + span);
        }
        /** Implement {@link Layout#encode|encode} for {@link Blob}.
         *
         * **NOTE** If {@link Layout#count|count} is an instance of {@link
         * ExternalLayout} then the length of `src` will be encoded as the
         * count after `src` is encoded. */
        encode(src, b, offset) {
            let span = this.length;
            if (this.length instanceof ExternalLayout) {
                span = src.length;
            }
            if (!(src instanceof Uint8Array && span === src.length)) {
                throw new TypeError(nameWithProperty('Blob.encode', this)
                    + ' requires (length ' + span + ') Uint8Array as src');
            }
            if ((offset + span) > b.length) {
                throw new RangeError('encoding overruns Uint8Array');
            }
            const srcBuffer = uint8ArrayToBuffer(src);
            uint8ArrayToBuffer(b).write(srcBuffer.toString('hex'), offset, span, 'hex');
            if (this.length instanceof ExternalLayout) {
                this.length.encode(span, b, offset);
            }
            return span;
        }
    }
    exports.Blob = Blob;
    /**
     * Contain a `NUL`-terminated UTF8 string.
     *
     * *Factory*: {@link module:Layout.cstr|cstr}
     *
     * **NOTE** Any UTF8 string that incorporates a zero-valued byte will
     * not be correctly decoded by this layout.
     *
     * @param {String} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class CString extends Layout {
        constructor(property) {
            super(-1, property);
        }
        /** @override */
        getSpan(b, offset = 0) {
            checkUint8Array(b);
            let idx = offset;
            while ((idx < b.length) && (0 !== b[idx])) {
                idx += 1;
            }
            return 1 + idx - offset;
        }
        /** @override */
        decode(b, offset = 0) {
            const span = this.getSpan(b, offset);
            return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString('utf-8');
        }
        /** @override */
        encode(src, b, offset = 0) {
            /* Must force this to a string, lest it be a number and the
             * "utf8-encoding" below actually allocate a buffer of length
             * src */
            if ('string' !== typeof src) {
                src = String(src);
            }
            const srcb = buffer_1.Buffer.from(src, 'utf8');
            const span = srcb.length;
            if ((offset + span) > b.length) {
                throw new RangeError('encoding overruns Buffer');
            }
            const buffer = uint8ArrayToBuffer(b);
            srcb.copy(buffer, offset);
            buffer[offset + span] = 0;
            return span + 1;
        }
    }
    exports.CString = CString;
    /**
     * Contain a UTF8 string with implicit length.
     *
     * *Factory*: {@link module:Layout.utf8|utf8}
     *
     * **NOTE** Because the length is implicit in the size of the buffer
     * this layout should be used only in isolation, or in a situation
     * where the length can be expressed by operating on a slice of the
     * containing buffer.
     *
     * @param {Number} [maxSpan] - the maximum length allowed for encoded
     * string content.  If not provided there is no bound on the allowed
     * content.
     *
     * @param {String} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class UTF8 extends Layout {
        constructor(maxSpan, property) {
            if (('string' === typeof maxSpan) && (undefined === property)) {
                property = maxSpan;
                maxSpan = undefined;
            }
            if (undefined === maxSpan) {
                maxSpan = -1;
            }
            else if (!Number.isInteger(maxSpan)) {
                throw new TypeError('maxSpan must be an integer');
            }
            super(-1, property);
            /** The maximum span of the layout in bytes.
             *
             * Positive values are generally expected.  Zero is abnormal.
             * Attempts to encode or decode a value that exceeds this length
             * will throw a `RangeError`.
             *
             * A negative value indicates that there is no bound on the length
             * of the content. */
            this.maxSpan = maxSpan;
        }
        /** @override */
        getSpan(b, offset = 0) {
            checkUint8Array(b);
            return b.length - offset;
        }
        /** @override */
        decode(b, offset = 0) {
            const span = this.getSpan(b, offset);
            if ((0 <= this.maxSpan)
                && (this.maxSpan < span)) {
                throw new RangeError('text length exceeds maxSpan');
            }
            return uint8ArrayToBuffer(b).slice(offset, offset + span).toString('utf-8');
        }
        /** @override */
        encode(src, b, offset = 0) {
            /* Must force this to a string, lest it be a number and the
             * "utf8-encoding" below actually allocate a buffer of length
             * src */
            if ('string' !== typeof src) {
                src = String(src);
            }
            const srcb = buffer_1.Buffer.from(src, 'utf8');
            const span = srcb.length;
            if ((0 <= this.maxSpan)
                && (this.maxSpan < span)) {
                throw new RangeError('text length exceeds maxSpan');
            }
            if ((offset + span) > b.length) {
                throw new RangeError('encoding overruns Buffer');
            }
            srcb.copy(uint8ArrayToBuffer(b), offset);
            return span;
        }
    }
    exports.UTF8 = UTF8;
    /**
     * Contain a constant value.
     *
     * This layout may be used in cases where a JavaScript value can be
     * inferred without an expression in the binary encoding.  An example
     * would be a {@link VariantLayout|variant layout} where the content
     * is implied by the union {@link Union#discriminator|discriminator}.
     *
     * @param {Object|Number|String} value - initializer for {@link
     * Constant#value|value}.  If the value is an object (or array) and
     * the application intends the object to remain unchanged regardless
     * of what is done to values decoded by this layout, the value should
     * be frozen prior passing it to this constructor.
     *
     * @param {String} [property] - initializer for {@link
     * Layout#property|property}.
     *
     * @augments {Layout}
     */
    class Constant extends Layout {
        constructor(value, property) {
            super(0, property);
            /** The value produced by this constant when the layout is {@link
             * Constant#decode|decoded}.
             *
             * Any JavaScript value including `null` and `undefined` is
             * permitted.
             *
             * **WARNING** If `value` passed in the constructor was not
             * frozen, it is possible for users of decoded values to change
             * the content of the value. */
            this.value = value;
        }
        /** @override */
        decode(b, offset) {
            return this.value;
        }
        /** @override */
        encode(src, b, offset) {
            /* Constants take no space */
            return 0;
        }
    }
    exports.Constant = Constant;
    /** Factory for {@link GreedyCount}. */
    exports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));
    /** Factory for {@link OffsetLayout}. */
    exports.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));
    /** Factory for {@link UInt|unsigned int layouts} spanning one
     * byte. */
    exports.u8 = ((property) => new UInt(1, property));
    /** Factory for {@link UInt|little-endian unsigned int layouts}
     * spanning two bytes. */
    exports.u16 = ((property) => new UInt(2, property));
    /** Factory for {@link UInt|little-endian unsigned int layouts}
     * spanning three bytes. */
    exports.u24 = ((property) => new UInt(3, property));
    /** Factory for {@link UInt|little-endian unsigned int layouts}
     * spanning four bytes. */
    exports.u32 = ((property) => new UInt(4, property));
    /** Factory for {@link UInt|little-endian unsigned int layouts}
     * spanning five bytes. */
    exports.u40 = ((property) => new UInt(5, property));
    /** Factory for {@link UInt|little-endian unsigned int layouts}
     * spanning six bytes. */
    exports.u48 = ((property) => new UInt(6, property));
    /** Factory for {@link NearUInt64|little-endian unsigned int
     * layouts} interpreted as Numbers. */
    exports.nu64 = ((property) => new NearUInt64(property));
    /** Factory for {@link UInt|big-endian unsigned int layouts}
     * spanning two bytes. */
    exports.u16be = ((property) => new UIntBE(2, property));
    /** Factory for {@link UInt|big-endian unsigned int layouts}
     * spanning three bytes. */
    exports.u24be = ((property) => new UIntBE(3, property));
    /** Factory for {@link UInt|big-endian unsigned int layouts}
     * spanning four bytes. */
    exports.u32be = ((property) => new UIntBE(4, property));
    /** Factory for {@link UInt|big-endian unsigned int layouts}
     * spanning five bytes. */
    exports.u40be = ((property) => new UIntBE(5, property));
    /** Factory for {@link UInt|big-endian unsigned int layouts}
     * spanning six bytes. */
    exports.u48be = ((property) => new UIntBE(6, property));
    /** Factory for {@link NearUInt64BE|big-endian unsigned int
     * layouts} interpreted as Numbers. */
    exports.nu64be = ((property) => new NearUInt64BE(property));
    /** Factory for {@link Int|signed int layouts} spanning one
     * byte. */
    exports.s8 = ((property) => new Int(1, property));
    /** Factory for {@link Int|little-endian signed int layouts}
     * spanning two bytes. */
    exports.s16 = ((property) => new Int(2, property));
    /** Factory for {@link Int|little-endian signed int layouts}
     * spanning three bytes. */
    exports.s24 = ((property) => new Int(3, property));
    /** Factory for {@link Int|little-endian signed int layouts}
     * spanning four bytes. */
    exports.s32 = ((property) => new Int(4, property));
    /** Factory for {@link Int|little-endian signed int layouts}
     * spanning five bytes. */
    exports.s40 = ((property) => new Int(5, property));
    /** Factory for {@link Int|little-endian signed int layouts}
     * spanning six bytes. */
    exports.s48 = ((property) => new Int(6, property));
    /** Factory for {@link NearInt64|little-endian signed int layouts}
     * interpreted as Numbers. */
    exports.ns64 = ((property) => new NearInt64(property));
    /** Factory for {@link Int|big-endian signed int layouts}
     * spanning two bytes. */
    exports.s16be = ((property) => new IntBE(2, property));
    /** Factory for {@link Int|big-endian signed int layouts}
     * spanning three bytes. */
    exports.s24be = ((property) => new IntBE(3, property));
    /** Factory for {@link Int|big-endian signed int layouts}
     * spanning four bytes. */
    exports.s32be = ((property) => new IntBE(4, property));
    /** Factory for {@link Int|big-endian signed int layouts}
     * spanning five bytes. */
    exports.s40be = ((property) => new IntBE(5, property));
    /** Factory for {@link Int|big-endian signed int layouts}
     * spanning six bytes. */
    exports.s48be = ((property) => new IntBE(6, property));
    /** Factory for {@link NearInt64BE|big-endian signed int layouts}
     * interpreted as Numbers. */
    exports.ns64be = ((property) => new NearInt64BE(property));
    /** Factory for {@link Float|little-endian 32-bit floating point} values. */
    exports.f32 = ((property) => new Float(property));
    /** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */
    exports.f32be = ((property) => new FloatBE(property));
    /** Factory for {@link Double|little-endian 64-bit floating point} values. */
    exports.f64 = ((property) => new Double(property));
    /** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */
    exports.f64be = ((property) => new DoubleBE(property));
    /** Factory for {@link Structure} values. */
    exports.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));
    /** Factory for {@link BitStructure} values. */
    exports.bits = ((word, msb, property) => new BitStructure(word, msb, property));
    /** Factory for {@link Sequence} values. */
    exports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));
    /** Factory for {@link Union} values. */
    exports.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));
    /** Factory for {@link UnionLayoutDiscriminator} values. */
    exports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));
    /** Factory for {@link Blob} values. */
    exports.blob = ((length, property) => new Blob(length, property));
    /** Factory for {@link CString} values. */
    exports.cstr = ((property) => new CString(property));
    /** Factory for {@link UTF8} values. */
    exports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));
    /** Factory for {@link Constant} values. */
    exports.constant = ((value, property) => new Constant(value, property));
    
    },{"buffer":3}],29:[function(require,module,exports){
    'use strict'
    // base-x encoding / decoding
    // Copyright (c) 2018 base-x contributors
    // Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
    // Distributed under the MIT software license, see the accompanying
    // file LICENSE or http://www.opensource.org/licenses/mit-license.php.
    // @ts-ignore
    var _Buffer = require('safe-buffer').Buffer
    function base (ALPHABET) {
      if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
      var BASE_MAP = new Uint8Array(256)
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i)
        var xc = x.charCodeAt(0)
        if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
        BASE_MAP[xc] = i
      }
      var BASE = ALPHABET.length
      var LEADER = ALPHABET.charAt(0)
      var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
      var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
      function encode (source) {
        if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }
        if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
        if (source.length === 0) { return '' }
            // Skip & count leading zeroes.
        var zeroes = 0
        var length = 0
        var pbegin = 0
        var pend = source.length
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++
          zeroes++
        }
            // Allocate enough space in big-endian base58 representation.
        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
        var b58 = new Uint8Array(size)
            // Process the bytes.
        while (pbegin !== pend) {
          var carry = source[pbegin]
                // Apply "b58 = b58 * 256 + ch".
          var i = 0
          for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
            carry += (256 * b58[it1]) >>> 0
            b58[it1] = (carry % BASE) >>> 0
            carry = (carry / BASE) >>> 0
          }
          if (carry !== 0) { throw new Error('Non-zero carry') }
          length = i
          pbegin++
        }
            // Skip leading zeroes in base58 result.
        var it2 = size - length
        while (it2 !== size && b58[it2] === 0) {
          it2++
        }
            // Translate the result into a string.
        var str = LEADER.repeat(zeroes)
        for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
        return str
      }
      function decodeUnsafe (source) {
        if (typeof source !== 'string') { throw new TypeError('Expected String') }
        if (source.length === 0) { return _Buffer.alloc(0) }
        var psz = 0
            // Skip and count leading '1's.
        var zeroes = 0
        var length = 0
        while (source[psz] === LEADER) {
          zeroes++
          psz++
        }
            // Allocate enough space in big-endian base256 representation.
        var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
        var b256 = new Uint8Array(size)
            // Process the characters.
        while (source[psz]) {
                // Decode character
          var carry = BASE_MAP[source.charCodeAt(psz)]
                // Invalid character
          if (carry === 255) { return }
          var i = 0
          for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
            carry += (BASE * b256[it3]) >>> 0
            b256[it3] = (carry % 256) >>> 0
            carry = (carry / 256) >>> 0
          }
          if (carry !== 0) { throw new Error('Non-zero carry') }
          length = i
          psz++
        }
            // Skip leading zeroes in b256.
        var it4 = size - length
        while (it4 !== size && b256[it4] === 0) {
          it4++
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4))
        vch.fill(0x00, 0, zeroes)
        var j = zeroes
        while (it4 !== size) {
          vch[j++] = b256[it4++]
        }
        return vch
      }
      function decode (string) {
        var buffer = decodeUnsafe(string)
        if (buffer) { return buffer }
        throw new Error('Non-base' + BASE + ' character')
      }
      return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
      }
    }
    module.exports = base
    
    },{"safe-buffer":40}],30:[function(require,module,exports){
    (function (Buffer){(function (){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", { value: true });
    let converter;
    /**
     * Convert a little-endian buffer into a BigInt.
     * @param buf The little-endian buffer to convert
     * @returns A BigInt with the little-endian representation of buf.
     */
    function toBigIntLE(buf) {
        {
            const reversed = Buffer.from(buf);
            reversed.reverse();
            const hex = reversed.toString('hex');
            if (hex.length === 0) {
                return BigInt(0);
            }
            return BigInt(`0x${hex}`);
        }
        return converter.toBigInt(buf, false);
    }
    exports.toBigIntLE = toBigIntLE;
    /**
     * Convert a big-endian buffer into a BigInt
     * @param buf The big-endian buffer to convert.
     * @returns A BigInt with the big-endian representation of buf.
     */
    function toBigIntBE(buf) {
        {
            const hex = buf.toString('hex');
            if (hex.length === 0) {
                return BigInt(0);
            }
            return BigInt(`0x${hex}`);
        }
        return converter.toBigInt(buf, true);
    }
    exports.toBigIntBE = toBigIntBE;
    /**
     * Convert a BigInt to a little-endian buffer.
     * @param num   The BigInt to convert.
     * @param width The number of bytes that the resulting buffer should be.
     * @returns A little-endian buffer representation of num.
     */
    function toBufferLE(num, width) {
        {
            const hex = num.toString(16);
            const buffer = Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');
            buffer.reverse();
            return buffer;
        }
        // Allocation is done here, since it is slower using napi in C
        return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
    }
    exports.toBufferLE = toBufferLE;
    /**
     * Convert a BigInt to a big-endian buffer.
     * @param num   The BigInt to convert.
     * @param width The number of bytes that the resulting buffer should be.
     * @returns A big-endian buffer representation of num.
     */
    function toBufferBE(num, width) {
        {
            const hex = num.toString(16);
            return Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');
        }
        return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
    }
    exports.toBufferBE = toBufferBE;
    
    }).call(this)}).call(this,require("buffer").Buffer)
    },{"buffer":3}],31:[function(require,module,exports){
    (function (module, exports) {
      'use strict';
    
      // Utils
      function assert (val, msg) {
        if (!val) throw new Error(msg || 'Assertion failed');
      }
    
      // Could use `inherits` module, but don't want to move from single file
      // architecture yet.
      function inherits (ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    
      // BN
    
      function BN (number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
    
        this.negative = 0;
        this.words = null;
        this.length = 0;
    
        // Reduction context
        this.red = null;
    
        if (number !== null) {
          if (base === 'le' || base === 'be') {
            endian = base;
            base = 10;
          }
    
          this._init(number || 0, base || 10, endian || 'be');
        }
      }
      if (typeof module === 'object') {
        module.exports = BN;
      } else {
        exports.BN = BN;
      }
    
      BN.BN = BN;
      BN.wordSize = 26;
    
      var Buffer;
      try {
        if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
          Buffer = window.Buffer;
        } else {
          Buffer = require('buffer').Buffer;
        }
      } catch (e) {
      }
    
      BN.isBN = function isBN (num) {
        if (num instanceof BN) {
          return true;
        }
    
        return num !== null && typeof num === 'object' &&
          num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
    
      BN.max = function max (left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
    
      BN.min = function min (left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
    
      BN.prototype._init = function init (number, base, endian) {
        if (typeof number === 'number') {
          return this._initNumber(number, base, endian);
        }
    
        if (typeof number === 'object') {
          return this._initArray(number, base, endian);
        }
    
        if (base === 'hex') {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
    
        number = number.toString().replace(/\s+/g, '');
        var start = 0;
        if (number[0] === '-') {
          start++;
          this.negative = 1;
        }
    
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === 'le') {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
    
      BN.prototype._initNumber = function _initNumber (number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 0x4000000) {
          this.words = [number & 0x3ffffff];
          this.length = 1;
        } else if (number < 0x10000000000000) {
          this.words = [
            number & 0x3ffffff,
            (number / 0x4000000) & 0x3ffffff
          ];
          this.length = 2;
        } else {
          assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
          this.words = [
            number & 0x3ffffff,
            (number / 0x4000000) & 0x3ffffff,
            1
          ];
          this.length = 3;
        }
    
        if (endian !== 'le') return;
    
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
      };
    
      BN.prototype._initArray = function _initArray (number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === 'number');
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
    
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
    
        var j, w;
        var off = 0;
        if (endian === 'be') {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
            this.words[j] |= (w << off) & 0x3ffffff;
            this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === 'le') {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
            this.words[j] |= (w << off) & 0x3ffffff;
            this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
    
      function parseHex4Bits (string, index) {
        var c = string.charCodeAt(index);
        // '0' - '9'
        if (c >= 48 && c <= 57) {
          return c - 48;
        // 'A' - 'F'
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        // 'a' - 'f'
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, 'Invalid character in ' + string);
        }
      }
    
      function parseHexByte (string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
    
      BN.prototype._parseHex = function _parseHex (number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
    
        // 24-bits chunks
        var off = 0;
        var j = 0;
    
        var w;
        if (endian === 'be') {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
    
        this._strip();
      };
    
      function parseBase (str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
    
          r *= mul;
    
          // 'a'
          if (c >= 49) {
            b = c - 49 + 0xa;
    
          // 'A'
          } else if (c >= 17) {
            b = c - 17 + 0xa;
    
          // '0' - '9'
          } else {
            b = c;
          }
          assert(c >= 0 && b < mul, 'Invalid character');
          r += b;
        }
        return r;
      }
    
      BN.prototype._parseBase = function _parseBase (number, base, start) {
        // Initialize as zero
        this.words = [0];
        this.length = 1;
    
        // Find length of limb in base
        for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = (limbPow / base) | 0;
    
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
    
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
    
          this.imuln(limbPow);
          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
    
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
    
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
    
          this.imuln(pow);
          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
    
        this._strip();
      };
    
      BN.prototype.copy = function copy (dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
    
      function move (dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
    
      BN.prototype._move = function _move (dest) {
        move(dest, this);
      };
    
      BN.prototype.clone = function clone () {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
    
      BN.prototype._expand = function _expand (size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
    
      // Remove leading `0` from `this`
      BN.prototype._strip = function strip () {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
    
      BN.prototype._normSign = function _normSign () {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
    
      // Check Symbol.for because not everywhere where Symbol defined
      // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
      if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
        try {
          BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
        } catch (e) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }
    
      function inspect () {
        return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
      }
    
      /*
    
      var zeros = [];
      var groupSizes = [];
      var groupBases = [];
    
      var s = '';
      var i = -1;
      while (++i < BN.wordSize) {
        zeros[i] = s;
        s += '0';
      }
      groupSizes[0] = 0;
      groupSizes[1] = 0;
      groupBases[0] = 0;
      groupBases[1] = 0;
      var base = 2 - 1;
      while (++base < 36 + 1) {
        var groupSize = 0;
        var groupBase = 1;
        while (groupBase < (1 << BN.wordSize) / base) {
          groupBase *= base;
          groupSize += 1;
        }
        groupSizes[base] = groupSize;
        groupBases[base] = groupBase;
      }
    
      */
    
      var zeros = [
        '',
        '0',
        '00',
        '000',
        '0000',
        '00000',
        '000000',
        '0000000',
        '00000000',
        '000000000',
        '0000000000',
        '00000000000',
        '000000000000',
        '0000000000000',
        '00000000000000',
        '000000000000000',
        '0000000000000000',
        '00000000000000000',
        '000000000000000000',
        '0000000000000000000',
        '00000000000000000000',
        '000000000000000000000',
        '0000000000000000000000',
        '00000000000000000000000',
        '000000000000000000000000',
        '0000000000000000000000000'
      ];
    
      var groupSizes = [
        0, 0,
        25, 16, 12, 11, 10, 9, 8,
        8, 7, 7, 7, 7, 6, 6,
        6, 6, 6, 6, 6, 5, 5,
        5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5
      ];
    
      var groupBases = [
        0, 0,
        33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
        43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
        16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
        6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
        24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
      ];
    
      BN.prototype.toString = function toString (base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
    
        var out;
        if (base === 16 || base === 'hex') {
          out = '';
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = (((w << off) | carry) & 0xffffff).toString(16);
            carry = (w >>> (24 - off)) & 0xffffff;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = '0' + out;
          }
          if (this.negative !== 0) {
            out = '-' + out;
          }
          return out;
        }
    
        if (base === (base | 0) && base >= 2 && base <= 36) {
          // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
          var groupSize = groupSizes[base];
          // var groupBase = Math.pow(base, groupSize);
          var groupBase = groupBases[base];
          out = '';
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
    
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = '0' + out;
          }
          while (out.length % padding !== 0) {
            out = '0' + out;
          }
          if (this.negative !== 0) {
            out = '-' + out;
          }
          return out;
        }
    
        assert(false, 'Base should be between 2 and 36');
      };
    
      BN.prototype.toNumber = function toNumber () {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 0x4000000;
        } else if (this.length === 3 && this.words[2] === 0x01) {
          // NOTE: at this stage it is known that the top bit is set
          ret += 0x10000000000000 + (this.words[1] * 0x4000000);
        } else if (this.length > 2) {
          assert(false, 'Number can only safely store up to 53 bits');
        }
        return (this.negative !== 0) ? -ret : ret;
      };
    
      BN.prototype.toJSON = function toJSON () {
        return this.toString(16, 2);
      };
    
      if (Buffer) {
        BN.prototype.toBuffer = function toBuffer (endian, length) {
          return this.toArrayLike(Buffer, endian, length);
        };
      }
    
      BN.prototype.toArray = function toArray (endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
    
      var allocate = function allocate (ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
    
      BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
        this._strip();
    
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, 'byte array longer than desired length');
        assert(reqLength > 0, 'Requested array length <= 0');
    
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === 'le' ? 'LE' : 'BE';
        this['_toArrayLike' + postfix](res, byteLength);
        return res;
      };
    
      BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
        var position = 0;
        var carry = 0;
    
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = (this.words[i] << shift) | carry;
    
          res[position++] = word & 0xff;
          if (position < res.length) {
            res[position++] = (word >> 8) & 0xff;
          }
          if (position < res.length) {
            res[position++] = (word >> 16) & 0xff;
          }
    
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = (word >> 24) & 0xff;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
    
        if (position < res.length) {
          res[position++] = carry;
    
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
    
      BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
    
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = (this.words[i] << shift) | carry;
    
          res[position--] = word & 0xff;
          if (position >= 0) {
            res[position--] = (word >> 8) & 0xff;
          }
          if (position >= 0) {
            res[position--] = (word >> 16) & 0xff;
          }
    
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = (word >> 24) & 0xff;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
    
        if (position >= 0) {
          res[position--] = carry;
    
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
    
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits (w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits (w) {
          var t = w;
          var r = 0;
          if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 0x40) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 0x8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 0x02) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
    
      BN.prototype._zeroBits = function _zeroBits (w) {
        // Short-cut
        if (w === 0) return 26;
    
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 0xf) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 0x3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 0x1) === 0) {
          r++;
        }
        return r;
      };
    
      // Return number of used bits in a BN
      BN.prototype.bitLength = function bitLength () {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
    
      function toBitArray (num) {
        var w = new Array(num.bitLength());
    
        for (var bit = 0; bit < w.length; bit++) {
          var off = (bit / 26) | 0;
          var wbit = bit % 26;
    
          w[bit] = (num.words[off] >>> wbit) & 0x01;
        }
    
        return w;
      }
    
      // Number of trailing zero bits
      BN.prototype.zeroBits = function zeroBits () {
        if (this.isZero()) return 0;
    
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
    
      BN.prototype.byteLength = function byteLength () {
        return Math.ceil(this.bitLength() / 8);
      };
    
      BN.prototype.toTwos = function toTwos (width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
    
      BN.prototype.fromTwos = function fromTwos (width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
    
      BN.prototype.isNeg = function isNeg () {
        return this.negative !== 0;
      };
    
      // Return negative clone of `this`
      BN.prototype.neg = function neg () {
        return this.clone().ineg();
      };
    
      BN.prototype.ineg = function ineg () {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
    
        return this;
      };
    
      // Or `num` with `this` in-place
      BN.prototype.iuor = function iuor (num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
    
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
    
        return this._strip();
      };
    
      BN.prototype.ior = function ior (num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
    
      // Or `num` with `this`
      BN.prototype.or = function or (num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
    
      BN.prototype.uor = function uor (num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
    
      // And `num` with `this` in-place
      BN.prototype.iuand = function iuand (num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
    
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
    
        this.length = b.length;
    
        return this._strip();
      };
    
      BN.prototype.iand = function iand (num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
    
      // And `num` with `this`
      BN.prototype.and = function and (num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
    
      BN.prototype.uand = function uand (num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
    
      // Xor `num` with `this` in-place
      BN.prototype.iuxor = function iuxor (num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
    
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
    
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
    
        this.length = a.length;
    
        return this._strip();
      };
    
      BN.prototype.ixor = function ixor (num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
    
      // Xor `num` with `this`
      BN.prototype.xor = function xor (num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
    
      BN.prototype.uxor = function uxor (num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
    
      // Not ``this`` with ``width`` bitwidth
      BN.prototype.inotn = function inotn (width) {
        assert(typeof width === 'number' && width >= 0);
    
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
    
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
    
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
    
        // Handle complete words
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 0x3ffffff;
        }
    
        // Handle the residue
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
        }
    
        // And remove leading zeroes
        return this._strip();
      };
    
      BN.prototype.notn = function notn (width) {
        return this.clone().inotn(width);
      };
    
      // Set `bit` of `this`
      BN.prototype.setn = function setn (bit, val) {
        assert(typeof bit === 'number' && bit >= 0);
    
        var off = (bit / 26) | 0;
        var wbit = bit % 26;
    
        this._expand(off + 1);
    
        if (val) {
          this.words[off] = this.words[off] | (1 << wbit);
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
    
        return this._strip();
      };
    
      // Add `num` to `this` in-place
      BN.prototype.iadd = function iadd (num) {
        var r;
    
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
    
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
    
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
    
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }
    
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        // Copy the rest of the words
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
    
        return this;
      };
    
      // Add `num` to `this`
      BN.prototype.add = function add (num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
    
        if (this.length > num.length) return this.clone().iadd(num);
    
        return num.clone().iadd(this);
      };
    
      // Subtract `num` from `this` in-place
      BN.prototype.isub = function isub (num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
    
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
    
        // At this point both numbers are positive
        var cmp = this.cmp(num);
    
        // Optimization - zeroify
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
    
        // a > b
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
    
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        }
    
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
    
        this.length = Math.max(this.length, i);
    
        if (a !== this) {
          this.negative = 1;
        }
    
        return this._strip();
      };
    
      // Subtract `num` from `this`
      BN.prototype.sub = function sub (num) {
        return this.clone().isub(num);
      };
    
      function smallMulTo (self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = (self.length + num.length) | 0;
        out.length = len;
        len = (len - 1) | 0;
    
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
    
        var lo = r & 0x3ffffff;
        var carry = (r / 0x4000000) | 0;
        out.words[0] = lo;
    
        for (var k = 1; k < len; k++) {
          // Sum all words with the same `i + j = k` and accumulate `ncarry`,
          // note that ncarry could be >= 0x3ffffff
          var ncarry = carry >>> 26;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = (k - j) | 0;
            a = self.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += (r / 0x4000000) | 0;
            rword = r & 0x3ffffff;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
    
        return out._strip();
      }
    
      // TODO(indutny): it may be reasonable to omit it for users who don't need
      // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
      // multiplication (like elliptic secp256k1).
      var comb10MulTo = function comb10MulTo (self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
    
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = (mid + Math.imul(ah0, bl0)) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = (mid + Math.imul(ah1, bl0)) | 0;
        hi = Math.imul(ah1, bh0);
        lo = (lo + Math.imul(al0, bl1)) | 0;
        mid = (mid + Math.imul(al0, bh1)) | 0;
        mid = (mid + Math.imul(ah0, bl1)) | 0;
        hi = (hi + Math.imul(ah0, bh1)) | 0;
        var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = (mid + Math.imul(ah2, bl0)) | 0;
        hi = Math.imul(ah2, bh0);
        lo = (lo + Math.imul(al1, bl1)) | 0;
        mid = (mid + Math.imul(al1, bh1)) | 0;
        mid = (mid + Math.imul(ah1, bl1)) | 0;
        hi = (hi + Math.imul(ah1, bh1)) | 0;
        lo = (lo + Math.imul(al0, bl2)) | 0;
        mid = (mid + Math.imul(al0, bh2)) | 0;
        mid = (mid + Math.imul(ah0, bl2)) | 0;
        hi = (hi + Math.imul(ah0, bh2)) | 0;
        var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = (mid + Math.imul(ah3, bl0)) | 0;
        hi = Math.imul(ah3, bh0);
        lo = (lo + Math.imul(al2, bl1)) | 0;
        mid = (mid + Math.imul(al2, bh1)) | 0;
        mid = (mid + Math.imul(ah2, bl1)) | 0;
        hi = (hi + Math.imul(ah2, bh1)) | 0;
        lo = (lo + Math.imul(al1, bl2)) | 0;
        mid = (mid + Math.imul(al1, bh2)) | 0;
        mid = (mid + Math.imul(ah1, bl2)) | 0;
        hi = (hi + Math.imul(ah1, bh2)) | 0;
        lo = (lo + Math.imul(al0, bl3)) | 0;
        mid = (mid + Math.imul(al0, bh3)) | 0;
        mid = (mid + Math.imul(ah0, bl3)) | 0;
        hi = (hi + Math.imul(ah0, bh3)) | 0;
        var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = (mid + Math.imul(ah4, bl0)) | 0;
        hi = Math.imul(ah4, bh0);
        lo = (lo + Math.imul(al3, bl1)) | 0;
        mid = (mid + Math.imul(al3, bh1)) | 0;
        mid = (mid + Math.imul(ah3, bl1)) | 0;
        hi = (hi + Math.imul(ah3, bh1)) | 0;
        lo = (lo + Math.imul(al2, bl2)) | 0;
        mid = (mid + Math.imul(al2, bh2)) | 0;
        mid = (mid + Math.imul(ah2, bl2)) | 0;
        hi = (hi + Math.imul(ah2, bh2)) | 0;
        lo = (lo + Math.imul(al1, bl3)) | 0;
        mid = (mid + Math.imul(al1, bh3)) | 0;
        mid = (mid + Math.imul(ah1, bl3)) | 0;
        hi = (hi + Math.imul(ah1, bh3)) | 0;
        lo = (lo + Math.imul(al0, bl4)) | 0;
        mid = (mid + Math.imul(al0, bh4)) | 0;
        mid = (mid + Math.imul(ah0, bl4)) | 0;
        hi = (hi + Math.imul(ah0, bh4)) | 0;
        var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = (mid + Math.imul(ah5, bl0)) | 0;
        hi = Math.imul(ah5, bh0);
        lo = (lo + Math.imul(al4, bl1)) | 0;
        mid = (mid + Math.imul(al4, bh1)) | 0;
        mid = (mid + Math.imul(ah4, bl1)) | 0;
        hi = (hi + Math.imul(ah4, bh1)) | 0;
        lo = (lo + Math.imul(al3, bl2)) | 0;
        mid = (mid + Math.imul(al3, bh2)) | 0;
        mid = (mid + Math.imul(ah3, bl2)) | 0;
        hi = (hi + Math.imul(ah3, bh2)) | 0;
        lo = (lo + Math.imul(al2, bl3)) | 0;
        mid = (mid + Math.imul(al2, bh3)) | 0;
        mid = (mid + Math.imul(ah2, bl3)) | 0;
        hi = (hi + Math.imul(ah2, bh3)) | 0;
        lo = (lo + Math.imul(al1, bl4)) | 0;
        mid = (mid + Math.imul(al1, bh4)) | 0;
        mid = (mid + Math.imul(ah1, bl4)) | 0;
        hi = (hi + Math.imul(ah1, bh4)) | 0;
        lo = (lo + Math.imul(al0, bl5)) | 0;
        mid = (mid + Math.imul(al0, bh5)) | 0;
        mid = (mid + Math.imul(ah0, bl5)) | 0;
        hi = (hi + Math.imul(ah0, bh5)) | 0;
        var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = (mid + Math.imul(ah6, bl0)) | 0;
        hi = Math.imul(ah6, bh0);
        lo = (lo + Math.imul(al5, bl1)) | 0;
        mid = (mid + Math.imul(al5, bh1)) | 0;
        mid = (mid + Math.imul(ah5, bl1)) | 0;
        hi = (hi + Math.imul(ah5, bh1)) | 0;
        lo = (lo + Math.imul(al4, bl2)) | 0;
        mid = (mid + Math.imul(al4, bh2)) | 0;
        mid = (mid + Math.imul(ah4, bl2)) | 0;
        hi = (hi + Math.imul(ah4, bh2)) | 0;
        lo = (lo + Math.imul(al3, bl3)) | 0;
        mid = (mid + Math.imul(al3, bh3)) | 0;
        mid = (mid + Math.imul(ah3, bl3)) | 0;
        hi = (hi + Math.imul(ah3, bh3)) | 0;
        lo = (lo + Math.imul(al2, bl4)) | 0;
        mid = (mid + Math.imul(al2, bh4)) | 0;
        mid = (mid + Math.imul(ah2, bl4)) | 0;
        hi = (hi + Math.imul(ah2, bh4)) | 0;
        lo = (lo + Math.imul(al1, bl5)) | 0;
        mid = (mid + Math.imul(al1, bh5)) | 0;
        mid = (mid + Math.imul(ah1, bl5)) | 0;
        hi = (hi + Math.imul(ah1, bh5)) | 0;
        lo = (lo + Math.imul(al0, bl6)) | 0;
        mid = (mid + Math.imul(al0, bh6)) | 0;
        mid = (mid + Math.imul(ah0, bl6)) | 0;
        hi = (hi + Math.imul(ah0, bh6)) | 0;
        var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = (mid + Math.imul(ah7, bl0)) | 0;
        hi = Math.imul(ah7, bh0);
        lo = (lo + Math.imul(al6, bl1)) | 0;
        mid = (mid + Math.imul(al6, bh1)) | 0;
        mid = (mid + Math.imul(ah6, bl1)) | 0;
        hi = (hi + Math.imul(ah6, bh1)) | 0;
        lo = (lo + Math.imul(al5, bl2)) | 0;
        mid = (mid + Math.imul(al5, bh2)) | 0;
        mid = (mid + Math.imul(ah5, bl2)) | 0;
        hi = (hi + Math.imul(ah5, bh2)) | 0;
        lo = (lo + Math.imul(al4, bl3)) | 0;
        mid = (mid + Math.imul(al4, bh3)) | 0;
        mid = (mid + Math.imul(ah4, bl3)) | 0;
        hi = (hi + Math.imul(ah4, bh3)) | 0;
        lo = (lo + Math.imul(al3, bl4)) | 0;
        mid = (mid + Math.imul(al3, bh4)) | 0;
        mid = (mid + Math.imul(ah3, bl4)) | 0;
        hi = (hi + Math.imul(ah3, bh4)) | 0;
        lo = (lo + Math.imul(al2, bl5)) | 0;
        mid = (mid + Math.imul(al2, bh5)) | 0;
        mid = (mid + Math.imul(ah2, bl5)) | 0;
        hi = (hi + Math.imul(ah2, bh5)) | 0;
        lo = (lo + Math.imul(al1, bl6)) | 0;
        mid = (mid + Math.imul(al1, bh6)) | 0;
        mid = (mid + Math.imul(ah1, bl6)) | 0;
        hi = (hi + Math.imul(ah1, bh6)) | 0;
        lo = (lo + Math.imul(al0, bl7)) | 0;
        mid = (mid + Math.imul(al0, bh7)) | 0;
        mid = (mid + Math.imul(ah0, bl7)) | 0;
        hi = (hi + Math.imul(ah0, bh7)) | 0;
        var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = (mid + Math.imul(ah8, bl0)) | 0;
        hi = Math.imul(ah8, bh0);
        lo = (lo + Math.imul(al7, bl1)) | 0;
        mid = (mid + Math.imul(al7, bh1)) | 0;
        mid = (mid + Math.imul(ah7, bl1)) | 0;
        hi = (hi + Math.imul(ah7, bh1)) | 0;
        lo = (lo + Math.imul(al6, bl2)) | 0;
        mid = (mid + Math.imul(al6, bh2)) | 0;
        mid = (mid + Math.imul(ah6, bl2)) | 0;
        hi = (hi + Math.imul(ah6, bh2)) | 0;
        lo = (lo + Math.imul(al5, bl3)) | 0;
        mid = (mid + Math.imul(al5, bh3)) | 0;
        mid = (mid + Math.imul(ah5, bl3)) | 0;
        hi = (hi + Math.imul(ah5, bh3)) | 0;
        lo = (lo + Math.imul(al4, bl4)) | 0;
        mid = (mid + Math.imul(al4, bh4)) | 0;
        mid = (mid + Math.imul(ah4, bl4)) | 0;
        hi = (hi + Math.imul(ah4, bh4)) | 0;
        lo = (lo + Math.imul(al3, bl5)) | 0;
        mid = (mid + Math.imul(al3, bh5)) | 0;
        mid = (mid + Math.imul(ah3, bl5)) | 0;
        hi = (hi + Math.imul(ah3, bh5)) | 0;
        lo = (lo + Math.imul(al2, bl6)) | 0;
        mid = (mid + Math.imul(al2, bh6)) | 0;
        mid = (mid + Math.imul(ah2, bl6)) | 0;
        hi = (hi + Math.imul(ah2, bh6)) | 0;
        lo = (lo + Math.imul(al1, bl7)) | 0;
        mid = (mid + Math.imul(al1, bh7)) | 0;
        mid = (mid + Math.imul(ah1, bl7)) | 0;
        hi = (hi + Math.imul(ah1, bh7)) | 0;
        lo = (lo + Math.imul(al0, bl8)) | 0;
        mid = (mid + Math.imul(al0, bh8)) | 0;
        mid = (mid + Math.imul(ah0, bl8)) | 0;
        hi = (hi + Math.imul(ah0, bh8)) | 0;
        var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = (mid + Math.imul(ah9, bl0)) | 0;
        hi = Math.imul(ah9, bh0);
        lo = (lo + Math.imul(al8, bl1)) | 0;
        mid = (mid + Math.imul(al8, bh1)) | 0;
        mid = (mid + Math.imul(ah8, bl1)) | 0;
        hi = (hi + Math.imul(ah8, bh1)) | 0;
        lo = (lo + Math.imul(al7, bl2)) | 0;
        mid = (mid + Math.imul(al7, bh2)) | 0;
        mid = (mid + Math.imul(ah7, bl2)) | 0;
        hi = (hi + Math.imul(ah7, bh2)) | 0;
        lo = (lo + Math.imul(al6, bl3)) | 0;
        mid = (mid + Math.imul(al6, bh3)) | 0;
        mid = (mid + Math.imul(ah6, bl3)) | 0;
        hi = (hi + Math.imul(ah6, bh3)) | 0;
        lo = (lo + Math.imul(al5, bl4)) | 0;
        mid = (mid + Math.imul(al5, bh4)) | 0;
        mid = (mid + Math.imul(ah5, bl4)) | 0;
        hi = (hi + Math.imul(ah5, bh4)) | 0;
        lo = (lo + Math.imul(al4, bl5)) | 0;
        mid = (mid + Math.imul(al4, bh5)) | 0;
        mid = (mid + Math.imul(ah4, bl5)) | 0;
        hi = (hi + Math.imul(ah4, bh5)) | 0;
        lo = (lo + Math.imul(al3, bl6)) | 0;
        mid = (mid + Math.imul(al3, bh6)) | 0;
        mid = (mid + Math.imul(ah3, bl6)) | 0;
        hi = (hi + Math.imul(ah3, bh6)) | 0;
        lo = (lo + Math.imul(al2, bl7)) | 0;
        mid = (mid + Math.imul(al2, bh7)) | 0;
        mid = (mid + Math.imul(ah2, bl7)) | 0;
        hi = (hi + Math.imul(ah2, bh7)) | 0;
        lo = (lo + Math.imul(al1, bl8)) | 0;
        mid = (mid + Math.imul(al1, bh8)) | 0;
        mid = (mid + Math.imul(ah1, bl8)) | 0;
        hi = (hi + Math.imul(ah1, bh8)) | 0;
        lo = (lo + Math.imul(al0, bl9)) | 0;
        mid = (mid + Math.imul(al0, bh9)) | 0;
        mid = (mid + Math.imul(ah0, bl9)) | 0;
        hi = (hi + Math.imul(ah0, bh9)) | 0;
        var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = (mid + Math.imul(ah9, bl1)) | 0;
        hi = Math.imul(ah9, bh1);
        lo = (lo + Math.imul(al8, bl2)) | 0;
        mid = (mid + Math.imul(al8, bh2)) | 0;
        mid = (mid + Math.imul(ah8, bl2)) | 0;
        hi = (hi + Math.imul(ah8, bh2)) | 0;
        lo = (lo + Math.imul(al7, bl3)) | 0;
        mid = (mid + Math.imul(al7, bh3)) | 0;
        mid = (mid + Math.imul(ah7, bl3)) | 0;
        hi = (hi + Math.imul(ah7, bh3)) | 0;
        lo = (lo + Math.imul(al6, bl4)) | 0;
        mid = (mid + Math.imul(al6, bh4)) | 0;
        mid = (mid + Math.imul(ah6, bl4)) | 0;
        hi = (hi + Math.imul(ah6, bh4)) | 0;
        lo = (lo + Math.imul(al5, bl5)) | 0;
        mid = (mid + Math.imul(al5, bh5)) | 0;
        mid = (mid + Math.imul(ah5, bl5)) | 0;
        hi = (hi + Math.imul(ah5, bh5)) | 0;
        lo = (lo + Math.imul(al4, bl6)) | 0;
        mid = (mid + Math.imul(al4, bh6)) | 0;
        mid = (mid + Math.imul(ah4, bl6)) | 0;
        hi = (hi + Math.imul(ah4, bh6)) | 0;
        lo = (lo + Math.imul(al3, bl7)) | 0;
        mid = (mid + Math.imul(al3, bh7)) | 0;
        mid = (mid + Math.imul(ah3, bl7)) | 0;
        hi = (hi + Math.imul(ah3, bh7)) | 0;
        lo = (lo + Math.imul(al2, bl8)) | 0;
        mid = (mid + Math.imul(al2, bh8)) | 0;
        mid = (mid + Math.imul(ah2, bl8)) | 0;
        hi = (hi + Math.imul(ah2, bh8)) | 0;
        lo = (lo + Math.imul(al1, bl9)) | 0;
        mid = (mid + Math.imul(al1, bh9)) | 0;
        mid = (mid + Math.imul(ah1, bl9)) | 0;
        hi = (hi + Math.imul(ah1, bh9)) | 0;
        var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = (mid + Math.imul(ah9, bl2)) | 0;
        hi = Math.imul(ah9, bh2);
        lo = (lo + Math.imul(al8, bl3)) | 0;
        mid = (mid + Math.imul(al8, bh3)) | 0;
        mid = (mid + Math.imul(ah8, bl3)) | 0;
        hi = (hi + Math.imul(ah8, bh3)) | 0;
        lo = (lo + Math.imul(al7, bl4)) | 0;
        mid = (mid + Math.imul(al7, bh4)) | 0;
        mid = (mid + Math.imul(ah7, bl4)) | 0;
        hi = (hi + Math.imul(ah7, bh4)) | 0;
        lo = (lo + Math.imul(al6, bl5)) | 0;
        mid = (mid + Math.imul(al6, bh5)) | 0;
        mid = (mid + Math.imul(ah6, bl5)) | 0;
        hi = (hi + Math.imul(ah6, bh5)) | 0;
        lo = (lo + Math.imul(al5, bl6)) | 0;
        mid = (mid + Math.imul(al5, bh6)) | 0;
        mid = (mid + Math.imul(ah5, bl6)) | 0;
        hi = (hi + Math.imul(ah5, bh6)) | 0;
        lo = (lo + Math.imul(al4, bl7)) | 0;
        mid = (mid + Math.imul(al4, bh7)) | 0;
        mid = (mid + Math.imul(ah4, bl7)) | 0;
        hi = (hi + Math.imul(ah4, bh7)) | 0;
        lo = (lo + Math.imul(al3, bl8)) | 0;
        mid = (mid + Math.imul(al3, bh8)) | 0;
        mid = (mid + Math.imul(ah3, bl8)) | 0;
        hi = (hi + Math.imul(ah3, bh8)) | 0;
        lo = (lo + Math.imul(al2, bl9)) | 0;
        mid = (mid + Math.imul(al2, bh9)) | 0;
        mid = (mid + Math.imul(ah2, bl9)) | 0;
        hi = (hi + Math.imul(ah2, bh9)) | 0;
        var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = (mid + Math.imul(ah9, bl3)) | 0;
        hi = Math.imul(ah9, bh3);
        lo = (lo + Math.imul(al8, bl4)) | 0;
        mid = (mid + Math.imul(al8, bh4)) | 0;
        mid = (mid + Math.imul(ah8, bl4)) | 0;
        hi = (hi + Math.imul(ah8, bh4)) | 0;
        lo = (lo + Math.imul(al7, bl5)) | 0;
        mid = (mid + Math.imul(al7, bh5)) | 0;
        mid = (mid + Math.imul(ah7, bl5)) | 0;
        hi = (hi + Math.imul(ah7, bh5)) | 0;
        lo = (lo + Math.imul(al6, bl6)) | 0;
        mid = (mid + Math.imul(al6, bh6)) | 0;
        mid = (mid + Math.imul(ah6, bl6)) | 0;
        hi = (hi + Math.imul(ah6, bh6)) | 0;
        lo = (lo + Math.imul(al5, bl7)) | 0;
        mid = (mid + Math.imul(al5, bh7)) | 0;
        mid = (mid + Math.imul(ah5, bl7)) | 0;
        hi = (hi + Math.imul(ah5, bh7)) | 0;
        lo = (lo + Math.imul(al4, bl8)) | 0;
        mid = (mid + Math.imul(al4, bh8)) | 0;
        mid = (mid + Math.imul(ah4, bl8)) | 0;
        hi = (hi + Math.imul(ah4, bh8)) | 0;
        lo = (lo + Math.imul(al3, bl9)) | 0;
        mid = (mid + Math.imul(al3, bh9)) | 0;
        mid = (mid + Math.imul(ah3, bl9)) | 0;
        hi = (hi + Math.imul(ah3, bh9)) | 0;
        var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = (mid + Math.imul(ah9, bl4)) | 0;
        hi = Math.imul(ah9, bh4);
        lo = (lo + Math.imul(al8, bl5)) | 0;
        mid = (mid + Math.imul(al8, bh5)) | 0;
        mid = (mid + Math.imul(ah8, bl5)) | 0;
        hi = (hi + Math.imul(ah8, bh5)) | 0;
        lo = (lo + Math.imul(al7, bl6)) | 0;
        mid = (mid + Math.imul(al7, bh6)) | 0;
        mid = (mid + Math.imul(ah7, bl6)) | 0;
        hi = (hi + Math.imul(ah7, bh6)) | 0;
        lo = (lo + Math.imul(al6, bl7)) | 0;
        mid = (mid + Math.imul(al6, bh7)) | 0;
        mid = (mid + Math.imul(ah6, bl7)) | 0;
        hi = (hi + Math.imul(ah6, bh7)) | 0;
        lo = (lo + Math.imul(al5, bl8)) | 0;
        mid = (mid + Math.imul(al5, bh8)) | 0;
        mid = (mid + Math.imul(ah5, bl8)) | 0;
        hi = (hi + Math.imul(ah5, bh8)) | 0;
        lo = (lo + Math.imul(al4, bl9)) | 0;
        mid = (mid + Math.imul(al4, bh9)) | 0;
        mid = (mid + Math.imul(ah4, bl9)) | 0;
        hi = (hi + Math.imul(ah4, bh9)) | 0;
        var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = (mid + Math.imul(ah9, bl5)) | 0;
        hi = Math.imul(ah9, bh5);
        lo = (lo + Math.imul(al8, bl6)) | 0;
        mid = (mid + Math.imul(al8, bh6)) | 0;
        mid = (mid + Math.imul(ah8, bl6)) | 0;
        hi = (hi + Math.imul(ah8, bh6)) | 0;
        lo = (lo + Math.imul(al7, bl7)) | 0;
        mid = (mid + Math.imul(al7, bh7)) | 0;
        mid = (mid + Math.imul(ah7, bl7)) | 0;
        hi = (hi + Math.imul(ah7, bh7)) | 0;
        lo = (lo + Math.imul(al6, bl8)) | 0;
        mid = (mid + Math.imul(al6, bh8)) | 0;
        mid = (mid + Math.imul(ah6, bl8)) | 0;
        hi = (hi + Math.imul(ah6, bh8)) | 0;
        lo = (lo + Math.imul(al5, bl9)) | 0;
        mid = (mid + Math.imul(al5, bh9)) | 0;
        mid = (mid + Math.imul(ah5, bl9)) | 0;
        hi = (hi + Math.imul(ah5, bh9)) | 0;
        var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = (mid + Math.imul(ah9, bl6)) | 0;
        hi = Math.imul(ah9, bh6);
        lo = (lo + Math.imul(al8, bl7)) | 0;
        mid = (mid + Math.imul(al8, bh7)) | 0;
        mid = (mid + Math.imul(ah8, bl7)) | 0;
        hi = (hi + Math.imul(ah8, bh7)) | 0;
        lo = (lo + Math.imul(al7, bl8)) | 0;
        mid = (mid + Math.imul(al7, bh8)) | 0;
        mid = (mid + Math.imul(ah7, bl8)) | 0;
        hi = (hi + Math.imul(ah7, bh8)) | 0;
        lo = (lo + Math.imul(al6, bl9)) | 0;
        mid = (mid + Math.imul(al6, bh9)) | 0;
        mid = (mid + Math.imul(ah6, bl9)) | 0;
        hi = (hi + Math.imul(ah6, bh9)) | 0;
        var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = (mid + Math.imul(ah9, bl7)) | 0;
        hi = Math.imul(ah9, bh7);
        lo = (lo + Math.imul(al8, bl8)) | 0;
        mid = (mid + Math.imul(al8, bh8)) | 0;
        mid = (mid + Math.imul(ah8, bl8)) | 0;
        hi = (hi + Math.imul(ah8, bh8)) | 0;
        lo = (lo + Math.imul(al7, bl9)) | 0;
        mid = (mid + Math.imul(al7, bh9)) | 0;
        mid = (mid + Math.imul(ah7, bl9)) | 0;
        hi = (hi + Math.imul(ah7, bh9)) | 0;
        var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = (mid + Math.imul(ah9, bl8)) | 0;
        hi = Math.imul(ah9, bh8);
        lo = (lo + Math.imul(al8, bl9)) | 0;
        mid = (mid + Math.imul(al8, bh9)) | 0;
        mid = (mid + Math.imul(ah8, bl9)) | 0;
        hi = (hi + Math.imul(ah8, bh9)) | 0;
        var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = (mid + Math.imul(ah9, bl9)) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
        c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
    
      // Polyfill comb
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
    
      function bigMulTo (self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
    
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          // Sum all words with the same `i + j = k` and accumulate `ncarry`,
          // note that ncarry could be >= 0x3ffffff
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
    
            var lo = r & 0x3ffffff;
            ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
            lo = (lo + rword) | 0;
            rword = lo & 0x3ffffff;
            ncarry = (ncarry + (lo >>> 26)) | 0;
    
            hncarry += ncarry >>> 26;
            ncarry &= 0x3ffffff;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
    
        return out._strip();
      }
    
      function jumboMulTo (self, num, out) {
        // Temporary disable, see https://github.com/indutny/bn.js/issues/211
        // var fftm = new FFTM();
        // return fftm.mulp(self, num, out);
        return bigMulTo(self, num, out);
      }
    
      BN.prototype.mulTo = function mulTo (num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
    
        return res;
      };
    
      // Cooley-Tukey algorithm for FFT
      // slightly revisited to rely on looping instead of recursion
    
      function FFTM (x, y) {
        this.x = x;
        this.y = y;
      }
    
      FFTM.prototype.makeRBT = function makeRBT (N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
    
        return t;
      };
    
      // Returns binary-reversed representation of `x`
      FFTM.prototype.revBin = function revBin (x, l, N) {
        if (x === 0 || x === N - 1) return x;
    
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << (l - i - 1);
          x >>= 1;
        }
    
        return rb;
      };
    
      // Performs "tweedling" phase, therefore 'emulating'
      // behaviour of the recursive algorithm
      FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
    
      FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
    
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
    
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
    
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
    
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
    
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
    
              var rx = rtwdf_ * ro - itwdf_ * io;
    
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
    
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
    
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
    
              /* jshint maxdepth : false */
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
    
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
    
      FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
    
        return 1 << i + 1 + odd;
      };
    
      FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
        if (N <= 1) return;
    
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
    
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
    
          t = iws[i];
    
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
    
      FFTM.prototype.normalize13b = function normalize13b (ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
            Math.round(ws[2 * i] / N) +
            carry;
    
          ws[i] = w & 0x3ffffff;
    
          if (w < 0x4000000) {
            carry = 0;
          } else {
            carry = w / 0x4000000 | 0;
          }
        }
    
        return ws;
      };
    
      FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
    
          rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
          rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
        }
    
        // Pad with zeroes
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
    
        assert(carry === 0);
        assert((carry & ~0x1fff) === 0);
      };
    
      FFTM.prototype.stub = function stub (N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
    
        return ph;
      };
    
      FFTM.prototype.mulp = function mulp (x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
    
        var rbt = this.makeRBT(N);
    
        var _ = this.stub(N);
    
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
    
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
    
        var rmws = out.words;
        rmws.length = N;
    
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
    
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
    
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
    
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
    
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
    
      // Multiply `this` by `num`
      BN.prototype.mul = function mul (num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
    
      // Multiply employing FFT
      BN.prototype.mulf = function mulf (num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
    
      // In-place Multiplication
      BN.prototype.imul = function imul (num) {
        return this.clone().mulTo(num, this);
      };
    
      BN.prototype.imuln = function imuln (num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
    
        assert(typeof num === 'number');
        assert(num < 0x4000000);
    
        // Carry
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
          carry >>= 26;
          carry += (w / 0x4000000) | 0;
          // NOTE: lo is 27bit maximum
          carry += lo >>> 26;
          this.words[i] = lo & 0x3ffffff;
        }
    
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
    
        return isNegNum ? this.ineg() : this;
      };
    
      BN.prototype.muln = function muln (num) {
        return this.clone().imuln(num);
      };
    
      // `this` * `this`
      BN.prototype.sqr = function sqr () {
        return this.mul(this);
      };
    
      // `this` * `this` in-place
      BN.prototype.isqr = function isqr () {
        return this.imul(this.clone());
      };
    
      // Math.pow(`this`, `num`)
      BN.prototype.pow = function pow (num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
    
        // Skip leading zeroes
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
    
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
    
            res = res.mul(q);
          }
        }
    
        return res;
      };
    
      // Shift-left in-place
      BN.prototype.iushln = function iushln (bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
        var i;
    
        if (r !== 0) {
          var carry = 0;
    
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = ((this.words[i] | 0) - newCarry) << r;
            this.words[i] = c | carry;
            carry = newCarry >>> (26 - r);
          }
    
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
    
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
    
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
    
          this.length += s;
        }
    
        return this._strip();
      };
    
      BN.prototype.ishln = function ishln (bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
      };
    
      // Shift-right in-place
      // NOTE: `hint` is a lowest bit before trailing zeroes
      // NOTE: if `extended` is present - it will be filled with destroyed bits
      BN.prototype.iushrn = function iushrn (bits, hint, extended) {
        assert(typeof bits === 'number' && bits >= 0);
        var h;
        if (hint) {
          h = (hint - (hint % 26)) / 26;
        } else {
          h = 0;
        }
    
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
        var maskedWords = extended;
    
        h -= s;
        h = Math.max(0, h);
    
        // Extended mode, copy masked part
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
    
        if (s === 0) {
          // No-op, we should not move anything at all
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
    
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = (carry << (26 - r)) | (word >>> r);
          carry = word & mask;
        }
    
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
    
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
    
        return this._strip();
      };
    
      BN.prototype.ishrn = function ishrn (bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
    
      // Shift-left
      BN.prototype.shln = function shln (bits) {
        return this.clone().ishln(bits);
      };
    
      BN.prototype.ushln = function ushln (bits) {
        return this.clone().iushln(bits);
      };
    
      // Shift-right
      BN.prototype.shrn = function shrn (bits) {
        return this.clone().ishrn(bits);
      };
    
      BN.prototype.ushrn = function ushrn (bits) {
        return this.clone().iushrn(bits);
      };
    
      // Test if n bit is set
      BN.prototype.testn = function testn (bit) {
        assert(typeof bit === 'number' && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
    
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
    
        // Check bit and return
        var w = this.words[s];
    
        return !!(w & q);
      };
    
      // Return only lowers bits of number (in-place)
      BN.prototype.imaskn = function imaskn (bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
    
        assert(this.negative === 0, 'imaskn works only with positive numbers');
    
        if (this.length <= s) {
          return this;
        }
    
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
    
        if (r !== 0) {
          var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
          this.words[this.length - 1] &= mask;
        }
    
        return this._strip();
      };
    
      // Return only lowers bits of number
      BN.prototype.maskn = function maskn (bits) {
        return this.clone().imaskn(bits);
      };
    
      // Add plain number `num` to `this`
      BN.prototype.iaddn = function iaddn (num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
    
        // Possible sign change
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
    
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
    
        // Add without checks
        return this._iaddn(num);
      };
    
      BN.prototype._iaddn = function _iaddn (num) {
        this.words[0] += num;
    
        // Carry
        for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
          this.words[i] -= 0x4000000;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
    
        return this;
      };
    
      // Subtract plain number `num` from `this`
      BN.prototype.isubn = function isubn (num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
    
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
    
        this.words[0] -= num;
    
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          // Carry
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
          }
        }
    
        return this._strip();
      };
    
      BN.prototype.addn = function addn (num) {
        return this.clone().iaddn(num);
      };
    
      BN.prototype.subn = function subn (num) {
        return this.clone().isubn(num);
      };
    
      BN.prototype.iabs = function iabs () {
        this.negative = 0;
    
        return this;
      };
    
      BN.prototype.abs = function abs () {
        return this.clone().iabs();
      };
    
      BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
        var len = num.length + shift;
        var i;
    
        this._expand(len);
    
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 0x3ffffff;
          carry = (w >> 26) - ((right / 0x4000000) | 0);
          this.words[i + shift] = w & 0x3ffffff;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 0x3ffffff;
        }
    
        if (carry === 0) return this._strip();
    
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
    
        return this._strip();
      };
    
      BN.prototype._wordDiv = function _wordDiv (num, mode) {
        var shift = this.length - num.length;
    
        var a = this.clone();
        var b = num;
    
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
    
        // Initialize quotient
        var m = a.length - b.length;
        var q;
    
        if (mode !== 'mod') {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
    
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
    
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 0x4000000 +
            (a.words[b.length + j - 1] | 0);
    
          // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
          // (0x7ffffff)
          qj = Math.min((qj / bhi) | 0, 0x3ffffff);
    
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
    
        // Denormalize
        if (mode !== 'div' && shift !== 0) {
          a.iushrn(shift);
        }
    
        return {
          div: q || null,
          mod: a
        };
      };
    
      // NOTE: 1) `mode` can be set to `mod` to request mod only,
      //       to `div` to request div only, or be absent to
      //       request both div & mod
      //       2) `positive` is true if unsigned mod is requested
      BN.prototype.divmod = function divmod (num, mode, positive) {
        assert(!num.isZero());
    
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
    
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
    
          if (mode !== 'mod') {
            div = res.div.neg();
          }
    
          if (mode !== 'div') {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
    
          return {
            div: div,
            mod: mod
          };
        }
    
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
    
          if (mode !== 'mod') {
            div = res.div.neg();
          }
    
          return {
            div: div,
            mod: res.mod
          };
        }
    
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
    
          if (mode !== 'div') {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
    
          return {
            div: res.div,
            mod: mod
          };
        }
    
        // Both numbers are positive at this point
    
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
    
        // Very short reduction
        if (num.length === 1) {
          if (mode === 'div') {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
    
          if (mode === 'mod') {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }
    
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }
    
        return this._wordDiv(num, mode);
      };
    
      // Find `this` / `num`
      BN.prototype.div = function div (num) {
        return this.divmod(num, 'div', false).div;
      };
    
      // Find `this` % `num`
      BN.prototype.mod = function mod (num) {
        return this.divmod(num, 'mod', false).mod;
      };
    
      BN.prototype.umod = function umod (num) {
        return this.divmod(num, 'mod', true).mod;
      };
    
      // Find Round(`this` / `num`)
      BN.prototype.divRound = function divRound (num) {
        var dm = this.divmod(num);
    
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
    
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
    
        // Round down
        if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;
    
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
    
      BN.prototype.modrn = function modrn (num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
    
        assert(num <= 0x3ffffff);
        var p = (1 << 26) % num;
    
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
    
        return isNegNum ? -acc : acc;
      };
    
      // WARNING: DEPRECATED
      BN.prototype.modn = function modn (num) {
        return this.modrn(num);
      };
    
      // In-place division by number
      BN.prototype.idivn = function idivn (num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
    
        assert(num <= 0x3ffffff);
    
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 0x4000000;
          this.words[i] = (w / num) | 0;
          carry = w % num;
        }
    
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
    
      BN.prototype.divn = function divn (num) {
        return this.clone().idivn(num);
      };
    
      BN.prototype.egcd = function egcd (p) {
        assert(p.negative === 0);
        assert(!p.isZero());
    
        var x = this;
        var y = p.clone();
    
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
    
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
    
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
    
        var g = 0;
    
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
    
        var yp = y.clone();
        var xp = x.clone();
    
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
    
              A.iushrn(1);
              B.iushrn(1);
            }
          }
    
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
    
              C.iushrn(1);
              D.iushrn(1);
            }
          }
    
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
    
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
    
      // This is reduced incarnation of the binary EEA
      // above, designated to invert members of the
      // _prime_ fields F(p) at a maximal speed
      BN.prototype._invmp = function _invmp (p) {
        assert(p.negative === 0);
        assert(!p.isZero());
    
        var a = this;
        var b = p.clone();
    
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
    
        var x1 = new BN(1);
        var x2 = new BN(0);
    
        var delta = b.clone();
    
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
    
              x1.iushrn(1);
            }
          }
    
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
    
              x2.iushrn(1);
            }
          }
    
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
    
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
    
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
    
        return res;
      };
    
      BN.prototype.gcd = function gcd (num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
    
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
    
        // Remove common factor of two
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
    
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
    
          var r = a.cmp(b);
          if (r < 0) {
            // Swap `a` and `b` to make `a` always bigger than `b`
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
    
          a.isub(b);
        } while (true);
    
        return b.iushln(shift);
      };
    
      // Invert number in the field F(num)
      BN.prototype.invm = function invm (num) {
        return this.egcd(num).a.umod(num);
      };
    
      BN.prototype.isEven = function isEven () {
        return (this.words[0] & 1) === 0;
      };
    
      BN.prototype.isOdd = function isOdd () {
        return (this.words[0] & 1) === 1;
      };
    
      // And first word and num
      BN.prototype.andln = function andln (num) {
        return this.words[0] & num;
      };
    
      // Increment at the bit position in-line
      BN.prototype.bincn = function bincn (bit) {
        assert(typeof bit === 'number');
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
    
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
    
        // Add bit and propagate, if needed
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 0x3ffffff;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
    
      BN.prototype.isZero = function isZero () {
        return this.length === 1 && this.words[0] === 0;
      };
    
      BN.prototype.cmpn = function cmpn (num) {
        var negative = num < 0;
    
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
    
        this._strip();
    
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
    
          assert(num <= 0x3ffffff, 'Number is too big');
    
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
    
      // Compare two numbers and return:
      // 1 - if `this` > `num`
      // 0 - if `this` == `num`
      // -1 - if `this` < `num`
      BN.prototype.cmp = function cmp (num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
    
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
    
      // Unsigned comparison
      BN.prototype.ucmp = function ucmp (num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
    
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
    
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
    
      BN.prototype.gtn = function gtn (num) {
        return this.cmpn(num) === 1;
      };
    
      BN.prototype.gt = function gt (num) {
        return this.cmp(num) === 1;
      };
    
      BN.prototype.gten = function gten (num) {
        return this.cmpn(num) >= 0;
      };
    
      BN.prototype.gte = function gte (num) {
        return this.cmp(num) >= 0;
      };
    
      BN.prototype.ltn = function ltn (num) {
        return this.cmpn(num) === -1;
      };
    
      BN.prototype.lt = function lt (num) {
        return this.cmp(num) === -1;
      };
    
      BN.prototype.lten = function lten (num) {
        return this.cmpn(num) <= 0;
      };
    
      BN.prototype.lte = function lte (num) {
        return this.cmp(num) <= 0;
      };
    
      BN.prototype.eqn = function eqn (num) {
        return this.cmpn(num) === 0;
      };
    
      BN.prototype.eq = function eq (num) {
        return this.cmp(num) === 0;
      };
    
      //
      // A reduce context, could be using montgomery or something better, depending
      // on the `m` itself.
      //
      BN.red = function red (num) {
        return new Red(num);
      };
    
      BN.prototype.toRed = function toRed (ctx) {
        assert(!this.red, 'Already a number in reduction context');
        assert(this.negative === 0, 'red works only with positives');
        return ctx.convertTo(this)._forceRed(ctx);
      };
    
      BN.prototype.fromRed = function fromRed () {
        assert(this.red, 'fromRed works only with numbers in reduction context');
        return this.red.convertFrom(this);
      };
    
      BN.prototype._forceRed = function _forceRed (ctx) {
        this.red = ctx;
        return this;
      };
    
      BN.prototype.forceRed = function forceRed (ctx) {
        assert(!this.red, 'Already a number in reduction context');
        return this._forceRed(ctx);
      };
    
      BN.prototype.redAdd = function redAdd (num) {
        assert(this.red, 'redAdd works only with red numbers');
        return this.red.add(this, num);
      };
    
      BN.prototype.redIAdd = function redIAdd (num) {
        assert(this.red, 'redIAdd works only with red numbers');
        return this.red.iadd(this, num);
      };
    
      BN.prototype.redSub = function redSub (num) {
        assert(this.red, 'redSub works only with red numbers');
        return this.red.sub(this, num);
      };
    
      BN.prototype.redISub = function redISub (num) {
        assert(this.red, 'redISub works only with red numbers');
        return this.red.isub(this, num);
      };
    
      BN.prototype.redShl = function redShl (num) {
        assert(this.red, 'redShl works only with red numbers');
        return this.red.shl(this, num);
      };
    
      BN.prototype.redMul = function redMul (num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
    
      BN.prototype.redIMul = function redIMul (num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
    
      BN.prototype.redSqr = function redSqr () {
        assert(this.red, 'redSqr works only with red numbers');
        this.red._verify1(this);
        return this.red.sqr(this);
      };
    
      BN.prototype.redISqr = function redISqr () {
        assert(this.red, 'redISqr works only with red numbers');
        this.red._verify1(this);
        return this.red.isqr(this);
      };
    
      // Square root over p
      BN.prototype.redSqrt = function redSqrt () {
        assert(this.red, 'redSqrt works only with red numbers');
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
    
      BN.prototype.redInvm = function redInvm () {
        assert(this.red, 'redInvm works only with red numbers');
        this.red._verify1(this);
        return this.red.invm(this);
      };
    
      // Return negative clone of `this` % `red modulo`
      BN.prototype.redNeg = function redNeg () {
        assert(this.red, 'redNeg works only with red numbers');
        this.red._verify1(this);
        return this.red.neg(this);
      };
    
      BN.prototype.redPow = function redPow (num) {
        assert(this.red && !num.red, 'redPow(normalNum)');
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
    
      // Prime numbers with efficient reduction
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
    
      // Pseudo-Mersenne prime
      function MPrime (name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
    
        this.tmp = this._tmp();
      }
    
      MPrime.prototype._tmp = function _tmp () {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
    
      MPrime.prototype.ireduce = function ireduce (num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
    
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
    
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== undefined) {
            // r is a BN v4 instance
            r.strip();
          } else {
            // r is a BN v5 instance
            r._strip();
          }
        }
    
        return r;
      };
    
      MPrime.prototype.split = function split (input, out) {
        input.iushrn(this.n, 0, out);
      };
    
      MPrime.prototype.imulK = function imulK (num) {
        return num.imul(this.k);
      };
    
      function K256 () {
        MPrime.call(
          this,
          'k256',
          'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
      }
      inherits(K256, MPrime);
    
      K256.prototype.split = function split (input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
    
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
    
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
    
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
    
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
    
      K256.prototype.imulK = function imulK (num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
    
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 0x3d1;
          num.words[i] = lo & 0x3ffffff;
          lo = w * 0x40 + ((lo / 0x4000000) | 0);
        }
    
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
    
      function P224 () {
        MPrime.call(
          this,
          'p224',
          'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
      }
      inherits(P224, MPrime);
    
      function P192 () {
        MPrime.call(
          this,
          'p192',
          'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
      }
      inherits(P192, MPrime);
    
      function P25519 () {
        // 2 ^ 255 - 19
        MPrime.call(
          this,
          '25519',
          '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
      }
      inherits(P25519, MPrime);
    
      P25519.prototype.imulK = function imulK (num) {
        // K = 0x13
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 0x13 + carry;
          var lo = hi & 0x3ffffff;
          hi >>>= 26;
    
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
    
      // Exported mostly for testing purposes, use plain name instead
      BN._prime = function prime (name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
    
        var prime;
        if (name === 'k256') {
          prime = new K256();
        } else if (name === 'p224') {
          prime = new P224();
        } else if (name === 'p192') {
          prime = new P192();
        } else if (name === 'p25519') {
          prime = new P25519();
        } else {
          throw new Error('Unknown prime ' + name);
        }
        primes[name] = prime;
    
        return prime;
      };
    
      //
      // Base reduction engine
      //
      function Red (m) {
        if (typeof m === 'string') {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), 'modulus must be greater than 1');
          this.m = m;
          this.prime = null;
        }
      }
    
      Red.prototype._verify1 = function _verify1 (a) {
        assert(a.negative === 0, 'red works only with positives');
        assert(a.red, 'red works only with red numbers');
      };
    
      Red.prototype._verify2 = function _verify2 (a, b) {
        assert((a.negative | b.negative) === 0, 'red works only with positives');
        assert(a.red && a.red === b.red,
          'red works only with red numbers');
      };
    
      Red.prototype.imod = function imod (a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
    
      Red.prototype.neg = function neg (a) {
        if (a.isZero()) {
          return a.clone();
        }
    
        return this.m.sub(a)._forceRed(this);
      };
    
      Red.prototype.add = function add (a, b) {
        this._verify2(a, b);
    
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
    
      Red.prototype.iadd = function iadd (a, b) {
        this._verify2(a, b);
    
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
    
      Red.prototype.sub = function sub (a, b) {
        this._verify2(a, b);
    
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
    
      Red.prototype.isub = function isub (a, b) {
        this._verify2(a, b);
    
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
    
      Red.prototype.shl = function shl (a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
    
      Red.prototype.imul = function imul (a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
    
      Red.prototype.mul = function mul (a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
    
      Red.prototype.isqr = function isqr (a) {
        return this.imul(a, a.clone());
      };
    
      Red.prototype.sqr = function sqr (a) {
        return this.mul(a, a);
      };
    
      Red.prototype.sqrt = function sqrt (a) {
        if (a.isZero()) return a.clone();
    
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
    
        // Fast case
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
    
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
    
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
    
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
    
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
    
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
    
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
    
        return r;
      };
    
      Red.prototype.invm = function invm (a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
    
      Red.prototype.pow = function pow (a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
    
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
    
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
    
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = (word >> j) & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
    
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
    
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
    
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
    
        return res;
      };
    
      Red.prototype.convertTo = function convertTo (num) {
        var r = num.umod(this.m);
    
        return r === num ? r.clone() : r;
      };
    
      Red.prototype.convertFrom = function convertFrom (num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
    
      //
      // Montgomery method engine
      //
    
      BN.mont = function mont (num) {
        return new Mont(num);
      };
    
      function Mont (m) {
        Red.call(this, m);
    
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - (this.shift % 26);
        }
    
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
    
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
    
      Mont.prototype.convertTo = function convertTo (num) {
        return this.imod(num.ushln(this.shift));
      };
    
      Mont.prototype.convertFrom = function convertFrom (num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
    
      Mont.prototype.imul = function imul (a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
    
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
    
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
    
        return res._forceRed(this);
      };
    
      Mont.prototype.mul = function mul (a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
    
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
    
        return res._forceRed(this);
      };
    
      Mont.prototype.invm = function invm (a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === 'undefined' || module, this);
    
    },{"buffer":2}],32:[function(require,module,exports){
    (function (Buffer){(function (){
    "use strict";
    var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __importStar = (this && this.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    var __importDefault = (this && this.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;
    const bn_js_1 = __importDefault(require("bn.js"));
    const bs58_1 = __importDefault(require("bs58"));
    // TODO: Make sure this polyfill not included when not required
    const encoding = __importStar(require("text-encoding-utf-8"));
    const ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
    const textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
    function baseEncode(value) {
        if (typeof value === "string") {
            value = Buffer.from(value, "utf8");
        }
        return bs58_1.default.encode(Buffer.from(value));
    }
    exports.baseEncode = baseEncode;
    function baseDecode(value) {
        return Buffer.from(bs58_1.default.decode(value));
    }
    exports.baseDecode = baseDecode;
    const INITIAL_LENGTH = 1024;
    class BorshError extends Error {
        constructor(message) {
            super(message);
            this.fieldPath = [];
            this.originalMessage = message;
        }
        addToFieldPath(fieldName) {
            this.fieldPath.splice(0, 0, fieldName);
            // NOTE: Modifying message directly as jest doesn't use .toString()
            this.message = this.originalMessage + ": " + this.fieldPath.join(".");
        }
    }
    exports.BorshError = BorshError;
    /// Binary encoder.
    class BinaryWriter {
        constructor() {
            this.buf = Buffer.alloc(INITIAL_LENGTH);
            this.length = 0;
        }
        maybeResize() {
            if (this.buf.length < 16 + this.length) {
                this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
            }
        }
        writeU8(value) {
            this.maybeResize();
            this.buf.writeUInt8(value, this.length);
            this.length += 1;
        }
        writeU16(value) {
            this.maybeResize();
            this.buf.writeUInt16LE(value, this.length);
            this.length += 2;
        }
        writeU32(value) {
            this.maybeResize();
            this.buf.writeUInt32LE(value, this.length);
            this.length += 4;
        }
        writeU64(value) {
            this.maybeResize();
            this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
        }
        writeU128(value) {
            this.maybeResize();
            this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
        }
        writeU256(value) {
            this.maybeResize();
            this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
        }
        writeU512(value) {
            this.maybeResize();
            this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
        }
        writeBuffer(buffer) {
            // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser
            this.buf = Buffer.concat([
                Buffer.from(this.buf.subarray(0, this.length)),
                buffer,
                Buffer.alloc(INITIAL_LENGTH),
            ]);
            this.length += buffer.length;
        }
        writeString(str) {
            this.maybeResize();
            const b = Buffer.from(str, "utf8");
            this.writeU32(b.length);
            this.writeBuffer(b);
        }
        writeFixedArray(array) {
            this.writeBuffer(Buffer.from(array));
        }
        writeArray(array, fn) {
            this.maybeResize();
            this.writeU32(array.length);
            for (const elem of array) {
                this.maybeResize();
                fn(elem);
            }
        }
        toArray() {
            return this.buf.subarray(0, this.length);
        }
    }
    exports.BinaryWriter = BinaryWriter;
    function handlingRangeError(target, propertyKey, propertyDescriptor) {
        const originalMethod = propertyDescriptor.value;
        propertyDescriptor.value = function (...args) {
            try {
                return originalMethod.apply(this, args);
            }
            catch (e) {
                if (e instanceof RangeError) {
                    const code = e.code;
                    if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
                        throw new BorshError("Reached the end of buffer when deserializing");
                    }
                }
                throw e;
            }
        };
    }
    class BinaryReader {
        constructor(buf) {
            this.buf = buf;
            this.offset = 0;
        }
        readU8() {
            const value = this.buf.readUInt8(this.offset);
            this.offset += 1;
            return value;
        }
        readU16() {
            const value = this.buf.readUInt16LE(this.offset);
            this.offset += 2;
            return value;
        }
        readU32() {
            const value = this.buf.readUInt32LE(this.offset);
            this.offset += 4;
            return value;
        }
        readU64() {
            const buf = this.readBuffer(8);
            return new bn_js_1.default(buf, "le");
        }
        readU128() {
            const buf = this.readBuffer(16);
            return new bn_js_1.default(buf, "le");
        }
        readU256() {
            const buf = this.readBuffer(32);
            return new bn_js_1.default(buf, "le");
        }
        readU512() {
            const buf = this.readBuffer(64);
            return new bn_js_1.default(buf, "le");
        }
        readBuffer(len) {
            if (this.offset + len > this.buf.length) {
                throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
            }
            const result = this.buf.slice(this.offset, this.offset + len);
            this.offset += len;
            return result;
        }
        readString() {
            const len = this.readU32();
            const buf = this.readBuffer(len);
            try {
                // NOTE: Using TextDecoder to fail on invalid UTF-8
                return textDecoder.decode(buf);
            }
            catch (e) {
                throw new BorshError(`Error decoding UTF-8 string: ${e}`);
            }
        }
        readFixedArray(len) {
            return new Uint8Array(this.readBuffer(len));
        }
        readArray(fn) {
            const len = this.readU32();
            const result = Array();
            for (let i = 0; i < len; ++i) {
                result.push(fn());
            }
            return result;
        }
    }
    __decorate([
        handlingRangeError
    ], BinaryReader.prototype, "readU8", null);
    __decorate([
        handlingRangeError
    ], BinaryReader.prototype, "readU16", null);
    __decorate([
        handlingRangeError
    ], BinaryReader.prototype, "readU32", null);
    __decorate([
        handlingRangeError
    ], BinaryReader.prototype, "readU64", null);
    __decorate([
        handlingRangeError
    ], BinaryReader.prototype, "readU128", null);
    __decorate([
        handlingRangeError
    ], BinaryReader.prototype, "readU256", null);
    __decorate([
        handlingRangeError
    ], BinaryReader.prototype, "readU512", null);
    __decorate([
        handlingRangeError
    ], BinaryReader.prototype, "readString", null);
    __decorate([
        handlingRangeError
    ], BinaryReader.prototype, "readFixedArray", null);
    __decorate([
        handlingRangeError
    ], BinaryReader.prototype, "readArray", null);
    exports.BinaryReader = BinaryReader;
    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }
    function serializeField(schema, fieldName, value, fieldType, writer) {
        try {
            // TODO: Handle missing values properly (make sure they never result in just skipped write)
            if (typeof fieldType === "string") {
                writer[`write${capitalizeFirstLetter(fieldType)}`](value);
            }
            else if (fieldType instanceof Array) {
                if (typeof fieldType[0] === "number") {
                    if (value.length !== fieldType[0]) {
                        throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
                    }
                    writer.writeFixedArray(value);
                }
                else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
                    if (value.length !== fieldType[1]) {
                        throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
                    }
                    for (let i = 0; i < fieldType[1]; i++) {
                        serializeField(schema, null, value[i], fieldType[0], writer);
                    }
                }
                else {
                    writer.writeArray(value, (item) => {
                        serializeField(schema, fieldName, item, fieldType[0], writer);
                    });
                }
            }
            else if (fieldType.kind !== undefined) {
                switch (fieldType.kind) {
                    case "option": {
                        if (value === null || value === undefined) {
                            writer.writeU8(0);
                        }
                        else {
                            writer.writeU8(1);
                            serializeField(schema, fieldName, value, fieldType.type, writer);
                        }
                        break;
                    }
                    case "map": {
                        writer.writeU32(value.size);
                        value.forEach((val, key) => {
                            serializeField(schema, fieldName, key, fieldType.key, writer);
                            serializeField(schema, fieldName, val, fieldType.value, writer);
                        });
                        break;
                    }
                    default:
                        throw new BorshError(`FieldType ${fieldType} unrecognized`);
                }
            }
            else {
                serializeStruct(schema, value, writer);
            }
        }
        catch (error) {
            if (error instanceof BorshError) {
                error.addToFieldPath(fieldName);
            }
            throw error;
        }
    }
    function serializeStruct(schema, obj, writer) {
        if (typeof obj.borshSerialize === "function") {
            obj.borshSerialize(writer);
            return;
        }
        const structSchema = schema.get(obj.constructor);
        if (!structSchema) {
            throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
            structSchema.fields.map(([fieldName, fieldType]) => {
                serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
            });
        }
        else if (structSchema.kind === "enum") {
            const name = obj[structSchema.field];
            for (let idx = 0; idx < structSchema.values.length; ++idx) {
                const [fieldName, fieldType] = structSchema.values[idx];
                if (fieldName === name) {
                    writer.writeU8(idx);
                    serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
                    break;
                }
            }
        }
        else {
            throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
        }
    }
    /// Serialize given object using schema of the form:
    /// { class_name -> [ [field_name, field_type], .. ], .. }
    function serialize(schema, obj, Writer = BinaryWriter) {
        const writer = new Writer();
        serializeStruct(schema, obj, writer);
        return writer.toArray();
    }
    exports.serialize = serialize;
    function deserializeField(schema, fieldName, fieldType, reader) {
        try {
            if (typeof fieldType === "string") {
                return reader[`read${capitalizeFirstLetter(fieldType)}`]();
            }
            if (fieldType instanceof Array) {
                if (typeof fieldType[0] === "number") {
                    return reader.readFixedArray(fieldType[0]);
                }
                else if (typeof fieldType[1] === "number") {
                    const arr = [];
                    for (let i = 0; i < fieldType[1]; i++) {
                        arr.push(deserializeField(schema, null, fieldType[0], reader));
                    }
                    return arr;
                }
                else {
                    return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
                }
            }
            if (fieldType.kind === "option") {
                const option = reader.readU8();
                if (option) {
                    return deserializeField(schema, fieldName, fieldType.type, reader);
                }
                return undefined;
            }
            if (fieldType.kind === "map") {
                let map = new Map();
                const length = reader.readU32();
                for (let i = 0; i < length; i++) {
                    const key = deserializeField(schema, fieldName, fieldType.key, reader);
                    const val = deserializeField(schema, fieldName, fieldType.value, reader);
                    map.set(key, val);
                }
                return map;
            }
            return deserializeStruct(schema, fieldType, reader);
        }
        catch (error) {
            if (error instanceof BorshError) {
                error.addToFieldPath(fieldName);
            }
            throw error;
        }
    }
    function deserializeStruct(schema, classType, reader) {
        if (typeof classType.borshDeserialize === "function") {
            return classType.borshDeserialize(reader);
        }
        const structSchema = schema.get(classType);
        if (!structSchema) {
            throw new BorshError(`Class ${classType.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
            const result = {};
            for (const [fieldName, fieldType] of schema.get(classType).fields) {
                result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
            }
            return new classType(result);
        }
        if (structSchema.kind === "enum") {
            const idx = reader.readU8();
            if (idx >= structSchema.values.length) {
                throw new BorshError(`Enum index: ${idx} is out of range`);
            }
            const [fieldName, fieldType] = structSchema.values[idx];
            const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
            return new classType({ [fieldName]: fieldValue });
        }
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
    }
    /// Deserializes object from bytes using schema.
    function deserialize(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        const result = deserializeStruct(schema, classType, reader);
        if (reader.offset < buffer.length) {
            throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
        }
        return result;
    }
    exports.deserialize = deserialize;
    /// Deserializes object from bytes using schema, without checking the length read
    function deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        return deserializeStruct(schema, classType, reader);
    }
    exports.deserializeUnchecked = deserializeUnchecked;
    
    }).call(this)}).call(this,require("buffer").Buffer)
    },{"bn.js":31,"bs58":33,"buffer":3,"text-encoding-utf-8":42}],33:[function(require,module,exports){
    var basex = require('base-x')
    var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    
    module.exports = basex(ALPHABET)
    
    },{"base-x":29}],34:[function(require,module,exports){
    'use strict';
    
    var has = Object.prototype.hasOwnProperty
      , prefix = '~';
    
    /**
     * Constructor to create a storage for our `EE` objects.
     * An `Events` instance is a plain object whose properties are event names.
     *
     * @constructor
     * @private
     */
    function Events() {}
    
    //
    // We try to not inherit from `Object.prototype`. In some engines creating an
    // instance in this way is faster than calling `Object.create(null)` directly.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // character to make sure that the built-in object properties are not
    // overridden or used as an attack vector.
    //
    if (Object.create) {
      Events.prototype = Object.create(null);
    
      //
      // This hack is needed because the `__proto__` property is still inherited in
      // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
      //
      if (!new Events().__proto__) prefix = false;
    }
    
    /**
     * Representation of a single event listener.
     *
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
     * @constructor
     * @private
     */
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    
    /**
     * Add a listener for a given event.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} once Specify if the listener is a one-time listener.
     * @returns {EventEmitter}
     * @private
     */
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== 'function') {
        throw new TypeError('The listener must be a function');
      }
    
      var listener = new EE(fn, context || emitter, once)
        , evt = prefix ? prefix + event : event;
    
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
    
      return emitter;
    }
    
    /**
     * Clear event by name.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} evt The Event name.
     * @private
     */
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    
    /**
     * Minimal `EventEmitter` interface that is molded against the Node.js
     * `EventEmitter` interface.
     *
     * @constructor
     * @public
     */
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    
    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     *
     * @returns {Array}
     * @public
     */
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = []
        , events
        , name;
    
      if (this._eventsCount === 0) return names;
    
      for (name in (events = this._events)) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
    
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
    
      return names;
    };
    
    /**
     * Return the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Array} The registered listeners.
     * @public
     */
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event
        , handlers = this._events[evt];
    
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
    
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
    
      return ee;
    };
    
    /**
     * Return the number of listeners listening to a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Number} The number of listeners.
     * @public
     */
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event
        , listeners = this._events[evt];
    
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    
    /**
     * Calls each of the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Boolean} `true` if the event had listeners, else `false`.
     * @public
     */
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
    
      if (!this._events[evt]) return false;
    
      var listeners = this._events[evt]
        , len = arguments.length
        , args
        , i;
    
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
    
        switch (len) {
          case 1: return listeners.fn.call(listeners.context), true;
          case 2: return listeners.fn.call(listeners.context, a1), true;
          case 3: return listeners.fn.call(listeners.context, a1, a2), true;
          case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
    
        for (i = 1, args = new Array(len -1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
    
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length
          , j;
    
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
    
          switch (len) {
            case 1: listeners[i].fn.call(listeners[i].context); break;
            case 2: listeners[i].fn.call(listeners[i].context, a1); break;
            case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
            case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
            default:
              if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
    
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
    
      return true;
    };
    
    /**
     * Add a listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    
    /**
     * Add a one-time listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    
    /**
     * Remove the listeners of a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn Only remove the listeners that match this function.
     * @param {*} context Only remove the listeners that have this context.
     * @param {Boolean} once Only remove one-time listeners.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
    
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
    
      var listeners = this._events[evt];
    
      if (listeners.fn) {
        if (
          listeners.fn === fn &&
          (!once || listeners.once) &&
          (!context || listeners.context === context)
        ) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (
            listeners[i].fn !== fn ||
            (once && !listeners[i].once) ||
            (context && listeners[i].context !== context)
          ) {
            events.push(listeners[i]);
          }
        }
    
        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
    
      return this;
    };
    
    /**
     * Remove all listeners, or those of the specified event.
     *
     * @param {(String|Symbol)} [event] The event name.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
    
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
    
      return this;
    };
    
    //
    // Alias methods names because people roll like that.
    //
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    
    //
    // Expose the prefix.
    //
    EventEmitter.prefixed = prefix;
    
    //
    // Allow `EventEmitter` to be imported as module namespace.
    //
    EventEmitter.EventEmitter = EventEmitter;
    
    //
    // Expose the module.
    //
    if ('undefined' !== typeof module) {
      module.exports = EventEmitter;
    }
    
    },{}],35:[function(require,module,exports){
    'use strict';
    
    const uuid = require('uuid').v4;
    const generateRequest = require('../../generateRequest');
    
    /**
     * Constructor for a Jayson Browser Client that does not depend any node.js core libraries
     * @class ClientBrowser
     * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback
     * @param {Object} [options]
     * @param {Function} [options.reviver] Reviver function for JSON
     * @param {Function} [options.replacer] Replacer function for JSON
     * @param {Number} [options.version=2] JSON-RPC version to use (1|2)
     * @param {Function} [options.generator] Function to use for generating request IDs
     *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
     * @return {ClientBrowser}
     */
    const ClientBrowser = function(callServer, options) {
      if(!(this instanceof ClientBrowser)) {
        return new ClientBrowser(callServer, options);
      }
    
      if (!options) {
        options = {};
      }
    
      this.options = {
        reviver: typeof options.reviver !== 'undefined' ? options.reviver : null,
        replacer: typeof options.replacer !== 'undefined' ? options.replacer : null,
        generator: typeof options.generator !== 'undefined' ? options.generator : function() { return uuid(); },
        version: typeof options.version !== 'undefined' ? options.version : 2,
        notificationIdNull: typeof options.notificationIdNull === 'boolean' ? options.notificationIdNull : false,
      };
    
      this.callServer = callServer;
    };
    
    module.exports = ClientBrowser;
    
    /**
     *  Creates a request and dispatches it if given a callback.
     *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String
     *  @param {Array|Object} [params] Parameters for the method
     *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request
     *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.
     *  @throws {TypeError} Invalid parameters
     *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request
     */
    ClientBrowser.prototype.request = function(method, params, id, callback) {
      const self = this;
      let request = null;
    
      // is this a batch request?
      const isBatch = Array.isArray(method) && typeof params === 'function';
    
      if (this.options.version === 1 && isBatch) {
        throw new TypeError('JSON-RPC 1.0 does not support batching');
      }
    
      // is this a raw request?
      const isRaw = !isBatch && method && typeof method === 'object' && typeof params === 'function';
    
      if(isBatch || isRaw) {
        callback = params;
        request = method;
      } else {
        if(typeof id === 'function') {
          callback = id;
          // specifically undefined because "null" is a notification request
          id = undefined;
        }
    
        const hasCallback = typeof callback === 'function';
    
        try {
          request = generateRequest(method, params, id, {
            generator: this.options.generator,
            version: this.options.version,
            notificationIdNull: this.options.notificationIdNull,
          });
        } catch(err) {
          if(hasCallback) {
            return callback(err);
          }
          throw err;
        }
    
        // no callback means we should just return a raw request
        if(!hasCallback) {
          return request;
        }
    
      }
    
      let message;
      try {
        message = JSON.stringify(request, this.options.replacer);
      } catch(err) {
        return callback(err);
      }
    
      this.callServer(message, function(err, response) {
        self._parseResponse(err, response, callback);
      });
    
      // always return the raw request
      return request;
    };
    
    /**
     * Parses a response from a server
     * @param {Object} err Error to pass on that is unrelated to the actual response
     * @param {String} responseText JSON-RPC 1.0 or 2.0 response
     * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters
     * @private
     */
    ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
      if(err) {
        callback(err);
        return;
      }
    
      if(!responseText) {
        // empty response text, assume that is correct because it could be a
        // notification which jayson does not give any body for
        return callback();
      }
    
      let response;
      try {
        response = JSON.parse(responseText, this.options.reviver);
      } catch(err) {
        return callback(err);
      }
    
      if(callback.length === 3) {
        // if callback length is 3, we split callback arguments on error and response
    
        // is batch response?
        if(Array.isArray(response)) {
    
          // neccesary to split strictly on validity according to spec here
          const isError = function(res) {
            return typeof res.error !== 'undefined';
          };
    
          const isNotError = function (res) {
            return !isError(res);
          };
    
          return callback(null, response.filter(isError), response.filter(isNotError));
        
        } else {
    
          // split regardless of validity
          return callback(null, response.error, response.result);
        
        }
      
      }
    
      callback(null, response);
    };
    
    },{"../../generateRequest":36,"uuid":43}],36:[function(require,module,exports){
    'use strict';
    
    const uuid = require('uuid').v4;
    
    /**
     *  Generates a JSON-RPC 1.0 or 2.0 request
     *  @param {String} method Name of method to call
     *  @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value
     *  @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation
     *  @param {Object} [options]
     *  @param {Number} [options.version=2] JSON-RPC version to use (1 or 2)
     *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
     *  @param {Function} [options.generator] Passed the request, and the options object and is expected to return a request ID
     *  @throws {TypeError} If any of the parameters are invalid
     *  @return {Object} A JSON-RPC 1.0 or 2.0 request
     *  @memberOf Utils
     */
    const generateRequest = function(method, params, id, options) {
      if(typeof method !== 'string') {
        throw new TypeError(method + ' must be a string');
      }
    
      options = options || {};
    
      // check valid version provided
      const version = typeof options.version === 'number' ? options.version : 2;
      if (version !== 1 && version !== 2) {
        throw new TypeError(version + ' must be 1 or 2');
      }
    
      const request = {
        method: method
      };
    
      if(version === 2) {
        request.jsonrpc = '2.0';
      }
    
      if(params) {
        // params given, but invalid?
        if(typeof params !== 'object' && !Array.isArray(params)) {
          throw new TypeError(params + ' must be an object, array or omitted');
        }
        request.params = params;
      }
    
      // if id was left out, generate one (null means explicit notification)
      if(typeof(id) === 'undefined') {
        const generator = typeof options.generator === 'function' ? options.generator : function() { return uuid(); };
        request.id = generator(request, options);
      } else if (version === 2 && id === null) {
        // we have a version 2 notification
        if (options.notificationIdNull) {
          request.id = null; // id will not be set at all unless option provided
        }
      } else {
        request.id = id;
      }
    
      return request;
    };
    
    module.exports = generateRequest;
    
    },{"uuid":43}],37:[function(require,module,exports){
    "use strict";
    
    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Client = void 0;
    
    var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
    
    var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
    
    var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
    
    var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
    
    var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
    
    var _websocket = _interopRequireDefault(require("./lib/client/websocket.browser"));
    
    var _client = _interopRequireDefault(require("./lib/client"));
    
    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
    
    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
    
    var Client = /*#__PURE__*/function (_CommonClient) {
      (0, _inherits2["default"])(Client, _CommonClient);
    
      var _super = _createSuper(Client);
    
      function Client() {
        var address = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ws://localhost:8080";
    
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$autoconnect = _ref.autoconnect,
            autoconnect = _ref$autoconnect === void 0 ? true : _ref$autoconnect,
            _ref$reconnect = _ref.reconnect,
            reconnect = _ref$reconnect === void 0 ? true : _ref$reconnect,
            _ref$reconnect_interv = _ref.reconnect_interval,
            reconnect_interval = _ref$reconnect_interv === void 0 ? 1000 : _ref$reconnect_interv,
            _ref$max_reconnects = _ref.max_reconnects,
            max_reconnects = _ref$max_reconnects === void 0 ? 5 : _ref$max_reconnects;
    
        var generate_request_id = arguments.length > 2 ? arguments[2] : undefined;
        (0, _classCallCheck2["default"])(this, Client);
        return _super.call(this, _websocket["default"], address, {
          autoconnect: autoconnect,
          reconnect: reconnect,
          reconnect_interval: reconnect_interval,
          max_reconnects: max_reconnects
        }, generate_request_id);
      }
    
      return (0, _createClass2["default"])(Client);
    }(_client["default"]);
    
    exports.Client = Client;
    },{"./lib/client":38,"./lib/client/websocket.browser":39,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":12}],38:[function(require,module,exports){
    (function (Buffer){(function (){
    /**
     * "Client" wraps "ws" or a browser-implemented "WebSocket" library
     * according to the environment providing JSON RPC 2.0 support on top.
     * @module Client
     */
    "use strict";
    
    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    
    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
    
    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
    
    var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
    
    var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
    
    var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
    
    var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
    
    var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
    
    var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
    
    var _eventemitter = require("eventemitter3");
    
    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
    
    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
    
    var __rest = void 0 && (void 0).__rest || function (s, e) {
      var t = {};
    
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }
    
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    }; // @ts-ignore
    
    
    var CommonClient = /*#__PURE__*/function (_EventEmitter) {
      (0, _inherits2["default"])(CommonClient, _EventEmitter);
    
      var _super = _createSuper(CommonClient);
    
      /**
       * Instantiate a Client class.
       * @constructor
       * @param {webSocketFactory} webSocketFactory - factory method for WebSocket
       * @param {String} address - url to a websocket server
       * @param {Object} options - ws options object with reconnect parameters
       * @param {Function} generate_request_id - custom generation request Id
       * @return {CommonClient}
       */
      function CommonClient(webSocketFactory) {
        var _this;
    
        var address = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "ws://localhost:8080";
    
        var _a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    
        var generate_request_id = arguments.length > 3 ? arguments[3] : undefined;
        (0, _classCallCheck2["default"])(this, CommonClient);
    
        var _a$autoconnect = _a.autoconnect,
            autoconnect = _a$autoconnect === void 0 ? true : _a$autoconnect,
            _a$reconnect = _a.reconnect,
            reconnect = _a$reconnect === void 0 ? true : _a$reconnect,
            _a$reconnect_interval = _a.reconnect_interval,
            reconnect_interval = _a$reconnect_interval === void 0 ? 1000 : _a$reconnect_interval,
            _a$max_reconnects = _a.max_reconnects,
            max_reconnects = _a$max_reconnects === void 0 ? 5 : _a$max_reconnects,
            rest_options = __rest(_a, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
    
        _this = _super.call(this);
        _this.webSocketFactory = webSocketFactory;
        _this.queue = {};
        _this.rpc_id = 0;
        _this.address = address;
        _this.autoconnect = autoconnect;
        _this.ready = false;
        _this.reconnect = reconnect;
        _this.reconnect_interval = reconnect_interval;
        _this.max_reconnects = max_reconnects;
        _this.rest_options = rest_options;
        _this.current_reconnects = 0;
    
        _this.generate_request_id = generate_request_id || function () {
          return ++_this.rpc_id;
        };
    
        if (_this.autoconnect) _this._connect(_this.address, Object.assign({
          autoconnect: _this.autoconnect,
          reconnect: _this.reconnect,
          reconnect_interval: _this.reconnect_interval,
          max_reconnects: _this.max_reconnects
        }, _this.rest_options));
        return _this;
      }
      /**
       * Connects to a defined server if not connected already.
       * @method
       * @return {Undefined}
       */
    
    
      (0, _createClass2["default"])(CommonClient, [{
        key: "connect",
        value: function connect() {
          if (this.socket) return;
    
          this._connect(this.address, Object.assign({
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects
          }, this.rest_options));
        }
        /**
         * Calls a registered RPC method on server.
         * @method
         * @param {String} method - RPC method name
         * @param {Object|Array} params - optional method parameters
         * @param {Number} timeout - RPC reply timeout value
         * @param {Object} ws_opts - options passed to ws
         * @return {Promise}
         */
    
      }, {
        key: "call",
        value: function call(method, params, timeout, ws_opts) {
          var _this2 = this;
    
          if (!ws_opts && "object" === (0, _typeof2["default"])(timeout)) {
            ws_opts = timeout;
            timeout = null;
          }
    
          return new Promise(function (resolve, reject) {
            if (!_this2.ready) return reject(new Error("socket not ready"));
    
            var rpc_id = _this2.generate_request_id(method, params);
    
            var message = {
              jsonrpc: "2.0",
              method: method,
              params: params || null,
              id: rpc_id
            };
    
            _this2.socket.send(JSON.stringify(message), ws_opts, function (error) {
              if (error) return reject(error);
              _this2.queue[rpc_id] = {
                promise: [resolve, reject]
              };
    
              if (timeout) {
                _this2.queue[rpc_id].timeout = setTimeout(function () {
                  delete _this2.queue[rpc_id];
                  reject(new Error("reply timeout"));
                }, timeout);
              }
            });
          });
        }
        /**
         * Logins with the other side of the connection.
         * @method
         * @param {Object} params - Login credentials object
         * @return {Promise}
         */
    
      }, {
        key: "login",
        value: function () {
          var _login = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(params) {
            var resp;
            return _regenerator["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.call("rpc.login", params);
    
                  case 2:
                    resp = _context.sent;
    
                    if (resp) {
                      _context.next = 5;
                      break;
                    }
    
                    throw new Error("authentication failed");
    
                  case 5:
                    return _context.abrupt("return", resp);
    
                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
    
          function login(_x) {
            return _login.apply(this, arguments);
          }
    
          return login;
        }()
        /**
         * Fetches a list of client's methods registered on server.
         * @method
         * @return {Array}
         */
    
      }, {
        key: "listMethods",
        value: function () {
          var _listMethods = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
            return _regenerator["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.call("__listMethods");
    
                  case 2:
                    return _context2.abrupt("return", _context2.sent);
    
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
    
          function listMethods() {
            return _listMethods.apply(this, arguments);
          }
    
          return listMethods;
        }()
        /**
         * Sends a JSON-RPC 2.0 notification to server.
         * @method
         * @param {String} method - RPC method name
         * @param {Object} params - optional method parameters
         * @return {Promise}
         */
    
      }, {
        key: "notify",
        value: function notify(method, params) {
          var _this3 = this;
    
          return new Promise(function (resolve, reject) {
            if (!_this3.ready) return reject(new Error("socket not ready"));
            var message = {
              jsonrpc: "2.0",
              method: method,
              params: params || null
            };
    
            _this3.socket.send(JSON.stringify(message), function (error) {
              if (error) return reject(error);
              resolve();
            });
          });
        }
        /**
         * Subscribes for a defined event.
         * @method
         * @param {String|Array} event - event name
         * @return {Undefined}
         * @throws {Error}
         */
    
      }, {
        key: "subscribe",
        value: function () {
          var _subscribe = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(event) {
            var result;
            return _regenerator["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (typeof event === "string") event = [event];
                    _context3.next = 3;
                    return this.call("rpc.on", event);
    
                  case 3:
                    result = _context3.sent;
    
                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context3.next = 6;
                      break;
                    }
    
                    throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);
    
                  case 6:
                    return _context3.abrupt("return", result);
    
                  case 7:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
    
          function subscribe(_x2) {
            return _subscribe.apply(this, arguments);
          }
    
          return subscribe;
        }()
        /**
         * Unsubscribes from a defined event.
         * @method
         * @param {String|Array} event - event name
         * @return {Undefined}
         * @throws {Error}
         */
    
      }, {
        key: "unsubscribe",
        value: function () {
          var _unsubscribe = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(event) {
            var result;
            return _regenerator["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (typeof event === "string") event = [event];
                    _context4.next = 3;
                    return this.call("rpc.off", event);
    
                  case 3:
                    result = _context4.sent;
    
                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context4.next = 6;
                      break;
                    }
    
                    throw new Error("Failed unsubscribing from an event with: " + result);
    
                  case 6:
                    return _context4.abrupt("return", result);
    
                  case 7:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
    
          function unsubscribe(_x3) {
            return _unsubscribe.apply(this, arguments);
          }
    
          return unsubscribe;
        }()
        /**
         * Closes a WebSocket connection gracefully.
         * @method
         * @param {Number} code - socket close code
         * @param {String} data - optional data to be sent before closing
         * @return {Undefined}
         */
    
      }, {
        key: "close",
        value: function close(code, data) {
          this.socket.close(code || 1000, data);
        }
        /**
         * Connection/Message handler.
         * @method
         * @private
         * @param {String} address - WebSocket API address
         * @param {Object} options - ws options object
         * @return {Undefined}
         */
    
      }, {
        key: "_connect",
        value: function _connect(address, options) {
          var _this4 = this;
    
          this.socket = this.webSocketFactory(address, options);
          this.socket.addEventListener("open", function () {
            _this4.ready = true;
    
            _this4.emit("open");
    
            _this4.current_reconnects = 0;
          });
          this.socket.addEventListener("message", function (_ref) {
            var message = _ref.data;
            if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();
    
            try {
              message = JSON.parse(message);
            } catch (error) {
              return;
            } // check if any listeners are attached and forward event
    
    
            if (message.notification && _this4.listeners(message.notification).length) {
              if (!Object.keys(message.params).length) return _this4.emit(message.notification);
              var args = [message.notification];
              if (message.params.constructor === Object) args.push(message.params);else // using for-loop instead of unshift/spread because performance is better
                for (var i = 0; i < message.params.length; i++) {
                  args.push(message.params[i]);
                } // run as microtask so that pending queue messages are resolved first
              // eslint-disable-next-line prefer-spread
    
              return Promise.resolve().then(function () {
                _this4.emit.apply(_this4, args);
              });
            }
    
            if (!_this4.queue[message.id]) {
              // general JSON RPC 2.0 events
              if (message.method && message.params) {
                // run as microtask so that pending queue messages are resolved first
                return Promise.resolve().then(function () {
                  _this4.emit(message.method, message.params);
                });
              }
    
              return;
            } // reject early since server's response is invalid
    
    
            if ("error" in message === "result" in message) _this4.queue[message.id].promise[1](new Error("Server response malformed. Response must include either \"result\"" + " or \"error\", but not both."));
            if (_this4.queue[message.id].timeout) clearTimeout(_this4.queue[message.id].timeout);
            if (message.error) _this4.queue[message.id].promise[1](message.error);else _this4.queue[message.id].promise[0](message.result);
            delete _this4.queue[message.id];
          });
          this.socket.addEventListener("error", function (error) {
            return _this4.emit("error", error);
          });
          this.socket.addEventListener("close", function (_ref2) {
            var code = _ref2.code,
                reason = _ref2.reason;
            if (_this4.ready) // Delay close event until internal state is updated
              setTimeout(function () {
                return _this4.emit("close", code, reason);
              }, 0);
            _this4.ready = false;
            _this4.socket = undefined;
            if (code === 1000) return;
            _this4.current_reconnects++;
            if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0)) setTimeout(function () {
              return _this4._connect(address, options);
            }, _this4.reconnect_interval);
          });
        }
      }]);
      return CommonClient;
    }(_eventemitter.EventEmitter);
    
    exports["default"] = CommonClient;
    }).call(this)}).call(this,require("buffer").Buffer)
    },{"@babel/runtime/helpers/asyncToGenerator":6,"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":12,"@babel/runtime/helpers/typeof":15,"@babel/runtime/regenerator":16,"buffer":3,"eventemitter3":34}],39:[function(require,module,exports){
    /**
     * WebSocket implements a browser-side WebSocket specification.
     * @module Client
     */
    "use strict";
    
    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = _default;
    
    var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
    
    var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
    
    var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
    
    var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
    
    var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
    
    var _eventemitter = require("eventemitter3");
    
    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
    
    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
    
    var WebSocketBrowserImpl = /*#__PURE__*/function (_EventEmitter) {
      (0, _inherits2["default"])(WebSocketBrowserImpl, _EventEmitter);
    
      var _super = _createSuper(WebSocketBrowserImpl);
    
      /** Instantiate a WebSocket class
       * @constructor
       * @param {String} address - url to a websocket server
       * @param {(Object)} options - websocket options
       * @param {(String|Array)} protocols - a list of protocols
       * @return {WebSocketBrowserImpl} - returns a WebSocket instance
       */
      function WebSocketBrowserImpl(address, options, protocols) {
        var _this;
    
        (0, _classCallCheck2["default"])(this, WebSocketBrowserImpl);
        _this = _super.call(this);
        _this.socket = new window.WebSocket(address, protocols);
    
        _this.socket.onopen = function () {
          return _this.emit("open");
        };
    
        _this.socket.onmessage = function (event) {
          return _this.emit("message", event.data);
        };
    
        _this.socket.onerror = function (error) {
          return _this.emit("error", error);
        };
    
        _this.socket.onclose = function (event) {
          _this.emit("close", event.code, event.reason);
        };
    
        return _this;
      }
      /**
       * Sends data through a websocket connection
       * @method
       * @param {(String|Object)} data - data to be sent via websocket
       * @param {Object} optionsOrCallback - ws options
       * @param {Function} callback - a callback called once the data is sent
       * @return {Undefined}
       */
    
    
      (0, _createClass2["default"])(WebSocketBrowserImpl, [{
        key: "send",
        value: function send(data, optionsOrCallback, callback) {
          var cb = callback || optionsOrCallback;
    
          try {
            this.socket.send(data);
            cb();
          } catch (error) {
            cb(error);
          }
        }
        /**
         * Closes an underlying socket
         * @method
         * @param {Number} code - status code explaining why the connection is being closed
         * @param {String} reason - a description why the connection is closing
         * @return {Undefined}
         * @throws {Error}
         */
    
      }, {
        key: "close",
        value: function close(code, reason) {
          this.socket.close(code, reason);
        }
      }, {
        key: "addEventListener",
        value: function addEventListener(type, listener, options) {
          this.socket.addEventListener(type, listener, options);
        }
      }]);
      return WebSocketBrowserImpl;
    }(_eventemitter.EventEmitter);
    /**
     * factory method for common WebSocket instance
     * @method
     * @param {String} address - url to a websocket server
     * @param {(Object)} options - websocket options
     * @return {Undefined}
     */
    
    
    function _default(address, options) {
      return new WebSocketBrowserImpl(address, options);
    }
    },{"@babel/runtime/helpers/classCallCheck":7,"@babel/runtime/helpers/createClass":8,"@babel/runtime/helpers/getPrototypeOf":9,"@babel/runtime/helpers/inherits":10,"@babel/runtime/helpers/interopRequireDefault":11,"@babel/runtime/helpers/possibleConstructorReturn":12,"eventemitter3":34}],40:[function(require,module,exports){
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    /* eslint-disable node/no-deprecated-api */
    var buffer = require('buffer')
    var Buffer = buffer.Buffer
    
    // alternative to using Object.keys for old browsers
    function copyProps (src, dst) {
      for (var key in src) {
        dst[key] = src[key]
      }
    }
    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = buffer
    } else {
      // Copy properties from require('buffer')
      copyProps(buffer, exports)
      exports.Buffer = SafeBuffer
    }
    
    function SafeBuffer (arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length)
    }
    
    SafeBuffer.prototype = Object.create(Buffer.prototype)
    
    // Copy static methods from Buffer
    copyProps(Buffer, SafeBuffer)
    
    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number')
      }
      return Buffer(arg, encodingOrOffset, length)
    }
    
    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      var buf = Buffer(size)
      if (fill !== undefined) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding)
        } else {
          buf.fill(fill)
        }
      } else {
        buf.fill(0)
      }
      return buf
    }
    
    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      return Buffer(size)
    }
    
    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      return buffer.SlowBuffer(size)
    }
    
    },{"buffer":3}],41:[function(require,module,exports){
    'use strict';
    
    Object.defineProperty(exports, '__esModule', { value: true });
    
    /**
     * A `StructFailure` represents a single specific failure in validation.
     */
    
    /**
     * `StructError` objects are thrown (or returned) when validation fails.
     *
     * Validation logic is design to exit early for maximum performance. The error
     * represents the first error encountered during validation. For more detail,
     * the `error.failures` property is a generator function that can be run to
     * continue validation and receive all the failures in the data.
     */
    class StructError extends TypeError {
      constructor(failure, failures) {
        let cached;
        const {
          message,
          ...rest
        } = failure;
        const {
          path
        } = failure;
        const msg = path.length === 0 ? message : "At path: " + path.join('.') + " -- " + message;
        super(msg);
        Object.assign(this, rest);
        this.name = this.constructor.name;
    
        this.failures = () => {
          var _cached;
    
          return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
        };
      }
    
    }
    
    /**
     * Check if a value is an iterator.
     */
    function isIterable(x) {
      return isObject(x) && typeof x[Symbol.iterator] === 'function';
    }
    /**
     * Check if a value is a plain object.
     */
    
    
    function isObject(x) {
      return typeof x === 'object' && x != null;
    }
    /**
     * Check if a value is a plain object.
     */
    
    function isPlainObject(x) {
      if (Object.prototype.toString.call(x) !== '[object Object]') {
        return false;
      }
    
      const prototype = Object.getPrototypeOf(x);
      return prototype === null || prototype === Object.prototype;
    }
    /**
     * Return a value as a printable string.
     */
    
    function print(value) {
      return typeof value === 'string' ? JSON.stringify(value) : "" + value;
    }
    /**
     * Shifts (removes and returns) the first value from the `input` iterator.
     * Like `Array.prototype.shift()` but for an `Iterator`.
     */
    
    function shiftIterator(input) {
      const {
        done,
        value
      } = input.next();
      return done ? undefined : value;
    }
    /**
     * Convert a single validation result to a failure.
     */
    
    function toFailure(result, context, struct, value) {
      if (result === true) {
        return;
      } else if (result === false) {
        result = {};
      } else if (typeof result === 'string') {
        result = {
          message: result
        };
      }
    
      const {
        path,
        branch
      } = context;
      const {
        type
      } = struct;
      const {
        refinement,
        message = "Expected a value of type `" + type + "`" + (refinement ? " with refinement `" + refinement + "`" : '') + ", but received: `" + print(value) + "`"
      } = result;
      return {
        value,
        type,
        refinement,
        key: path[path.length - 1],
        path,
        branch,
        ...result,
        message
      };
    }
    /**
     * Convert a validation result to an iterable of failures.
     */
    
    function* toFailures(result, context, struct, value) {
      if (!isIterable(result)) {
        result = [result];
      }
    
      for (const r of result) {
        const failure = toFailure(r, context, struct, value);
    
        if (failure) {
          yield failure;
        }
      }
    }
    /**
     * Check a value against a struct, traversing deeply into nested values, and
     * returning an iterator of failures or success.
     */
    
    function* run(value, struct, options = {}) {
      const {
        path = [],
        branch = [value],
        coerce = false,
        mask = false
      } = options;
      const ctx = {
        path,
        branch
      };
    
      if (coerce) {
        value = struct.coercer(value, ctx);
    
        if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {
          for (const key in value) {
            if (struct.schema[key] === undefined) {
              delete value[key];
            }
          }
        }
      }
    
      let valid = true;
    
      for (const failure of struct.validator(value, ctx)) {
        valid = false;
        yield [failure, undefined];
      }
    
      for (let [k, v, s] of struct.entries(value, ctx)) {
        const ts = run(v, s, {
          path: k === undefined ? path : [...path, k],
          branch: k === undefined ? branch : [...branch, v],
          coerce,
          mask
        });
    
        for (const t of ts) {
          if (t[0]) {
            valid = false;
            yield [t[0], undefined];
          } else if (coerce) {
            v = t[1];
    
            if (k === undefined) {
              value = v;
            } else if (value instanceof Map) {
              value.set(k, v);
            } else if (value instanceof Set) {
              value.add(v);
            } else if (isObject(value)) {
              value[k] = v;
            }
          }
        }
      }
    
      if (valid) {
        for (const failure of struct.refiner(value, ctx)) {
          valid = false;
          yield [failure, undefined];
        }
      }
    
      if (valid) {
        yield [undefined, value];
      }
    }
    
    /**
     * `Struct` objects encapsulate the validation logic for a specific type of
     * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
     * validate unknown input data against the struct.
     */
    
    class Struct {
      constructor(props) {
        const {
          type,
          schema,
          validator,
          refiner,
          coercer = value => value,
          entries = function* () {}
        } = props;
        this.type = type;
        this.schema = schema;
        this.entries = entries;
        this.coercer = coercer;
    
        if (validator) {
          this.validator = (value, context) => {
            const result = validator(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.validator = () => [];
        }
    
        if (refiner) {
          this.refiner = (value, context) => {
            const result = refiner(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.refiner = () => [];
        }
      }
      /**
       * Assert that a value passes the struct's validation, throwing if it doesn't.
       */
    
    
      assert(value) {
        return assert(value, this);
      }
      /**
       * Create a value with the struct's coercion logic, then validate it.
       */
    
    
      create(value) {
        return create(value, this);
      }
      /**
       * Check if a value passes the struct's validation.
       */
    
    
      is(value) {
        return is(value, this);
      }
      /**
       * Mask a value, coercing and validating it, but returning only the subset of
       * properties defined by the struct's schema.
       */
    
    
      mask(value) {
        return mask(value, this);
      }
      /**
       * Validate a value with the struct's validation logic, returning a tuple
       * representing the result.
       *
       * You may optionally pass `true` for the `withCoercion` argument to coerce
       * the value before attempting to validate it. If you do, the result will
       * contain the coerced result when successful.
       */
    
    
      validate(value, options = {}) {
        return validate(value, this, options);
      }
    
    }
    /**
     * Assert that a value passes a struct, throwing if it doesn't.
     */
    
    function assert(value, struct) {
      const result = validate(value, struct);
    
      if (result[0]) {
        throw result[0];
      }
    }
    /**
     * Create a value with the coercion logic of struct and validate it.
     */
    
    function create(value, struct) {
      const result = validate(value, struct, {
        coerce: true
      });
    
      if (result[0]) {
        throw result[0];
      } else {
        return result[1];
      }
    }
    /**
     * Mask a value, returning only the subset of properties defined by a struct.
     */
    
    function mask(value, struct) {
      const result = validate(value, struct, {
        coerce: true,
        mask: true
      });
    
      if (result[0]) {
        throw result[0];
      } else {
        return result[1];
      }
    }
    /**
     * Check if a value passes a struct.
     */
    
    function is(value, struct) {
      const result = validate(value, struct);
      return !result[0];
    }
    /**
     * Validate a value against a struct, returning an error if invalid, or the
     * value (with potential coercion) if valid.
     */
    
    function validate(value, struct, options = {}) {
      const tuples = run(value, struct, options);
      const tuple = shiftIterator(tuples);
    
      if (tuple[0]) {
        const error = new StructError(tuple[0], function* () {
          for (const t of tuples) {
            if (t[0]) {
              yield t[0];
            }
          }
        });
        return [error, undefined];
      } else {
        const v = tuple[1];
        return [undefined, v];
      }
    }
    
    function assign(...Structs) {
      const schemas = Structs.map(s => s.schema);
      const schema = Object.assign({}, ...schemas);
      return object(schema);
    }
    /**
     * Define a new struct type with a custom validation function.
     */
    
    function define(name, validator) {
      return new Struct({
        type: name,
        schema: null,
        validator
      });
    }
    /**
     * Create a new struct based on an existing struct, but the value is allowed to
     * be `undefined`. `log` will be called if the value is not `undefined`.
     */
    
    function deprecated(struct, log) {
      return new Struct({ ...struct,
        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),
    
        validator(value, ctx) {
          if (value === undefined) {
            return true;
          } else {
            log(value, ctx);
            return struct.validator(value, ctx);
          }
        }
    
      });
    }
    /**
     * Create a struct with dynamic validation logic.
     *
     * The callback will receive the value currently being validated, and must
     * return a struct object to validate it with. This can be useful to model
     * validation logic that changes based on its input.
     */
    
    function dynamic(fn) {
      return new Struct({
        type: 'dynamic',
        schema: null,
    
        *entries(value, ctx) {
          const struct = fn(value, ctx);
          yield* struct.entries(value, ctx);
        },
    
        validator(value, ctx) {
          const struct = fn(value, ctx);
          return struct.validator(value, ctx);
        },
    
        coercer(value, ctx) {
          const struct = fn(value, ctx);
          return struct.coercer(value, ctx);
        }
    
      });
    }
    /**
     * Create a struct with lazily evaluated validation logic.
     *
     * The first time validation is run with the struct, the callback will be called
     * and must return a struct object to use. This is useful for cases where you
     * want to have self-referential structs for nested data structures to avoid a
     * circular definition problem.
     */
    
    function lazy(fn) {
      let struct;
      return new Struct({
        type: 'lazy',
        schema: null,
    
        *entries(value, ctx) {
          var _struct;
    
          (_struct = struct) != null ? _struct : struct = fn();
          yield* struct.entries(value, ctx);
        },
    
        validator(value, ctx) {
          var _struct2;
    
          (_struct2 = struct) != null ? _struct2 : struct = fn();
          return struct.validator(value, ctx);
        },
    
        coercer(value, ctx) {
          var _struct3;
    
          (_struct3 = struct) != null ? _struct3 : struct = fn();
          return struct.coercer(value, ctx);
        }
    
      });
    }
    /**
     * Create a new struct based on an existing object struct, but excluding
     * specific properties.
     *
     * Like TypeScript's `Omit` utility.
     */
    
    function omit(struct, keys) {
      const {
        schema
      } = struct;
      const subschema = { ...schema
      };
    
      for (const key of keys) {
        delete subschema[key];
      }
    
      return object(subschema);
    }
    /**
     * Create a new struct based on an existing object struct, but with all of its
     * properties allowed to be `undefined`.
     *
     * Like TypeScript's `Partial` utility.
     */
    
    function partial(struct) {
      const schema = struct instanceof Struct ? { ...struct.schema
      } : { ...struct
      };
    
      for (const key in schema) {
        schema[key] = optional(schema[key]);
      }
    
      return object(schema);
    }
    /**
     * Create a new struct based on an existing object struct, but only including
     * specific properties.
     *
     * Like TypeScript's `Pick` utility.
     */
    
    function pick(struct, keys) {
      const {
        schema
      } = struct;
      const subschema = {};
    
      for (const key of keys) {
        subschema[key] = schema[key];
      }
    
      return object(subschema);
    }
    /**
     * Define a new struct type with a custom validation function.
     *
     * @deprecated This function has been renamed to `define`.
     */
    
    function struct(name, validator) {
      console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');
      return define(name, validator);
    }
    
    /**
     * Ensure that any value passes validation.
     */
    
    function any() {
      return define('any', () => true);
    }
    function array(Element) {
      return new Struct({
        type: 'array',
        schema: Element,
    
        *entries(value) {
          if (Element && Array.isArray(value)) {
            for (const [i, v] of value.entries()) {
              yield [i, v, Element];
            }
          }
        },
    
        coercer(value) {
          return Array.isArray(value) ? value.slice() : value;
        },
    
        validator(value) {
          return Array.isArray(value) || "Expected an array value, but received: " + print(value);
        }
    
      });
    }
    /**
     * Ensure that a value is a boolean.
     */
    
    function boolean() {
      return define('boolean', value => {
        return typeof value === 'boolean';
      });
    }
    /**
     * Ensure that a value is a valid `Date`.
     *
     * Note: this also ensures that the value is *not* an invalid `Date` object,
     * which can occur when parsing a date fails but still returns a `Date`.
     */
    
    function date() {
      return define('date', value => {
        return value instanceof Date && !isNaN(value.getTime()) || "Expected a valid `Date` object, but received: " + print(value);
      });
    }
    function enums(values) {
      const schema = {};
      const description = values.map(v => print(v)).join();
    
      for (const key of values) {
        schema[key] = key;
      }
    
      return new Struct({
        type: 'enums',
        schema,
    
        validator(value) {
          return values.includes(value) || "Expected one of `" + description + "`, but received: " + print(value);
        }
    
      });
    }
    /**
     * Ensure that a value is a function.
     */
    
    function func() {
      return define('func', value => {
        return typeof value === 'function' || "Expected a function, but received: " + print(value);
      });
    }
    /**
     * Ensure that a value is an instance of a specific class.
     */
    
    function instance(Class) {
      return define('instance', value => {
        return value instanceof Class || "Expected a `" + Class.name + "` instance, but received: " + print(value);
      });
    }
    /**
     * Ensure that a value is an integer.
     */
    
    function integer() {
      return define('integer', value => {
        return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || "Expected an integer, but received: " + print(value);
      });
    }
    function intersection(Structs) {
      return new Struct({
        type: 'intersection',
        schema: null,
    
        *entries(value, ctx) {
          for (const S of Structs) {
            yield* S.entries(value, ctx);
          }
        },
    
        *validator(value, ctx) {
          for (const S of Structs) {
            yield* S.validator(value, ctx);
          }
        },
    
        *refiner(value, ctx) {
          for (const S of Structs) {
            yield* S.refiner(value, ctx);
          }
        }
    
      });
    }
    function literal(constant) {
      const description = print(constant);
      const t = typeof constant;
      return new Struct({
        type: 'literal',
        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,
    
        validator(value) {
          return value === constant || "Expected the literal `" + description + "`, but received: " + print(value);
        }
    
      });
    }
    function map(Key, Value) {
      return new Struct({
        type: 'map',
        schema: null,
    
        *entries(value) {
          if (Key && Value && value instanceof Map) {
            for (const [k, v] of value.entries()) {
              yield [k, k, Key];
              yield [k, v, Value];
            }
          }
        },
    
        coercer(value) {
          return value instanceof Map ? new Map(value) : value;
        },
    
        validator(value) {
          return value instanceof Map || "Expected a `Map` object, but received: " + print(value);
        }
    
      });
    }
    /**
     * Ensure that no value ever passes validation.
     */
    
    function never() {
      return define('never', () => false);
    }
    /**
     * Augment an existing struct to allow `null` values.
     */
    
    function nullable(struct) {
      return new Struct({ ...struct,
        validator: (value, ctx) => value === null || struct.validator(value, ctx),
        refiner: (value, ctx) => value === null || struct.refiner(value, ctx)
      });
    }
    /**
     * Ensure that a value is a number.
     */
    
    function number() {
      return define('number', value => {
        return typeof value === 'number' && !isNaN(value) || "Expected a number, but received: " + print(value);
      });
    }
    function object(schema) {
      const knowns = schema ? Object.keys(schema) : [];
      const Never = never();
      return new Struct({
        type: 'object',
        schema: schema ? schema : null,
    
        *entries(value) {
          if (schema && isObject(value)) {
            const unknowns = new Set(Object.keys(value));
    
            for (const key of knowns) {
              unknowns.delete(key);
              yield [key, value[key], schema[key]];
            }
    
            for (const key of unknowns) {
              yield [key, value[key], Never];
            }
          }
        },
    
        validator(value) {
          return isObject(value) || "Expected an object, but received: " + print(value);
        },
    
        coercer(value) {
          return isObject(value) ? { ...value
          } : value;
        }
    
      });
    }
    /**
     * Augment a struct to allow `undefined` values.
     */
    
    function optional(struct) {
      return new Struct({ ...struct,
        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)
      });
    }
    /**
     * Ensure that a value is an object with keys and values of specific types, but
     * without ensuring any specific shape of properties.
     *
     * Like TypeScript's `Record` utility.
     */
    
    function record(Key, Value) {
      return new Struct({
        type: 'record',
        schema: null,
    
        *entries(value) {
          if (isObject(value)) {
            for (const k in value) {
              const v = value[k];
              yield [k, k, Key];
              yield [k, v, Value];
            }
          }
        },
    
        validator(value) {
          return isObject(value) || "Expected an object, but received: " + print(value);
        }
    
      });
    }
    /**
     * Ensure that a value is a `RegExp`.
     *
     * Note: this does not test the value against the regular expression! For that
     * you need to use the `pattern()` refinement.
     */
    
    function regexp() {
      return define('regexp', value => {
        return value instanceof RegExp;
      });
    }
    function set(Element) {
      return new Struct({
        type: 'set',
        schema: null,
    
        *entries(value) {
          if (Element && value instanceof Set) {
            for (const v of value) {
              yield [v, v, Element];
            }
          }
        },
    
        coercer(value) {
          return value instanceof Set ? new Set(value) : value;
        },
    
        validator(value) {
          return value instanceof Set || "Expected a `Set` object, but received: " + print(value);
        }
    
      });
    }
    /**
     * Ensure that a value is a string.
     */
    
    function string() {
      return define('string', value => {
        return typeof value === 'string' || "Expected a string, but received: " + print(value);
      });
    }
    function tuple(Elements) {
      const Never = never();
      return new Struct({
        type: 'tuple',
        schema: null,
    
        *entries(value) {
          if (Array.isArray(value)) {
            const length = Math.max(Elements.length, value.length);
    
            for (let i = 0; i < length; i++) {
              yield [i, value[i], Elements[i] || Never];
            }
          }
        },
    
        validator(value) {
          return Array.isArray(value) || "Expected an array, but received: " + print(value);
        }
    
      });
    }
    /**
     * Ensure that a value has a set of known properties of specific types.
     *
     * Note: Unrecognized properties are allowed and untouched. This is similar to
     * how TypeScript's structural typing works.
     */
    
    function type(schema) {
      const keys = Object.keys(schema);
      return new Struct({
        type: 'type',
        schema,
    
        *entries(value) {
          if (isObject(value)) {
            for (const k of keys) {
              yield [k, value[k], schema[k]];
            }
          }
        },
    
        validator(value) {
          return isObject(value) || "Expected an object, but received: " + print(value);
        }
    
      });
    }
    function union(Structs) {
      const description = Structs.map(s => s.type).join(' | ');
      return new Struct({
        type: 'union',
        schema: null,
    
        validator(value, ctx) {
          const failures = [];
    
          for (const S of Structs) {
            const [...tuples] = run(value, S, ctx);
            const [first] = tuples;
    
            if (!first[0]) {
              return [];
            } else {
              for (const [failure] of tuples) {
                if (failure) {
                  failures.push(failure);
                }
              }
            }
          }
    
          return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value), ...failures];
        }
    
      });
    }
    /**
     * Ensure that any value passes validation, without widening its type to `any`.
     */
    
    function unknown() {
      return define('unknown', () => true);
    }
    
    /**
     * Augment a `Struct` to add an additional coercion step to its input.
     *
     * This allows you to transform input data before validating it, to increase the
     * likelihood that it passes validationfor example for default values, parsing
     * different formats, etc.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    
    function coerce(struct, condition, coercer) {
      return new Struct({ ...struct,
        coercer: (value, ctx) => {
          return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
        }
      });
    }
    /**
     * Augment a struct to replace `undefined` values with a default.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    
    function defaulted(struct, fallback, options = {}) {
      return coerce(struct, unknown(), x => {
        const f = typeof fallback === 'function' ? fallback() : fallback;
    
        if (x === undefined) {
          return f;
        }
    
        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {
          const ret = { ...x
          };
          let changed = false;
    
          for (const key in f) {
            if (ret[key] === undefined) {
              ret[key] = f[key];
              changed = true;
            }
          }
    
          if (changed) {
            return ret;
          }
        }
    
        return x;
      });
    }
    /**
     * Augment a struct to trim string inputs.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    
    function trimmed(struct) {
      return coerce(struct, string(), x => x.trim());
    }
    
    /**
     * Ensure that a string, array, map, or set is empty.
     */
    
    function empty(struct) {
      const expected = "Expected an empty " + struct.type;
      return refine(struct, 'empty', value => {
        if (value instanceof Map || value instanceof Set) {
          const {
            size
          } = value;
          return size === 0 || expected + " but received one with a size of `" + size + "`";
        } else {
          const {
            length
          } = value;
          return length === 0 || expected + " but received one with a length of `" + length + "`";
        }
      });
    }
    /**
     * Ensure that a number or date is below a threshold.
     */
    
    function max(struct, threshold, options = {}) {
      const {
        exclusive
      } = options;
      return refine(struct, 'max', value => {
        return exclusive ? value < threshold : value <= threshold || "Expected a " + struct.type + " greater than " + (exclusive ? '' : 'or equal to ') + threshold + " but received `" + value + "`";
      });
    }
    /**
     * Ensure that a number or date is above a threshold.
     */
    
    function min(struct, threshold, options = {}) {
      const {
        exclusive
      } = options;
      return refine(struct, 'min', value => {
        return exclusive ? value > threshold : value >= threshold || "Expected a " + struct.type + " greater than " + (exclusive ? '' : 'or equal to ') + threshold + " but received `" + value + "`";
      });
    }
    /**
     * Ensure that a string matches a regular expression.
     */
    
    function pattern(struct, regexp) {
      return refine(struct, 'pattern', value => {
        return regexp.test(value) || "Expected a " + struct.type + " matching `/" + regexp.source + "/` but received \"" + value + "\"";
      });
    }
    /**
     * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.
     */
    
    function size(struct, min, max = min) {
      const expected = "Expected a " + struct.type;
      const of = min === max ? "of `" + min + "`" : "between `" + min + "` and `" + max + "`";
      return refine(struct, 'size', value => {
        if (typeof value === 'number' || value instanceof Date) {
          return min <= value && value <= max || expected + " " + of + " but received `" + value + "`";
        } else if (value instanceof Map || value instanceof Set) {
          const {
            size
          } = value;
          return min <= size && size <= max || expected + " with a size " + of + " but received one with a size of `" + size + "`";
        } else {
          const {
            length
          } = value;
          return min <= length && length <= max || expected + " with a length " + of + " but received one with a length of `" + length + "`";
        }
      });
    }
    /**
     * Augment a `Struct` to add an additional refinement to the validation.
     *
     * The refiner function is guaranteed to receive a value of the struct's type,
     * because the struct's existing validation will already have passed. This
     * allows you to layer additional validation on top of existing structs.
     */
    
    function refine(struct, name, refiner) {
      return new Struct({ ...struct,
    
        *refiner(value, ctx) {
          yield* struct.refiner(value, ctx);
          const result = refiner(value, ctx);
          const failures = toFailures(result, ctx, struct, value);
    
          for (const failure of failures) {
            yield { ...failure,
              refinement: name
            };
          }
        }
    
      });
    }
    
    exports.Struct = Struct;
    exports.StructError = StructError;
    exports.any = any;
    exports.array = array;
    exports.assert = assert;
    exports.assign = assign;
    exports.boolean = boolean;
    exports.coerce = coerce;
    exports.create = create;
    exports.date = date;
    exports.defaulted = defaulted;
    exports.define = define;
    exports.deprecated = deprecated;
    exports.dynamic = dynamic;
    exports.empty = empty;
    exports.enums = enums;
    exports.func = func;
    exports.instance = instance;
    exports.integer = integer;
    exports.intersection = intersection;
    exports.is = is;
    exports.lazy = lazy;
    exports.literal = literal;
    exports.map = map;
    exports.mask = mask;
    exports.max = max;
    exports.min = min;
    exports.never = never;
    exports.nullable = nullable;
    exports.number = number;
    exports.object = object;
    exports.omit = omit;
    exports.optional = optional;
    exports.partial = partial;
    exports.pattern = pattern;
    exports.pick = pick;
    exports.record = record;
    exports.refine = refine;
    exports.regexp = regexp;
    exports.set = set;
    exports.size = size;
    exports.string = string;
    exports.struct = struct;
    exports.trimmed = trimmed;
    exports.tuple = tuple;
    exports.type = type;
    exports.union = union;
    exports.unknown = unknown;
    exports.validate = validate;
    
    
    },{}],42:[function(require,module,exports){
    'use strict';
    
    // This is free and unencumbered software released into the public domain.
    // See LICENSE.md for more information.
    
    //
    // Utilities
    //
    
    /**
     * @param {number} a The number to test.
     * @param {number} min The minimum value in the range, inclusive.
     * @param {number} max The maximum value in the range, inclusive.
     * @return {boolean} True if a >= min and a <= max.
     */
    function inRange(a, min, max) {
      return min <= a && a <= max;
    }
    
    /**
     * @param {*} o
     * @return {Object}
     */
    function ToDictionary(o) {
      if (o === undefined) return {};
      if (o === Object(o)) return o;
      throw TypeError('Could not convert argument to dictionary');
    }
    
    /**
     * @param {string} string Input string of UTF-16 code units.
     * @return {!Array.<number>} Code points.
     */
    function stringToCodePoints(string) {
      // https://heycam.github.io/webidl/#dfn-obtain-unicode
    
      // 1. Let S be the DOMString value.
      var s = String(string);
    
      // 2. Let n be the length of S.
      var n = s.length;
    
      // 3. Initialize i to 0.
      var i = 0;
    
      // 4. Initialize U to be an empty sequence of Unicode characters.
      var u = [];
    
      // 5. While i < n:
      while (i < n) {
    
        // 1. Let c be the code unit in S at index i.
        var c = s.charCodeAt(i);
    
        // 2. Depending on the value of c:
    
        // c < 0xD800 or c > 0xDFFF
        if (c < 0xD800 || c > 0xDFFF) {
          // Append to U the Unicode character with code point c.
          u.push(c);
        }
    
        // 0xDC00  c  0xDFFF
        else if (0xDC00 <= c && c <= 0xDFFF) {
          // Append to U a U+FFFD REPLACEMENT CHARACTER.
          u.push(0xFFFD);
        }
    
        // 0xD800  c  0xDBFF
        else if (0xD800 <= c && c <= 0xDBFF) {
          // 1. If i = n1, then append to U a U+FFFD REPLACEMENT
          // CHARACTER.
          if (i === n - 1) {
            u.push(0xFFFD);
          }
          // 2. Otherwise, i < n1:
          else {
            // 1. Let d be the code unit in S at index i+1.
            var d = string.charCodeAt(i + 1);
    
            // 2. If 0xDC00  d  0xDFFF, then:
            if (0xDC00 <= d && d <= 0xDFFF) {
              // 1. Let a be c & 0x3FF.
              var a = c & 0x3FF;
    
              // 2. Let b be d & 0x3FF.
              var b = d & 0x3FF;
    
              // 3. Append to U the Unicode character with code point
              // 2^16+2^10*a+b.
              u.push(0x10000 + (a << 10) + b);
    
              // 4. Set i to i+1.
              i += 1;
            }
    
            // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a
            // U+FFFD REPLACEMENT CHARACTER.
            else  {
              u.push(0xFFFD);
            }
          }
        }
    
        // 3. Set i to i+1.
        i += 1;
      }
    
      // 6. Return U.
      return u;
    }
    
    /**
     * @param {!Array.<number>} code_points Array of code points.
     * @return {string} string String of UTF-16 code units.
     */
    function codePointsToString(code_points) {
      var s = '';
      for (var i = 0; i < code_points.length; ++i) {
        var cp = code_points[i];
        if (cp <= 0xFFFF) {
          s += String.fromCharCode(cp);
        } else {
          cp -= 0x10000;
          s += String.fromCharCode((cp >> 10) + 0xD800,
                                   (cp & 0x3FF) + 0xDC00);
        }
      }
      return s;
    }
    
    
    //
    // Implementation of Encoding specification
    // https://encoding.spec.whatwg.org/
    //
    
    //
    // 3. Terminology
    //
    
    /**
     * End-of-stream is a special token that signifies no more tokens
     * are in the stream.
     * @const
     */ var end_of_stream = -1;
    
    /**
     * A stream represents an ordered sequence of tokens.
     *
     * @constructor
     * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the
     * stream.
     */
    function Stream(tokens) {
      /** @type {!Array.<number>} */
      this.tokens = [].slice.call(tokens);
    }
    
    Stream.prototype = {
      /**
       * @return {boolean} True if end-of-stream has been hit.
       */
      endOfStream: function() {
        return !this.tokens.length;
      },
    
      /**
       * When a token is read from a stream, the first token in the
       * stream must be returned and subsequently removed, and
       * end-of-stream must be returned otherwise.
       *
       * @return {number} Get the next token from the stream, or
       * end_of_stream.
       */
       read: function() {
        if (!this.tokens.length)
          return end_of_stream;
         return this.tokens.shift();
       },
    
      /**
       * When one or more tokens are prepended to a stream, those tokens
       * must be inserted, in given order, before the first token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
       */
      prepend: function(token) {
        if (Array.isArray(token)) {
          var tokens = /**@type {!Array.<number>}*/(token);
          while (tokens.length)
            this.tokens.unshift(tokens.pop());
        } else {
          this.tokens.unshift(token);
        }
      },
    
      /**
       * When one or more tokens are pushed to a stream, those tokens
       * must be inserted, in given order, after the last token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
       */
      push: function(token) {
        if (Array.isArray(token)) {
          var tokens = /**@type {!Array.<number>}*/(token);
          while (tokens.length)
            this.tokens.push(tokens.shift());
        } else {
          this.tokens.push(token);
        }
      }
    };
    
    //
    // 4. Encodings
    //
    
    // 4.1 Encoders and decoders
    
    /** @const */
    var finished = -1;
    
    /**
     * @param {boolean} fatal If true, decoding errors raise an exception.
     * @param {number=} opt_code_point Override the standard fallback code point.
     * @return {number} The code point to insert on a decoding error.
     */
    function decoderError(fatal, opt_code_point) {
      if (fatal)
        throw TypeError('Decoder error');
      return opt_code_point || 0xFFFD;
    }
    
    //
    // 7. API
    //
    
    /** @const */ var DEFAULT_ENCODING = 'utf-8';
    
    // 7.1 Interface TextDecoder
    
    /**
     * @constructor
     * @param {string=} encoding The label of the encoding;
     *     defaults to 'utf-8'.
     * @param {Object=} options
     */
    function TextDecoder(encoding, options) {
      if (!(this instanceof TextDecoder)) {
        return new TextDecoder(encoding, options);
      }
      encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
      if (encoding !== DEFAULT_ENCODING) {
        throw new Error('Encoding not supported. Only utf-8 is supported');
      }
      options = ToDictionary(options);
    
      /** @private @type {boolean} */
      this._streaming = false;
      /** @private @type {boolean} */
      this._BOMseen = false;
      /** @private @type {?Decoder} */
      this._decoder = null;
      /** @private @type {boolean} */
      this._fatal = Boolean(options['fatal']);
      /** @private @type {boolean} */
      this._ignoreBOM = Boolean(options['ignoreBOM']);
    
      Object.defineProperty(this, 'encoding', {value: 'utf-8'});
      Object.defineProperty(this, 'fatal', {value: this._fatal});
      Object.defineProperty(this, 'ignoreBOM', {value: this._ignoreBOM});
    }
    
    TextDecoder.prototype = {
      /**
       * @param {ArrayBufferView=} input The buffer of bytes to decode.
       * @param {Object=} options
       * @return {string} The decoded string.
       */
      decode: function decode(input, options) {
        var bytes;
        if (typeof input === 'object' && input instanceof ArrayBuffer) {
          bytes = new Uint8Array(input);
        } else if (typeof input === 'object' && 'buffer' in input &&
                   input.buffer instanceof ArrayBuffer) {
          bytes = new Uint8Array(input.buffer,
                                 input.byteOffset,
                                 input.byteLength);
        } else {
          bytes = new Uint8Array(0);
        }
    
        options = ToDictionary(options);
    
        if (!this._streaming) {
          this._decoder = new UTF8Decoder({fatal: this._fatal});
          this._BOMseen = false;
        }
        this._streaming = Boolean(options['stream']);
    
        var input_stream = new Stream(bytes);
    
        var code_points = [];
    
        /** @type {?(number|!Array.<number>)} */
        var result;
    
        while (!input_stream.endOfStream()) {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (result === null)
            continue;
          if (Array.isArray(result))
            code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));
          else
            code_points.push(result);
        }
        if (!this._streaming) {
          do {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));
            else
              code_points.push(result);
          } while (!input_stream.endOfStream());
          this._decoder = null;
        }
    
        if (code_points.length) {
          // If encoding is one of utf-8, utf-16be, and utf-16le, and
          // ignore BOM flag and BOM seen flag are unset, run these
          // subsubsteps:
          if (['utf-8'].indexOf(this.encoding) !== -1 &&
              !this._ignoreBOM && !this._BOMseen) {
            // If token is U+FEFF, set BOM seen flag.
            if (code_points[0] === 0xFEFF) {
              this._BOMseen = true;
              code_points.shift();
            } else {
              // Otherwise, if token is not end-of-stream, set BOM seen
              // flag and append token to output.
              this._BOMseen = true;
            }
          }
        }
    
        return codePointsToString(code_points);
      }
    };
    
    // 7.2 Interface TextEncoder
    
    /**
     * @constructor
     * @param {string=} encoding The label of the encoding;
     *     defaults to 'utf-8'.
     * @param {Object=} options
     */
    function TextEncoder(encoding, options) {
      if (!(this instanceof TextEncoder))
        return new TextEncoder(encoding, options);
      encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
      if (encoding !== DEFAULT_ENCODING) {
        throw new Error('Encoding not supported. Only utf-8 is supported');
      }
      options = ToDictionary(options);
    
      /** @private @type {boolean} */
      this._streaming = false;
      /** @private @type {?Encoder} */
      this._encoder = null;
      /** @private @type {{fatal: boolean}} */
      this._options = {fatal: Boolean(options['fatal'])};
    
      Object.defineProperty(this, 'encoding', {value: 'utf-8'});
    }
    
    TextEncoder.prototype = {
      /**
       * @param {string=} opt_string The string to encode.
       * @param {Object=} options
       * @return {Uint8Array} Encoded bytes, as a Uint8Array.
       */
      encode: function encode(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : '';
        options = ToDictionary(options);
    
        // NOTE: This option is nonstandard. None of the encodings
        // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,
        // so streaming is not necessary.
        if (!this._streaming)
          this._encoder = new UTF8Encoder(this._options);
        this._streaming = Boolean(options['stream']);
    
        var bytes = [];
        var input_stream = new Stream(stringToCodePoints(opt_string));
        /** @type {?(number|!Array.<number>)} */
        var result;
        while (!input_stream.endOfStream()) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (Array.isArray(result))
            bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));
          else
            bytes.push(result);
        }
        if (!this._streaming) {
          while (true) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));
            else
              bytes.push(result);
          }
          this._encoder = null;
        }
        return new Uint8Array(bytes);
      }
    };
    
    //
    // 8. The encoding
    //
    
    // 8.1 utf-8
    
    /**
     * @constructor
     * @implements {Decoder}
     * @param {{fatal: boolean}} options
     */
    function UTF8Decoder(options) {
      var fatal = options.fatal;
    
      // utf-8's decoder's has an associated utf-8 code point, utf-8
      // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8
      // lower boundary (initially 0x80), and a utf-8 upper boundary
      // (initially 0xBF).
      var /** @type {number} */ utf8_code_point = 0,
          /** @type {number} */ utf8_bytes_seen = 0,
          /** @type {number} */ utf8_bytes_needed = 0,
          /** @type {number} */ utf8_lower_boundary = 0x80,
          /** @type {number} */ utf8_upper_boundary = 0xBF;
    
      /**
       * @param {Stream} stream The stream of bytes being decoded.
       * @param {number} bite The next byte read from the stream.
       * @return {?(number|!Array.<number>)} The next code point(s)
       *     decoded, or null if not enough data exists in the input
       *     stream to decode a complete code point.
       */
      this.handler = function(stream, bite) {
        // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,
        // set utf-8 bytes needed to 0 and return error.
        if (bite === end_of_stream && utf8_bytes_needed !== 0) {
          utf8_bytes_needed = 0;
          return decoderError(fatal);
        }
    
        // 2. If byte is end-of-stream, return finished.
        if (bite === end_of_stream)
          return finished;
    
        // 3. If utf-8 bytes needed is 0, based on byte:
        if (utf8_bytes_needed === 0) {
    
          // 0x00 to 0x7F
          if (inRange(bite, 0x00, 0x7F)) {
            // Return a code point whose value is byte.
            return bite;
          }
    
          // 0xC2 to 0xDF
          if (inRange(bite, 0xC2, 0xDF)) {
            // Set utf-8 bytes needed to 1 and utf-8 code point to byte
            //  0xC0.
            utf8_bytes_needed = 1;
            utf8_code_point = bite - 0xC0;
          }
    
          // 0xE0 to 0xEF
          else if (inRange(bite, 0xE0, 0xEF)) {
            // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.
            if (bite === 0xE0)
              utf8_lower_boundary = 0xA0;
            // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.
            if (bite === 0xED)
              utf8_upper_boundary = 0x9F;
            // 3. Set utf-8 bytes needed to 2 and utf-8 code point to
            // byte  0xE0.
            utf8_bytes_needed = 2;
            utf8_code_point = bite - 0xE0;
          }
    
          // 0xF0 to 0xF4
          else if (inRange(bite, 0xF0, 0xF4)) {
            // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.
            if (bite === 0xF0)
              utf8_lower_boundary = 0x90;
            // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.
            if (bite === 0xF4)
              utf8_upper_boundary = 0x8F;
            // 3. Set utf-8 bytes needed to 3 and utf-8 code point to
            // byte  0xF0.
            utf8_bytes_needed = 3;
            utf8_code_point = bite - 0xF0;
          }
    
          // Otherwise
          else {
            // Return error.
            return decoderError(fatal);
          }
    
          // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code
          // point to utf-8 code point << (6  utf-8 bytes needed) and
          // return continue.
          utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);
          return null;
        }
    
        // 4. If byte is not in the range utf-8 lower boundary to utf-8
        // upper boundary, run these substeps:
        if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
    
          // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8
          // bytes seen to 0, set utf-8 lower boundary to 0x80, and set
          // utf-8 upper boundary to 0xBF.
          utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
          utf8_lower_boundary = 0x80;
          utf8_upper_boundary = 0xBF;
    
          // 2. Prepend byte to stream.
          stream.prepend(bite);
    
          // 3. Return error.
          return decoderError(fatal);
        }
    
        // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary
        // to 0xBF.
        utf8_lower_boundary = 0x80;
        utf8_upper_boundary = 0xBF;
    
        // 6. Increase utf-8 bytes seen by one and set utf-8 code point
        // to utf-8 code point + (byte  0x80) << (6  (utf-8 bytes
        // needed  utf-8 bytes seen)).
        utf8_bytes_seen += 1;
        utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed - utf8_bytes_seen));
    
        // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,
        // continue.
        if (utf8_bytes_seen !== utf8_bytes_needed)
          return null;
    
        // 8. Let code point be utf-8 code point.
        var code_point = utf8_code_point;
    
        // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes
        // seen to 0.
        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    
        // 10. Return a code point whose value is code point.
        return code_point;
      };
    }
    
    /**
     * @constructor
     * @implements {Encoder}
     * @param {{fatal: boolean}} options
     */
    function UTF8Encoder(options) {
      var fatal = options.fatal;
      /**
       * @param {Stream} stream Input stream.
       * @param {number} code_point Next code point read from the stream.
       * @return {(number|!Array.<number>)} Byte(s) to emit.
       */
      this.handler = function(stream, code_point) {
        // 1. If code point is end-of-stream, return finished.
        if (code_point === end_of_stream)
          return finished;
    
        // 2. If code point is in the range U+0000 to U+007F, return a
        // byte whose value is code point.
        if (inRange(code_point, 0x0000, 0x007f))
          return code_point;
    
        // 3. Set count and offset based on the range code point is in:
        var count, offset;
        // U+0080 to U+07FF:    1 and 0xC0
        if (inRange(code_point, 0x0080, 0x07FF)) {
          count = 1;
          offset = 0xC0;
        }
        // U+0800 to U+FFFF:    2 and 0xE0
        else if (inRange(code_point, 0x0800, 0xFFFF)) {
          count = 2;
          offset = 0xE0;
        }
        // U+10000 to U+10FFFF: 3 and 0xF0
        else if (inRange(code_point, 0x10000, 0x10FFFF)) {
          count = 3;
          offset = 0xF0;
        }
    
        // 4.Let bytes be a byte sequence whose first byte is (code
        // point >> (6  count)) + offset.
        var bytes = [(code_point >> (6 * count)) + offset];
    
        // 5. Run these substeps while count is greater than 0:
        while (count > 0) {
    
          // 1. Set temp to code point >> (6  (count  1)).
          var temp = code_point >> (6 * (count - 1));
    
          // 2. Append to bytes 0x80 | (temp & 0x3F).
          bytes.push(0x80 | (temp & 0x3F));
    
          // 3. Decrease count by one.
          count -= 1;
        }
    
        // 6. Return bytes bytes, in order.
        return bytes;
      };
    }
    
    exports.TextEncoder = TextEncoder;
    exports.TextDecoder = TextDecoder;
    },{}],43:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function () {
        return _v.default;
      }
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function () {
        return _v2.default;
      }
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function () {
        return _v3.default;
      }
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function () {
        return _v4.default;
      }
    });
    Object.defineProperty(exports, "NIL", {
      enumerable: true,
      get: function () {
        return _nil.default;
      }
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function () {
        return _version.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function () {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "stringify", {
      enumerable: true,
      get: function () {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function () {
        return _parse.default;
      }
    });
    
    var _v = _interopRequireDefault(require("./v1.js"));
    
    var _v2 = _interopRequireDefault(require("./v3.js"));
    
    var _v3 = _interopRequireDefault(require("./v4.js"));
    
    var _v4 = _interopRequireDefault(require("./v5.js"));
    
    var _nil = _interopRequireDefault(require("./nil.js"));
    
    var _version = _interopRequireDefault(require("./version.js"));
    
    var _validate = _interopRequireDefault(require("./validate.js"));
    
    var _stringify = _interopRequireDefault(require("./stringify.js"));
    
    var _parse = _interopRequireDefault(require("./parse.js"));
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    },{"./nil.js":45,"./parse.js":46,"./stringify.js":50,"./v1.js":51,"./v3.js":52,"./v4.js":54,"./v5.js":55,"./validate.js":56,"./version.js":57}],44:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    
    /*
     * Browser-compatible JavaScript MD5
     *
     * Modification of JavaScript MD5
     * https://github.com/blueimp/JavaScript-MD5
     *
     * Copyright 2011, Sebastian Tschan
     * https://blueimp.net
     *
     * Licensed under the MIT license:
     * https://opensource.org/licenses/MIT
     *
     * Based on
     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
     * Digest Algorithm, as defined in RFC 1321.
     * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for more info.
     */
    function md5(bytes) {
      if (typeof bytes === 'string') {
        const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
    
        bytes = new Uint8Array(msg.length);
    
        for (let i = 0; i < msg.length; ++i) {
          bytes[i] = msg.charCodeAt(i);
        }
      }
    
      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    /*
     * Convert an array of little-endian words to an array of bytes
     */
    
    
    function md5ToHexEncodedArray(input) {
      const output = [];
      const length32 = input.length * 32;
      const hexTab = '0123456789abcdef';
    
      for (let i = 0; i < length32; i += 8) {
        const x = input[i >> 5] >>> i % 32 & 0xff;
        const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
        output.push(hex);
      }
    
      return output;
    }
    /**
     * Calculate output length with padding and bit length
     */
    
    
    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length.
     */
    
    
    function wordsToMd5(x, len) {
      /* append padding */
      x[len >> 5] |= 0x80 << len % 32;
      x[getOutputLength(len) - 1] = len;
      let a = 1732584193;
      let b = -271733879;
      let c = -1732584194;
      let d = 271733878;
    
      for (let i = 0; i < x.length; i += 16) {
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }
    
      return [a, b, c, d];
    }
    /*
     * Convert an array bytes to an array of little-endian words
     * Characters >255 have their high-byte silently ignored.
     */
    
    
    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }
    
      const length8 = input.length * 8;
      const output = new Uint32Array(getOutputLength(length8));
    
      for (let i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
      }
    
      return output;
    }
    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    
    
    function safeAdd(x, y) {
      const lsw = (x & 0xffff) + (y & 0xffff);
      const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 0xffff;
    }
    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    
    
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    
    
    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    
    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }
    
    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }
    
    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    
    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    
    var _default = md5;
    exports.default = _default;
    },{}],45:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = '00000000-0000-0000-0000-000000000000';
    exports.default = _default;
    },{}],46:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    
    var _validate = _interopRequireDefault(require("./validate.js"));
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function parse(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError('Invalid UUID');
      }
    
      let v;
      const arr = new Uint8Array(16); // Parse ########-....-....-....-............
    
      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 0xff;
      arr[2] = v >>> 8 & 0xff;
      arr[3] = v & 0xff; // Parse ........-####-....-....-............
    
      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 0xff; // Parse ........-....-####-....-............
    
      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 0xff; // Parse ........-....-....-####-............
    
      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 0xff; // Parse ........-....-....-....-############
      // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)
    
      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
      arr[11] = v / 0x100000000 & 0xff;
      arr[12] = v >>> 24 & 0xff;
      arr[13] = v >>> 16 & 0xff;
      arr[14] = v >>> 8 & 0xff;
      arr[15] = v & 0xff;
      return arr;
    }
    
    var _default = parse;
    exports.default = _default;
    },{"./validate.js":56}],47:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports.default = _default;
    },{}],48:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = rng;
    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    let getRandomValues;
    const rnds8 = new Uint8Array(16);
    
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
    
        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }
    
      return getRandomValues(rnds8);
    }
    },{}],49:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    
    // Adapted from Chris Veness' SHA1 code at
    // http://www.movable-type.co.uk/scripts/sha1.html
    function f(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;
    
        case 1:
          return x ^ y ^ z;
    
        case 2:
          return x & y ^ x & z ^ y & z;
    
        case 3:
          return x ^ y ^ z;
      }
    }
    
    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }
    
    function sha1(bytes) {
      const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
      const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    
      if (typeof bytes === 'string') {
        const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
    
        bytes = [];
    
        for (let i = 0; i < msg.length; ++i) {
          bytes.push(msg.charCodeAt(i));
        }
      } else if (!Array.isArray(bytes)) {
        // Convert Array-like to Array
        bytes = Array.prototype.slice.call(bytes);
      }
    
      bytes.push(0x80);
      const l = bytes.length / 4 + 2;
      const N = Math.ceil(l / 16);
      const M = new Array(N);
    
      for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);
    
        for (let j = 0; j < 16; ++j) {
          arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }
    
        M[i] = arr;
      }
    
      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
    
      for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);
    
        for (let t = 0; t < 16; ++t) {
          W[t] = M[i][t];
        }
    
        for (let t = 16; t < 80; ++t) {
          W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
    
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
    
        for (let t = 0; t < 80; ++t) {
          const s = Math.floor(t / 20);
          const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }
    
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }
    
      return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
    }
    
    var _default = sha1;
    exports.default = _default;
    },{}],50:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    
    var _validate = _interopRequireDefault(require("./validate.js"));
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */
    const byteToHex = [];
    
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).substr(1));
    }
    
    function stringify(arr, offset = 0) {
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields
    
      if (!(0, _validate.default)(uuid)) {
        throw TypeError('Stringified UUID is invalid');
      }
    
      return uuid;
    }
    
    var _default = stringify;
    exports.default = _default;
    },{"./validate.js":56}],51:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    
    var _rng = _interopRequireDefault(require("./rng.js"));
    
    var _stringify = _interopRequireDefault(require("./stringify.js"));
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    // **`v1()` - Generate time-based UUID**
    //
    // Inspired by https://github.com/LiosK/UUID.js
    // and http://docs.python.org/library/uuid.html
    let _nodeId;
    
    let _clockseq; // Previous uuid creation time
    
    
    let _lastMSecs = 0;
    let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details
    
    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
      // specified.  We do this lazily to minimize issues related to insufficient
      // system entropy.  See #189
    
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
    
        if (node == null) {
          // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
          node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
    
        if (clockseq == null) {
          // Per 4.2.2, randomize (14 bit) clockseq
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
        }
      } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
      // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
      // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
      // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    
    
      let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
      // cycle to simulate higher resolution clock
    
      let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)
    
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression
    
      if (dt < 0 && options.clockseq === undefined) {
        clockseq = clockseq + 1 & 0x3fff;
      } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
      // time interval
    
    
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
      } // Per 4.2.1.2 Throw error if too many uuids are requested
    
    
      if (nsecs >= 10000) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
    
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    
      msecs += 12219292800000; // `time_low`
    
      const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
      b[i++] = tl >>> 24 & 0xff;
      b[i++] = tl >>> 16 & 0xff;
      b[i++] = tl >>> 8 & 0xff;
      b[i++] = tl & 0xff; // `time_mid`
    
      const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
      b[i++] = tmh >>> 8 & 0xff;
      b[i++] = tmh & 0xff; // `time_high_and_version`
    
      b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    
      b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    
      b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`
    
      b[i++] = clockseq & 0xff; // `node`
    
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
    
      return buf || (0, _stringify.default)(b);
    }
    
    var _default = v1;
    exports.default = _default;
    },{"./rng.js":48,"./stringify.js":50}],52:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    
    var _v = _interopRequireDefault(require("./v35.js"));
    
    var _md = _interopRequireDefault(require("./md5.js"));
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    const v3 = (0, _v.default)('v3', 0x30, _md.default);
    var _default = v3;
    exports.default = _default;
    },{"./md5.js":44,"./v35.js":53}],53:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _default;
    exports.URL = exports.DNS = void 0;
    
    var _stringify = _interopRequireDefault(require("./stringify.js"));
    
    var _parse = _interopRequireDefault(require("./parse.js"));
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str)); // UTF8 escape
    
      const bytes = [];
    
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
    
      return bytes;
    }
    
    const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
    exports.DNS = DNS;
    const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
    exports.URL = URL;
    
    function _default(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        if (typeof value === 'string') {
          value = stringToBytes(value);
        }
    
        if (typeof namespace === 'string') {
          namespace = (0, _parse.default)(namespace);
        }
    
        if (namespace.length !== 16) {
          throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
        } // Compute hash of namespace and value, Per 4.3
        // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
        // hashfunc([...namespace, ... value])`
    
    
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 0x0f | version;
        bytes[8] = bytes[8] & 0x3f | 0x80;
    
        if (buf) {
          offset = offset || 0;
    
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
    
          return buf;
        }
    
        return (0, _stringify.default)(bytes);
      } // Function#name is not settable on some platforms (#270)
    
    
      try {
        generateUUID.name = name; // eslint-disable-next-line no-empty
      } catch (err) {} // For CommonJS default export support
    
    
      generateUUID.DNS = DNS;
      generateUUID.URL = URL;
      return generateUUID;
    }
    },{"./parse.js":46,"./stringify.js":50}],54:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    
    var _rng = _interopRequireDefault(require("./rng.js"));
    
    var _stringify = _interopRequireDefault(require("./stringify.js"));
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function v4(options, buf, offset) {
      options = options || {};
    
      const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    
    
      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    
      if (buf) {
        offset = offset || 0;
    
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
    
        return buf;
      }
    
      return (0, _stringify.default)(rnds);
    }
    
    var _default = v4;
    exports.default = _default;
    },{"./rng.js":48,"./stringify.js":50}],55:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    
    var _v = _interopRequireDefault(require("./v35.js"));
    
    var _sha = _interopRequireDefault(require("./sha1.js"));
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    const v5 = (0, _v.default)('v5', 0x50, _sha.default);
    var _default = v5;
    exports.default = _default;
    },{"./sha1.js":49,"./v35.js":53}],56:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    
    var _regex = _interopRequireDefault(require("./regex.js"));
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function validate(uuid) {
      return typeof uuid === 'string' && _regex.default.test(uuid);
    }
    
    var _default = validate;
    exports.default = _default;
    },{"./regex.js":47}],57:[function(require,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    
    var _validate = _interopRequireDefault(require("./validate.js"));
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function version(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError('Invalid UUID');
      }
    
      return parseInt(uuid.substr(14, 1), 16);
    }
    
    var _default = version;
    exports.default = _default;
    },{"./validate.js":56}]},{},[])("@solana/web3.js")
    });
    
    // //// spl:
    
    // window[tokenName] = (function (exports) {
    //   'use strict';
    
    //   function _defineProperty$1(obj, key, value) {
    //     if (key in obj) {
    //       Object.defineProperty(obj, key, {
    //         value: value,
    //         enumerable: true,
    //         configurable: true,
    //         writable: true
    //       });
    //     } else {
    //       obj[key] = value;
    //     }
    
    //     return obj;
    //   }
    
    //   var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
    
    //   function getAugmentedNamespace(n) {
    //       if (n.__esModule) return n;
    //       var a = Object.defineProperty({}, '__esModule', {value: true});
    //       Object.keys(n).forEach(function (k) {
    //           var d = Object.getOwnPropertyDescriptor(n, k);
    //           Object.defineProperty(a, k, d.get ? d : {
    //               enumerable: true,
    //               get: function () {
    //                   return n[k];
    //               }
    //           });
    //       });
    //       return a;
    //   }
    
    //   function commonjsRequire (path) {
    //       throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    //   }
    
    //   var buffer = {};
    
    //   var base64Js = {};
    
    //   base64Js.byteLength = byteLength;
    //   base64Js.toByteArray = toByteArray;
    //   base64Js.fromByteArray = fromByteArray;
    
    //   var lookup = [];
    //   var revLookup = [];
    //   var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    
    //   var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    //   for (var i = 0, len = code.length; i < len; ++i) {
    //     lookup[i] = code[i];
    //     revLookup[code.charCodeAt(i)] = i;
    //   }
    
    //   // Support decoding URL-safe base64 strings, as Node.js does.
    //   // See: https://en.wikipedia.org/wiki/Base64#URL_applications
    //   revLookup['-'.charCodeAt(0)] = 62;
    //   revLookup['_'.charCodeAt(0)] = 63;
    
    //   function getLens (b64) {
    //     var len = b64.length;
    
    //     if (len % 4 > 0) {
    //       throw new Error('Invalid string. Length must be a multiple of 4')
    //     }
    
    //     // Trim off extra bytes after placeholder bytes are found
    //     // See: https://github.com/beatgammit/base64-js/issues/42
    //     var validLen = b64.indexOf('=');
    //     if (validLen === -1) validLen = len;
    
    //     var placeHoldersLen = validLen === len
    //       ? 0
    //       : 4 - (validLen % 4);
    
    //     return [validLen, placeHoldersLen]
    //   }
    
    //   // base64 is 4/3 + up to two characters of the original data
    //   function byteLength (b64) {
    //     var lens = getLens(b64);
    //     var validLen = lens[0];
    //     var placeHoldersLen = lens[1];
    //     return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    //   }
    
    //   function _byteLength (b64, validLen, placeHoldersLen) {
    //     return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    //   }
    
    //   function toByteArray (b64) {
    //     var tmp;
    //     var lens = getLens(b64);
    //     var validLen = lens[0];
    //     var placeHoldersLen = lens[1];
    
    //     var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    
    //     var curByte = 0;
    
    //     // if there are placeholders, only get up to the last complete 4 chars
    //     var len = placeHoldersLen > 0
    //       ? validLen - 4
    //       : validLen;
    
    //     var i;
    //     for (i = 0; i < len; i += 4) {
    //       tmp =
    //         (revLookup[b64.charCodeAt(i)] << 18) |
    //         (revLookup[b64.charCodeAt(i + 1)] << 12) |
    //         (revLookup[b64.charCodeAt(i + 2)] << 6) |
    //         revLookup[b64.charCodeAt(i + 3)];
    //       arr[curByte++] = (tmp >> 16) & 0xFF;
    //       arr[curByte++] = (tmp >> 8) & 0xFF;
    //       arr[curByte++] = tmp & 0xFF;
    //     }
    
    //     if (placeHoldersLen === 2) {
    //       tmp =
    //         (revLookup[b64.charCodeAt(i)] << 2) |
    //         (revLookup[b64.charCodeAt(i + 1)] >> 4);
    //       arr[curByte++] = tmp & 0xFF;
    //     }
    
    //     if (placeHoldersLen === 1) {
    //       tmp =
    //         (revLookup[b64.charCodeAt(i)] << 10) |
    //         (revLookup[b64.charCodeAt(i + 1)] << 4) |
    //         (revLookup[b64.charCodeAt(i + 2)] >> 2);
    //       arr[curByte++] = (tmp >> 8) & 0xFF;
    //       arr[curByte++] = tmp & 0xFF;
    //     }
    
    //     return arr
    //   }
    
    //   function tripletToBase64 (num) {
    //     return lookup[num >> 18 & 0x3F] +
    //       lookup[num >> 12 & 0x3F] +
    //       lookup[num >> 6 & 0x3F] +
    //       lookup[num & 0x3F]
    //   }
    
    //   function encodeChunk (uint8, start, end) {
    //     var tmp;
    //     var output = [];
    //     for (var i = start; i < end; i += 3) {
    //       tmp =
    //         ((uint8[i] << 16) & 0xFF0000) +
    //         ((uint8[i + 1] << 8) & 0xFF00) +
    //         (uint8[i + 2] & 0xFF);
    //       output.push(tripletToBase64(tmp));
    //     }
    //     return output.join('')
    //   }
    
    //   function fromByteArray (uint8) {
    //     var tmp;
    //     var len = uint8.length;
    //     var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    //     var parts = [];
    //     var maxChunkLength = 16383; // must be multiple of 3
    
    //     // go through the array every three bytes, we'll deal with trailing stuff later
    //     for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    //       parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    //     }
    
    //     // pad the end with zeros, but make sure to not forget the extra bytes
    //     if (extraBytes === 1) {
    //       tmp = uint8[len - 1];
    //       parts.push(
    //         lookup[tmp >> 2] +
    //         lookup[(tmp << 4) & 0x3F] +
    //         '=='
    //       );
    //     } else if (extraBytes === 2) {
    //       tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    //       parts.push(
    //         lookup[tmp >> 10] +
    //         lookup[(tmp >> 4) & 0x3F] +
    //         lookup[(tmp << 2) & 0x3F] +
    //         '='
    //       );
    //     }
    
    //     return parts.join('')
    //   }
    
    //   var ieee754 = {};
    
    //   /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    
    //   ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
    //     var e, m;
    //     var eLen = (nBytes * 8) - mLen - 1;
    //     var eMax = (1 << eLen) - 1;
    //     var eBias = eMax >> 1;
    //     var nBits = -7;
    //     var i = isLE ? (nBytes - 1) : 0;
    //     var d = isLE ? -1 : 1;
    //     var s = buffer[offset + i];
    
    //     i += d;
    
    //     e = s & ((1 << (-nBits)) - 1);
    //     s >>= (-nBits);
    //     nBits += eLen;
    //     for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}
    
    //     m = e & ((1 << (-nBits)) - 1);
    //     e >>= (-nBits);
    //     nBits += mLen;
    //     for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}
    
    //     if (e === 0) {
    //       e = 1 - eBias;
    //     } else if (e === eMax) {
    //       return m ? NaN : ((s ? -1 : 1) * Infinity)
    //     } else {
    //       m = m + Math.pow(2, mLen);
    //       e = e - eBias;
    //     }
    //     return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    //   };
    
    //   ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    //     var e, m, c;
    //     var eLen = (nBytes * 8) - mLen - 1;
    //     var eMax = (1 << eLen) - 1;
    //     var eBias = eMax >> 1;
    //     var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    //     var i = isLE ? 0 : (nBytes - 1);
    //     var d = isLE ? 1 : -1;
    //     var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    
    //     value = Math.abs(value);
    
    //     if (isNaN(value) || value === Infinity) {
    //       m = isNaN(value) ? 1 : 0;
    //       e = eMax;
    //     } else {
    //       e = Math.floor(Math.log(value) / Math.LN2);
    //       if (value * (c = Math.pow(2, -e)) < 1) {
    //         e--;
    //         c *= 2;
    //       }
    //       if (e + eBias >= 1) {
    //         value += rt / c;
    //       } else {
    //         value += rt * Math.pow(2, 1 - eBias);
    //       }
    //       if (value * c >= 2) {
    //         e++;
    //         c /= 2;
    //       }
    
    //       if (e + eBias >= eMax) {
    //         m = 0;
    //         e = eMax;
    //       } else if (e + eBias >= 1) {
    //         m = ((value * c) - 1) * Math.pow(2, mLen);
    //         e = e + eBias;
    //       } else {
    //         m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
    //         e = 0;
    //       }
    //     }
    
    //     for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    
    //     e = (e << mLen) | m;
    //     eLen += mLen;
    //     for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    
    //     buffer[offset + i - d] |= s * 128;
    //   };
    
    //   /*!
    //    * The buffer module from node.js, for the browser.
    //    *
    //    * @author   Feross Aboukhadijeh <https://feross.org>
    //    * @license  MIT
    //    */
    
    //   (function (exports) {
    
    //   const base64 = base64Js;
    //   const ieee754$1 = ieee754;
    //   const customInspectSymbol =
    //     (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    //       ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    //       : null;
    
    //   exports.Buffer = Buffer;
    //   exports.SlowBuffer = SlowBuffer;
    //   exports.INSPECT_MAX_BYTES = 50;
    
    //   const K_MAX_LENGTH = 0x7fffffff;
    //   exports.kMaxLength = K_MAX_LENGTH;
    
    //   /**
    //    * If `Buffer.TYPED_ARRAY_SUPPORT`:
    //    *   === true    Use Uint8Array implementation (fastest)
    //    *   === false   Print warning and recommend using `buffer` v4.x which has an Object
    //    *               implementation (most compatible, even IE6)
    //    *
    //    * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
    //    * Opera 11.6+, iOS 4.2+.
    //    *
    //    * We report that the browser does not support typed arrays if the are not subclassable
    //    * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
    //    * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
    //    * for __proto__ and has a buggy typed array implementation.
    //    */
    //   Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
    
    //   if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    //       typeof console.error === 'function') {
    //     console.error(
    //       'This browser lacks typed array (Uint8Array) support which is required by ' +
    //       '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
    //     );
    //   }
    
    //   function typedArraySupport () {
    //     // Can typed array instances can be augmented?
    //     try {
    //       const arr = new Uint8Array(1);
    //       const proto = { foo: function () { return 42 } };
    //       Object.setPrototypeOf(proto, Uint8Array.prototype);
    //       Object.setPrototypeOf(arr, proto);
    //       return arr.foo() === 42
    //     } catch (e) {
    //       return false
    //     }
    //   }
    
    //   Object.defineProperty(Buffer.prototype, 'parent', {
    //     enumerable: true,
    //     get: function () {
    //       if (!Buffer.isBuffer(this)) return undefined
    //       return this.buffer
    //     }
    //   });
    
    //   Object.defineProperty(Buffer.prototype, 'offset', {
    //     enumerable: true,
    //     get: function () {
    //       if (!Buffer.isBuffer(this)) return undefined
    //       return this.byteOffset
    //     }
    //   });
    
    //   function createBuffer (length) {
    //     if (length > K_MAX_LENGTH) {
    //       throw new RangeError('The value "' + length + '" is invalid for option "size"')
    //     }
    //     // Return an augmented `Uint8Array` instance
    //     const buf = new Uint8Array(length);
    //     Object.setPrototypeOf(buf, Buffer.prototype);
    //     return buf
    //   }
    
    //   /**
    //    * The Buffer constructor returns instances of `Uint8Array` that have their
    //    * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
    //    * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
    //    * and the `Uint8Array` methods. Square bracket notation works as expected -- it
    //    * returns a single octet.
    //    *
    //    * The `Uint8Array` prototype remains unmodified.
    //    */
    
    //   function Buffer (arg, encodingOrOffset, length) {
    //     // Common case.
    //     if (typeof arg === 'number') {
    //       if (typeof encodingOrOffset === 'string') {
    //         throw new TypeError(
    //           'The "string" argument must be of type string. Received type number'
    //         )
    //       }
    //       return allocUnsafe(arg)
    //     }
    //     return from(arg, encodingOrOffset, length)
    //   }
    
    //   Buffer.poolSize = 8192; // not used by this implementation
    
    //   function from (value, encodingOrOffset, length) {
    //     if (typeof value === 'string') {
    //       return fromString(value, encodingOrOffset)
    //     }
    
    //     if (ArrayBuffer.isView(value)) {
    //       return fromArrayView(value)
    //     }
    
    //     if (value == null) {
    //       throw new TypeError(
    //         'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    //         'or Array-like Object. Received type ' + (typeof value)
    //       )
    //     }
    
    //     if (isInstance(value, ArrayBuffer) ||
    //         (value && isInstance(value.buffer, ArrayBuffer))) {
    //       return fromArrayBuffer(value, encodingOrOffset, length)
    //     }
    
    //     if (typeof SharedArrayBuffer !== 'undefined' &&
    //         (isInstance(value, SharedArrayBuffer) ||
    //         (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    //       return fromArrayBuffer(value, encodingOrOffset, length)
    //     }
    
    //     if (typeof value === 'number') {
    //       throw new TypeError(
    //         'The "value" argument must not be of type number. Received type number'
    //       )
    //     }
    
    //     const valueOf = value.valueOf && value.valueOf();
    //     if (valueOf != null && valueOf !== value) {
    //       return Buffer.from(valueOf, encodingOrOffset, length)
    //     }
    
    //     const b = fromObject(value);
    //     if (b) return b
    
    //     if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
    //         typeof value[Symbol.toPrimitive] === 'function') {
    //       return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
    //     }
    
    //     throw new TypeError(
    //       'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    //       'or Array-like Object. Received type ' + (typeof value)
    //     )
    //   }
    
    //   /**
    //    * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
    //    * if value is a number.
    //    * Buffer.from(str[, encoding])
    //    * Buffer.from(array)
    //    * Buffer.from(buffer)
    //    * Buffer.from(arrayBuffer[, byteOffset[, length]])
    //    **/
    //   Buffer.from = function (value, encodingOrOffset, length) {
    //     return from(value, encodingOrOffset, length)
    //   };
    
    //   // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    //   // https://github.com/feross/buffer/pull/148
    //   Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    //   Object.setPrototypeOf(Buffer, Uint8Array);
    
    //   function assertSize (size) {
    //     if (typeof size !== 'number') {
    //       throw new TypeError('"size" argument must be of type number')
    //     } else if (size < 0) {
    //       throw new RangeError('The value "' + size + '" is invalid for option "size"')
    //     }
    //   }
    
    //   function alloc (size, fill, encoding) {
    //     assertSize(size);
    //     if (size <= 0) {
    //       return createBuffer(size)
    //     }
    //     if (fill !== undefined) {
    //       // Only pay attention to encoding if it's a string. This
    //       // prevents accidentally sending in a number that would
    //       // be interpreted as a start offset.
    //       return typeof encoding === 'string'
    //         ? createBuffer(size).fill(fill, encoding)
    //         : createBuffer(size).fill(fill)
    //     }
    //     return createBuffer(size)
    //   }
    
    //   /**
    //    * Creates a new filled Buffer instance.
    //    * alloc(size[, fill[, encoding]])
    //    **/
    //   Buffer.alloc = function (size, fill, encoding) {
    //     return alloc(size, fill, encoding)
    //   };
    
    //   function allocUnsafe (size) {
    //     assertSize(size);
    //     return createBuffer(size < 0 ? 0 : checked(size) | 0)
    //   }
    
    //   /**
    //    * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
    //    * */
    //   Buffer.allocUnsafe = function (size) {
    //     return allocUnsafe(size)
    //   };
    //   /**
    //    * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
    //    */
    //   Buffer.allocUnsafeSlow = function (size) {
    //     return allocUnsafe(size)
    //   };
    
    //   function fromString (string, encoding) {
    //     if (typeof encoding !== 'string' || encoding === '') {
    //       encoding = 'utf8';
    //     }
    
    //     if (!Buffer.isEncoding(encoding)) {
    //       throw new TypeError('Unknown encoding: ' + encoding)
    //     }
    
    //     const length = byteLength(string, encoding) | 0;
    //     let buf = createBuffer(length);
    
    //     const actual = buf.write(string, encoding);
    
    //     if (actual !== length) {
    //       // Writing a hex string, for example, that contains invalid characters will
    //       // cause everything after the first invalid character to be ignored. (e.g.
    //       // 'abxxcd' will be treated as 'ab')
    //       buf = buf.slice(0, actual);
    //     }
    
    //     return buf
    //   }
    
    //   function fromArrayLike (array) {
    //     const length = array.length < 0 ? 0 : checked(array.length) | 0;
    //     const buf = createBuffer(length);
    //     for (let i = 0; i < length; i += 1) {
    //       buf[i] = array[i] & 255;
    //     }
    //     return buf
    //   }
    
    //   function fromArrayView (arrayView) {
    //     if (isInstance(arrayView, Uint8Array)) {
    //       const copy = new Uint8Array(arrayView);
    //       return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
    //     }
    //     return fromArrayLike(arrayView)
    //   }
    
    //   function fromArrayBuffer (array, byteOffset, length) {
    //     if (byteOffset < 0 || array.byteLength < byteOffset) {
    //       throw new RangeError('"offset" is outside of buffer bounds')
    //     }
    
    //     if (array.byteLength < byteOffset + (length || 0)) {
    //       throw new RangeError('"length" is outside of buffer bounds')
    //     }
    
    //     let buf;
    //     if (byteOffset === undefined && length === undefined) {
    //       buf = new Uint8Array(array);
    //     } else if (length === undefined) {
    //       buf = new Uint8Array(array, byteOffset);
    //     } else {
    //       buf = new Uint8Array(array, byteOffset, length);
    //     }
    
    //     // Return an augmented `Uint8Array` instance
    //     Object.setPrototypeOf(buf, Buffer.prototype);
    
    //     return buf
    //   }
    
    //   function fromObject (obj) {
    //     if (Buffer.isBuffer(obj)) {
    //       const len = checked(obj.length) | 0;
    //       const buf = createBuffer(len);
    
    //       if (buf.length === 0) {
    //         return buf
    //       }
    
    //       obj.copy(buf, 0, 0, len);
    //       return buf
    //     }
    
    //     if (obj.length !== undefined) {
    //       if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
    //         return createBuffer(0)
    //       }
    //       return fromArrayLike(obj)
    //     }
    
    //     if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    //       return fromArrayLike(obj.data)
    //     }
    //   }
    
    //   function checked (length) {
    //     // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    //     // length is NaN (which is otherwise coerced to zero.)
    //     if (length >= K_MAX_LENGTH) {
    //       throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
    //                            'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
    //     }
    //     return length | 0
    //   }
    
    //   function SlowBuffer (length) {
    //     if (+length != length) { // eslint-disable-line eqeqeq
    //       length = 0;
    //     }
    //     return Buffer.alloc(+length)
    //   }
    
    //   Buffer.isBuffer = function isBuffer (b) {
    //     return b != null && b._isBuffer === true &&
    //       b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    //   };
    
    //   Buffer.compare = function compare (a, b) {
    //     if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    //     if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    //     if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    //       throw new TypeError(
    //         'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    //       )
    //     }
    
    //     if (a === b) return 0
    
    //     let x = a.length;
    //     let y = b.length;
    
    //     for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    //       if (a[i] !== b[i]) {
    //         x = a[i];
    //         y = b[i];
    //         break
    //       }
    //     }
    
    //     if (x < y) return -1
    //     if (y < x) return 1
    //     return 0
    //   };
    
    //   Buffer.isEncoding = function isEncoding (encoding) {
    //     switch (String(encoding).toLowerCase()) {
    //       case 'hex':
    //       case 'utf8':
    //       case 'utf-8':
    //       case 'ascii':
    //       case 'latin1':
    //       case 'binary':
    //       case 'base64':
    //       case 'ucs2':
    //       case 'ucs-2':
    //       case 'utf16le':
    //       case 'utf-16le':
    //         return true
    //       default:
    //         return false
    //     }
    //   };
    
    //   Buffer.concat = function concat (list, length) {
    //     if (!Array.isArray(list)) {
    //       throw new TypeError('"list" argument must be an Array of Buffers')
    //     }
    
    //     if (list.length === 0) {
    //       return Buffer.alloc(0)
    //     }
    
    //     let i;
    //     if (length === undefined) {
    //       length = 0;
    //       for (i = 0; i < list.length; ++i) {
    //         length += list[i].length;
    //       }
    //     }
    
    //     const buffer = Buffer.allocUnsafe(length);
    //     let pos = 0;
    //     for (i = 0; i < list.length; ++i) {
    //       let buf = list[i];
    //       if (isInstance(buf, Uint8Array)) {
    //         if (pos + buf.length > buffer.length) {
    //           if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
    //           buf.copy(buffer, pos);
    //         } else {
    //           Uint8Array.prototype.set.call(
    //             buffer,
    //             buf,
    //             pos
    //           );
    //         }
    //       } else if (!Buffer.isBuffer(buf)) {
    //         throw new TypeError('"list" argument must be an Array of Buffers')
    //       } else {
    //         buf.copy(buffer, pos);
    //       }
    //       pos += buf.length;
    //     }
    //     return buffer
    //   };
    
    //   function byteLength (string, encoding) {
    //     if (Buffer.isBuffer(string)) {
    //       return string.length
    //     }
    //     if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    //       return string.byteLength
    //     }
    //     if (typeof string !== 'string') {
    //       throw new TypeError(
    //         'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
    //         'Received type ' + typeof string
    //       )
    //     }
    
    //     const len = string.length;
    //     const mustMatch = (arguments.length > 2 && arguments[2] === true);
    //     if (!mustMatch && len === 0) return 0
    
    //     // Use a for loop to avoid recursion
    //     let loweredCase = false;
    //     for (;;) {
    //       switch (encoding) {
    //         case 'ascii':
    //         case 'latin1':
    //         case 'binary':
    //           return len
    //         case 'utf8':
    //         case 'utf-8':
    //           return utf8ToBytes(string).length
    //         case 'ucs2':
    //         case 'ucs-2':
    //         case 'utf16le':
    //         case 'utf-16le':
    //           return len * 2
    //         case 'hex':
    //           return len >>> 1
    //         case 'base64':
    //           return base64ToBytes(string).length
    //         default:
    //           if (loweredCase) {
    //             return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
    //           }
    //           encoding = ('' + encoding).toLowerCase();
    //           loweredCase = true;
    //       }
    //     }
    //   }
    //   Buffer.byteLength = byteLength;
    
    //   function slowToString (encoding, start, end) {
    //     let loweredCase = false;
    
    //     // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    //     // property of a typed array.
    
    //     // This behaves neither like String nor Uint8Array in that we set start/end
    //     // to their upper/lower bounds if the value passed is out of range.
    //     // undefined is handled specially as per ECMA-262 6th Edition,
    //     // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    //     if (start === undefined || start < 0) {
    //       start = 0;
    //     }
    //     // Return early if start > this.length. Done here to prevent potential uint32
    //     // coercion fail below.
    //     if (start > this.length) {
    //       return ''
    //     }
    
    //     if (end === undefined || end > this.length) {
    //       end = this.length;
    //     }
    
    //     if (end <= 0) {
    //       return ''
    //     }
    
    //     // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    //     end >>>= 0;
    //     start >>>= 0;
    
    //     if (end <= start) {
    //       return ''
    //     }
    
    //     if (!encoding) encoding = 'utf8';
    
    //     while (true) {
    //       switch (encoding) {
    //         case 'hex':
    //           return hexSlice(this, start, end)
    
    //         case 'utf8':
    //         case 'utf-8':
    //           return utf8Slice(this, start, end)
    
    //         case 'ascii':
    //           return asciiSlice(this, start, end)
    
    //         case 'latin1':
    //         case 'binary':
    //           return latin1Slice(this, start, end)
    
    //         case 'base64':
    //           return base64Slice(this, start, end)
    
    //         case 'ucs2':
    //         case 'ucs-2':
    //         case 'utf16le':
    //         case 'utf-16le':
    //           return utf16leSlice(this, start, end)
    
    //         default:
    //           if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
    //           encoding = (encoding + '').toLowerCase();
    //           loweredCase = true;
    //       }
    //     }
    //   }
    
    //   // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    //   // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    //   // reliably in a browserify context because there could be multiple different
    //   // copies of the 'buffer' package in use. This method works even for Buffer
    //   // instances that were created from another copy of the `buffer` package.
    //   // See: https://github.com/feross/buffer/issues/154
    //   Buffer.prototype._isBuffer = true;
    
    //   function swap (b, n, m) {
    //     const i = b[n];
    //     b[n] = b[m];
    //     b[m] = i;
    //   }
    
    //   Buffer.prototype.swap16 = function swap16 () {
    //     const len = this.length;
    //     if (len % 2 !== 0) {
    //       throw new RangeError('Buffer size must be a multiple of 16-bits')
    //     }
    //     for (let i = 0; i < len; i += 2) {
    //       swap(this, i, i + 1);
    //     }
    //     return this
    //   };
    
    //   Buffer.prototype.swap32 = function swap32 () {
    //     const len = this.length;
    //     if (len % 4 !== 0) {
    //       throw new RangeError('Buffer size must be a multiple of 32-bits')
    //     }
    //     for (let i = 0; i < len; i += 4) {
    //       swap(this, i, i + 3);
    //       swap(this, i + 1, i + 2);
    //     }
    //     return this
    //   };
    
    //   Buffer.prototype.swap64 = function swap64 () {
    //     const len = this.length;
    //     if (len % 8 !== 0) {
    //       throw new RangeError('Buffer size must be a multiple of 64-bits')
    //     }
    //     for (let i = 0; i < len; i += 8) {
    //       swap(this, i, i + 7);
    //       swap(this, i + 1, i + 6);
    //       swap(this, i + 2, i + 5);
    //       swap(this, i + 3, i + 4);
    //     }
    //     return this
    //   };
    
    //   Buffer.prototype.toString = function toString () {
    //     const length = this.length;
    //     if (length === 0) return ''
    //     if (arguments.length === 0) return utf8Slice(this, 0, length)
    //     return slowToString.apply(this, arguments)
    //   };
    
    //   Buffer.prototype.toLocaleString = Buffer.prototype.toString;
    
    //   Buffer.prototype.equals = function equals (b) {
    //     if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
    //     if (this === b) return true
    //     return Buffer.compare(this, b) === 0
    //   };
    
    //   Buffer.prototype.inspect = function inspect () {
    //     let str = '';
    //     const max = exports.INSPECT_MAX_BYTES;
    //     str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    //     if (this.length > max) str += ' ... ';
    //     return '<Buffer ' + str + '>'
    //   };
    //   if (customInspectSymbol) {
    //     Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    //   }
    
    //   Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    //     if (isInstance(target, Uint8Array)) {
    //       target = Buffer.from(target, target.offset, target.byteLength);
    //     }
    //     if (!Buffer.isBuffer(target)) {
    //       throw new TypeError(
    //         'The "target" argument must be one of type Buffer or Uint8Array. ' +
    //         'Received type ' + (typeof target)
    //       )
    //     }
    
    //     if (start === undefined) {
    //       start = 0;
    //     }
    //     if (end === undefined) {
    //       end = target ? target.length : 0;
    //     }
    //     if (thisStart === undefined) {
    //       thisStart = 0;
    //     }
    //     if (thisEnd === undefined) {
    //       thisEnd = this.length;
    //     }
    
    //     if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    //       throw new RangeError('out of range index')
    //     }
    
    //     if (thisStart >= thisEnd && start >= end) {
    //       return 0
    //     }
    //     if (thisStart >= thisEnd) {
    //       return -1
    //     }
    //     if (start >= end) {
    //       return 1
    //     }
    
    //     start >>>= 0;
    //     end >>>= 0;
    //     thisStart >>>= 0;
    //     thisEnd >>>= 0;
    
    //     if (this === target) return 0
    
    //     let x = thisEnd - thisStart;
    //     let y = end - start;
    //     const len = Math.min(x, y);
    
    //     const thisCopy = this.slice(thisStart, thisEnd);
    //     const targetCopy = target.slice(start, end);
    
    //     for (let i = 0; i < len; ++i) {
    //       if (thisCopy[i] !== targetCopy[i]) {
    //         x = thisCopy[i];
    //         y = targetCopy[i];
    //         break
    //       }
    //     }
    
    //     if (x < y) return -1
    //     if (y < x) return 1
    //     return 0
    //   };
    
    //   // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    //   // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //   //
    //   // Arguments:
    //   // - buffer - a Buffer to search
    //   // - val - a string, Buffer, or number
    //   // - byteOffset - an index into `buffer`; will be clamped to an int32
    //   // - encoding - an optional encoding, relevant is val is a string
    //   // - dir - true for indexOf, false for lastIndexOf
    //   function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    //     // Empty buffer means no match
    //     if (buffer.length === 0) return -1
    
    //     // Normalize byteOffset
    //     if (typeof byteOffset === 'string') {
    //       encoding = byteOffset;
    //       byteOffset = 0;
    //     } else if (byteOffset > 0x7fffffff) {
    //       byteOffset = 0x7fffffff;
    //     } else if (byteOffset < -0x80000000) {
    //       byteOffset = -0x80000000;
    //     }
    //     byteOffset = +byteOffset; // Coerce to Number.
    //     if (numberIsNaN(byteOffset)) {
    //       // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    //       byteOffset = dir ? 0 : (buffer.length - 1);
    //     }
    
    //     // Normalize byteOffset: negative offsets start from the end of the buffer
    //     if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    //     if (byteOffset >= buffer.length) {
    //       if (dir) return -1
    //       else byteOffset = buffer.length - 1;
    //     } else if (byteOffset < 0) {
    //       if (dir) byteOffset = 0;
    //       else return -1
    //     }
    
    //     // Normalize val
    //     if (typeof val === 'string') {
    //       val = Buffer.from(val, encoding);
    //     }
    
    //     // Finally, search either indexOf (if dir is true) or lastIndexOf
    //     if (Buffer.isBuffer(val)) {
    //       // Special case: looking for empty string/buffer always fails
    //       if (val.length === 0) {
    //         return -1
    //       }
    //       return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    //     } else if (typeof val === 'number') {
    //       val = val & 0xFF; // Search for a byte value [0-255]
    //       if (typeof Uint8Array.prototype.indexOf === 'function') {
    //         if (dir) {
    //           return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
    //         } else {
    //           return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
    //         }
    //       }
    //       return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
    //     }
    
    //     throw new TypeError('val must be string, number or Buffer')
    //   }
    
    //   function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    //     let indexSize = 1;
    //     let arrLength = arr.length;
    //     let valLength = val.length;
    
    //     if (encoding !== undefined) {
    //       encoding = String(encoding).toLowerCase();
    //       if (encoding === 'ucs2' || encoding === 'ucs-2' ||
    //           encoding === 'utf16le' || encoding === 'utf-16le') {
    //         if (arr.length < 2 || val.length < 2) {
    //           return -1
    //         }
    //         indexSize = 2;
    //         arrLength /= 2;
    //         valLength /= 2;
    //         byteOffset /= 2;
    //       }
    //     }
    
    //     function read (buf, i) {
    //       if (indexSize === 1) {
    //         return buf[i]
    //       } else {
    //         return buf.readUInt16BE(i * indexSize)
    //       }
    //     }
    
    //     let i;
    //     if (dir) {
    //       let foundIndex = -1;
    //       for (i = byteOffset; i < arrLength; i++) {
    //         if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
    //           if (foundIndex === -1) foundIndex = i;
    //           if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
    //         } else {
    //           if (foundIndex !== -1) i -= i - foundIndex;
    //           foundIndex = -1;
    //         }
    //       }
    //     } else {
    //       if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    //       for (i = byteOffset; i >= 0; i--) {
    //         let found = true;
    //         for (let j = 0; j < valLength; j++) {
    //           if (read(arr, i + j) !== read(val, j)) {
    //             found = false;
    //             break
    //           }
    //         }
    //         if (found) return i
    //       }
    //     }
    
    //     return -1
    //   }
    
    //   Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    //     return this.indexOf(val, byteOffset, encoding) !== -1
    //   };
    
    //   Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    //     return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    //   };
    
    //   Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    //     return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    //   };
    
    //   function hexWrite (buf, string, offset, length) {
    //     offset = Number(offset) || 0;
    //     const remaining = buf.length - offset;
    //     if (!length) {
    //       length = remaining;
    //     } else {
    //       length = Number(length);
    //       if (length > remaining) {
    //         length = remaining;
    //       }
    //     }
    
    //     const strLen = string.length;
    
    //     if (length > strLen / 2) {
    //       length = strLen / 2;
    //     }
    //     let i;
    //     for (i = 0; i < length; ++i) {
    //       const parsed = parseInt(string.substr(i * 2, 2), 16);
    //       if (numberIsNaN(parsed)) return i
    //       buf[offset + i] = parsed;
    //     }
    //     return i
    //   }
    
    //   function utf8Write (buf, string, offset, length) {
    //     return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    //   }
    
    //   function asciiWrite (buf, string, offset, length) {
    //     return blitBuffer(asciiToBytes(string), buf, offset, length)
    //   }
    
    //   function base64Write (buf, string, offset, length) {
    //     return blitBuffer(base64ToBytes(string), buf, offset, length)
    //   }
    
    //   function ucs2Write (buf, string, offset, length) {
    //     return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    //   }
    
    //   Buffer.prototype.write = function write (string, offset, length, encoding) {
    //     // Buffer#write(string)
    //     if (offset === undefined) {
    //       encoding = 'utf8';
    //       length = this.length;
    //       offset = 0;
    //     // Buffer#write(string, encoding)
    //     } else if (length === undefined && typeof offset === 'string') {
    //       encoding = offset;
    //       length = this.length;
    //       offset = 0;
    //     // Buffer#write(string, offset[, length][, encoding])
    //     } else if (isFinite(offset)) {
    //       offset = offset >>> 0;
    //       if (isFinite(length)) {
    //         length = length >>> 0;
    //         if (encoding === undefined) encoding = 'utf8';
    //       } else {
    //         encoding = length;
    //         length = undefined;
    //       }
    //     } else {
    //       throw new Error(
    //         'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    //       )
    //     }
    
    //     const remaining = this.length - offset;
    //     if (length === undefined || length > remaining) length = remaining;
    
    //     if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    //       throw new RangeError('Attempt to write outside buffer bounds')
    //     }
    
    //     if (!encoding) encoding = 'utf8';
    
    //     let loweredCase = false;
    //     for (;;) {
    //       switch (encoding) {
    //         case 'hex':
    //           return hexWrite(this, string, offset, length)
    
    //         case 'utf8':
    //         case 'utf-8':
    //           return utf8Write(this, string, offset, length)
    
    //         case 'ascii':
    //         case 'latin1':
    //         case 'binary':
    //           return asciiWrite(this, string, offset, length)
    
    //         case 'base64':
    //           // Warning: maxLength not taken into account in base64Write
    //           return base64Write(this, string, offset, length)
    
    //         case 'ucs2':
    //         case 'ucs-2':
    //         case 'utf16le':
    //         case 'utf-16le':
    //           return ucs2Write(this, string, offset, length)
    
    //         default:
    //           if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
    //           encoding = ('' + encoding).toLowerCase();
    //           loweredCase = true;
    //       }
    //     }
    //   };
    
    //   Buffer.prototype.toJSON = function toJSON () {
    //     return {
    //       type: 'Buffer',
    //       data: Array.prototype.slice.call(this._arr || this, 0)
    //     }
    //   };
    
    //   function base64Slice (buf, start, end) {
    //     if (start === 0 && end === buf.length) {
    //       return base64.fromByteArray(buf)
    //     } else {
    //       return base64.fromByteArray(buf.slice(start, end))
    //     }
    //   }
    
    //   function utf8Slice (buf, start, end) {
    //     end = Math.min(buf.length, end);
    //     const res = [];
    
    //     let i = start;
    //     while (i < end) {
    //       const firstByte = buf[i];
    //       let codePoint = null;
    //       let bytesPerSequence = (firstByte > 0xEF)
    //         ? 4
    //         : (firstByte > 0xDF)
    //             ? 3
    //             : (firstByte > 0xBF)
    //                 ? 2
    //                 : 1;
    
    //       if (i + bytesPerSequence <= end) {
    //         let secondByte, thirdByte, fourthByte, tempCodePoint;
    
    //         switch (bytesPerSequence) {
    //           case 1:
    //             if (firstByte < 0x80) {
    //               codePoint = firstByte;
    //             }
    //             break
    //           case 2:
    //             secondByte = buf[i + 1];
    //             if ((secondByte & 0xC0) === 0x80) {
    //               tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
    //               if (tempCodePoint > 0x7F) {
    //                 codePoint = tempCodePoint;
    //               }
    //             }
    //             break
    //           case 3:
    //             secondByte = buf[i + 1];
    //             thirdByte = buf[i + 2];
    //             if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
    //               tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
    //               if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
    //                 codePoint = tempCodePoint;
    //               }
    //             }
    //             break
    //           case 4:
    //             secondByte = buf[i + 1];
    //             thirdByte = buf[i + 2];
    //             fourthByte = buf[i + 3];
    //             if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
    //               tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
    //               if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
    //                 codePoint = tempCodePoint;
    //               }
    //             }
    //         }
    //       }
    
    //       if (codePoint === null) {
    //         // we did not generate a valid codePoint so insert a
    //         // replacement char (U+FFFD) and advance only 1 byte
    //         codePoint = 0xFFFD;
    //         bytesPerSequence = 1;
    //       } else if (codePoint > 0xFFFF) {
    //         // encode to utf16 (surrogate pair dance)
    //         codePoint -= 0x10000;
    //         res.push(codePoint >>> 10 & 0x3FF | 0xD800);
    //         codePoint = 0xDC00 | codePoint & 0x3FF;
    //       }
    
    //       res.push(codePoint);
    //       i += bytesPerSequence;
    //     }
    
    //     return decodeCodePointsArray(res)
    //   }
    
    //   // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    //   // the lowest limit is Chrome, with 0x10000 args.
    //   // We go 1 magnitude less, for safety
    //   const MAX_ARGUMENTS_LENGTH = 0x1000;
    
    //   function decodeCodePointsArray (codePoints) {
    //     const len = codePoints.length;
    //     if (len <= MAX_ARGUMENTS_LENGTH) {
    //       return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    //     }
    
    //     // Decode in chunks to avoid "call stack size exceeded".
    //     let res = '';
    //     let i = 0;
    //     while (i < len) {
    //       res += String.fromCharCode.apply(
    //         String,
    //         codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    //       );
    //     }
    //     return res
    //   }
    
    //   function asciiSlice (buf, start, end) {
    //     let ret = '';
    //     end = Math.min(buf.length, end);
    
    //     for (let i = start; i < end; ++i) {
    //       ret += String.fromCharCode(buf[i] & 0x7F);
    //     }
    //     return ret
    //   }
    
    //   function latin1Slice (buf, start, end) {
    //     let ret = '';
    //     end = Math.min(buf.length, end);
    
    //     for (let i = start; i < end; ++i) {
    //       ret += String.fromCharCode(buf[i]);
    //     }
    //     return ret
    //   }
    
    //   function hexSlice (buf, start, end) {
    //     const len = buf.length;
    
    //     if (!start || start < 0) start = 0;
    //     if (!end || end < 0 || end > len) end = len;
    
    //     let out = '';
    //     for (let i = start; i < end; ++i) {
    //       out += hexSliceLookupTable[buf[i]];
    //     }
    //     return out
    //   }
    
    //   function utf16leSlice (buf, start, end) {
    //     const bytes = buf.slice(start, end);
    //     let res = '';
    //     // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    //     for (let i = 0; i < bytes.length - 1; i += 2) {
    //       res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
    //     }
    //     return res
    //   }
    
    //   Buffer.prototype.slice = function slice (start, end) {
    //     const len = this.length;
    //     start = ~~start;
    //     end = end === undefined ? len : ~~end;
    
    //     if (start < 0) {
    //       start += len;
    //       if (start < 0) start = 0;
    //     } else if (start > len) {
    //       start = len;
    //     }
    
    //     if (end < 0) {
    //       end += len;
    //       if (end < 0) end = 0;
    //     } else if (end > len) {
    //       end = len;
    //     }
    
    //     if (end < start) end = start;
    
    //     const newBuf = this.subarray(start, end);
    //     // Return an augmented `Uint8Array` instance
    //     Object.setPrototypeOf(newBuf, Buffer.prototype);
    
    //     return newBuf
    //   };
    
    //   /*
    //    * Need to make sure that buffer isn't trying to write out of bounds.
    //    */
    //   function checkOffset (offset, ext, length) {
    //     if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    //     if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    //   }
    
    //   Buffer.prototype.readUintLE =
    //   Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    //     offset = offset >>> 0;
    //     byteLength = byteLength >>> 0;
    //     if (!noAssert) checkOffset(offset, byteLength, this.length);
    
    //     let val = this[offset];
    //     let mul = 1;
    //     let i = 0;
    //     while (++i < byteLength && (mul *= 0x100)) {
    //       val += this[offset + i] * mul;
    //     }
    
    //     return val
    //   };
    
    //   Buffer.prototype.readUintBE =
    //   Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    //     offset = offset >>> 0;
    //     byteLength = byteLength >>> 0;
    //     if (!noAssert) {
    //       checkOffset(offset, byteLength, this.length);
    //     }
    
    //     let val = this[offset + --byteLength];
    //     let mul = 1;
    //     while (byteLength > 0 && (mul *= 0x100)) {
    //       val += this[offset + --byteLength] * mul;
    //     }
    
    //     return val
    //   };
    
    //   Buffer.prototype.readUint8 =
    //   Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 1, this.length);
    //     return this[offset]
    //   };
    
    //   Buffer.prototype.readUint16LE =
    //   Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 2, this.length);
    //     return this[offset] | (this[offset + 1] << 8)
    //   };
    
    //   Buffer.prototype.readUint16BE =
    //   Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 2, this.length);
    //     return (this[offset] << 8) | this[offset + 1]
    //   };
    
    //   Buffer.prototype.readUint32LE =
    //   Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 4, this.length);
    
    //     return ((this[offset]) |
    //         (this[offset + 1] << 8) |
    //         (this[offset + 2] << 16)) +
    //         (this[offset + 3] * 0x1000000)
    //   };
    
    //   Buffer.prototype.readUint32BE =
    //   Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 4, this.length);
    
    //     return (this[offset] * 0x1000000) +
    //       ((this[offset + 1] << 16) |
    //       (this[offset + 2] << 8) |
    //       this[offset + 3])
    //   };
    
    //   Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
    //     offset = offset >>> 0;
    //     validateNumber(offset, 'offset');
    //     const first = this[offset];
    //     const last = this[offset + 7];
    //     if (first === undefined || last === undefined) {
    //       boundsError(offset, this.length - 8);
    //     }
    
    //     const lo = first +
    //       this[++offset] * 2 ** 8 +
    //       this[++offset] * 2 ** 16 +
    //       this[++offset] * 2 ** 24;
    
    //     const hi = this[++offset] +
    //       this[++offset] * 2 ** 8 +
    //       this[++offset] * 2 ** 16 +
    //       last * 2 ** 24;
    
    //     return BigInt(lo) + (BigInt(hi) << BigInt(32))
    //   });
    
    //   Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
    //     offset = offset >>> 0;
    //     validateNumber(offset, 'offset');
    //     const first = this[offset];
    //     const last = this[offset + 7];
    //     if (first === undefined || last === undefined) {
    //       boundsError(offset, this.length - 8);
    //     }
    
    //     const hi = first * 2 ** 24 +
    //       this[++offset] * 2 ** 16 +
    //       this[++offset] * 2 ** 8 +
    //       this[++offset];
    
    //     const lo = this[++offset] * 2 ** 24 +
    //       this[++offset] * 2 ** 16 +
    //       this[++offset] * 2 ** 8 +
    //       last;
    
    //     return (BigInt(hi) << BigInt(32)) + BigInt(lo)
    //   });
    
    //   Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    //     offset = offset >>> 0;
    //     byteLength = byteLength >>> 0;
    //     if (!noAssert) checkOffset(offset, byteLength, this.length);
    
    //     let val = this[offset];
    //     let mul = 1;
    //     let i = 0;
    //     while (++i < byteLength && (mul *= 0x100)) {
    //       val += this[offset + i] * mul;
    //     }
    //     mul *= 0x80;
    
    //     if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    
    //     return val
    //   };
    
    //   Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    //     offset = offset >>> 0;
    //     byteLength = byteLength >>> 0;
    //     if (!noAssert) checkOffset(offset, byteLength, this.length);
    
    //     let i = byteLength;
    //     let mul = 1;
    //     let val = this[offset + --i];
    //     while (i > 0 && (mul *= 0x100)) {
    //       val += this[offset + --i] * mul;
    //     }
    //     mul *= 0x80;
    
    //     if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    
    //     return val
    //   };
    
    //   Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 1, this.length);
    //     if (!(this[offset] & 0x80)) return (this[offset])
    //     return ((0xff - this[offset] + 1) * -1)
    //   };
    
    //   Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 2, this.length);
    //     const val = this[offset] | (this[offset + 1] << 8);
    //     return (val & 0x8000) ? val | 0xFFFF0000 : val
    //   };
    
    //   Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 2, this.length);
    //     const val = this[offset + 1] | (this[offset] << 8);
    //     return (val & 0x8000) ? val | 0xFFFF0000 : val
    //   };
    
    //   Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 4, this.length);
    
    //     return (this[offset]) |
    //       (this[offset + 1] << 8) |
    //       (this[offset + 2] << 16) |
    //       (this[offset + 3] << 24)
    //   };
    
    //   Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 4, this.length);
    
    //     return (this[offset] << 24) |
    //       (this[offset + 1] << 16) |
    //       (this[offset + 2] << 8) |
    //       (this[offset + 3])
    //   };
    
    //   Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
    //     offset = offset >>> 0;
    //     validateNumber(offset, 'offset');
    //     const first = this[offset];
    //     const last = this[offset + 7];
    //     if (first === undefined || last === undefined) {
    //       boundsError(offset, this.length - 8);
    //     }
    
    //     const val = this[offset + 4] +
    //       this[offset + 5] * 2 ** 8 +
    //       this[offset + 6] * 2 ** 16 +
    //       (last << 24); // Overflow
    
    //     return (BigInt(val) << BigInt(32)) +
    //       BigInt(first +
    //       this[++offset] * 2 ** 8 +
    //       this[++offset] * 2 ** 16 +
    //       this[++offset] * 2 ** 24)
    //   });
    
    //   Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
    //     offset = offset >>> 0;
    //     validateNumber(offset, 'offset');
    //     const first = this[offset];
    //     const last = this[offset + 7];
    //     if (first === undefined || last === undefined) {
    //       boundsError(offset, this.length - 8);
    //     }
    
    //     const val = (first << 24) + // Overflow
    //       this[++offset] * 2 ** 16 +
    //       this[++offset] * 2 ** 8 +
    //       this[++offset];
    
    //     return (BigInt(val) << BigInt(32)) +
    //       BigInt(this[++offset] * 2 ** 24 +
    //       this[++offset] * 2 ** 16 +
    //       this[++offset] * 2 ** 8 +
    //       last)
    //   });
    
    //   Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 4, this.length);
    //     return ieee754$1.read(this, offset, true, 23, 4)
    //   };
    
    //   Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 4, this.length);
    //     return ieee754$1.read(this, offset, false, 23, 4)
    //   };
    
    //   Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 8, this.length);
    //     return ieee754$1.read(this, offset, true, 52, 8)
    //   };
    
    //   Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    //     offset = offset >>> 0;
    //     if (!noAssert) checkOffset(offset, 8, this.length);
    //     return ieee754$1.read(this, offset, false, 52, 8)
    //   };
    
    //   function checkInt (buf, value, offset, ext, max, min) {
    //     if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    //     if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    //     if (offset + ext > buf.length) throw new RangeError('Index out of range')
    //   }
    
    //   Buffer.prototype.writeUintLE =
    //   Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     byteLength = byteLength >>> 0;
    //     if (!noAssert) {
    //       const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    //       checkInt(this, value, offset, byteLength, maxBytes, 0);
    //     }
    
    //     let mul = 1;
    //     let i = 0;
    //     this[offset] = value & 0xFF;
    //     while (++i < byteLength && (mul *= 0x100)) {
    //       this[offset + i] = (value / mul) & 0xFF;
    //     }
    
    //     return offset + byteLength
    //   };
    
    //   Buffer.prototype.writeUintBE =
    //   Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     byteLength = byteLength >>> 0;
    //     if (!noAssert) {
    //       const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    //       checkInt(this, value, offset, byteLength, maxBytes, 0);
    //     }
    
    //     let i = byteLength - 1;
    //     let mul = 1;
    //     this[offset + i] = value & 0xFF;
    //     while (--i >= 0 && (mul *= 0x100)) {
    //       this[offset + i] = (value / mul) & 0xFF;
    //     }
    
    //     return offset + byteLength
    //   };
    
    //   Buffer.prototype.writeUint8 =
    //   Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    //     this[offset] = (value & 0xff);
    //     return offset + 1
    //   };
    
    //   Buffer.prototype.writeUint16LE =
    //   Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    //     this[offset] = (value & 0xff);
    //     this[offset + 1] = (value >>> 8);
    //     return offset + 2
    //   };
    
    //   Buffer.prototype.writeUint16BE =
    //   Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    //     this[offset] = (value >>> 8);
    //     this[offset + 1] = (value & 0xff);
    //     return offset + 2
    //   };
    
    //   Buffer.prototype.writeUint32LE =
    //   Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    //     this[offset + 3] = (value >>> 24);
    //     this[offset + 2] = (value >>> 16);
    //     this[offset + 1] = (value >>> 8);
    //     this[offset] = (value & 0xff);
    //     return offset + 4
    //   };
    
    //   Buffer.prototype.writeUint32BE =
    //   Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    //     this[offset] = (value >>> 24);
    //     this[offset + 1] = (value >>> 16);
    //     this[offset + 2] = (value >>> 8);
    //     this[offset + 3] = (value & 0xff);
    //     return offset + 4
    //   };
    
    //   function wrtBigUInt64LE (buf, value, offset, min, max) {
    //     checkIntBI(value, min, max, buf, offset, 7);
    
    //     let lo = Number(value & BigInt(0xffffffff));
    //     buf[offset++] = lo;
    //     lo = lo >> 8;
    //     buf[offset++] = lo;
    //     lo = lo >> 8;
    //     buf[offset++] = lo;
    //     lo = lo >> 8;
    //     buf[offset++] = lo;
    //     let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    //     buf[offset++] = hi;
    //     hi = hi >> 8;
    //     buf[offset++] = hi;
    //     hi = hi >> 8;
    //     buf[offset++] = hi;
    //     hi = hi >> 8;
    //     buf[offset++] = hi;
    //     return offset
    //   }
    
    //   function wrtBigUInt64BE (buf, value, offset, min, max) {
    //     checkIntBI(value, min, max, buf, offset, 7);
    
    //     let lo = Number(value & BigInt(0xffffffff));
    //     buf[offset + 7] = lo;
    //     lo = lo >> 8;
    //     buf[offset + 6] = lo;
    //     lo = lo >> 8;
    //     buf[offset + 5] = lo;
    //     lo = lo >> 8;
    //     buf[offset + 4] = lo;
    //     let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    //     buf[offset + 3] = hi;
    //     hi = hi >> 8;
    //     buf[offset + 2] = hi;
    //     hi = hi >> 8;
    //     buf[offset + 1] = hi;
    //     hi = hi >> 8;
    //     buf[offset] = hi;
    //     return offset + 8
    //   }
    
    //   Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
    //     return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
    //   });
    
    //   Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
    //     return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
    //   });
    
    //   Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) {
    //       const limit = Math.pow(2, (8 * byteLength) - 1);
    
    //       checkInt(this, value, offset, byteLength, limit - 1, -limit);
    //     }
    
    //     let i = 0;
    //     let mul = 1;
    //     let sub = 0;
    //     this[offset] = value & 0xFF;
    //     while (++i < byteLength && (mul *= 0x100)) {
    //       if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
    //         sub = 1;
    //       }
    //       this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    //     }
    
    //     return offset + byteLength
    //   };
    
    //   Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) {
    //       const limit = Math.pow(2, (8 * byteLength) - 1);
    
    //       checkInt(this, value, offset, byteLength, limit - 1, -limit);
    //     }
    
    //     let i = byteLength - 1;
    //     let mul = 1;
    //     let sub = 0;
    //     this[offset + i] = value & 0xFF;
    //     while (--i >= 0 && (mul *= 0x100)) {
    //       if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
    //         sub = 1;
    //       }
    //       this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    //     }
    
    //     return offset + byteLength
    //   };
    
    //   Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    //     if (value < 0) value = 0xff + value + 1;
    //     this[offset] = (value & 0xff);
    //     return offset + 1
    //   };
    
    //   Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    //     this[offset] = (value & 0xff);
    //     this[offset + 1] = (value >>> 8);
    //     return offset + 2
    //   };
    
    //   Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    //     this[offset] = (value >>> 8);
    //     this[offset + 1] = (value & 0xff);
    //     return offset + 2
    //   };
    
    //   Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    //     this[offset] = (value & 0xff);
    //     this[offset + 1] = (value >>> 8);
    //     this[offset + 2] = (value >>> 16);
    //     this[offset + 3] = (value >>> 24);
    //     return offset + 4
    //   };
    
    //   Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    //     if (value < 0) value = 0xffffffff + value + 1;
    //     this[offset] = (value >>> 24);
    //     this[offset + 1] = (value >>> 16);
    //     this[offset + 2] = (value >>> 8);
    //     this[offset + 3] = (value & 0xff);
    //     return offset + 4
    //   };
    
    //   Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
    //     return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
    //   });
    
    //   Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
    //     return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
    //   });
    
    //   function checkIEEE754 (buf, value, offset, ext, max, min) {
    //     if (offset + ext > buf.length) throw new RangeError('Index out of range')
    //     if (offset < 0) throw new RangeError('Index out of range')
    //   }
    
    //   function writeFloat (buf, value, offset, littleEndian, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) {
    //       checkIEEE754(buf, value, offset, 4);
    //     }
    //     ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    //     return offset + 4
    //   }
    
    //   Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    //     return writeFloat(this, value, offset, true, noAssert)
    //   };
    
    //   Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    //     return writeFloat(this, value, offset, false, noAssert)
    //   };
    
    //   function writeDouble (buf, value, offset, littleEndian, noAssert) {
    //     value = +value;
    //     offset = offset >>> 0;
    //     if (!noAssert) {
    //       checkIEEE754(buf, value, offset, 8);
    //     }
    //     ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    //     return offset + 8
    //   }
    
    //   Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    //     return writeDouble(this, value, offset, true, noAssert)
    //   };
    
    //   Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    //     return writeDouble(this, value, offset, false, noAssert)
    //   };
    
    //   // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    //   Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    //     if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
    //     if (!start) start = 0;
    //     if (!end && end !== 0) end = this.length;
    //     if (targetStart >= target.length) targetStart = target.length;
    //     if (!targetStart) targetStart = 0;
    //     if (end > 0 && end < start) end = start;
    
    //     // Copy 0 bytes; we're done
    //     if (end === start) return 0
    //     if (target.length === 0 || this.length === 0) return 0
    
    //     // Fatal error conditions
    //     if (targetStart < 0) {
    //       throw new RangeError('targetStart out of bounds')
    //     }
    //     if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
    //     if (end < 0) throw new RangeError('sourceEnd out of bounds')
    
    //     // Are we oob?
    //     if (end > this.length) end = this.length;
    //     if (target.length - targetStart < end - start) {
    //       end = target.length - targetStart + start;
    //     }
    
    //     const len = end - start;
    
    //     if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    //       // Use built-in when available, missing from IE11
    //       this.copyWithin(targetStart, start, end);
    //     } else {
    //       Uint8Array.prototype.set.call(
    //         target,
    //         this.subarray(start, end),
    //         targetStart
    //       );
    //     }
    
    //     return len
    //   };
    
    //   // Usage:
    //   //    buffer.fill(number[, offset[, end]])
    //   //    buffer.fill(buffer[, offset[, end]])
    //   //    buffer.fill(string[, offset[, end]][, encoding])
    //   Buffer.prototype.fill = function fill (val, start, end, encoding) {
    //     // Handle string cases:
    //     if (typeof val === 'string') {
    //       if (typeof start === 'string') {
    //         encoding = start;
    //         start = 0;
    //         end = this.length;
    //       } else if (typeof end === 'string') {
    //         encoding = end;
    //         end = this.length;
    //       }
    //       if (encoding !== undefined && typeof encoding !== 'string') {
    //         throw new TypeError('encoding must be a string')
    //       }
    //       if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
    //         throw new TypeError('Unknown encoding: ' + encoding)
    //       }
    //       if (val.length === 1) {
    //         const code = val.charCodeAt(0);
    //         if ((encoding === 'utf8' && code < 128) ||
    //             encoding === 'latin1') {
    //           // Fast path: If `val` fits into a single byte, use that numeric value.
    //           val = code;
    //         }
    //       }
    //     } else if (typeof val === 'number') {
    //       val = val & 255;
    //     } else if (typeof val === 'boolean') {
    //       val = Number(val);
    //     }
    
    //     // Invalid ranges are not set to a default, so can range check early.
    //     if (start < 0 || this.length < start || this.length < end) {
    //       throw new RangeError('Out of range index')
    //     }
    
    //     if (end <= start) {
    //       return this
    //     }
    
    //     start = start >>> 0;
    //     end = end === undefined ? this.length : end >>> 0;
    
    //     if (!val) val = 0;
    
    //     let i;
    //     if (typeof val === 'number') {
    //       for (i = start; i < end; ++i) {
    //         this[i] = val;
    //       }
    //     } else {
    //       const bytes = Buffer.isBuffer(val)
    //         ? val
    //         : Buffer.from(val, encoding);
    //       const len = bytes.length;
    //       if (len === 0) {
    //         throw new TypeError('The value "' + val +
    //           '" is invalid for argument "value"')
    //       }
    //       for (i = 0; i < end - start; ++i) {
    //         this[i + start] = bytes[i % len];
    //       }
    //     }
    
    //     return this
    //   };
    
    //   // CUSTOM ERRORS
    //   // =============
    
    //   // Simplified versions from Node, changed for Buffer-only usage
    //   const errors = {};
    //   function E (sym, getMessage, Base) {
    //     errors[sym] = class NodeError extends Base {
    //       constructor () {
    //         super();
    
    //         Object.defineProperty(this, 'message', {
    //           value: getMessage.apply(this, arguments),
    //           writable: true,
    //           configurable: true
    //         });
    
    //         // Add the error code to the name to include it in the stack trace.
    //         this.name = `${this.name} [${sym}]`;
    //         // Access the stack to generate the error message including the error code
    //         // from the name.
    //         this.stack; // eslint-disable-line no-unused-expressions
    //         // Reset the name to the actual name.
    //         delete this.name;
    //       }
    
    //       get code () {
    //         return sym
    //       }
    
    //       set code (value) {
    //         Object.defineProperty(this, 'code', {
    //           configurable: true,
    //           enumerable: true,
    //           value,
    //           writable: true
    //         });
    //       }
    
    //       toString () {
    //         return `${this.name} [${sym}]: ${this.message}`
    //       }
    //     };
    //   }
    
    //   E('ERR_BUFFER_OUT_OF_BOUNDS',
    //     function (name) {
    //       if (name) {
    //         return `${name} is outside of buffer bounds`
    //       }
    
    //       return 'Attempt to access memory outside buffer bounds'
    //     }, RangeError);
    //   E('ERR_INVALID_ARG_TYPE',
    //     function (name, actual) {
    //       return `The "${name}" argument must be of type number. Received type ${typeof actual}`
    //     }, TypeError);
    //   E('ERR_OUT_OF_RANGE',
    //     function (str, range, input) {
    //       let msg = `The value of "${str}" is out of range.`;
    //       let received = input;
    //       if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
    //         received = addNumericalSeparator(String(input));
    //       } else if (typeof input === 'bigint') {
    //         received = String(input);
    //         if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
    //           received = addNumericalSeparator(received);
    //         }
    //         received += 'n';
    //       }
    //       msg += ` It must be ${range}. Received ${received}`;
    //       return msg
    //     }, RangeError);
    
    //   function addNumericalSeparator (val) {
    //     let res = '';
    //     let i = val.length;
    //     const start = val[0] === '-' ? 1 : 0;
    //     for (; i >= start + 4; i -= 3) {
    //       res = `_${val.slice(i - 3, i)}${res}`;
    //     }
    //     return `${val.slice(0, i)}${res}`
    //   }
    
    //   // CHECK FUNCTIONS
    //   // ===============
    
    //   function checkBounds (buf, offset, byteLength) {
    //     validateNumber(offset, 'offset');
    //     if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    //       boundsError(offset, buf.length - (byteLength + 1));
    //     }
    //   }
    
    //   function checkIntBI (value, min, max, buf, offset, byteLength) {
    //     if (value > max || value < min) {
    //       const n = typeof min === 'bigint' ? 'n' : '';
    //       let range;
    //       if (byteLength > 3) {
    //         if (min === 0 || min === BigInt(0)) {
    //           range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
    //         } else {
    //           range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
    //                   `${(byteLength + 1) * 8 - 1}${n}`;
    //         }
    //       } else {
    //         range = `>= ${min}${n} and <= ${max}${n}`;
    //       }
    //       throw new errors.ERR_OUT_OF_RANGE('value', range, value)
    //     }
    //     checkBounds(buf, offset, byteLength);
    //   }
    
    //   function validateNumber (value, name) {
    //     if (typeof value !== 'number') {
    //       throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
    //     }
    //   }
    
    //   function boundsError (value, length, type) {
    //     if (Math.floor(value) !== value) {
    //       validateNumber(value, type);
    //       throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
    //     }
    
    //     if (length < 0) {
    //       throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
    //     }
    
    //     throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
    //                                       `>= ${type ? 1 : 0} and <= ${length}`,
    //                                       value)
    //   }
    
    //   // HELPER FUNCTIONS
    //   // ================
    
    //   const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    
    //   function base64clean (str) {
    //     // Node takes equal signs as end of the Base64 encoding
    //     str = str.split('=')[0];
    //     // Node strips out invalid characters like \n and \t from the string, base64-js does not
    //     str = str.trim().replace(INVALID_BASE64_RE, '');
    //     // Node converts strings with length < 2 to ''
    //     if (str.length < 2) return ''
    //     // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    //     while (str.length % 4 !== 0) {
    //       str = str + '=';
    //     }
    //     return str
    //   }
    
    //   function utf8ToBytes (string, units) {
    //     units = units || Infinity;
    //     let codePoint;
    //     const length = string.length;
    //     let leadSurrogate = null;
    //     const bytes = [];
    
    //     for (let i = 0; i < length; ++i) {
    //       codePoint = string.charCodeAt(i);
    
    //       // is surrogate component
    //       if (codePoint > 0xD7FF && codePoint < 0xE000) {
    //         // last char was a lead
    //         if (!leadSurrogate) {
    //           // no lead yet
    //           if (codePoint > 0xDBFF) {
    //             // unexpected trail
    //             if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    //             continue
    //           } else if (i + 1 === length) {
    //             // unpaired lead
    //             if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    //             continue
    //           }
    
    //           // valid lead
    //           leadSurrogate = codePoint;
    
    //           continue
    //         }
    
    //         // 2 leads in a row
    //         if (codePoint < 0xDC00) {
    //           if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    //           leadSurrogate = codePoint;
    //           continue
    //         }
    
    //         // valid surrogate pair
    //         codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    //       } else if (leadSurrogate) {
    //         // valid bmp char, but last char was a lead
    //         if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    //       }
    
    //       leadSurrogate = null;
    
    //       // encode utf8
    //       if (codePoint < 0x80) {
    //         if ((units -= 1) < 0) break
    //         bytes.push(codePoint);
    //       } else if (codePoint < 0x800) {
    //         if ((units -= 2) < 0) break
    //         bytes.push(
    //           codePoint >> 0x6 | 0xC0,
    //           codePoint & 0x3F | 0x80
    //         );
    //       } else if (codePoint < 0x10000) {
    //         if ((units -= 3) < 0) break
    //         bytes.push(
    //           codePoint >> 0xC | 0xE0,
    //           codePoint >> 0x6 & 0x3F | 0x80,
    //           codePoint & 0x3F | 0x80
    //         );
    //       } else if (codePoint < 0x110000) {
    //         if ((units -= 4) < 0) break
    //         bytes.push(
    //           codePoint >> 0x12 | 0xF0,
    //           codePoint >> 0xC & 0x3F | 0x80,
    //           codePoint >> 0x6 & 0x3F | 0x80,
    //           codePoint & 0x3F | 0x80
    //         );
    //       } else {
    //         throw new Error('Invalid code point')
    //       }
    //     }
    
    //     return bytes
    //   }
    
    //   function asciiToBytes (str) {
    //     const byteArray = [];
    //     for (let i = 0; i < str.length; ++i) {
    //       // Node's code seems to be doing this and not & 0x7F..
    //       byteArray.push(str.charCodeAt(i) & 0xFF);
    //     }
    //     return byteArray
    //   }
    
    //   function utf16leToBytes (str, units) {
    //     let c, hi, lo;
    //     const byteArray = [];
    //     for (let i = 0; i < str.length; ++i) {
    //       if ((units -= 2) < 0) break
    
    //       c = str.charCodeAt(i);
    //       hi = c >> 8;
    //       lo = c % 256;
    //       byteArray.push(lo);
    //       byteArray.push(hi);
    //     }
    
    //     return byteArray
    //   }
    
    //   function base64ToBytes (str) {
    //     return base64.toByteArray(base64clean(str))
    //   }
    
    //   function blitBuffer (src, dst, offset, length) {
    //     let i;
    //     for (i = 0; i < length; ++i) {
    //       if ((i + offset >= dst.length) || (i >= src.length)) break
    //       dst[i + offset] = src[i];
    //     }
    //     return i
    //   }
    
    //   // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    //   // the `instanceof` check but they should be treated as of that type.
    //   // See: https://github.com/feross/buffer/issues/166
    //   function isInstance (obj, type) {
    //     return obj instanceof type ||
    //       (obj != null && obj.constructor != null && obj.constructor.name != null &&
    //         obj.constructor.name === type.name)
    //   }
    //   function numberIsNaN (obj) {
    //     // For IE11 support
    //     return obj !== obj // eslint-disable-line no-self-compare
    //   }
    
    //   // Create lookup table for `toString('hex')`
    //   // See: https://github.com/feross/buffer/issues/219
    //   const hexSliceLookupTable = (function () {
    //     const alphabet = '0123456789abcdef';
    //     const table = new Array(256);
    //     for (let i = 0; i < 16; ++i) {
    //       const i16 = i * 16;
    //       for (let j = 0; j < 16; ++j) {
    //         table[i16 + j] = alphabet[i] + alphabet[j];
    //       }
    //     }
    //     return table
    //   })();
    
    //   // Return not function with Error if BigInt not supported
    //   function defineBigIntMethod (fn) {
    //     return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
    //   }
    
    //   function BufferBigIntNotDefined () {
    //     throw new Error('BigInt not supported')
    //   }
    //   }(buffer));
    
    //   var global$1 = (typeof global !== "undefined" ? global :
    //     typeof self !== "undefined" ? self :
    //     typeof window !== "undefined" ? window : {});
    
    //   // shim for using process in browser
    //   // based off https://github.com/defunctzombie/node-process/blob/master/browser.js
    
    //   function defaultSetTimout() {
    //       throw new Error('setTimeout has not been defined');
    //   }
    //   function defaultClearTimeout () {
    //       throw new Error('clearTimeout has not been defined');
    //   }
    //   var cachedSetTimeout = defaultSetTimout;
    //   var cachedClearTimeout = defaultClearTimeout;
    //   if (typeof global$1.setTimeout === 'function') {
    //       cachedSetTimeout = setTimeout;
    //   }
    //   if (typeof global$1.clearTimeout === 'function') {
    //       cachedClearTimeout = clearTimeout;
    //   }
    
    //   function runTimeout(fun) {
    //       if (cachedSetTimeout === setTimeout) {
    //           //normal enviroments in sane situations
    //           return setTimeout(fun, 0);
    //       }
    //       // if setTimeout wasn't available but was latter defined
    //       if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    //           cachedSetTimeout = setTimeout;
    //           return setTimeout(fun, 0);
    //       }
    //       try {
    //           // when when somebody has screwed with setTimeout but no I.E. maddness
    //           return cachedSetTimeout(fun, 0);
    //       } catch(e){
    //           try {
    //               // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
    //               return cachedSetTimeout.call(null, fun, 0);
    //           } catch(e){
    //               // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
    //               return cachedSetTimeout.call(this, fun, 0);
    //           }
    //       }
    
    
    //   }
    //   function runClearTimeout(marker) {
    //       if (cachedClearTimeout === clearTimeout) {
    //           //normal enviroments in sane situations
    //           return clearTimeout(marker);
    //       }
    //       // if clearTimeout wasn't available but was latter defined
    //       if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    //           cachedClearTimeout = clearTimeout;
    //           return clearTimeout(marker);
    //       }
    //       try {
    //           // when when somebody has screwed with setTimeout but no I.E. maddness
    //           return cachedClearTimeout(marker);
    //       } catch (e){
    //           try {
    //               // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
    //               return cachedClearTimeout.call(null, marker);
    //           } catch (e){
    //               // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
    //               // Some versions of I.E. have different rules for clearTimeout vs setTimeout
    //               return cachedClearTimeout.call(this, marker);
    //           }
    //       }
    
    
    
    //   }
    //   var queue = [];
    //   var draining = false;
    //   var currentQueue;
    //   var queueIndex = -1;
    
    //   function cleanUpNextTick() {
    //       if (!draining || !currentQueue) {
    //           return;
    //       }
    //       draining = false;
    //       if (currentQueue.length) {
    //           queue = currentQueue.concat(queue);
    //       } else {
    //           queueIndex = -1;
    //       }
    //       if (queue.length) {
    //           drainQueue();
    //       }
    //   }
    
    //   function drainQueue() {
    //       if (draining) {
    //           return;
    //       }
    //       var timeout = runTimeout(cleanUpNextTick);
    //       draining = true;
    
    //       var len = queue.length;
    //       while(len) {
    //           currentQueue = queue;
    //           queue = [];
    //           while (++queueIndex < len) {
    //               if (currentQueue) {
    //                   currentQueue[queueIndex].run();
    //               }
    //           }
    //           queueIndex = -1;
    //           len = queue.length;
    //       }
    //       currentQueue = null;
    //       draining = false;
    //       runClearTimeout(timeout);
    //   }
    //   function nextTick(fun) {
    //       var args = new Array(arguments.length - 1);
    //       if (arguments.length > 1) {
    //           for (var i = 1; i < arguments.length; i++) {
    //               args[i - 1] = arguments[i];
    //           }
    //       }
    //       queue.push(new Item(fun, args));
    //       if (queue.length === 1 && !draining) {
    //           runTimeout(drainQueue);
    //       }
    //   }
    //   // v8 likes predictible objects
    //   function Item(fun, array) {
    //       this.fun = fun;
    //       this.array = array;
    //   }
    //   Item.prototype.run = function () {
    //       this.fun.apply(null, this.array);
    //   };
    //   var title = 'browser';
    //   var platform = 'browser';
    //   var browser$2 = true;
    //   var env = {};
    //   var argv = [];
    //   var version$1 = ''; // empty string to avoid regexp issues
    //   var versions = {};
    //   var release = {};
    //   var config = {};
    
    //   function noop() {}
    
    //   var on = noop;
    //   var addListener = noop;
    //   var once = noop;
    //   var off = noop;
    //   var removeListener = noop;
    //   var removeAllListeners = noop;
    //   var emit = noop;
    
    //   function binding(name) {
    //       throw new Error('process.binding is not supported');
    //   }
    
    //   function cwd () { return '/' }
    //   function chdir (dir) {
    //       throw new Error('process.chdir is not supported');
    //   }function umask() { return 0; }
    
    //   // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    //   var performance = global$1.performance || {};
    //   var performanceNow =
    //     performance.now        ||
    //     performance.mozNow     ||
    //     performance.msNow      ||
    //     performance.oNow       ||
    //     performance.webkitNow  ||
    //     function(){ return (new Date()).getTime() };
    
    //   // generate timestamp or delta
    //   // see http://nodejs.org/api/process.html#process_process_hrtime
    //   function hrtime(previousTimestamp){
    //     var clocktime = performanceNow.call(performance)*1e-3;
    //     var seconds = Math.floor(clocktime);
    //     var nanoseconds = Math.floor((clocktime%1)*1e9);
    //     if (previousTimestamp) {
    //       seconds = seconds - previousTimestamp[0];
    //       nanoseconds = nanoseconds - previousTimestamp[1];
    //       if (nanoseconds<0) {
    //         seconds--;
    //         nanoseconds += 1e9;
    //       }
    //     }
    //     return [seconds,nanoseconds]
    //   }
    
    //   var startTime = new Date();
    //   function uptime() {
    //     var currentTime = new Date();
    //     var dif = currentTime - startTime;
    //     return dif / 1000;
    //   }
    
    //   var browser$1$1 = {
    //     nextTick: nextTick,
    //     title: title,
    //     browser: browser$2,
    //     env: env,
    //     argv: argv,
    //     version: version$1,
    //     versions: versions,
    //     on: on,
    //     addListener: addListener,
    //     once: once,
    //     off: off,
    //     removeListener: removeListener,
    //     removeAllListeners: removeAllListeners,
    //     emit: emit,
    //     binding: binding,
    //     cwd: cwd,
    //     chdir: chdir,
    //     umask: umask,
    //     hrtime: hrtime,
    //     platform: platform,
    //     release: release,
    //     config: config,
    //     uptime: uptime
    //   };
    
    //   var process = browser$1$1;
    
    //   var inherits$4;
    //   if (typeof Object.create === 'function'){
    //     inherits$4 = function inherits(ctor, superCtor) {
    //       // implementation from standard node.js 'util' module
    //       ctor.super_ = superCtor;
    //       ctor.prototype = Object.create(superCtor.prototype, {
    //         constructor: {
    //           value: ctor,
    //           enumerable: false,
    //           writable: true,
    //           configurable: true
    //         }
    //       });
    //     };
    //   } else {
    //     inherits$4 = function inherits(ctor, superCtor) {
    //       ctor.super_ = superCtor;
    //       var TempCtor = function () {};
    //       TempCtor.prototype = superCtor.prototype;
    //       ctor.prototype = new TempCtor();
    //       ctor.prototype.constructor = ctor;
    //     };
    //   }
    //   var inherits$5 = inherits$4;
    
    //   /**
    //    * Echos the value of a value. Trys to print the value out
    //    * in the best way possible given the different types.
    //    *
    //    * @param {Object} obj The object to print out.
    //    * @param {Object} opts Optional options object that alters the output.
    //    */
    //   /* legacy: obj, showHidden, depth, colors*/
    //   function inspect$1(obj, opts) {
    //     // default options
    //     var ctx = {
    //       seen: [],
    //       stylize: stylizeNoColor
    //     };
    //     // legacy...
    //     if (arguments.length >= 3) ctx.depth = arguments[2];
    //     if (arguments.length >= 4) ctx.colors = arguments[3];
    //     if (isBoolean(opts)) {
    //       // legacy...
    //       ctx.showHidden = opts;
    //     } else if (opts) {
    //       // got an "options" object
    //       _extend(ctx, opts);
    //     }
    //     // set default options
    //     if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    //     if (isUndefined(ctx.depth)) ctx.depth = 2;
    //     if (isUndefined(ctx.colors)) ctx.colors = false;
    //     if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    //     if (ctx.colors) ctx.stylize = stylizeWithColor;
    //     return formatValue(ctx, obj, ctx.depth);
    //   }
    
    //   // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    //   inspect$1.colors = {
    //     'bold' : [1, 22],
    //     'italic' : [3, 23],
    //     'underline' : [4, 24],
    //     'inverse' : [7, 27],
    //     'white' : [37, 39],
    //     'grey' : [90, 39],
    //     'black' : [30, 39],
    //     'blue' : [34, 39],
    //     'cyan' : [36, 39],
    //     'green' : [32, 39],
    //     'magenta' : [35, 39],
    //     'red' : [31, 39],
    //     'yellow' : [33, 39]
    //   };
    
    //   // Don't use 'blue' not visible on cmd.exe
    //   inspect$1.styles = {
    //     'special': 'cyan',
    //     'number': 'yellow',
    //     'boolean': 'yellow',
    //     'undefined': 'grey',
    //     'null': 'bold',
    //     'string': 'green',
    //     'date': 'magenta',
    //     // "name": intentionally not styling
    //     'regexp': 'red'
    //   };
    
    
    //   function stylizeWithColor(str, styleType) {
    //     var style = inspect$1.styles[styleType];
    
    //     if (style) {
    //       return '\u001b[' + inspect$1.colors[style][0] + 'm' + str +
    //              '\u001b[' + inspect$1.colors[style][1] + 'm';
    //     } else {
    //       return str;
    //     }
    //   }
    
    
    //   function stylizeNoColor(str, styleType) {
    //     return str;
    //   }
    
    
    //   function arrayToHash(array) {
    //     var hash = {};
    
    //     array.forEach(function(val, idx) {
    //       hash[val] = true;
    //     });
    
    //     return hash;
    //   }
    
    
    //   function formatValue(ctx, value, recurseTimes) {
    //     // Provide a hook for user-specified inspect functions.
    //     // Check that value is an object with an inspect function on it
    //     if (ctx.customInspect &&
    //         value &&
    //         isFunction(value.inspect) &&
    //         // Filter out the util module, it's inspect function is special
    //         value.inspect !== inspect$1 &&
    //         // Also filter out any prototype objects using the circular check.
    //         !(value.constructor && value.constructor.prototype === value)) {
    //       var ret = value.inspect(recurseTimes, ctx);
    //       if (!isString(ret)) {
    //         ret = formatValue(ctx, ret, recurseTimes);
    //       }
    //       return ret;
    //     }
    
    //     // Primitive types cannot have properties
    //     var primitive = formatPrimitive(ctx, value);
    //     if (primitive) {
    //       return primitive;
    //     }
    
    //     // Look up the keys of the object.
    //     var keys = Object.keys(value);
    //     var visibleKeys = arrayToHash(keys);
    
    //     if (ctx.showHidden) {
    //       keys = Object.getOwnPropertyNames(value);
    //     }
    
    //     // IE doesn't make error fields non-enumerable
    //     // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    //     if (isError(value)
    //         && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    //       return formatError(value);
    //     }
    
    //     // Some type of object without properties can be shortcutted.
    //     if (keys.length === 0) {
    //       if (isFunction(value)) {
    //         var name = value.name ? ': ' + value.name : '';
    //         return ctx.stylize('[Function' + name + ']', 'special');
    //       }
    //       if (isRegExp(value)) {
    //         return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    //       }
    //       if (isDate(value)) {
    //         return ctx.stylize(Date.prototype.toString.call(value), 'date');
    //       }
    //       if (isError(value)) {
    //         return formatError(value);
    //       }
    //     }
    
    //     var base = '', array = false, braces = ['{', '}'];
    
    //     // Make Array say that they are Array
    //     if (isArray(value)) {
    //       array = true;
    //       braces = ['[', ']'];
    //     }
    
    //     // Make functions say that they are functions
    //     if (isFunction(value)) {
    //       var n = value.name ? ': ' + value.name : '';
    //       base = ' [Function' + n + ']';
    //     }
    
    //     // Make RegExps say that they are RegExps
    //     if (isRegExp(value)) {
    //       base = ' ' + RegExp.prototype.toString.call(value);
    //     }
    
    //     // Make dates with properties first say the date
    //     if (isDate(value)) {
    //       base = ' ' + Date.prototype.toUTCString.call(value);
    //     }
    
    //     // Make error with message first say the error
    //     if (isError(value)) {
    //       base = ' ' + formatError(value);
    //     }
    
    //     if (keys.length === 0 && (!array || value.length == 0)) {
    //       return braces[0] + base + braces[1];
    //     }
    
    //     if (recurseTimes < 0) {
    //       if (isRegExp(value)) {
    //         return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    //       } else {
    //         return ctx.stylize('[Object]', 'special');
    //       }
    //     }
    
    //     ctx.seen.push(value);
    
    //     var output;
    //     if (array) {
    //       output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    //     } else {
    //       output = keys.map(function(key) {
    //         return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    //       });
    //     }
    
    //     ctx.seen.pop();
    
    //     return reduceToSingleString(output, base, braces);
    //   }
    
    
    //   function formatPrimitive(ctx, value) {
    //     if (isUndefined(value))
    //       return ctx.stylize('undefined', 'undefined');
    //     if (isString(value)) {
    //       var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
    //                                                .replace(/'/g, "\\'")
    //                                                .replace(/\\"/g, '"') + '\'';
    //       return ctx.stylize(simple, 'string');
    //     }
    //     if (isNumber(value))
    //       return ctx.stylize('' + value, 'number');
    //     if (isBoolean(value))
    //       return ctx.stylize('' + value, 'boolean');
    //     // For some reason typeof null is "object", so special case here.
    //     if (isNull(value))
    //       return ctx.stylize('null', 'null');
    //   }
    
    
    //   function formatError(value) {
    //     return '[' + Error.prototype.toString.call(value) + ']';
    //   }
    
    
    //   function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    //     var output = [];
    //     for (var i = 0, l = value.length; i < l; ++i) {
    //       if (hasOwnProperty(value, String(i))) {
    //         output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
    //             String(i), true));
    //       } else {
    //         output.push('');
    //       }
    //     }
    //     keys.forEach(function(key) {
    //       if (!key.match(/^\d+$/)) {
    //         output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
    //             key, true));
    //       }
    //     });
    //     return output;
    //   }
    
    
    //   function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    //     var name, str, desc;
    //     desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    //     if (desc.get) {
    //       if (desc.set) {
    //         str = ctx.stylize('[Getter/Setter]', 'special');
    //       } else {
    //         str = ctx.stylize('[Getter]', 'special');
    //       }
    //     } else {
    //       if (desc.set) {
    //         str = ctx.stylize('[Setter]', 'special');
    //       }
    //     }
    //     if (!hasOwnProperty(visibleKeys, key)) {
    //       name = '[' + key + ']';
    //     }
    //     if (!str) {
    //       if (ctx.seen.indexOf(desc.value) < 0) {
    //         if (isNull(recurseTimes)) {
    //           str = formatValue(ctx, desc.value, null);
    //         } else {
    //           str = formatValue(ctx, desc.value, recurseTimes - 1);
    //         }
    //         if (str.indexOf('\n') > -1) {
    //           if (array) {
    //             str = str.split('\n').map(function(line) {
    //               return '  ' + line;
    //             }).join('\n').substr(2);
    //           } else {
    //             str = '\n' + str.split('\n').map(function(line) {
    //               return '   ' + line;
    //             }).join('\n');
    //           }
    //         }
    //       } else {
    //         str = ctx.stylize('[Circular]', 'special');
    //       }
    //     }
    //     if (isUndefined(name)) {
    //       if (array && key.match(/^\d+$/)) {
    //         return str;
    //       }
    //       name = JSON.stringify('' + key);
    //       if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
    //         name = name.substr(1, name.length - 2);
    //         name = ctx.stylize(name, 'name');
    //       } else {
    //         name = name.replace(/'/g, "\\'")
    //                    .replace(/\\"/g, '"')
    //                    .replace(/(^"|"$)/g, "'");
    //         name = ctx.stylize(name, 'string');
    //       }
    //     }
    
    //     return name + ': ' + str;
    //   }
    
    
    //   function reduceToSingleString(output, base, braces) {
    //     var length = output.reduce(function(prev, cur) {
    //       if (cur.indexOf('\n') >= 0) ;
    //       return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    //     }, 0);
    
    //     if (length > 60) {
    //       return braces[0] +
    //              (base === '' ? '' : base + '\n ') +
    //              ' ' +
    //              output.join(',\n  ') +
    //              ' ' +
    //              braces[1];
    //     }
    
    //     return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    //   }
    
    
    //   // NOTE: These type checking functions intentionally don't use `instanceof`
    //   // because it is fragile and can be easily faked with `Object.create()`.
    //   function isArray(ar) {
    //     return Array.isArray(ar);
    //   }
    
    //   function isBoolean(arg) {
    //     return typeof arg === 'boolean';
    //   }
    
    //   function isNull(arg) {
    //     return arg === null;
    //   }
    
    //   function isNumber(arg) {
    //     return typeof arg === 'number';
    //   }
    
    //   function isString(arg) {
    //     return typeof arg === 'string';
    //   }
    
    //   function isUndefined(arg) {
    //     return arg === void 0;
    //   }
    
    //   function isRegExp(re) {
    //     return isObject$1(re) && objectToString(re) === '[object RegExp]';
    //   }
    
    //   function isObject$1(arg) {
    //     return typeof arg === 'object' && arg !== null;
    //   }
    
    //   function isDate(d) {
    //     return isObject$1(d) && objectToString(d) === '[object Date]';
    //   }
    
    //   function isError(e) {
    //     return isObject$1(e) &&
    //         (objectToString(e) === '[object Error]' || e instanceof Error);
    //   }
    
    //   function isFunction(arg) {
    //     return typeof arg === 'function';
    //   }
    
    //   function isPrimitive(arg) {
    //     return arg === null ||
    //            typeof arg === 'boolean' ||
    //            typeof arg === 'number' ||
    //            typeof arg === 'string' ||
    //            typeof arg === 'symbol' ||  // ES6 symbol
    //            typeof arg === 'undefined';
    //   }
    
    //   function objectToString(o) {
    //     return Object.prototype.toString.call(o);
    //   }
    
    //   function _extend(origin, add) {
    //     // Don't do anything if add isn't an object
    //     if (!add || !isObject$1(add)) return origin;
    
    //     var keys = Object.keys(add);
    //     var i = keys.length;
    //     while (i--) {
    //       origin[keys[i]] = add[keys[i]];
    //     }
    //     return origin;
    //   }
    //   function hasOwnProperty(obj, prop) {
    //     return Object.prototype.hasOwnProperty.call(obj, prop);
    //   }
    
    //   function compare(a, b) {
    //     if (a === b) {
    //       return 0;
    //     }
    
    //     var x = a.length;
    //     var y = b.length;
    
    //     for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    //       if (a[i] !== b[i]) {
    //         x = a[i];
    //         y = b[i];
    //         break;
    //       }
    //     }
    
    //     if (x < y) {
    //       return -1;
    //     }
    //     if (y < x) {
    //       return 1;
    //     }
    //     return 0;
    //   }
    //   var hasOwn = Object.prototype.hasOwnProperty;
    
    //   var objectKeys = Object.keys || function (obj) {
    //     var keys = [];
    //     for (var key in obj) {
    //       if (hasOwn.call(obj, key)) keys.push(key);
    //     }
    //     return keys;
    //   };
    //   var pSlice = Array.prototype.slice;
    //   var _functionsHaveNames;
    //   function functionsHaveNames() {
    //     if (typeof _functionsHaveNames !== 'undefined') {
    //       return _functionsHaveNames;
    //     }
    //     return _functionsHaveNames = (function () {
    //       return function foo() {}.name === 'foo';
    //     }());
    //   }
    //   function pToString (obj) {
    //     return Object.prototype.toString.call(obj);
    //   }
    //   function isView(arrbuf) {
    //     if (buffer.isBuffer(arrbuf)) {
    //       return false;
    //     }
    //     if (typeof global$1.ArrayBuffer !== 'function') {
    //       return false;
    //     }
    //     if (typeof ArrayBuffer.isView === 'function') {
    //       return ArrayBuffer.isView(arrbuf);
    //     }
    //     if (!arrbuf) {
    //       return false;
    //     }
    //     if (arrbuf instanceof DataView) {
    //       return true;
    //     }
    //     if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    //       return true;
    //     }
    //     return false;
    //   }
    //   // 1. The assert module provides functions that throw
    //   // AssertionError's when particular conditions are not met. The
    //   // assert module must conform to the following interface.
    
    //   function assert$j(value, message) {
    //     if (!value) fail(value, true, message, '==', ok);
    //   }
    
    //   // 2. The AssertionError is defined in assert.
    //   // new assert.AssertionError({ message: message,
    //   //                             actual: actual,
    //   //                             expected: expected })
    
    //   var regex = /\s*function\s+([^\(\s]*)\s*/;
    //   // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
    //   function getName(func) {
    //     if (!isFunction(func)) {
    //       return;
    //     }
    //     if (functionsHaveNames()) {
    //       return func.name;
    //     }
    //     var str = func.toString();
    //     var match = str.match(regex);
    //     return match && match[1];
    //   }
    //   assert$j.AssertionError = AssertionError;
    //   function AssertionError(options) {
    //     this.name = 'AssertionError';
    //     this.actual = options.actual;
    //     this.expected = options.expected;
    //     this.operator = options.operator;
    //     if (options.message) {
    //       this.message = options.message;
    //       this.generatedMessage = false;
    //     } else {
    //       this.message = getMessage(this);
    //       this.generatedMessage = true;
    //     }
    //     var stackStartFunction = options.stackStartFunction || fail;
    //     if (Error.captureStackTrace) {
    //       Error.captureStackTrace(this, stackStartFunction);
    //     } else {
    //       // non v8 browsers so we can have a stacktrace
    //       var err = new Error();
    //       if (err.stack) {
    //         var out = err.stack;
    
    //         // try to strip useless frames
    //         var fn_name = getName(stackStartFunction);
    //         var idx = out.indexOf('\n' + fn_name);
    //         if (idx >= 0) {
    //           // once we have located the function frame
    //           // we need to strip out everything before it (and its line)
    //           var next_line = out.indexOf('\n', idx + 1);
    //           out = out.substring(next_line + 1);
    //         }
    
    //         this.stack = out;
    //       }
    //     }
    //   }
    
    //   // assert.AssertionError instanceof Error
    //   inherits$5(AssertionError, Error);
    
    //   function truncate(s, n) {
    //     if (typeof s === 'string') {
    //       return s.length < n ? s : s.slice(0, n);
    //     } else {
    //       return s;
    //     }
    //   }
    //   function inspect(something) {
    //     if (functionsHaveNames() || !isFunction(something)) {
    //       return inspect$1(something);
    //     }
    //     var rawname = getName(something);
    //     var name = rawname ? ': ' + rawname : '';
    //     return '[Function' +  name + ']';
    //   }
    //   function getMessage(self) {
    //     return truncate(inspect(self.actual), 128) + ' ' +
    //            self.operator + ' ' +
    //            truncate(inspect(self.expected), 128);
    //   }
    
    //   // At present only the three keys mentioned above are used and
    //   // understood by the spec. Implementations or sub modules can pass
    //   // other keys to the AssertionError's constructor - they will be
    //   // ignored.
    
    //   // 3. All of the following functions must throw an AssertionError
    //   // when a corresponding condition is not met, with a message that
    //   // may be undefined if not provided.  All assertion methods provide
    //   // both the actual and expected values to the assertion error for
    //   // display purposes.
    
    //   function fail(actual, expected, message, operator, stackStartFunction) {
    //     throw new AssertionError({
    //       message: message,
    //       actual: actual,
    //       expected: expected,
    //       operator: operator,
    //       stackStartFunction: stackStartFunction
    //     });
    //   }
    
    //   // EXTENSION! allows for well behaved errors defined elsewhere.
    //   assert$j.fail = fail;
    
    //   // 4. Pure assertion tests whether a value is truthy, as determined
    //   // by !!guard.
    //   // assert.ok(guard, message_opt);
    //   // This statement is equivalent to assert.equal(true, !!guard,
    //   // message_opt);. To test strictly for the value true, use
    //   // assert.strictEqual(true, guard, message_opt);.
    
    //   function ok(value, message) {
    //     if (!value) fail(value, true, message, '==', ok);
    //   }
    //   assert$j.ok = ok;
    
    //   // 5. The equality assertion tests shallow, coercive equality with
    //   // ==.
    //   // assert.equal(actual, expected, message_opt);
    //   assert$j.equal = equal;
    //   function equal(actual, expected, message) {
    //     if (actual != expected) fail(actual, expected, message, '==', equal);
    //   }
    
    //   // 6. The non-equality assertion tests for whether two objects are not equal
    //   // with != assert.notEqual(actual, expected, message_opt);
    //   assert$j.notEqual = notEqual;
    //   function notEqual(actual, expected, message) {
    //     if (actual == expected) {
    //       fail(actual, expected, message, '!=', notEqual);
    //     }
    //   }
    
    //   // 7. The equivalence assertion tests a deep equality relation.
    //   // assert.deepEqual(actual, expected, message_opt);
    //   assert$j.deepEqual = deepEqual;
    //   function deepEqual(actual, expected, message) {
    //     if (!_deepEqual(actual, expected, false)) {
    //       fail(actual, expected, message, 'deepEqual', deepEqual);
    //     }
    //   }
    //   assert$j.deepStrictEqual = deepStrictEqual;
    //   function deepStrictEqual(actual, expected, message) {
    //     if (!_deepEqual(actual, expected, true)) {
    //       fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
    //     }
    //   }
    
    //   function _deepEqual(actual, expected, strict, memos) {
    //     // 7.1. All identical values are equivalent, as determined by ===.
    //     if (actual === expected) {
    //       return true;
    //     } else if (buffer.isBuffer(actual) && buffer.isBuffer(expected)) {
    //       return compare(actual, expected) === 0;
    
    //     // 7.2. If the expected value is a Date object, the actual value is
    //     // equivalent if it is also a Date object that refers to the same time.
    //     } else if (isDate(actual) && isDate(expected)) {
    //       return actual.getTime() === expected.getTime();
    
    //     // 7.3 If the expected value is a RegExp object, the actual value is
    //     // equivalent if it is also a RegExp object with the same source and
    //     // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
    //     } else if (isRegExp(actual) && isRegExp(expected)) {
    //       return actual.source === expected.source &&
    //              actual.global === expected.global &&
    //              actual.multiline === expected.multiline &&
    //              actual.lastIndex === expected.lastIndex &&
    //              actual.ignoreCase === expected.ignoreCase;
    
    //     // 7.4. Other pairs that do not both pass typeof value == 'object',
    //     // equivalence is determined by ==.
    //     } else if ((actual === null || typeof actual !== 'object') &&
    //                (expected === null || typeof expected !== 'object')) {
    //       return strict ? actual === expected : actual == expected;
    
    //     // If both values are instances of typed arrays, wrap their underlying
    //     // ArrayBuffers in a Buffer each to increase performance
    //     // This optimization requires the arrays to have the same type as checked by
    //     // Object.prototype.toString (aka pToString). Never perform binary
    //     // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    //     // bit patterns are not identical.
    //     } else if (isView(actual) && isView(expected) &&
    //                pToString(actual) === pToString(expected) &&
    //                !(actual instanceof Float32Array ||
    //                  actual instanceof Float64Array)) {
    //       return compare(new Uint8Array(actual.buffer),
    //                      new Uint8Array(expected.buffer)) === 0;
    
    //     // 7.5 For all other Object pairs, including Array objects, equivalence is
    //     // determined by having the same number of owned properties (as verified
    //     // with Object.prototype.hasOwnProperty.call), the same set of keys
    //     // (although not necessarily the same order), equivalent values for every
    //     // corresponding key, and an identical 'prototype' property. Note: this
    //     // accounts for both named and indexed properties on Arrays.
    //     } else if (buffer.isBuffer(actual) !== buffer.isBuffer(expected)) {
    //       return false;
    //     } else {
    //       memos = memos || {actual: [], expected: []};
    
    //       var actualIndex = memos.actual.indexOf(actual);
    //       if (actualIndex !== -1) {
    //         if (actualIndex === memos.expected.indexOf(expected)) {
    //           return true;
    //         }
    //       }
    
    //       memos.actual.push(actual);
    //       memos.expected.push(expected);
    
    //       return objEquiv(actual, expected, strict, memos);
    //     }
    //   }
    
    //   function isArguments(object) {
    //     return Object.prototype.toString.call(object) == '[object Arguments]';
    //   }
    
    //   function objEquiv(a, b, strict, actualVisitedObjects) {
    //     if (a === null || a === undefined || b === null || b === undefined)
    //       return false;
    //     // if one is a primitive, the other must be same
    //     if (isPrimitive(a) || isPrimitive(b))
    //       return a === b;
    //     if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    //       return false;
    //     var aIsArgs = isArguments(a);
    //     var bIsArgs = isArguments(b);
    //     if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    //       return false;
    //     if (aIsArgs) {
    //       a = pSlice.call(a);
    //       b = pSlice.call(b);
    //       return _deepEqual(a, b, strict);
    //     }
    //     var ka = objectKeys(a);
    //     var kb = objectKeys(b);
    //     var key, i;
    //     // having the same number of owned properties (keys incorporates
    //     // hasOwnProperty)
    //     if (ka.length !== kb.length)
    //       return false;
    //     //the same set of keys (although not necessarily the same order),
    //     ka.sort();
    //     kb.sort();
    //     //~~~cheap key test
    //     for (i = ka.length - 1; i >= 0; i--) {
    //       if (ka[i] !== kb[i])
    //         return false;
    //     }
    //     //equivalent values for every corresponding key, and
    //     //~~~possibly expensive deep test
    //     for (i = ka.length - 1; i >= 0; i--) {
    //       key = ka[i];
    //       if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
    //         return false;
    //     }
    //     return true;
    //   }
    
    //   // 8. The non-equivalence assertion tests for any deep inequality.
    //   // assert.notDeepEqual(actual, expected, message_opt);
    //   assert$j.notDeepEqual = notDeepEqual;
    //   function notDeepEqual(actual, expected, message) {
    //     if (_deepEqual(actual, expected, false)) {
    //       fail(actual, expected, message, 'notDeepEqual', notDeepEqual);
    //     }
    //   }
    
    //   assert$j.notDeepStrictEqual = notDeepStrictEqual;
    //   function notDeepStrictEqual(actual, expected, message) {
    //     if (_deepEqual(actual, expected, true)) {
    //       fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
    //     }
    //   }
    
    
    //   // 9. The strict equality assertion tests strict equality, as determined by ===.
    //   // assert.strictEqual(actual, expected, message_opt);
    //   assert$j.strictEqual = strictEqual;
    //   function strictEqual(actual, expected, message) {
    //     if (actual !== expected) {
    //       fail(actual, expected, message, '===', strictEqual);
    //     }
    //   }
    
    //   // 10. The strict non-equality assertion tests for strict inequality, as
    //   // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
    //   assert$j.notStrictEqual = notStrictEqual;
    //   function notStrictEqual(actual, expected, message) {
    //     if (actual === expected) {
    //       fail(actual, expected, message, '!==', notStrictEqual);
    //     }
    //   }
    
    //   function expectedException(actual, expected) {
    //     if (!actual || !expected) {
    //       return false;
    //     }
    
    //     if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    //       return expected.test(actual);
    //     }
    
    //     try {
    //       if (actual instanceof expected) {
    //         return true;
    //       }
    //     } catch (e) {
    //       // Ignore.  The instanceof check doesn't work for arrow functions.
    //     }
    
    //     if (Error.isPrototypeOf(expected)) {
    //       return false;
    //     }
    
    //     return expected.call({}, actual) === true;
    //   }
    
    //   function _tryBlock(block) {
    //     var error;
    //     try {
    //       block();
    //     } catch (e) {
    //       error = e;
    //     }
    //     return error;
    //   }
    
    //   function _throws(shouldThrow, block, expected, message) {
    //     var actual;
    
    //     if (typeof block !== 'function') {
    //       throw new TypeError('"block" argument must be a function');
    //     }
    
    //     if (typeof expected === 'string') {
    //       message = expected;
    //       expected = null;
    //     }
    
    //     actual = _tryBlock(block);
    
    //     message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
    //               (message ? ' ' + message : '.');
    
    //     if (shouldThrow && !actual) {
    //       fail(actual, expected, 'Missing expected exception' + message);
    //     }
    
    //     var userProvidedMessage = typeof message === 'string';
    //     var isUnwantedException = !shouldThrow && isError(actual);
    //     var isUnexpectedException = !shouldThrow && actual && !expected;
    
    //     if ((isUnwantedException &&
    //         userProvidedMessage &&
    //         expectedException(actual, expected)) ||
    //         isUnexpectedException) {
    //       fail(actual, expected, 'Got unwanted exception' + message);
    //     }
    
    //     if ((shouldThrow && actual && expected &&
    //         !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    //       throw actual;
    //     }
    //   }
    
    //   // 11. Expected to throw an error:
    //   // assert.throws(block, Error_opt, message_opt);
    //   assert$j.throws = throws;
    //   function throws(block, /*optional*/error, /*optional*/message) {
    //     _throws(true, block, error, message);
    //   }
    
    //   // EXTENSION! This is annoying to write outside this module.
    //   assert$j.doesNotThrow = doesNotThrow;
    //   function doesNotThrow(block, /*optional*/error, /*optional*/message) {
    //     _throws(false, block, error, message);
    //   }
    
    //   assert$j.ifError = ifError;
    //   function ifError(err) {
    //     if (err) throw err;
    //   }
    
    //   var bn = {exports: {}};
    
    //   var _nodeResolve_empty = {};
    
    //   var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    //     __proto__: null,
    //     'default': _nodeResolve_empty
    //   });
    
    //   var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);
    
    //   (function (module) {
    //   (function (module, exports) {
    
    //     // Utils
    //     function assert (val, msg) {
    //       if (!val) throw new Error(msg || 'Assertion failed');
    //     }
    
    //     // Could use `inherits` module, but don't want to move from single file
    //     // architecture yet.
    //     function inherits (ctor, superCtor) {
    //       ctor.super_ = superCtor;
    //       var TempCtor = function () {};
    //       TempCtor.prototype = superCtor.prototype;
    //       ctor.prototype = new TempCtor();
    //       ctor.prototype.constructor = ctor;
    //     }
    
    //     // BN
    
    //     function BN (number, base, endian) {
    //       if (BN.isBN(number)) {
    //         return number;
    //       }
    
    //       this.negative = 0;
    //       this.words = null;
    //       this.length = 0;
    
    //       // Reduction context
    //       this.red = null;
    
    //       if (number !== null) {
    //         if (base === 'le' || base === 'be') {
    //           endian = base;
    //           base = 10;
    //         }
    
    //         this._init(number || 0, base || 10, endian || 'be');
    //       }
    //     }
    //     if (typeof module === 'object') {
    //       module.exports = BN;
    //     } else {
    //       exports.BN = BN;
    //     }
    
    //     BN.BN = BN;
    //     BN.wordSize = 26;
    
    //     var Buffer;
    //     try {
    //       if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
    //         Buffer = window.Buffer;
    //       } else {
    //         Buffer = require$$0$1.Buffer;
    //       }
    //     } catch (e) {
    //     }
    
    //     BN.isBN = function isBN (num) {
    //       if (num instanceof BN) {
    //         return true;
    //       }
    
    //       return num !== null && typeof num === 'object' &&
    //         num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    //     };
    
    //     BN.max = function max (left, right) {
    //       if (left.cmp(right) > 0) return left;
    //       return right;
    //     };
    
    //     BN.min = function min (left, right) {
    //       if (left.cmp(right) < 0) return left;
    //       return right;
    //     };
    
    //     BN.prototype._init = function init (number, base, endian) {
    //       if (typeof number === 'number') {
    //         return this._initNumber(number, base, endian);
    //       }
    
    //       if (typeof number === 'object') {
    //         return this._initArray(number, base, endian);
    //       }
    
    //       if (base === 'hex') {
    //         base = 16;
    //       }
    //       assert(base === (base | 0) && base >= 2 && base <= 36);
    
    //       number = number.toString().replace(/\s+/g, '');
    //       var start = 0;
    //       if (number[0] === '-') {
    //         start++;
    //         this.negative = 1;
    //       }
    
    //       if (start < number.length) {
    //         if (base === 16) {
    //           this._parseHex(number, start, endian);
    //         } else {
    //           this._parseBase(number, base, start);
    //           if (endian === 'le') {
    //             this._initArray(this.toArray(), base, endian);
    //           }
    //         }
    //       }
    //     };
    
    //     BN.prototype._initNumber = function _initNumber (number, base, endian) {
    //       if (number < 0) {
    //         this.negative = 1;
    //         number = -number;
    //       }
    //       if (number < 0x4000000) {
    //         this.words = [number & 0x3ffffff];
    //         this.length = 1;
    //       } else if (number < 0x10000000000000) {
    //         this.words = [
    //           number & 0x3ffffff,
    //           (number / 0x4000000) & 0x3ffffff
    //         ];
    //         this.length = 2;
    //       } else {
    //         assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
    //         this.words = [
    //           number & 0x3ffffff,
    //           (number / 0x4000000) & 0x3ffffff,
    //           1
    //         ];
    //         this.length = 3;
    //       }
    
    //       if (endian !== 'le') return;
    
    //       // Reverse the bytes
    //       this._initArray(this.toArray(), base, endian);
    //     };
    
    //     BN.prototype._initArray = function _initArray (number, base, endian) {
    //       // Perhaps a Uint8Array
    //       assert(typeof number.length === 'number');
    //       if (number.length <= 0) {
    //         this.words = [0];
    //         this.length = 1;
    //         return this;
    //       }
    
    //       this.length = Math.ceil(number.length / 3);
    //       this.words = new Array(this.length);
    //       for (var i = 0; i < this.length; i++) {
    //         this.words[i] = 0;
    //       }
    
    //       var j, w;
    //       var off = 0;
    //       if (endian === 'be') {
    //         for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
    //           w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
    //           this.words[j] |= (w << off) & 0x3ffffff;
    //           this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
    //           off += 24;
    //           if (off >= 26) {
    //             off -= 26;
    //             j++;
    //           }
    //         }
    //       } else if (endian === 'le') {
    //         for (i = 0, j = 0; i < number.length; i += 3) {
    //           w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
    //           this.words[j] |= (w << off) & 0x3ffffff;
    //           this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
    //           off += 24;
    //           if (off >= 26) {
    //             off -= 26;
    //             j++;
    //           }
    //         }
    //       }
    //       return this._strip();
    //     };
    
    //     function parseHex4Bits (string, index) {
    //       var c = string.charCodeAt(index);
    //       // '0' - '9'
    //       if (c >= 48 && c <= 57) {
    //         return c - 48;
    //       // 'A' - 'F'
    //       } else if (c >= 65 && c <= 70) {
    //         return c - 55;
    //       // 'a' - 'f'
    //       } else if (c >= 97 && c <= 102) {
    //         return c - 87;
    //       } else {
    //         assert(false, 'Invalid character in ' + string);
    //       }
    //     }
    
    //     function parseHexByte (string, lowerBound, index) {
    //       var r = parseHex4Bits(string, index);
    //       if (index - 1 >= lowerBound) {
    //         r |= parseHex4Bits(string, index - 1) << 4;
    //       }
    //       return r;
    //     }
    
    //     BN.prototype._parseHex = function _parseHex (number, start, endian) {
    //       // Create possibly bigger array to ensure that it fits the number
    //       this.length = Math.ceil((number.length - start) / 6);
    //       this.words = new Array(this.length);
    //       for (var i = 0; i < this.length; i++) {
    //         this.words[i] = 0;
    //       }
    
    //       // 24-bits chunks
    //       var off = 0;
    //       var j = 0;
    
    //       var w;
    //       if (endian === 'be') {
    //         for (i = number.length - 1; i >= start; i -= 2) {
    //           w = parseHexByte(number, start, i) << off;
    //           this.words[j] |= w & 0x3ffffff;
    //           if (off >= 18) {
    //             off -= 18;
    //             j += 1;
    //             this.words[j] |= w >>> 26;
    //           } else {
    //             off += 8;
    //           }
    //         }
    //       } else {
    //         var parseLength = number.length - start;
    //         for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
    //           w = parseHexByte(number, start, i) << off;
    //           this.words[j] |= w & 0x3ffffff;
    //           if (off >= 18) {
    //             off -= 18;
    //             j += 1;
    //             this.words[j] |= w >>> 26;
    //           } else {
    //             off += 8;
    //           }
    //         }
    //       }
    
    //       this._strip();
    //     };
    
    //     function parseBase (str, start, end, mul) {
    //       var r = 0;
    //       var b = 0;
    //       var len = Math.min(str.length, end);
    //       for (var i = start; i < len; i++) {
    //         var c = str.charCodeAt(i) - 48;
    
    //         r *= mul;
    
    //         // 'a'
    //         if (c >= 49) {
    //           b = c - 49 + 0xa;
    
    //         // 'A'
    //         } else if (c >= 17) {
    //           b = c - 17 + 0xa;
    
    //         // '0' - '9'
    //         } else {
    //           b = c;
    //         }
    //         assert(c >= 0 && b < mul, 'Invalid character');
    //         r += b;
    //       }
    //       return r;
    //     }
    
    //     BN.prototype._parseBase = function _parseBase (number, base, start) {
    //       // Initialize as zero
    //       this.words = [0];
    //       this.length = 1;
    
    //       // Find length of limb in base
    //       for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
    //         limbLen++;
    //       }
    //       limbLen--;
    //       limbPow = (limbPow / base) | 0;
    
    //       var total = number.length - start;
    //       var mod = total % limbLen;
    //       var end = Math.min(total, total - mod) + start;
    
    //       var word = 0;
    //       for (var i = start; i < end; i += limbLen) {
    //         word = parseBase(number, i, i + limbLen, base);
    
    //         this.imuln(limbPow);
    //         if (this.words[0] + word < 0x4000000) {
    //           this.words[0] += word;
    //         } else {
    //           this._iaddn(word);
    //         }
    //       }
    
    //       if (mod !== 0) {
    //         var pow = 1;
    //         word = parseBase(number, i, number.length, base);
    
    //         for (i = 0; i < mod; i++) {
    //           pow *= base;
    //         }
    
    //         this.imuln(pow);
    //         if (this.words[0] + word < 0x4000000) {
    //           this.words[0] += word;
    //         } else {
    //           this._iaddn(word);
    //         }
    //       }
    
    //       this._strip();
    //     };
    
    //     BN.prototype.copy = function copy (dest) {
    //       dest.words = new Array(this.length);
    //       for (var i = 0; i < this.length; i++) {
    //         dest.words[i] = this.words[i];
    //       }
    //       dest.length = this.length;
    //       dest.negative = this.negative;
    //       dest.red = this.red;
    //     };
    
    //     function move (dest, src) {
    //       dest.words = src.words;
    //       dest.length = src.length;
    //       dest.negative = src.negative;
    //       dest.red = src.red;
    //     }
    
    //     BN.prototype._move = function _move (dest) {
    //       move(dest, this);
    //     };
    
    //     BN.prototype.clone = function clone () {
    //       var r = new BN(null);
    //       this.copy(r);
    //       return r;
    //     };
    
    //     BN.prototype._expand = function _expand (size) {
    //       while (this.length < size) {
    //         this.words[this.length++] = 0;
    //       }
    //       return this;
    //     };
    
    //     // Remove leading `0` from `this`
    //     BN.prototype._strip = function strip () {
    //       while (this.length > 1 && this.words[this.length - 1] === 0) {
    //         this.length--;
    //       }
    //       return this._normSign();
    //     };
    
    //     BN.prototype._normSign = function _normSign () {
    //       // -0 = 0
    //       if (this.length === 1 && this.words[0] === 0) {
    //         this.negative = 0;
    //       }
    //       return this;
    //     };
    
    //     // Check Symbol.for because not everywhere where Symbol defined
    //     // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
    //     if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    //       try {
    //         BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    //       } catch (e) {
    //         BN.prototype.inspect = inspect;
    //       }
    //     } else {
    //       BN.prototype.inspect = inspect;
    //     }
    
    //     function inspect () {
    //       return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    //     }
    
    //     /*
    
    //     var zeros = [];
    //     var groupSizes = [];
    //     var groupBases = [];
    
    //     var s = '';
    //     var i = -1;
    //     while (++i < BN.wordSize) {
    //       zeros[i] = s;
    //       s += '0';
    //     }
    //     groupSizes[0] = 0;
    //     groupSizes[1] = 0;
    //     groupBases[0] = 0;
    //     groupBases[1] = 0;
    //     var base = 2 - 1;
    //     while (++base < 36 + 1) {
    //       var groupSize = 0;
    //       var groupBase = 1;
    //       while (groupBase < (1 << BN.wordSize) / base) {
    //         groupBase *= base;
    //         groupSize += 1;
    //       }
    //       groupSizes[base] = groupSize;
    //       groupBases[base] = groupBase;
    //     }
    
    //     */
    
    //     var zeros = [
    //       '',
    //       '0',
    //       '00',
    //       '000',
    //       '0000',
    //       '00000',
    //       '000000',
    //       '0000000',
    //       '00000000',
    //       '000000000',
    //       '0000000000',
    //       '00000000000',
    //       '000000000000',
    //       '0000000000000',
    //       '00000000000000',
    //       '000000000000000',
    //       '0000000000000000',
    //       '00000000000000000',
    //       '000000000000000000',
    //       '0000000000000000000',
    //       '00000000000000000000',
    //       '000000000000000000000',
    //       '0000000000000000000000',
    //       '00000000000000000000000',
    //       '000000000000000000000000',
    //       '0000000000000000000000000'
    //     ];
    
    //     var groupSizes = [
    //       0, 0,
    //       25, 16, 12, 11, 10, 9, 8,
    //       8, 7, 7, 7, 7, 6, 6,
    //       6, 6, 6, 6, 6, 5, 5,
    //       5, 5, 5, 5, 5, 5, 5,
    //       5, 5, 5, 5, 5, 5, 5
    //     ];
    
    //     var groupBases = [
    //       0, 0,
    //       33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    //       43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    //       16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    //       6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    //       24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
    //     ];
    
    //     BN.prototype.toString = function toString (base, padding) {
    //       base = base || 10;
    //       padding = padding | 0 || 1;
    
    //       var out;
    //       if (base === 16 || base === 'hex') {
    //         out = '';
    //         var off = 0;
    //         var carry = 0;
    //         for (var i = 0; i < this.length; i++) {
    //           var w = this.words[i];
    //           var word = (((w << off) | carry) & 0xffffff).toString(16);
    //           carry = (w >>> (24 - off)) & 0xffffff;
    //           if (carry !== 0 || i !== this.length - 1) {
    //             out = zeros[6 - word.length] + word + out;
    //           } else {
    //             out = word + out;
    //           }
    //           off += 2;
    //           if (off >= 26) {
    //             off -= 26;
    //             i--;
    //           }
    //         }
    //         if (carry !== 0) {
    //           out = carry.toString(16) + out;
    //         }
    //         while (out.length % padding !== 0) {
    //           out = '0' + out;
    //         }
    //         if (this.negative !== 0) {
    //           out = '-' + out;
    //         }
    //         return out;
    //       }
    
    //       if (base === (base | 0) && base >= 2 && base <= 36) {
    //         // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
    //         var groupSize = groupSizes[base];
    //         // var groupBase = Math.pow(base, groupSize);
    //         var groupBase = groupBases[base];
    //         out = '';
    //         var c = this.clone();
    //         c.negative = 0;
    //         while (!c.isZero()) {
    //           var r = c.modrn(groupBase).toString(base);
    //           c = c.idivn(groupBase);
    
    //           if (!c.isZero()) {
    //             out = zeros[groupSize - r.length] + r + out;
    //           } else {
    //             out = r + out;
    //           }
    //         }
    //         if (this.isZero()) {
    //           out = '0' + out;
    //         }
    //         while (out.length % padding !== 0) {
    //           out = '0' + out;
    //         }
    //         if (this.negative !== 0) {
    //           out = '-' + out;
    //         }
    //         return out;
    //       }
    
    //       assert(false, 'Base should be between 2 and 36');
    //     };
    
    //     BN.prototype.toNumber = function toNumber () {
    //       var ret = this.words[0];
    //       if (this.length === 2) {
    //         ret += this.words[1] * 0x4000000;
    //       } else if (this.length === 3 && this.words[2] === 0x01) {
    //         // NOTE: at this stage it is known that the top bit is set
    //         ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    //       } else if (this.length > 2) {
    //         assert(false, 'Number can only safely store up to 53 bits');
    //       }
    //       return (this.negative !== 0) ? -ret : ret;
    //     };
    
    //     BN.prototype.toJSON = function toJSON () {
    //       return this.toString(16, 2);
    //     };
    
    //     if (Buffer) {
    //       BN.prototype.toBuffer = function toBuffer (endian, length) {
    //         return this.toArrayLike(Buffer, endian, length);
    //       };
    //     }
    
    //     BN.prototype.toArray = function toArray (endian, length) {
    //       return this.toArrayLike(Array, endian, length);
    //     };
    
    //     var allocate = function allocate (ArrayType, size) {
    //       if (ArrayType.allocUnsafe) {
    //         return ArrayType.allocUnsafe(size);
    //       }
    //       return new ArrayType(size);
    //     };
    
    //     BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    //       this._strip();
    
    //       var byteLength = this.byteLength();
    //       var reqLength = length || Math.max(1, byteLength);
    //       assert(byteLength <= reqLength, 'byte array longer than desired length');
    //       assert(reqLength > 0, 'Requested array length <= 0');
    
    //       var res = allocate(ArrayType, reqLength);
    //       var postfix = endian === 'le' ? 'LE' : 'BE';
    //       this['_toArrayLike' + postfix](res, byteLength);
    //       return res;
    //     };
    
    //     BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    //       var position = 0;
    //       var carry = 0;
    
    //       for (var i = 0, shift = 0; i < this.length; i++) {
    //         var word = (this.words[i] << shift) | carry;
    
    //         res[position++] = word & 0xff;
    //         if (position < res.length) {
    //           res[position++] = (word >> 8) & 0xff;
    //         }
    //         if (position < res.length) {
    //           res[position++] = (word >> 16) & 0xff;
    //         }
    
    //         if (shift === 6) {
    //           if (position < res.length) {
    //             res[position++] = (word >> 24) & 0xff;
    //           }
    //           carry = 0;
    //           shift = 0;
    //         } else {
    //           carry = word >>> 24;
    //           shift += 2;
    //         }
    //       }
    
    //       if (position < res.length) {
    //         res[position++] = carry;
    
    //         while (position < res.length) {
    //           res[position++] = 0;
    //         }
    //       }
    //     };
    
    //     BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    //       var position = res.length - 1;
    //       var carry = 0;
    
    //       for (var i = 0, shift = 0; i < this.length; i++) {
    //         var word = (this.words[i] << shift) | carry;
    
    //         res[position--] = word & 0xff;
    //         if (position >= 0) {
    //           res[position--] = (word >> 8) & 0xff;
    //         }
    //         if (position >= 0) {
    //           res[position--] = (word >> 16) & 0xff;
    //         }
    
    //         if (shift === 6) {
    //           if (position >= 0) {
    //             res[position--] = (word >> 24) & 0xff;
    //           }
    //           carry = 0;
    //           shift = 0;
    //         } else {
    //           carry = word >>> 24;
    //           shift += 2;
    //         }
    //       }
    
    //       if (position >= 0) {
    //         res[position--] = carry;
    
    //         while (position >= 0) {
    //           res[position--] = 0;
    //         }
    //       }
    //     };
    
    //     if (Math.clz32) {
    //       BN.prototype._countBits = function _countBits (w) {
    //         return 32 - Math.clz32(w);
    //       };
    //     } else {
    //       BN.prototype._countBits = function _countBits (w) {
    //         var t = w;
    //         var r = 0;
    //         if (t >= 0x1000) {
    //           r += 13;
    //           t >>>= 13;
    //         }
    //         if (t >= 0x40) {
    //           r += 7;
    //           t >>>= 7;
    //         }
    //         if (t >= 0x8) {
    //           r += 4;
    //           t >>>= 4;
    //         }
    //         if (t >= 0x02) {
    //           r += 2;
    //           t >>>= 2;
    //         }
    //         return r + t;
    //       };
    //     }
    
    //     BN.prototype._zeroBits = function _zeroBits (w) {
    //       // Short-cut
    //       if (w === 0) return 26;
    
    //       var t = w;
    //       var r = 0;
    //       if ((t & 0x1fff) === 0) {
    //         r += 13;
    //         t >>>= 13;
    //       }
    //       if ((t & 0x7f) === 0) {
    //         r += 7;
    //         t >>>= 7;
    //       }
    //       if ((t & 0xf) === 0) {
    //         r += 4;
    //         t >>>= 4;
    //       }
    //       if ((t & 0x3) === 0) {
    //         r += 2;
    //         t >>>= 2;
    //       }
    //       if ((t & 0x1) === 0) {
    //         r++;
    //       }
    //       return r;
    //     };
    
    //     // Return number of used bits in a BN
    //     BN.prototype.bitLength = function bitLength () {
    //       var w = this.words[this.length - 1];
    //       var hi = this._countBits(w);
    //       return (this.length - 1) * 26 + hi;
    //     };
    
    //     function toBitArray (num) {
    //       var w = new Array(num.bitLength());
    
    //       for (var bit = 0; bit < w.length; bit++) {
    //         var off = (bit / 26) | 0;
    //         var wbit = bit % 26;
    
    //         w[bit] = (num.words[off] >>> wbit) & 0x01;
    //       }
    
    //       return w;
    //     }
    
    //     // Number of trailing zero bits
    //     BN.prototype.zeroBits = function zeroBits () {
    //       if (this.isZero()) return 0;
    
    //       var r = 0;
    //       for (var i = 0; i < this.length; i++) {
    //         var b = this._zeroBits(this.words[i]);
    //         r += b;
    //         if (b !== 26) break;
    //       }
    //       return r;
    //     };
    
    //     BN.prototype.byteLength = function byteLength () {
    //       return Math.ceil(this.bitLength() / 8);
    //     };
    
    //     BN.prototype.toTwos = function toTwos (width) {
    //       if (this.negative !== 0) {
    //         return this.abs().inotn(width).iaddn(1);
    //       }
    //       return this.clone();
    //     };
    
    //     BN.prototype.fromTwos = function fromTwos (width) {
    //       if (this.testn(width - 1)) {
    //         return this.notn(width).iaddn(1).ineg();
    //       }
    //       return this.clone();
    //     };
    
    //     BN.prototype.isNeg = function isNeg () {
    //       return this.negative !== 0;
    //     };
    
    //     // Return negative clone of `this`
    //     BN.prototype.neg = function neg () {
    //       return this.clone().ineg();
    //     };
    
    //     BN.prototype.ineg = function ineg () {
    //       if (!this.isZero()) {
    //         this.negative ^= 1;
    //       }
    
    //       return this;
    //     };
    
    //     // Or `num` with `this` in-place
    //     BN.prototype.iuor = function iuor (num) {
    //       while (this.length < num.length) {
    //         this.words[this.length++] = 0;
    //       }
    
    //       for (var i = 0; i < num.length; i++) {
    //         this.words[i] = this.words[i] | num.words[i];
    //       }
    
    //       return this._strip();
    //     };
    
    //     BN.prototype.ior = function ior (num) {
    //       assert((this.negative | num.negative) === 0);
    //       return this.iuor(num);
    //     };
    
    //     // Or `num` with `this`
    //     BN.prototype.or = function or (num) {
    //       if (this.length > num.length) return this.clone().ior(num);
    //       return num.clone().ior(this);
    //     };
    
    //     BN.prototype.uor = function uor (num) {
    //       if (this.length > num.length) return this.clone().iuor(num);
    //       return num.clone().iuor(this);
    //     };
    
    //     // And `num` with `this` in-place
    //     BN.prototype.iuand = function iuand (num) {
    //       // b = min-length(num, this)
    //       var b;
    //       if (this.length > num.length) {
    //         b = num;
    //       } else {
    //         b = this;
    //       }
    
    //       for (var i = 0; i < b.length; i++) {
    //         this.words[i] = this.words[i] & num.words[i];
    //       }
    
    //       this.length = b.length;
    
    //       return this._strip();
    //     };
    
    //     BN.prototype.iand = function iand (num) {
    //       assert((this.negative | num.negative) === 0);
    //       return this.iuand(num);
    //     };
    
    //     // And `num` with `this`
    //     BN.prototype.and = function and (num) {
    //       if (this.length > num.length) return this.clone().iand(num);
    //       return num.clone().iand(this);
    //     };
    
    //     BN.prototype.uand = function uand (num) {
    //       if (this.length > num.length) return this.clone().iuand(num);
    //       return num.clone().iuand(this);
    //     };
    
    //     // Xor `num` with `this` in-place
    //     BN.prototype.iuxor = function iuxor (num) {
    //       // a.length > b.length
    //       var a;
    //       var b;
    //       if (this.length > num.length) {
    //         a = this;
    //         b = num;
    //       } else {
    //         a = num;
    //         b = this;
    //       }
    
    //       for (var i = 0; i < b.length; i++) {
    //         this.words[i] = a.words[i] ^ b.words[i];
    //       }
    
    //       if (this !== a) {
    //         for (; i < a.length; i++) {
    //           this.words[i] = a.words[i];
    //         }
    //       }
    
    //       this.length = a.length;
    
    //       return this._strip();
    //     };
    
    //     BN.prototype.ixor = function ixor (num) {
    //       assert((this.negative | num.negative) === 0);
    //       return this.iuxor(num);
    //     };
    
    //     // Xor `num` with `this`
    //     BN.prototype.xor = function xor (num) {
    //       if (this.length > num.length) return this.clone().ixor(num);
    //       return num.clone().ixor(this);
    //     };
    
    //     BN.prototype.uxor = function uxor (num) {
    //       if (this.length > num.length) return this.clone().iuxor(num);
    //       return num.clone().iuxor(this);
    //     };
    
    //     // Not ``this`` with ``width`` bitwidth
    //     BN.prototype.inotn = function inotn (width) {
    //       assert(typeof width === 'number' && width >= 0);
    
    //       var bytesNeeded = Math.ceil(width / 26) | 0;
    //       var bitsLeft = width % 26;
    
    //       // Extend the buffer with leading zeroes
    //       this._expand(bytesNeeded);
    
    //       if (bitsLeft > 0) {
    //         bytesNeeded--;
    //       }
    
    //       // Handle complete words
    //       for (var i = 0; i < bytesNeeded; i++) {
    //         this.words[i] = ~this.words[i] & 0x3ffffff;
    //       }
    
    //       // Handle the residue
    //       if (bitsLeft > 0) {
    //         this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    //       }
    
    //       // And remove leading zeroes
    //       return this._strip();
    //     };
    
    //     BN.prototype.notn = function notn (width) {
    //       return this.clone().inotn(width);
    //     };
    
    //     // Set `bit` of `this`
    //     BN.prototype.setn = function setn (bit, val) {
    //       assert(typeof bit === 'number' && bit >= 0);
    
    //       var off = (bit / 26) | 0;
    //       var wbit = bit % 26;
    
    //       this._expand(off + 1);
    
    //       if (val) {
    //         this.words[off] = this.words[off] | (1 << wbit);
    //       } else {
    //         this.words[off] = this.words[off] & ~(1 << wbit);
    //       }
    
    //       return this._strip();
    //     };
    
    //     // Add `num` to `this` in-place
    //     BN.prototype.iadd = function iadd (num) {
    //       var r;
    
    //       // negative + positive
    //       if (this.negative !== 0 && num.negative === 0) {
    //         this.negative = 0;
    //         r = this.isub(num);
    //         this.negative ^= 1;
    //         return this._normSign();
    
    //       // positive + negative
    //       } else if (this.negative === 0 && num.negative !== 0) {
    //         num.negative = 0;
    //         r = this.isub(num);
    //         num.negative = 1;
    //         return r._normSign();
    //       }
    
    //       // a.length > b.length
    //       var a, b;
    //       if (this.length > num.length) {
    //         a = this;
    //         b = num;
    //       } else {
    //         a = num;
    //         b = this;
    //       }
    
    //       var carry = 0;
    //       for (var i = 0; i < b.length; i++) {
    //         r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
    //         this.words[i] = r & 0x3ffffff;
    //         carry = r >>> 26;
    //       }
    //       for (; carry !== 0 && i < a.length; i++) {
    //         r = (a.words[i] | 0) + carry;
    //         this.words[i] = r & 0x3ffffff;
    //         carry = r >>> 26;
    //       }
    
    //       this.length = a.length;
    //       if (carry !== 0) {
    //         this.words[this.length] = carry;
    //         this.length++;
    //       // Copy the rest of the words
    //       } else if (a !== this) {
    //         for (; i < a.length; i++) {
    //           this.words[i] = a.words[i];
    //         }
    //       }
    
    //       return this;
    //     };
    
    //     // Add `num` to `this`
    //     BN.prototype.add = function add (num) {
    //       var res;
    //       if (num.negative !== 0 && this.negative === 0) {
    //         num.negative = 0;
    //         res = this.sub(num);
    //         num.negative ^= 1;
    //         return res;
    //       } else if (num.negative === 0 && this.negative !== 0) {
    //         this.negative = 0;
    //         res = num.sub(this);
    //         this.negative = 1;
    //         return res;
    //       }
    
    //       if (this.length > num.length) return this.clone().iadd(num);
    
    //       return num.clone().iadd(this);
    //     };
    
    //     // Subtract `num` from `this` in-place
    //     BN.prototype.isub = function isub (num) {
    //       // this - (-num) = this + num
    //       if (num.negative !== 0) {
    //         num.negative = 0;
    //         var r = this.iadd(num);
    //         num.negative = 1;
    //         return r._normSign();
    
    //       // -this - num = -(this + num)
    //       } else if (this.negative !== 0) {
    //         this.negative = 0;
    //         this.iadd(num);
    //         this.negative = 1;
    //         return this._normSign();
    //       }
    
    //       // At this point both numbers are positive
    //       var cmp = this.cmp(num);
    
    //       // Optimization - zeroify
    //       if (cmp === 0) {
    //         this.negative = 0;
    //         this.length = 1;
    //         this.words[0] = 0;
    //         return this;
    //       }
    
    //       // a > b
    //       var a, b;
    //       if (cmp > 0) {
    //         a = this;
    //         b = num;
    //       } else {
    //         a = num;
    //         b = this;
    //       }
    
    //       var carry = 0;
    //       for (var i = 0; i < b.length; i++) {
    //         r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
    //         carry = r >> 26;
    //         this.words[i] = r & 0x3ffffff;
    //       }
    //       for (; carry !== 0 && i < a.length; i++) {
    //         r = (a.words[i] | 0) + carry;
    //         carry = r >> 26;
    //         this.words[i] = r & 0x3ffffff;
    //       }
    
    //       // Copy rest of the words
    //       if (carry === 0 && i < a.length && a !== this) {
    //         for (; i < a.length; i++) {
    //           this.words[i] = a.words[i];
    //         }
    //       }
    
    //       this.length = Math.max(this.length, i);
    
    //       if (a !== this) {
    //         this.negative = 1;
    //       }
    
    //       return this._strip();
    //     };
    
    //     // Subtract `num` from `this`
    //     BN.prototype.sub = function sub (num) {
    //       return this.clone().isub(num);
    //     };
    
    //     function smallMulTo (self, num, out) {
    //       out.negative = num.negative ^ self.negative;
    //       var len = (self.length + num.length) | 0;
    //       out.length = len;
    //       len = (len - 1) | 0;
    
    //       // Peel one iteration (compiler can't do it, because of code complexity)
    //       var a = self.words[0] | 0;
    //       var b = num.words[0] | 0;
    //       var r = a * b;
    
    //       var lo = r & 0x3ffffff;
    //       var carry = (r / 0x4000000) | 0;
    //       out.words[0] = lo;
    
    //       for (var k = 1; k < len; k++) {
    //         // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    //         // note that ncarry could be >= 0x3ffffff
    //         var ncarry = carry >>> 26;
    //         var rword = carry & 0x3ffffff;
    //         var maxJ = Math.min(k, num.length - 1);
    //         for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
    //           var i = (k - j) | 0;
    //           a = self.words[i] | 0;
    //           b = num.words[j] | 0;
    //           r = a * b + rword;
    //           ncarry += (r / 0x4000000) | 0;
    //           rword = r & 0x3ffffff;
    //         }
    //         out.words[k] = rword | 0;
    //         carry = ncarry | 0;
    //       }
    //       if (carry !== 0) {
    //         out.words[k] = carry | 0;
    //       } else {
    //         out.length--;
    //       }
    
    //       return out._strip();
    //     }
    
    //     // TODO(indutny): it may be reasonable to omit it for users who don't need
    //     // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    //     // multiplication (like elliptic secp256k1).
    //     var comb10MulTo = function comb10MulTo (self, num, out) {
    //       var a = self.words;
    //       var b = num.words;
    //       var o = out.words;
    //       var c = 0;
    //       var lo;
    //       var mid;
    //       var hi;
    //       var a0 = a[0] | 0;
    //       var al0 = a0 & 0x1fff;
    //       var ah0 = a0 >>> 13;
    //       var a1 = a[1] | 0;
    //       var al1 = a1 & 0x1fff;
    //       var ah1 = a1 >>> 13;
    //       var a2 = a[2] | 0;
    //       var al2 = a2 & 0x1fff;
    //       var ah2 = a2 >>> 13;
    //       var a3 = a[3] | 0;
    //       var al3 = a3 & 0x1fff;
    //       var ah3 = a3 >>> 13;
    //       var a4 = a[4] | 0;
    //       var al4 = a4 & 0x1fff;
    //       var ah4 = a4 >>> 13;
    //       var a5 = a[5] | 0;
    //       var al5 = a5 & 0x1fff;
    //       var ah5 = a5 >>> 13;
    //       var a6 = a[6] | 0;
    //       var al6 = a6 & 0x1fff;
    //       var ah6 = a6 >>> 13;
    //       var a7 = a[7] | 0;
    //       var al7 = a7 & 0x1fff;
    //       var ah7 = a7 >>> 13;
    //       var a8 = a[8] | 0;
    //       var al8 = a8 & 0x1fff;
    //       var ah8 = a8 >>> 13;
    //       var a9 = a[9] | 0;
    //       var al9 = a9 & 0x1fff;
    //       var ah9 = a9 >>> 13;
    //       var b0 = b[0] | 0;
    //       var bl0 = b0 & 0x1fff;
    //       var bh0 = b0 >>> 13;
    //       var b1 = b[1] | 0;
    //       var bl1 = b1 & 0x1fff;
    //       var bh1 = b1 >>> 13;
    //       var b2 = b[2] | 0;
    //       var bl2 = b2 & 0x1fff;
    //       var bh2 = b2 >>> 13;
    //       var b3 = b[3] | 0;
    //       var bl3 = b3 & 0x1fff;
    //       var bh3 = b3 >>> 13;
    //       var b4 = b[4] | 0;
    //       var bl4 = b4 & 0x1fff;
    //       var bh4 = b4 >>> 13;
    //       var b5 = b[5] | 0;
    //       var bl5 = b5 & 0x1fff;
    //       var bh5 = b5 >>> 13;
    //       var b6 = b[6] | 0;
    //       var bl6 = b6 & 0x1fff;
    //       var bh6 = b6 >>> 13;
    //       var b7 = b[7] | 0;
    //       var bl7 = b7 & 0x1fff;
    //       var bh7 = b7 >>> 13;
    //       var b8 = b[8] | 0;
    //       var bl8 = b8 & 0x1fff;
    //       var bh8 = b8 >>> 13;
    //       var b9 = b[9] | 0;
    //       var bl9 = b9 & 0x1fff;
    //       var bh9 = b9 >>> 13;
    
    //       out.negative = self.negative ^ num.negative;
    //       out.length = 19;
    //       /* k = 0 */
    //       lo = Math.imul(al0, bl0);
    //       mid = Math.imul(al0, bh0);
    //       mid = (mid + Math.imul(ah0, bl0)) | 0;
    //       hi = Math.imul(ah0, bh0);
    //       var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    //       w0 &= 0x3ffffff;
    //       /* k = 1 */
    //       lo = Math.imul(al1, bl0);
    //       mid = Math.imul(al1, bh0);
    //       mid = (mid + Math.imul(ah1, bl0)) | 0;
    //       hi = Math.imul(ah1, bh0);
    //       lo = (lo + Math.imul(al0, bl1)) | 0;
    //       mid = (mid + Math.imul(al0, bh1)) | 0;
    //       mid = (mid + Math.imul(ah0, bl1)) | 0;
    //       hi = (hi + Math.imul(ah0, bh1)) | 0;
    //       var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    //       w1 &= 0x3ffffff;
    //       /* k = 2 */
    //       lo = Math.imul(al2, bl0);
    //       mid = Math.imul(al2, bh0);
    //       mid = (mid + Math.imul(ah2, bl0)) | 0;
    //       hi = Math.imul(ah2, bh0);
    //       lo = (lo + Math.imul(al1, bl1)) | 0;
    //       mid = (mid + Math.imul(al1, bh1)) | 0;
    //       mid = (mid + Math.imul(ah1, bl1)) | 0;
    //       hi = (hi + Math.imul(ah1, bh1)) | 0;
    //       lo = (lo + Math.imul(al0, bl2)) | 0;
    //       mid = (mid + Math.imul(al0, bh2)) | 0;
    //       mid = (mid + Math.imul(ah0, bl2)) | 0;
    //       hi = (hi + Math.imul(ah0, bh2)) | 0;
    //       var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    //       w2 &= 0x3ffffff;
    //       /* k = 3 */
    //       lo = Math.imul(al3, bl0);
    //       mid = Math.imul(al3, bh0);
    //       mid = (mid + Math.imul(ah3, bl0)) | 0;
    //       hi = Math.imul(ah3, bh0);
    //       lo = (lo + Math.imul(al2, bl1)) | 0;
    //       mid = (mid + Math.imul(al2, bh1)) | 0;
    //       mid = (mid + Math.imul(ah2, bl1)) | 0;
    //       hi = (hi + Math.imul(ah2, bh1)) | 0;
    //       lo = (lo + Math.imul(al1, bl2)) | 0;
    //       mid = (mid + Math.imul(al1, bh2)) | 0;
    //       mid = (mid + Math.imul(ah1, bl2)) | 0;
    //       hi = (hi + Math.imul(ah1, bh2)) | 0;
    //       lo = (lo + Math.imul(al0, bl3)) | 0;
    //       mid = (mid + Math.imul(al0, bh3)) | 0;
    //       mid = (mid + Math.imul(ah0, bl3)) | 0;
    //       hi = (hi + Math.imul(ah0, bh3)) | 0;
    //       var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    //       w3 &= 0x3ffffff;
    //       /* k = 4 */
    //       lo = Math.imul(al4, bl0);
    //       mid = Math.imul(al4, bh0);
    //       mid = (mid + Math.imul(ah4, bl0)) | 0;
    //       hi = Math.imul(ah4, bh0);
    //       lo = (lo + Math.imul(al3, bl1)) | 0;
    //       mid = (mid + Math.imul(al3, bh1)) | 0;
    //       mid = (mid + Math.imul(ah3, bl1)) | 0;
    //       hi = (hi + Math.imul(ah3, bh1)) | 0;
    //       lo = (lo + Math.imul(al2, bl2)) | 0;
    //       mid = (mid + Math.imul(al2, bh2)) | 0;
    //       mid = (mid + Math.imul(ah2, bl2)) | 0;
    //       hi = (hi + Math.imul(ah2, bh2)) | 0;
    //       lo = (lo + Math.imul(al1, bl3)) | 0;
    //       mid = (mid + Math.imul(al1, bh3)) | 0;
    //       mid = (mid + Math.imul(ah1, bl3)) | 0;
    //       hi = (hi + Math.imul(ah1, bh3)) | 0;
    //       lo = (lo + Math.imul(al0, bl4)) | 0;
    //       mid = (mid + Math.imul(al0, bh4)) | 0;
    //       mid = (mid + Math.imul(ah0, bl4)) | 0;
    //       hi = (hi + Math.imul(ah0, bh4)) | 0;
    //       var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    //       w4 &= 0x3ffffff;
    //       /* k = 5 */
    //       lo = Math.imul(al5, bl0);
    //       mid = Math.imul(al5, bh0);
    //       mid = (mid + Math.imul(ah5, bl0)) | 0;
    //       hi = Math.imul(ah5, bh0);
    //       lo = (lo + Math.imul(al4, bl1)) | 0;
    //       mid = (mid + Math.imul(al4, bh1)) | 0;
    //       mid = (mid + Math.imul(ah4, bl1)) | 0;
    //       hi = (hi + Math.imul(ah4, bh1)) | 0;
    //       lo = (lo + Math.imul(al3, bl2)) | 0;
    //       mid = (mid + Math.imul(al3, bh2)) | 0;
    //       mid = (mid + Math.imul(ah3, bl2)) | 0;
    //       hi = (hi + Math.imul(ah3, bh2)) | 0;
    //       lo = (lo + Math.imul(al2, bl3)) | 0;
    //       mid = (mid + Math.imul(al2, bh3)) | 0;
    //       mid = (mid + Math.imul(ah2, bl3)) | 0;
    //       hi = (hi + Math.imul(ah2, bh3)) | 0;
    //       lo = (lo + Math.imul(al1, bl4)) | 0;
    //       mid = (mid + Math.imul(al1, bh4)) | 0;
    //       mid = (mid + Math.imul(ah1, bl4)) | 0;
    //       hi = (hi + Math.imul(ah1, bh4)) | 0;
    //       lo = (lo + Math.imul(al0, bl5)) | 0;
    //       mid = (mid + Math.imul(al0, bh5)) | 0;
    //       mid = (mid + Math.imul(ah0, bl5)) | 0;
    //       hi = (hi + Math.imul(ah0, bh5)) | 0;
    //       var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    //       w5 &= 0x3ffffff;
    //       /* k = 6 */
    //       lo = Math.imul(al6, bl0);
    //       mid = Math.imul(al6, bh0);
    //       mid = (mid + Math.imul(ah6, bl0)) | 0;
    //       hi = Math.imul(ah6, bh0);
    //       lo = (lo + Math.imul(al5, bl1)) | 0;
    //       mid = (mid + Math.imul(al5, bh1)) | 0;
    //       mid = (mid + Math.imul(ah5, bl1)) | 0;
    //       hi = (hi + Math.imul(ah5, bh1)) | 0;
    //       lo = (lo + Math.imul(al4, bl2)) | 0;
    //       mid = (mid + Math.imul(al4, bh2)) | 0;
    //       mid = (mid + Math.imul(ah4, bl2)) | 0;
    //       hi = (hi + Math.imul(ah4, bh2)) | 0;
    //       lo = (lo + Math.imul(al3, bl3)) | 0;
    //       mid = (mid + Math.imul(al3, bh3)) | 0;
    //       mid = (mid + Math.imul(ah3, bl3)) | 0;
    //       hi = (hi + Math.imul(ah3, bh3)) | 0;
    //       lo = (lo + Math.imul(al2, bl4)) | 0;
    //       mid = (mid + Math.imul(al2, bh4)) | 0;
    //       mid = (mid + Math.imul(ah2, bl4)) | 0;
    //       hi = (hi + Math.imul(ah2, bh4)) | 0;
    //       lo = (lo + Math.imul(al1, bl5)) | 0;
    //       mid = (mid + Math.imul(al1, bh5)) | 0;
    //       mid = (mid + Math.imul(ah1, bl5)) | 0;
    //       hi = (hi + Math.imul(ah1, bh5)) | 0;
    //       lo = (lo + Math.imul(al0, bl6)) | 0;
    //       mid = (mid + Math.imul(al0, bh6)) | 0;
    //       mid = (mid + Math.imul(ah0, bl6)) | 0;
    //       hi = (hi + Math.imul(ah0, bh6)) | 0;
    //       var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    //       w6 &= 0x3ffffff;
    //       /* k = 7 */
    //       lo = Math.imul(al7, bl0);
    //       mid = Math.imul(al7, bh0);
    //       mid = (mid + Math.imul(ah7, bl0)) | 0;
    //       hi = Math.imul(ah7, bh0);
    //       lo = (lo + Math.imul(al6, bl1)) | 0;
    //       mid = (mid + Math.imul(al6, bh1)) | 0;
    //       mid = (mid + Math.imul(ah6, bl1)) | 0;
    //       hi = (hi + Math.imul(ah6, bh1)) | 0;
    //       lo = (lo + Math.imul(al5, bl2)) | 0;
    //       mid = (mid + Math.imul(al5, bh2)) | 0;
    //       mid = (mid + Math.imul(ah5, bl2)) | 0;
    //       hi = (hi + Math.imul(ah5, bh2)) | 0;
    //       lo = (lo + Math.imul(al4, bl3)) | 0;
    //       mid = (mid + Math.imul(al4, bh3)) | 0;
    //       mid = (mid + Math.imul(ah4, bl3)) | 0;
    //       hi = (hi + Math.imul(ah4, bh3)) | 0;
    //       lo = (lo + Math.imul(al3, bl4)) | 0;
    //       mid = (mid + Math.imul(al3, bh4)) | 0;
    //       mid = (mid + Math.imul(ah3, bl4)) | 0;
    //       hi = (hi + Math.imul(ah3, bh4)) | 0;
    //       lo = (lo + Math.imul(al2, bl5)) | 0;
    //       mid = (mid + Math.imul(al2, bh5)) | 0;
    //       mid = (mid + Math.imul(ah2, bl5)) | 0;
    //       hi = (hi + Math.imul(ah2, bh5)) | 0;
    //       lo = (lo + Math.imul(al1, bl6)) | 0;
    //       mid = (mid + Math.imul(al1, bh6)) | 0;
    //       mid = (mid + Math.imul(ah1, bl6)) | 0;
    //       hi = (hi + Math.imul(ah1, bh6)) | 0;
    //       lo = (lo + Math.imul(al0, bl7)) | 0;
    //       mid = (mid + Math.imul(al0, bh7)) | 0;
    //       mid = (mid + Math.imul(ah0, bl7)) | 0;
    //       hi = (hi + Math.imul(ah0, bh7)) | 0;
    //       var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    //       w7 &= 0x3ffffff;
    //       /* k = 8 */
    //       lo = Math.imul(al8, bl0);
    //       mid = Math.imul(al8, bh0);
    //       mid = (mid + Math.imul(ah8, bl0)) | 0;
    //       hi = Math.imul(ah8, bh0);
    //       lo = (lo + Math.imul(al7, bl1)) | 0;
    //       mid = (mid + Math.imul(al7, bh1)) | 0;
    //       mid = (mid + Math.imul(ah7, bl1)) | 0;
    //       hi = (hi + Math.imul(ah7, bh1)) | 0;
    //       lo = (lo + Math.imul(al6, bl2)) | 0;
    //       mid = (mid + Math.imul(al6, bh2)) | 0;
    //       mid = (mid + Math.imul(ah6, bl2)) | 0;
    //       hi = (hi + Math.imul(ah6, bh2)) | 0;
    //       lo = (lo + Math.imul(al5, bl3)) | 0;
    //       mid = (mid + Math.imul(al5, bh3)) | 0;
    //       mid = (mid + Math.imul(ah5, bl3)) | 0;
    //       hi = (hi + Math.imul(ah5, bh3)) | 0;
    //       lo = (lo + Math.imul(al4, bl4)) | 0;
    //       mid = (mid + Math.imul(al4, bh4)) | 0;
    //       mid = (mid + Math.imul(ah4, bl4)) | 0;
    //       hi = (hi + Math.imul(ah4, bh4)) | 0;
    //       lo = (lo + Math.imul(al3, bl5)) | 0;
    //       mid = (mid + Math.imul(al3, bh5)) | 0;
    //       mid = (mid + Math.imul(ah3, bl5)) | 0;
    //       hi = (hi + Math.imul(ah3, bh5)) | 0;
    //       lo = (lo + Math.imul(al2, bl6)) | 0;
    //       mid = (mid + Math.imul(al2, bh6)) | 0;
    //       mid = (mid + Math.imul(ah2, bl6)) | 0;
    //       hi = (hi + Math.imul(ah2, bh6)) | 0;
    //       lo = (lo + Math.imul(al1, bl7)) | 0;
    //       mid = (mid + Math.imul(al1, bh7)) | 0;
    //       mid = (mid + Math.imul(ah1, bl7)) | 0;
    //       hi = (hi + Math.imul(ah1, bh7)) | 0;
    //       lo = (lo + Math.imul(al0, bl8)) | 0;
    //       mid = (mid + Math.imul(al0, bh8)) | 0;
    //       mid = (mid + Math.imul(ah0, bl8)) | 0;
    //       hi = (hi + Math.imul(ah0, bh8)) | 0;
    //       var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    //       w8 &= 0x3ffffff;
    //       /* k = 9 */
    //       lo = Math.imul(al9, bl0);
    //       mid = Math.imul(al9, bh0);
    //       mid = (mid + Math.imul(ah9, bl0)) | 0;
    //       hi = Math.imul(ah9, bh0);
    //       lo = (lo + Math.imul(al8, bl1)) | 0;
    //       mid = (mid + Math.imul(al8, bh1)) | 0;
    //       mid = (mid + Math.imul(ah8, bl1)) | 0;
    //       hi = (hi + Math.imul(ah8, bh1)) | 0;
    //       lo = (lo + Math.imul(al7, bl2)) | 0;
    //       mid = (mid + Math.imul(al7, bh2)) | 0;
    //       mid = (mid + Math.imul(ah7, bl2)) | 0;
    //       hi = (hi + Math.imul(ah7, bh2)) | 0;
    //       lo = (lo + Math.imul(al6, bl3)) | 0;
    //       mid = (mid + Math.imul(al6, bh3)) | 0;
    //       mid = (mid + Math.imul(ah6, bl3)) | 0;
    //       hi = (hi + Math.imul(ah6, bh3)) | 0;
    //       lo = (lo + Math.imul(al5, bl4)) | 0;
    //       mid = (mid + Math.imul(al5, bh4)) | 0;
    //       mid = (mid + Math.imul(ah5, bl4)) | 0;
    //       hi = (hi + Math.imul(ah5, bh4)) | 0;
    //       lo = (lo + Math.imul(al4, bl5)) | 0;
    //       mid = (mid + Math.imul(al4, bh5)) | 0;
    //       mid = (mid + Math.imul(ah4, bl5)) | 0;
    //       hi = (hi + Math.imul(ah4, bh5)) | 0;
    //       lo = (lo + Math.imul(al3, bl6)) | 0;
    //       mid = (mid + Math.imul(al3, bh6)) | 0;
    //       mid = (mid + Math.imul(ah3, bl6)) | 0;
    //       hi = (hi + Math.imul(ah3, bh6)) | 0;
    //       lo = (lo + Math.imul(al2, bl7)) | 0;
    //       mid = (mid + Math.imul(al2, bh7)) | 0;
    //       mid = (mid + Math.imul(ah2, bl7)) | 0;
    //       hi = (hi + Math.imul(ah2, bh7)) | 0;
    //       lo = (lo + Math.imul(al1, bl8)) | 0;
    //       mid = (mid + Math.imul(al1, bh8)) | 0;
    //       mid = (mid + Math.imul(ah1, bl8)) | 0;
    //       hi = (hi + Math.imul(ah1, bh8)) | 0;
    //       lo = (lo + Math.imul(al0, bl9)) | 0;
    //       mid = (mid + Math.imul(al0, bh9)) | 0;
    //       mid = (mid + Math.imul(ah0, bl9)) | 0;
    //       hi = (hi + Math.imul(ah0, bh9)) | 0;
    //       var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    //       w9 &= 0x3ffffff;
    //       /* k = 10 */
    //       lo = Math.imul(al9, bl1);
    //       mid = Math.imul(al9, bh1);
    //       mid = (mid + Math.imul(ah9, bl1)) | 0;
    //       hi = Math.imul(ah9, bh1);
    //       lo = (lo + Math.imul(al8, bl2)) | 0;
    //       mid = (mid + Math.imul(al8, bh2)) | 0;
    //       mid = (mid + Math.imul(ah8, bl2)) | 0;
    //       hi = (hi + Math.imul(ah8, bh2)) | 0;
    //       lo = (lo + Math.imul(al7, bl3)) | 0;
    //       mid = (mid + Math.imul(al7, bh3)) | 0;
    //       mid = (mid + Math.imul(ah7, bl3)) | 0;
    //       hi = (hi + Math.imul(ah7, bh3)) | 0;
    //       lo = (lo + Math.imul(al6, bl4)) | 0;
    //       mid = (mid + Math.imul(al6, bh4)) | 0;
    //       mid = (mid + Math.imul(ah6, bl4)) | 0;
    //       hi = (hi + Math.imul(ah6, bh4)) | 0;
    //       lo = (lo + Math.imul(al5, bl5)) | 0;
    //       mid = (mid + Math.imul(al5, bh5)) | 0;
    //       mid = (mid + Math.imul(ah5, bl5)) | 0;
    //       hi = (hi + Math.imul(ah5, bh5)) | 0;
    //       lo = (lo + Math.imul(al4, bl6)) | 0;
    //       mid = (mid + Math.imul(al4, bh6)) | 0;
    //       mid = (mid + Math.imul(ah4, bl6)) | 0;
    //       hi = (hi + Math.imul(ah4, bh6)) | 0;
    //       lo = (lo + Math.imul(al3, bl7)) | 0;
    //       mid = (mid + Math.imul(al3, bh7)) | 0;
    //       mid = (mid + Math.imul(ah3, bl7)) | 0;
    //       hi = (hi + Math.imul(ah3, bh7)) | 0;
    //       lo = (lo + Math.imul(al2, bl8)) | 0;
    //       mid = (mid + Math.imul(al2, bh8)) | 0;
    //       mid = (mid + Math.imul(ah2, bl8)) | 0;
    //       hi = (hi + Math.imul(ah2, bh8)) | 0;
    //       lo = (lo + Math.imul(al1, bl9)) | 0;
    //       mid = (mid + Math.imul(al1, bh9)) | 0;
    //       mid = (mid + Math.imul(ah1, bl9)) | 0;
    //       hi = (hi + Math.imul(ah1, bh9)) | 0;
    //       var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    //       w10 &= 0x3ffffff;
    //       /* k = 11 */
    //       lo = Math.imul(al9, bl2);
    //       mid = Math.imul(al9, bh2);
    //       mid = (mid + Math.imul(ah9, bl2)) | 0;
    //       hi = Math.imul(ah9, bh2);
    //       lo = (lo + Math.imul(al8, bl3)) | 0;
    //       mid = (mid + Math.imul(al8, bh3)) | 0;
    //       mid = (mid + Math.imul(ah8, bl3)) | 0;
    //       hi = (hi + Math.imul(ah8, bh3)) | 0;
    //       lo = (lo + Math.imul(al7, bl4)) | 0;
    //       mid = (mid + Math.imul(al7, bh4)) | 0;
    //       mid = (mid + Math.imul(ah7, bl4)) | 0;
    //       hi = (hi + Math.imul(ah7, bh4)) | 0;
    //       lo = (lo + Math.imul(al6, bl5)) | 0;
    //       mid = (mid + Math.imul(al6, bh5)) | 0;
    //       mid = (mid + Math.imul(ah6, bl5)) | 0;
    //       hi = (hi + Math.imul(ah6, bh5)) | 0;
    //       lo = (lo + Math.imul(al5, bl6)) | 0;
    //       mid = (mid + Math.imul(al5, bh6)) | 0;
    //       mid = (mid + Math.imul(ah5, bl6)) | 0;
    //       hi = (hi + Math.imul(ah5, bh6)) | 0;
    //       lo = (lo + Math.imul(al4, bl7)) | 0;
    //       mid = (mid + Math.imul(al4, bh7)) | 0;
    //       mid = (mid + Math.imul(ah4, bl7)) | 0;
    //       hi = (hi + Math.imul(ah4, bh7)) | 0;
    //       lo = (lo + Math.imul(al3, bl8)) | 0;
    //       mid = (mid + Math.imul(al3, bh8)) | 0;
    //       mid = (mid + Math.imul(ah3, bl8)) | 0;
    //       hi = (hi + Math.imul(ah3, bh8)) | 0;
    //       lo = (lo + Math.imul(al2, bl9)) | 0;
    //       mid = (mid + Math.imul(al2, bh9)) | 0;
    //       mid = (mid + Math.imul(ah2, bl9)) | 0;
    //       hi = (hi + Math.imul(ah2, bh9)) | 0;
    //       var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    //       w11 &= 0x3ffffff;
    //       /* k = 12 */
    //       lo = Math.imul(al9, bl3);
    //       mid = Math.imul(al9, bh3);
    //       mid = (mid + Math.imul(ah9, bl3)) | 0;
    //       hi = Math.imul(ah9, bh3);
    //       lo = (lo + Math.imul(al8, bl4)) | 0;
    //       mid = (mid + Math.imul(al8, bh4)) | 0;
    //       mid = (mid + Math.imul(ah8, bl4)) | 0;
    //       hi = (hi + Math.imul(ah8, bh4)) | 0;
    //       lo = (lo + Math.imul(al7, bl5)) | 0;
    //       mid = (mid + Math.imul(al7, bh5)) | 0;
    //       mid = (mid + Math.imul(ah7, bl5)) | 0;
    //       hi = (hi + Math.imul(ah7, bh5)) | 0;
    //       lo = (lo + Math.imul(al6, bl6)) | 0;
    //       mid = (mid + Math.imul(al6, bh6)) | 0;
    //       mid = (mid + Math.imul(ah6, bl6)) | 0;
    //       hi = (hi + Math.imul(ah6, bh6)) | 0;
    //       lo = (lo + Math.imul(al5, bl7)) | 0;
    //       mid = (mid + Math.imul(al5, bh7)) | 0;
    //       mid = (mid + Math.imul(ah5, bl7)) | 0;
    //       hi = (hi + Math.imul(ah5, bh7)) | 0;
    //       lo = (lo + Math.imul(al4, bl8)) | 0;
    //       mid = (mid + Math.imul(al4, bh8)) | 0;
    //       mid = (mid + Math.imul(ah4, bl8)) | 0;
    //       hi = (hi + Math.imul(ah4, bh8)) | 0;
    //       lo = (lo + Math.imul(al3, bl9)) | 0;
    //       mid = (mid + Math.imul(al3, bh9)) | 0;
    //       mid = (mid + Math.imul(ah3, bl9)) | 0;
    //       hi = (hi + Math.imul(ah3, bh9)) | 0;
    //       var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    //       w12 &= 0x3ffffff;
    //       /* k = 13 */
    //       lo = Math.imul(al9, bl4);
    //       mid = Math.imul(al9, bh4);
    //       mid = (mid + Math.imul(ah9, bl4)) | 0;
    //       hi = Math.imul(ah9, bh4);
    //       lo = (lo + Math.imul(al8, bl5)) | 0;
    //       mid = (mid + Math.imul(al8, bh5)) | 0;
    //       mid = (mid + Math.imul(ah8, bl5)) | 0;
    //       hi = (hi + Math.imul(ah8, bh5)) | 0;
    //       lo = (lo + Math.imul(al7, bl6)) | 0;
    //       mid = (mid + Math.imul(al7, bh6)) | 0;
    //       mid = (mid + Math.imul(ah7, bl6)) | 0;
    //       hi = (hi + Math.imul(ah7, bh6)) | 0;
    //       lo = (lo + Math.imul(al6, bl7)) | 0;
    //       mid = (mid + Math.imul(al6, bh7)) | 0;
    //       mid = (mid + Math.imul(ah6, bl7)) | 0;
    //       hi = (hi + Math.imul(ah6, bh7)) | 0;
    //       lo = (lo + Math.imul(al5, bl8)) | 0;
    //       mid = (mid + Math.imul(al5, bh8)) | 0;
    //       mid = (mid + Math.imul(ah5, bl8)) | 0;
    //       hi = (hi + Math.imul(ah5, bh8)) | 0;
    //       lo = (lo + Math.imul(al4, bl9)) | 0;
    //       mid = (mid + Math.imul(al4, bh9)) | 0;
    //       mid = (mid + Math.imul(ah4, bl9)) | 0;
    //       hi = (hi + Math.imul(ah4, bh9)) | 0;
    //       var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    //       w13 &= 0x3ffffff;
    //       /* k = 14 */
    //       lo = Math.imul(al9, bl5);
    //       mid = Math.imul(al9, bh5);
    //       mid = (mid + Math.imul(ah9, bl5)) | 0;
    //       hi = Math.imul(ah9, bh5);
    //       lo = (lo + Math.imul(al8, bl6)) | 0;
    //       mid = (mid + Math.imul(al8, bh6)) | 0;
    //       mid = (mid + Math.imul(ah8, bl6)) | 0;
    //       hi = (hi + Math.imul(ah8, bh6)) | 0;
    //       lo = (lo + Math.imul(al7, bl7)) | 0;
    //       mid = (mid + Math.imul(al7, bh7)) | 0;
    //       mid = (mid + Math.imul(ah7, bl7)) | 0;
    //       hi = (hi + Math.imul(ah7, bh7)) | 0;
    //       lo = (lo + Math.imul(al6, bl8)) | 0;
    //       mid = (mid + Math.imul(al6, bh8)) | 0;
    //       mid = (mid + Math.imul(ah6, bl8)) | 0;
    //       hi = (hi + Math.imul(ah6, bh8)) | 0;
    //       lo = (lo + Math.imul(al5, bl9)) | 0;
    //       mid = (mid + Math.imul(al5, bh9)) | 0;
    //       mid = (mid + Math.imul(ah5, bl9)) | 0;
    //       hi = (hi + Math.imul(ah5, bh9)) | 0;
    //       var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    //       w14 &= 0x3ffffff;
    //       /* k = 15 */
    //       lo = Math.imul(al9, bl6);
    //       mid = Math.imul(al9, bh6);
    //       mid = (mid + Math.imul(ah9, bl6)) | 0;
    //       hi = Math.imul(ah9, bh6);
    //       lo = (lo + Math.imul(al8, bl7)) | 0;
    //       mid = (mid + Math.imul(al8, bh7)) | 0;
    //       mid = (mid + Math.imul(ah8, bl7)) | 0;
    //       hi = (hi + Math.imul(ah8, bh7)) | 0;
    //       lo = (lo + Math.imul(al7, bl8)) | 0;
    //       mid = (mid + Math.imul(al7, bh8)) | 0;
    //       mid = (mid + Math.imul(ah7, bl8)) | 0;
    //       hi = (hi + Math.imul(ah7, bh8)) | 0;
    //       lo = (lo + Math.imul(al6, bl9)) | 0;
    //       mid = (mid + Math.imul(al6, bh9)) | 0;
    //       mid = (mid + Math.imul(ah6, bl9)) | 0;
    //       hi = (hi + Math.imul(ah6, bh9)) | 0;
    //       var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    //       w15 &= 0x3ffffff;
    //       /* k = 16 */
    //       lo = Math.imul(al9, bl7);
    //       mid = Math.imul(al9, bh7);
    //       mid = (mid + Math.imul(ah9, bl7)) | 0;
    //       hi = Math.imul(ah9, bh7);
    //       lo = (lo + Math.imul(al8, bl8)) | 0;
    //       mid = (mid + Math.imul(al8, bh8)) | 0;
    //       mid = (mid + Math.imul(ah8, bl8)) | 0;
    //       hi = (hi + Math.imul(ah8, bh8)) | 0;
    //       lo = (lo + Math.imul(al7, bl9)) | 0;
    //       mid = (mid + Math.imul(al7, bh9)) | 0;
    //       mid = (mid + Math.imul(ah7, bl9)) | 0;
    //       hi = (hi + Math.imul(ah7, bh9)) | 0;
    //       var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    //       w16 &= 0x3ffffff;
    //       /* k = 17 */
    //       lo = Math.imul(al9, bl8);
    //       mid = Math.imul(al9, bh8);
    //       mid = (mid + Math.imul(ah9, bl8)) | 0;
    //       hi = Math.imul(ah9, bh8);
    //       lo = (lo + Math.imul(al8, bl9)) | 0;
    //       mid = (mid + Math.imul(al8, bh9)) | 0;
    //       mid = (mid + Math.imul(ah8, bl9)) | 0;
    //       hi = (hi + Math.imul(ah8, bh9)) | 0;
    //       var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    //       w17 &= 0x3ffffff;
    //       /* k = 18 */
    //       lo = Math.imul(al9, bl9);
    //       mid = Math.imul(al9, bh9);
    //       mid = (mid + Math.imul(ah9, bl9)) | 0;
    //       hi = Math.imul(ah9, bh9);
    //       var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    //       c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    //       w18 &= 0x3ffffff;
    //       o[0] = w0;
    //       o[1] = w1;
    //       o[2] = w2;
    //       o[3] = w3;
    //       o[4] = w4;
    //       o[5] = w5;
    //       o[6] = w6;
    //       o[7] = w7;
    //       o[8] = w8;
    //       o[9] = w9;
    //       o[10] = w10;
    //       o[11] = w11;
    //       o[12] = w12;
    //       o[13] = w13;
    //       o[14] = w14;
    //       o[15] = w15;
    //       o[16] = w16;
    //       o[17] = w17;
    //       o[18] = w18;
    //       if (c !== 0) {
    //         o[19] = c;
    //         out.length++;
    //       }
    //       return out;
    //     };
    
    //     // Polyfill comb
    //     if (!Math.imul) {
    //       comb10MulTo = smallMulTo;
    //     }
    
    //     function bigMulTo (self, num, out) {
    //       out.negative = num.negative ^ self.negative;
    //       out.length = self.length + num.length;
    
    //       var carry = 0;
    //       var hncarry = 0;
    //       for (var k = 0; k < out.length - 1; k++) {
    //         // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    //         // note that ncarry could be >= 0x3ffffff
    //         var ncarry = hncarry;
    //         hncarry = 0;
    //         var rword = carry & 0x3ffffff;
    //         var maxJ = Math.min(k, num.length - 1);
    //         for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
    //           var i = k - j;
    //           var a = self.words[i] | 0;
    //           var b = num.words[j] | 0;
    //           var r = a * b;
    
    //           var lo = r & 0x3ffffff;
    //           ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
    //           lo = (lo + rword) | 0;
    //           rword = lo & 0x3ffffff;
    //           ncarry = (ncarry + (lo >>> 26)) | 0;
    
    //           hncarry += ncarry >>> 26;
    //           ncarry &= 0x3ffffff;
    //         }
    //         out.words[k] = rword;
    //         carry = ncarry;
    //         ncarry = hncarry;
    //       }
    //       if (carry !== 0) {
    //         out.words[k] = carry;
    //       } else {
    //         out.length--;
    //       }
    
    //       return out._strip();
    //     }
    
    //     function jumboMulTo (self, num, out) {
    //       // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    //       // var fftm = new FFTM();
    //       // return fftm.mulp(self, num, out);
    //       return bigMulTo(self, num, out);
    //     }
    
    //     BN.prototype.mulTo = function mulTo (num, out) {
    //       var res;
    //       var len = this.length + num.length;
    //       if (this.length === 10 && num.length === 10) {
    //         res = comb10MulTo(this, num, out);
    //       } else if (len < 63) {
    //         res = smallMulTo(this, num, out);
    //       } else if (len < 1024) {
    //         res = bigMulTo(this, num, out);
    //       } else {
    //         res = jumboMulTo(this, num, out);
    //       }
    
    //       return res;
    //     };
    
    //     // Multiply `this` by `num`
    //     BN.prototype.mul = function mul (num) {
    //       var out = new BN(null);
    //       out.words = new Array(this.length + num.length);
    //       return this.mulTo(num, out);
    //     };
    
    //     // Multiply employing FFT
    //     BN.prototype.mulf = function mulf (num) {
    //       var out = new BN(null);
    //       out.words = new Array(this.length + num.length);
    //       return jumboMulTo(this, num, out);
    //     };
    
    //     // In-place Multiplication
    //     BN.prototype.imul = function imul (num) {
    //       return this.clone().mulTo(num, this);
    //     };
    
    //     BN.prototype.imuln = function imuln (num) {
    //       var isNegNum = num < 0;
    //       if (isNegNum) num = -num;
    
    //       assert(typeof num === 'number');
    //       assert(num < 0x4000000);
    
    //       // Carry
    //       var carry = 0;
    //       for (var i = 0; i < this.length; i++) {
    //         var w = (this.words[i] | 0) * num;
    //         var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
    //         carry >>= 26;
    //         carry += (w / 0x4000000) | 0;
    //         // NOTE: lo is 27bit maximum
    //         carry += lo >>> 26;
    //         this.words[i] = lo & 0x3ffffff;
    //       }
    
    //       if (carry !== 0) {
    //         this.words[i] = carry;
    //         this.length++;
    //       }
    
    //       return isNegNum ? this.ineg() : this;
    //     };
    
    //     BN.prototype.muln = function muln (num) {
    //       return this.clone().imuln(num);
    //     };
    
    //     // `this` * `this`
    //     BN.prototype.sqr = function sqr () {
    //       return this.mul(this);
    //     };
    
    //     // `this` * `this` in-place
    //     BN.prototype.isqr = function isqr () {
    //       return this.imul(this.clone());
    //     };
    
    //     // Math.pow(`this`, `num`)
    //     BN.prototype.pow = function pow (num) {
    //       var w = toBitArray(num);
    //       if (w.length === 0) return new BN(1);
    
    //       // Skip leading zeroes
    //       var res = this;
    //       for (var i = 0; i < w.length; i++, res = res.sqr()) {
    //         if (w[i] !== 0) break;
    //       }
    
    //       if (++i < w.length) {
    //         for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
    //           if (w[i] === 0) continue;
    
    //           res = res.mul(q);
    //         }
    //       }
    
    //       return res;
    //     };
    
    //     // Shift-left in-place
    //     BN.prototype.iushln = function iushln (bits) {
    //       assert(typeof bits === 'number' && bits >= 0);
    //       var r = bits % 26;
    //       var s = (bits - r) / 26;
    //       var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    //       var i;
    
    //       if (r !== 0) {
    //         var carry = 0;
    
    //         for (i = 0; i < this.length; i++) {
    //           var newCarry = this.words[i] & carryMask;
    //           var c = ((this.words[i] | 0) - newCarry) << r;
    //           this.words[i] = c | carry;
    //           carry = newCarry >>> (26 - r);
    //         }
    
    //         if (carry) {
    //           this.words[i] = carry;
    //           this.length++;
    //         }
    //       }
    
    //       if (s !== 0) {
    //         for (i = this.length - 1; i >= 0; i--) {
    //           this.words[i + s] = this.words[i];
    //         }
    
    //         for (i = 0; i < s; i++) {
    //           this.words[i] = 0;
    //         }
    
    //         this.length += s;
    //       }
    
    //       return this._strip();
    //     };
    
    //     BN.prototype.ishln = function ishln (bits) {
    //       // TODO(indutny): implement me
    //       assert(this.negative === 0);
    //       return this.iushln(bits);
    //     };
    
    //     // Shift-right in-place
    //     // NOTE: `hint` is a lowest bit before trailing zeroes
    //     // NOTE: if `extended` is present - it will be filled with destroyed bits
    //     BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    //       assert(typeof bits === 'number' && bits >= 0);
    //       var h;
    //       if (hint) {
    //         h = (hint - (hint % 26)) / 26;
    //       } else {
    //         h = 0;
    //       }
    
    //       var r = bits % 26;
    //       var s = Math.min((bits - r) / 26, this.length);
    //       var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    //       var maskedWords = extended;
    
    //       h -= s;
    //       h = Math.max(0, h);
    
    //       // Extended mode, copy masked part
    //       if (maskedWords) {
    //         for (var i = 0; i < s; i++) {
    //           maskedWords.words[i] = this.words[i];
    //         }
    //         maskedWords.length = s;
    //       }
    
    //       if (s === 0) ; else if (this.length > s) {
    //         this.length -= s;
    //         for (i = 0; i < this.length; i++) {
    //           this.words[i] = this.words[i + s];
    //         }
    //       } else {
    //         this.words[0] = 0;
    //         this.length = 1;
    //       }
    
    //       var carry = 0;
    //       for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
    //         var word = this.words[i] | 0;
    //         this.words[i] = (carry << (26 - r)) | (word >>> r);
    //         carry = word & mask;
    //       }
    
    //       // Push carried bits as a mask
    //       if (maskedWords && carry !== 0) {
    //         maskedWords.words[maskedWords.length++] = carry;
    //       }
    
    //       if (this.length === 0) {
    //         this.words[0] = 0;
    //         this.length = 1;
    //       }
    
    //       return this._strip();
    //     };
    
    //     BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    //       // TODO(indutny): implement me
    //       assert(this.negative === 0);
    //       return this.iushrn(bits, hint, extended);
    //     };
    
    //     // Shift-left
    //     BN.prototype.shln = function shln (bits) {
    //       return this.clone().ishln(bits);
    //     };
    
    //     BN.prototype.ushln = function ushln (bits) {
    //       return this.clone().iushln(bits);
    //     };
    
    //     // Shift-right
    //     BN.prototype.shrn = function shrn (bits) {
    //       return this.clone().ishrn(bits);
    //     };
    
    //     BN.prototype.ushrn = function ushrn (bits) {
    //       return this.clone().iushrn(bits);
    //     };
    
    //     // Test if n bit is set
    //     BN.prototype.testn = function testn (bit) {
    //       assert(typeof bit === 'number' && bit >= 0);
    //       var r = bit % 26;
    //       var s = (bit - r) / 26;
    //       var q = 1 << r;
    
    //       // Fast case: bit is much higher than all existing words
    //       if (this.length <= s) return false;
    
    //       // Check bit and return
    //       var w = this.words[s];
    
    //       return !!(w & q);
    //     };
    
    //     // Return only lowers bits of number (in-place)
    //     BN.prototype.imaskn = function imaskn (bits) {
    //       assert(typeof bits === 'number' && bits >= 0);
    //       var r = bits % 26;
    //       var s = (bits - r) / 26;
    
    //       assert(this.negative === 0, 'imaskn works only with positive numbers');
    
    //       if (this.length <= s) {
    //         return this;
    //       }
    
    //       if (r !== 0) {
    //         s++;
    //       }
    //       this.length = Math.min(s, this.length);
    
    //       if (r !== 0) {
    //         var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    //         this.words[this.length - 1] &= mask;
    //       }
    
    //       return this._strip();
    //     };
    
    //     // Return only lowers bits of number
    //     BN.prototype.maskn = function maskn (bits) {
    //       return this.clone().imaskn(bits);
    //     };
    
    //     // Add plain number `num` to `this`
    //     BN.prototype.iaddn = function iaddn (num) {
    //       assert(typeof num === 'number');
    //       assert(num < 0x4000000);
    //       if (num < 0) return this.isubn(-num);
    
    //       // Possible sign change
    //       if (this.negative !== 0) {
    //         if (this.length === 1 && (this.words[0] | 0) <= num) {
    //           this.words[0] = num - (this.words[0] | 0);
    //           this.negative = 0;
    //           return this;
    //         }
    
    //         this.negative = 0;
    //         this.isubn(num);
    //         this.negative = 1;
    //         return this;
    //       }
    
    //       // Add without checks
    //       return this._iaddn(num);
    //     };
    
    //     BN.prototype._iaddn = function _iaddn (num) {
    //       this.words[0] += num;
    
    //       // Carry
    //       for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
    //         this.words[i] -= 0x4000000;
    //         if (i === this.length - 1) {
    //           this.words[i + 1] = 1;
    //         } else {
    //           this.words[i + 1]++;
    //         }
    //       }
    //       this.length = Math.max(this.length, i + 1);
    
    //       return this;
    //     };
    
    //     // Subtract plain number `num` from `this`
    //     BN.prototype.isubn = function isubn (num) {
    //       assert(typeof num === 'number');
    //       assert(num < 0x4000000);
    //       if (num < 0) return this.iaddn(-num);
    
    //       if (this.negative !== 0) {
    //         this.negative = 0;
    //         this.iaddn(num);
    //         this.negative = 1;
    //         return this;
    //       }
    
    //       this.words[0] -= num;
    
    //       if (this.length === 1 && this.words[0] < 0) {
    //         this.words[0] = -this.words[0];
    //         this.negative = 1;
    //       } else {
    //         // Carry
    //         for (var i = 0; i < this.length && this.words[i] < 0; i++) {
    //           this.words[i] += 0x4000000;
    //           this.words[i + 1] -= 1;
    //         }
    //       }
    
    //       return this._strip();
    //     };
    
    //     BN.prototype.addn = function addn (num) {
    //       return this.clone().iaddn(num);
    //     };
    
    //     BN.prototype.subn = function subn (num) {
    //       return this.clone().isubn(num);
    //     };
    
    //     BN.prototype.iabs = function iabs () {
    //       this.negative = 0;
    
    //       return this;
    //     };
    
    //     BN.prototype.abs = function abs () {
    //       return this.clone().iabs();
    //     };
    
    //     BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    //       var len = num.length + shift;
    //       var i;
    
    //       this._expand(len);
    
    //       var w;
    //       var carry = 0;
    //       for (i = 0; i < num.length; i++) {
    //         w = (this.words[i + shift] | 0) + carry;
    //         var right = (num.words[i] | 0) * mul;
    //         w -= right & 0x3ffffff;
    //         carry = (w >> 26) - ((right / 0x4000000) | 0);
    //         this.words[i + shift] = w & 0x3ffffff;
    //       }
    //       for (; i < this.length - shift; i++) {
    //         w = (this.words[i + shift] | 0) + carry;
    //         carry = w >> 26;
    //         this.words[i + shift] = w & 0x3ffffff;
    //       }
    
    //       if (carry === 0) return this._strip();
    
    //       // Subtraction overflow
    //       assert(carry === -1);
    //       carry = 0;
    //       for (i = 0; i < this.length; i++) {
    //         w = -(this.words[i] | 0) + carry;
    //         carry = w >> 26;
    //         this.words[i] = w & 0x3ffffff;
    //       }
    //       this.negative = 1;
    
    //       return this._strip();
    //     };
    
    //     BN.prototype._wordDiv = function _wordDiv (num, mode) {
    //       var shift = this.length - num.length;
    
    //       var a = this.clone();
    //       var b = num;
    
    //       // Normalize
    //       var bhi = b.words[b.length - 1] | 0;
    //       var bhiBits = this._countBits(bhi);
    //       shift = 26 - bhiBits;
    //       if (shift !== 0) {
    //         b = b.ushln(shift);
    //         a.iushln(shift);
    //         bhi = b.words[b.length - 1] | 0;
    //       }
    
    //       // Initialize quotient
    //       var m = a.length - b.length;
    //       var q;
    
    //       if (mode !== 'mod') {
    //         q = new BN(null);
    //         q.length = m + 1;
    //         q.words = new Array(q.length);
    //         for (var i = 0; i < q.length; i++) {
    //           q.words[i] = 0;
    //         }
    //       }
    
    //       var diff = a.clone()._ishlnsubmul(b, 1, m);
    //       if (diff.negative === 0) {
    //         a = diff;
    //         if (q) {
    //           q.words[m] = 1;
    //         }
    //       }
    
    //       for (var j = m - 1; j >= 0; j--) {
    //         var qj = (a.words[b.length + j] | 0) * 0x4000000 +
    //           (a.words[b.length + j - 1] | 0);
    
    //         // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
    //         // (0x7ffffff)
    //         qj = Math.min((qj / bhi) | 0, 0x3ffffff);
    
    //         a._ishlnsubmul(b, qj, j);
    //         while (a.negative !== 0) {
    //           qj--;
    //           a.negative = 0;
    //           a._ishlnsubmul(b, 1, j);
    //           if (!a.isZero()) {
    //             a.negative ^= 1;
    //           }
    //         }
    //         if (q) {
    //           q.words[j] = qj;
    //         }
    //       }
    //       if (q) {
    //         q._strip();
    //       }
    //       a._strip();
    
    //       // Denormalize
    //       if (mode !== 'div' && shift !== 0) {
    //         a.iushrn(shift);
    //       }
    
    //       return {
    //         div: q || null,
    //         mod: a
    //       };
    //     };
    
    //     // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //     //       to `div` to request div only, or be absent to
    //     //       request both div & mod
    //     //       2) `positive` is true if unsigned mod is requested
    //     BN.prototype.divmod = function divmod (num, mode, positive) {
    //       assert(!num.isZero());
    
    //       if (this.isZero()) {
    //         return {
    //           div: new BN(0),
    //           mod: new BN(0)
    //         };
    //       }
    
    //       var div, mod, res;
    //       if (this.negative !== 0 && num.negative === 0) {
    //         res = this.neg().divmod(num, mode);
    
    //         if (mode !== 'mod') {
    //           div = res.div.neg();
    //         }
    
    //         if (mode !== 'div') {
    //           mod = res.mod.neg();
    //           if (positive && mod.negative !== 0) {
    //             mod.iadd(num);
    //           }
    //         }
    
    //         return {
    //           div: div,
    //           mod: mod
    //         };
    //       }
    
    //       if (this.negative === 0 && num.negative !== 0) {
    //         res = this.divmod(num.neg(), mode);
    
    //         if (mode !== 'mod') {
    //           div = res.div.neg();
    //         }
    
    //         return {
    //           div: div,
    //           mod: res.mod
    //         };
    //       }
    
    //       if ((this.negative & num.negative) !== 0) {
    //         res = this.neg().divmod(num.neg(), mode);
    
    //         if (mode !== 'div') {
    //           mod = res.mod.neg();
    //           if (positive && mod.negative !== 0) {
    //             mod.isub(num);
    //           }
    //         }
    
    //         return {
    //           div: res.div,
    //           mod: mod
    //         };
    //       }
    
    //       // Both numbers are positive at this point
    
    //       // Strip both numbers to approximate shift value
    //       if (num.length > this.length || this.cmp(num) < 0) {
    //         return {
    //           div: new BN(0),
    //           mod: this
    //         };
    //       }
    
    //       // Very short reduction
    //       if (num.length === 1) {
    //         if (mode === 'div') {
    //           return {
    //             div: this.divn(num.words[0]),
    //             mod: null
    //           };
    //         }
    
    //         if (mode === 'mod') {
    //           return {
    //             div: null,
    //             mod: new BN(this.modrn(num.words[0]))
    //           };
    //         }
    
    //         return {
    //           div: this.divn(num.words[0]),
    //           mod: new BN(this.modrn(num.words[0]))
    //         };
    //       }
    
    //       return this._wordDiv(num, mode);
    //     };
    
    //     // Find `this` / `num`
    //     BN.prototype.div = function div (num) {
    //       return this.divmod(num, 'div', false).div;
    //     };
    
    //     // Find `this` % `num`
    //     BN.prototype.mod = function mod (num) {
    //       return this.divmod(num, 'mod', false).mod;
    //     };
    
    //     BN.prototype.umod = function umod (num) {
    //       return this.divmod(num, 'mod', true).mod;
    //     };
    
    //     // Find Round(`this` / `num`)
    //     BN.prototype.divRound = function divRound (num) {
    //       var dm = this.divmod(num);
    
    //       // Fast case - exact division
    //       if (dm.mod.isZero()) return dm.div;
    
    //       var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    
    //       var half = num.ushrn(1);
    //       var r2 = num.andln(1);
    //       var cmp = mod.cmp(half);
    
    //       // Round down
    //       if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;
    
    //       // Round up
    //       return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    //     };
    
    //     BN.prototype.modrn = function modrn (num) {
    //       var isNegNum = num < 0;
    //       if (isNegNum) num = -num;
    
    //       assert(num <= 0x3ffffff);
    //       var p = (1 << 26) % num;
    
    //       var acc = 0;
    //       for (var i = this.length - 1; i >= 0; i--) {
    //         acc = (p * acc + (this.words[i] | 0)) % num;
    //       }
    
    //       return isNegNum ? -acc : acc;
    //     };
    
    //     // WARNING: DEPRECATED
    //     BN.prototype.modn = function modn (num) {
    //       return this.modrn(num);
    //     };
    
    //     // In-place division by number
    //     BN.prototype.idivn = function idivn (num) {
    //       var isNegNum = num < 0;
    //       if (isNegNum) num = -num;
    
    //       assert(num <= 0x3ffffff);
    
    //       var carry = 0;
    //       for (var i = this.length - 1; i >= 0; i--) {
    //         var w = (this.words[i] | 0) + carry * 0x4000000;
    //         this.words[i] = (w / num) | 0;
    //         carry = w % num;
    //       }
    
    //       this._strip();
    //       return isNegNum ? this.ineg() : this;
    //     };
    
    //     BN.prototype.divn = function divn (num) {
    //       return this.clone().idivn(num);
    //     };
    
    //     BN.prototype.egcd = function egcd (p) {
    //       assert(p.negative === 0);
    //       assert(!p.isZero());
    
    //       var x = this;
    //       var y = p.clone();
    
    //       if (x.negative !== 0) {
    //         x = x.umod(p);
    //       } else {
    //         x = x.clone();
    //       }
    
    //       // A * x + B * y = x
    //       var A = new BN(1);
    //       var B = new BN(0);
    
    //       // C * x + D * y = y
    //       var C = new BN(0);
    //       var D = new BN(1);
    
    //       var g = 0;
    
    //       while (x.isEven() && y.isEven()) {
    //         x.iushrn(1);
    //         y.iushrn(1);
    //         ++g;
    //       }
    
    //       var yp = y.clone();
    //       var xp = x.clone();
    
    //       while (!x.isZero()) {
    //         for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
    //         if (i > 0) {
    //           x.iushrn(i);
    //           while (i-- > 0) {
    //             if (A.isOdd() || B.isOdd()) {
    //               A.iadd(yp);
    //               B.isub(xp);
    //             }
    
    //             A.iushrn(1);
    //             B.iushrn(1);
    //           }
    //         }
    
    //         for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
    //         if (j > 0) {
    //           y.iushrn(j);
    //           while (j-- > 0) {
    //             if (C.isOdd() || D.isOdd()) {
    //               C.iadd(yp);
    //               D.isub(xp);
    //             }
    
    //             C.iushrn(1);
    //             D.iushrn(1);
    //           }
    //         }
    
    //         if (x.cmp(y) >= 0) {
    //           x.isub(y);
    //           A.isub(C);
    //           B.isub(D);
    //         } else {
    //           y.isub(x);
    //           C.isub(A);
    //           D.isub(B);
    //         }
    //       }
    
    //       return {
    //         a: C,
    //         b: D,
    //         gcd: y.iushln(g)
    //       };
    //     };
    
    //     // This is reduced incarnation of the binary EEA
    //     // above, designated to invert members of the
    //     // _prime_ fields F(p) at a maximal speed
    //     BN.prototype._invmp = function _invmp (p) {
    //       assert(p.negative === 0);
    //       assert(!p.isZero());
    
    //       var a = this;
    //       var b = p.clone();
    
    //       if (a.negative !== 0) {
    //         a = a.umod(p);
    //       } else {
    //         a = a.clone();
    //       }
    
    //       var x1 = new BN(1);
    //       var x2 = new BN(0);
    
    //       var delta = b.clone();
    
    //       while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
    //         for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
    //         if (i > 0) {
    //           a.iushrn(i);
    //           while (i-- > 0) {
    //             if (x1.isOdd()) {
    //               x1.iadd(delta);
    //             }
    
    //             x1.iushrn(1);
    //           }
    //         }
    
    //         for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
    //         if (j > 0) {
    //           b.iushrn(j);
    //           while (j-- > 0) {
    //             if (x2.isOdd()) {
    //               x2.iadd(delta);
    //             }
    
    //             x2.iushrn(1);
    //           }
    //         }
    
    //         if (a.cmp(b) >= 0) {
    //           a.isub(b);
    //           x1.isub(x2);
    //         } else {
    //           b.isub(a);
    //           x2.isub(x1);
    //         }
    //       }
    
    //       var res;
    //       if (a.cmpn(1) === 0) {
    //         res = x1;
    //       } else {
    //         res = x2;
    //       }
    
    //       if (res.cmpn(0) < 0) {
    //         res.iadd(p);
    //       }
    
    //       return res;
    //     };
    
    //     BN.prototype.gcd = function gcd (num) {
    //       if (this.isZero()) return num.abs();
    //       if (num.isZero()) return this.abs();
    
    //       var a = this.clone();
    //       var b = num.clone();
    //       a.negative = 0;
    //       b.negative = 0;
    
    //       // Remove common factor of two
    //       for (var shift = 0; a.isEven() && b.isEven(); shift++) {
    //         a.iushrn(1);
    //         b.iushrn(1);
    //       }
    
    //       do {
    //         while (a.isEven()) {
    //           a.iushrn(1);
    //         }
    //         while (b.isEven()) {
    //           b.iushrn(1);
    //         }
    
    //         var r = a.cmp(b);
    //         if (r < 0) {
    //           // Swap `a` and `b` to make `a` always bigger than `b`
    //           var t = a;
    //           a = b;
    //           b = t;
    //         } else if (r === 0 || b.cmpn(1) === 0) {
    //           break;
    //         }
    
    //         a.isub(b);
    //       } while (true);
    
    //       return b.iushln(shift);
    //     };
    
    //     // Invert number in the field F(num)
    //     BN.prototype.invm = function invm (num) {
    //       return this.egcd(num).a.umod(num);
    //     };
    
    //     BN.prototype.isEven = function isEven () {
    //       return (this.words[0] & 1) === 0;
    //     };
    
    //     BN.prototype.isOdd = function isOdd () {
    //       return (this.words[0] & 1) === 1;
    //     };
    
    //     // And first word and num
    //     BN.prototype.andln = function andln (num) {
    //       return this.words[0] & num;
    //     };
    
    //     // Increment at the bit position in-line
    //     BN.prototype.bincn = function bincn (bit) {
    //       assert(typeof bit === 'number');
    //       var r = bit % 26;
    //       var s = (bit - r) / 26;
    //       var q = 1 << r;
    
    //       // Fast case: bit is much higher than all existing words
    //       if (this.length <= s) {
    //         this._expand(s + 1);
    //         this.words[s] |= q;
    //         return this;
    //       }
    
    //       // Add bit and propagate, if needed
    //       var carry = q;
    //       for (var i = s; carry !== 0 && i < this.length; i++) {
    //         var w = this.words[i] | 0;
    //         w += carry;
    //         carry = w >>> 26;
    //         w &= 0x3ffffff;
    //         this.words[i] = w;
    //       }
    //       if (carry !== 0) {
    //         this.words[i] = carry;
    //         this.length++;
    //       }
    //       return this;
    //     };
    
    //     BN.prototype.isZero = function isZero () {
    //       return this.length === 1 && this.words[0] === 0;
    //     };
    
    //     BN.prototype.cmpn = function cmpn (num) {
    //       var negative = num < 0;
    
    //       if (this.negative !== 0 && !negative) return -1;
    //       if (this.negative === 0 && negative) return 1;
    
    //       this._strip();
    
    //       var res;
    //       if (this.length > 1) {
    //         res = 1;
    //       } else {
    //         if (negative) {
    //           num = -num;
    //         }
    
    //         assert(num <= 0x3ffffff, 'Number is too big');
    
    //         var w = this.words[0] | 0;
    //         res = w === num ? 0 : w < num ? -1 : 1;
    //       }
    //       if (this.negative !== 0) return -res | 0;
    //       return res;
    //     };
    
    //     // Compare two numbers and return:
    //     // 1 - if `this` > `num`
    //     // 0 - if `this` == `num`
    //     // -1 - if `this` < `num`
    //     BN.prototype.cmp = function cmp (num) {
    //       if (this.negative !== 0 && num.negative === 0) return -1;
    //       if (this.negative === 0 && num.negative !== 0) return 1;
    
    //       var res = this.ucmp(num);
    //       if (this.negative !== 0) return -res | 0;
    //       return res;
    //     };
    
    //     // Unsigned comparison
    //     BN.prototype.ucmp = function ucmp (num) {
    //       // At this point both numbers have the same sign
    //       if (this.length > num.length) return 1;
    //       if (this.length < num.length) return -1;
    
    //       var res = 0;
    //       for (var i = this.length - 1; i >= 0; i--) {
    //         var a = this.words[i] | 0;
    //         var b = num.words[i] | 0;
    
    //         if (a === b) continue;
    //         if (a < b) {
    //           res = -1;
    //         } else if (a > b) {
    //           res = 1;
    //         }
    //         break;
    //       }
    //       return res;
    //     };
    
    //     BN.prototype.gtn = function gtn (num) {
    //       return this.cmpn(num) === 1;
    //     };
    
    //     BN.prototype.gt = function gt (num) {
    //       return this.cmp(num) === 1;
    //     };
    
    //     BN.prototype.gten = function gten (num) {
    //       return this.cmpn(num) >= 0;
    //     };
    
    //     BN.prototype.gte = function gte (num) {
    //       return this.cmp(num) >= 0;
    //     };
    
    //     BN.prototype.ltn = function ltn (num) {
    //       return this.cmpn(num) === -1;
    //     };
    
    //     BN.prototype.lt = function lt (num) {
    //       return this.cmp(num) === -1;
    //     };
    
    //     BN.prototype.lten = function lten (num) {
    //       return this.cmpn(num) <= 0;
    //     };
    
    //     BN.prototype.lte = function lte (num) {
    //       return this.cmp(num) <= 0;
    //     };
    
    //     BN.prototype.eqn = function eqn (num) {
    //       return this.cmpn(num) === 0;
    //     };
    
    //     BN.prototype.eq = function eq (num) {
    //       return this.cmp(num) === 0;
    //     };
    
    //     //
    //     // A reduce context, could be using montgomery or something better, depending
    //     // on the `m` itself.
    //     //
    //     BN.red = function red (num) {
    //       return new Red(num);
    //     };
    
    //     BN.prototype.toRed = function toRed (ctx) {
    //       assert(!this.red, 'Already a number in reduction context');
    //       assert(this.negative === 0, 'red works only with positives');
    //       return ctx.convertTo(this)._forceRed(ctx);
    //     };
    
    //     BN.prototype.fromRed = function fromRed () {
    //       assert(this.red, 'fromRed works only with numbers in reduction context');
    //       return this.red.convertFrom(this);
    //     };
    
    //     BN.prototype._forceRed = function _forceRed (ctx) {
    //       this.red = ctx;
    //       return this;
    //     };
    
    //     BN.prototype.forceRed = function forceRed (ctx) {
    //       assert(!this.red, 'Already a number in reduction context');
    //       return this._forceRed(ctx);
    //     };
    
    //     BN.prototype.redAdd = function redAdd (num) {
    //       assert(this.red, 'redAdd works only with red numbers');
    //       return this.red.add(this, num);
    //     };
    
    //     BN.prototype.redIAdd = function redIAdd (num) {
    //       assert(this.red, 'redIAdd works only with red numbers');
    //       return this.red.iadd(this, num);
    //     };
    
    //     BN.prototype.redSub = function redSub (num) {
    //       assert(this.red, 'redSub works only with red numbers');
    //       return this.red.sub(this, num);
    //     };
    
    //     BN.prototype.redISub = function redISub (num) {
    //       assert(this.red, 'redISub works only with red numbers');
    //       return this.red.isub(this, num);
    //     };
    
    //     BN.prototype.redShl = function redShl (num) {
    //       assert(this.red, 'redShl works only with red numbers');
    //       return this.red.shl(this, num);
    //     };
    
    //     BN.prototype.redMul = function redMul (num) {
    //       assert(this.red, 'redMul works only with red numbers');
    //       this.red._verify2(this, num);
    //       return this.red.mul(this, num);
    //     };
    
    //     BN.prototype.redIMul = function redIMul (num) {
    //       assert(this.red, 'redMul works only with red numbers');
    //       this.red._verify2(this, num);
    //       return this.red.imul(this, num);
    //     };
    
    //     BN.prototype.redSqr = function redSqr () {
    //       assert(this.red, 'redSqr works only with red numbers');
    //       this.red._verify1(this);
    //       return this.red.sqr(this);
    //     };
    
    //     BN.prototype.redISqr = function redISqr () {
    //       assert(this.red, 'redISqr works only with red numbers');
    //       this.red._verify1(this);
    //       return this.red.isqr(this);
    //     };
    
    //     // Square root over p
    //     BN.prototype.redSqrt = function redSqrt () {
    //       assert(this.red, 'redSqrt works only with red numbers');
    //       this.red._verify1(this);
    //       return this.red.sqrt(this);
    //     };
    
    //     BN.prototype.redInvm = function redInvm () {
    //       assert(this.red, 'redInvm works only with red numbers');
    //       this.red._verify1(this);
    //       return this.red.invm(this);
    //     };
    
    //     // Return negative clone of `this` % `red modulo`
    //     BN.prototype.redNeg = function redNeg () {
    //       assert(this.red, 'redNeg works only with red numbers');
    //       this.red._verify1(this);
    //       return this.red.neg(this);
    //     };
    
    //     BN.prototype.redPow = function redPow (num) {
    //       assert(this.red && !num.red, 'redPow(normalNum)');
    //       this.red._verify1(this);
    //       return this.red.pow(this, num);
    //     };
    
    //     // Prime numbers with efficient reduction
    //     var primes = {
    //       k256: null,
    //       p224: null,
    //       p192: null,
    //       p25519: null
    //     };
    
    //     // Pseudo-Mersenne prime
    //     function MPrime (name, p) {
    //       // P = 2 ^ N - K
    //       this.name = name;
    //       this.p = new BN(p, 16);
    //       this.n = this.p.bitLength();
    //       this.k = new BN(1).iushln(this.n).isub(this.p);
    
    //       this.tmp = this._tmp();
    //     }
    
    //     MPrime.prototype._tmp = function _tmp () {
    //       var tmp = new BN(null);
    //       tmp.words = new Array(Math.ceil(this.n / 13));
    //       return tmp;
    //     };
    
    //     MPrime.prototype.ireduce = function ireduce (num) {
    //       // Assumes that `num` is less than `P^2`
    //       // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    //       var r = num;
    //       var rlen;
    
    //       do {
    //         this.split(r, this.tmp);
    //         r = this.imulK(r);
    //         r = r.iadd(this.tmp);
    //         rlen = r.bitLength();
    //       } while (rlen > this.n);
    
    //       var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    //       if (cmp === 0) {
    //         r.words[0] = 0;
    //         r.length = 1;
    //       } else if (cmp > 0) {
    //         r.isub(this.p);
    //       } else {
    //         if (r.strip !== undefined) {
    //           // r is a BN v4 instance
    //           r.strip();
    //         } else {
    //           // r is a BN v5 instance
    //           r._strip();
    //         }
    //       }
    
    //       return r;
    //     };
    
    //     MPrime.prototype.split = function split (input, out) {
    //       input.iushrn(this.n, 0, out);
    //     };
    
    //     MPrime.prototype.imulK = function imulK (num) {
    //       return num.imul(this.k);
    //     };
    
    //     function K256 () {
    //       MPrime.call(
    //         this,
    //         'k256',
    //         'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    //     }
    //     inherits(K256, MPrime);
    
    //     K256.prototype.split = function split (input, output) {
    //       // 256 = 9 * 26 + 22
    //       var mask = 0x3fffff;
    
    //       var outLen = Math.min(input.length, 9);
    //       for (var i = 0; i < outLen; i++) {
    //         output.words[i] = input.words[i];
    //       }
    //       output.length = outLen;
    
    //       if (input.length <= 9) {
    //         input.words[0] = 0;
    //         input.length = 1;
    //         return;
    //       }
    
    //       // Shift by 9 limbs
    //       var prev = input.words[9];
    //       output.words[output.length++] = prev & mask;
    
    //       for (i = 10; i < input.length; i++) {
    //         var next = input.words[i] | 0;
    //         input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
    //         prev = next;
    //       }
    //       prev >>>= 22;
    //       input.words[i - 10] = prev;
    //       if (prev === 0 && input.length > 10) {
    //         input.length -= 10;
    //       } else {
    //         input.length -= 9;
    //       }
    //     };
    
    //     K256.prototype.imulK = function imulK (num) {
    //       // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    //       num.words[num.length] = 0;
    //       num.words[num.length + 1] = 0;
    //       num.length += 2;
    
    //       // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    //       var lo = 0;
    //       for (var i = 0; i < num.length; i++) {
    //         var w = num.words[i] | 0;
    //         lo += w * 0x3d1;
    //         num.words[i] = lo & 0x3ffffff;
    //         lo = w * 0x40 + ((lo / 0x4000000) | 0);
    //       }
    
    //       // Fast length reduction
    //       if (num.words[num.length - 1] === 0) {
    //         num.length--;
    //         if (num.words[num.length - 1] === 0) {
    //           num.length--;
    //         }
    //       }
    //       return num;
    //     };
    
    //     function P224 () {
    //       MPrime.call(
    //         this,
    //         'p224',
    //         'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    //     }
    //     inherits(P224, MPrime);
    
    //     function P192 () {
    //       MPrime.call(
    //         this,
    //         'p192',
    //         'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    //     }
    //     inherits(P192, MPrime);
    
    //     function P25519 () {
    //       // 2 ^ 255 - 19
    //       MPrime.call(
    //         this,
    //         '25519',
    //         '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    //     }
    //     inherits(P25519, MPrime);
    
    //     P25519.prototype.imulK = function imulK (num) {
    //       // K = 0x13
    //       var carry = 0;
    //       for (var i = 0; i < num.length; i++) {
    //         var hi = (num.words[i] | 0) * 0x13 + carry;
    //         var lo = hi & 0x3ffffff;
    //         hi >>>= 26;
    
    //         num.words[i] = lo;
    //         carry = hi;
    //       }
    //       if (carry !== 0) {
    //         num.words[num.length++] = carry;
    //       }
    //       return num;
    //     };
    
    //     // Exported mostly for testing purposes, use plain name instead
    //     BN._prime = function prime (name) {
    //       // Cached version of prime
    //       if (primes[name]) return primes[name];
    
    //       var prime;
    //       if (name === 'k256') {
    //         prime = new K256();
    //       } else if (name === 'p224') {
    //         prime = new P224();
    //       } else if (name === 'p192') {
    //         prime = new P192();
    //       } else if (name === 'p25519') {
    //         prime = new P25519();
    //       } else {
    //         throw new Error('Unknown prime ' + name);
    //       }
    //       primes[name] = prime;
    
    //       return prime;
    //     };
    
    //     //
    //     // Base reduction engine
    //     //
    //     function Red (m) {
    //       if (typeof m === 'string') {
    //         var prime = BN._prime(m);
    //         this.m = prime.p;
    //         this.prime = prime;
    //       } else {
    //         assert(m.gtn(1), 'modulus must be greater than 1');
    //         this.m = m;
    //         this.prime = null;
    //       }
    //     }
    
    //     Red.prototype._verify1 = function _verify1 (a) {
    //       assert(a.negative === 0, 'red works only with positives');
    //       assert(a.red, 'red works only with red numbers');
    //     };
    
    //     Red.prototype._verify2 = function _verify2 (a, b) {
    //       assert((a.negative | b.negative) === 0, 'red works only with positives');
    //       assert(a.red && a.red === b.red,
    //         'red works only with red numbers');
    //     };
    
    //     Red.prototype.imod = function imod (a) {
    //       if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    
    //       move(a, a.umod(this.m)._forceRed(this));
    //       return a;
    //     };
    
    //     Red.prototype.neg = function neg (a) {
    //       if (a.isZero()) {
    //         return a.clone();
    //       }
    
    //       return this.m.sub(a)._forceRed(this);
    //     };
    
    //     Red.prototype.add = function add (a, b) {
    //       this._verify2(a, b);
    
    //       var res = a.add(b);
    //       if (res.cmp(this.m) >= 0) {
    //         res.isub(this.m);
    //       }
    //       return res._forceRed(this);
    //     };
    
    //     Red.prototype.iadd = function iadd (a, b) {
    //       this._verify2(a, b);
    
    //       var res = a.iadd(b);
    //       if (res.cmp(this.m) >= 0) {
    //         res.isub(this.m);
    //       }
    //       return res;
    //     };
    
    //     Red.prototype.sub = function sub (a, b) {
    //       this._verify2(a, b);
    
    //       var res = a.sub(b);
    //       if (res.cmpn(0) < 0) {
    //         res.iadd(this.m);
    //       }
    //       return res._forceRed(this);
    //     };
    
    //     Red.prototype.isub = function isub (a, b) {
    //       this._verify2(a, b);
    
    //       var res = a.isub(b);
    //       if (res.cmpn(0) < 0) {
    //         res.iadd(this.m);
    //       }
    //       return res;
    //     };
    
    //     Red.prototype.shl = function shl (a, num) {
    //       this._verify1(a);
    //       return this.imod(a.ushln(num));
    //     };
    
    //     Red.prototype.imul = function imul (a, b) {
    //       this._verify2(a, b);
    //       return this.imod(a.imul(b));
    //     };
    
    //     Red.prototype.mul = function mul (a, b) {
    //       this._verify2(a, b);
    //       return this.imod(a.mul(b));
    //     };
    
    //     Red.prototype.isqr = function isqr (a) {
    //       return this.imul(a, a.clone());
    //     };
    
    //     Red.prototype.sqr = function sqr (a) {
    //       return this.mul(a, a);
    //     };
    
    //     Red.prototype.sqrt = function sqrt (a) {
    //       if (a.isZero()) return a.clone();
    
    //       var mod3 = this.m.andln(3);
    //       assert(mod3 % 2 === 1);
    
    //       // Fast case
    //       if (mod3 === 3) {
    //         var pow = this.m.add(new BN(1)).iushrn(2);
    //         return this.pow(a, pow);
    //       }
    
    //       // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //       //
    //       // Find Q and S, that Q * 2 ^ S = (P - 1)
    //       var q = this.m.subn(1);
    //       var s = 0;
    //       while (!q.isZero() && q.andln(1) === 0) {
    //         s++;
    //         q.iushrn(1);
    //       }
    //       assert(!q.isZero());
    
    //       var one = new BN(1).toRed(this);
    //       var nOne = one.redNeg();
    
    //       // Find quadratic non-residue
    //       // NOTE: Max is such because of generalized Riemann hypothesis.
    //       var lpow = this.m.subn(1).iushrn(1);
    //       var z = this.m.bitLength();
    //       z = new BN(2 * z * z).toRed(this);
    
    //       while (this.pow(z, lpow).cmp(nOne) !== 0) {
    //         z.redIAdd(nOne);
    //       }
    
    //       var c = this.pow(z, q);
    //       var r = this.pow(a, q.addn(1).iushrn(1));
    //       var t = this.pow(a, q);
    //       var m = s;
    //       while (t.cmp(one) !== 0) {
    //         var tmp = t;
    //         for (var i = 0; tmp.cmp(one) !== 0; i++) {
    //           tmp = tmp.redSqr();
    //         }
    //         assert(i < m);
    //         var b = this.pow(c, new BN(1).iushln(m - i - 1));
    
    //         r = r.redMul(b);
    //         c = b.redSqr();
    //         t = t.redMul(c);
    //         m = i;
    //       }
    
    //       return r;
    //     };
    
    //     Red.prototype.invm = function invm (a) {
    //       var inv = a._invmp(this.m);
    //       if (inv.negative !== 0) {
    //         inv.negative = 0;
    //         return this.imod(inv).redNeg();
    //       } else {
    //         return this.imod(inv);
    //       }
    //     };
    
    //     Red.prototype.pow = function pow (a, num) {
    //       if (num.isZero()) return new BN(1).toRed(this);
    //       if (num.cmpn(1) === 0) return a.clone();
    
    //       var windowSize = 4;
    //       var wnd = new Array(1 << windowSize);
    //       wnd[0] = new BN(1).toRed(this);
    //       wnd[1] = a;
    //       for (var i = 2; i < wnd.length; i++) {
    //         wnd[i] = this.mul(wnd[i - 1], a);
    //       }
    
    //       var res = wnd[0];
    //       var current = 0;
    //       var currentLen = 0;
    //       var start = num.bitLength() % 26;
    //       if (start === 0) {
    //         start = 26;
    //       }
    
    //       for (i = num.length - 1; i >= 0; i--) {
    //         var word = num.words[i];
    //         for (var j = start - 1; j >= 0; j--) {
    //           var bit = (word >> j) & 1;
    //           if (res !== wnd[0]) {
    //             res = this.sqr(res);
    //           }
    
    //           if (bit === 0 && current === 0) {
    //             currentLen = 0;
    //             continue;
    //           }
    
    //           current <<= 1;
    //           current |= bit;
    //           currentLen++;
    //           if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
    
    //           res = this.mul(res, wnd[current]);
    //           currentLen = 0;
    //           current = 0;
    //         }
    //         start = 26;
    //       }
    
    //       return res;
    //     };
    
    //     Red.prototype.convertTo = function convertTo (num) {
    //       var r = num.umod(this.m);
    
    //       return r === num ? r.clone() : r;
    //     };
    
    //     Red.prototype.convertFrom = function convertFrom (num) {
    //       var res = num.clone();
    //       res.red = null;
    //       return res;
    //     };
    
    //     //
    //     // Montgomery method engine
    //     //
    
    //     BN.mont = function mont (num) {
    //       return new Mont(num);
    //     };
    
    //     function Mont (m) {
    //       Red.call(this, m);
    
    //       this.shift = this.m.bitLength();
    //       if (this.shift % 26 !== 0) {
    //         this.shift += 26 - (this.shift % 26);
    //       }
    
    //       this.r = new BN(1).iushln(this.shift);
    //       this.r2 = this.imod(this.r.sqr());
    //       this.rinv = this.r._invmp(this.m);
    
    //       this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    //       this.minv = this.minv.umod(this.r);
    //       this.minv = this.r.sub(this.minv);
    //     }
    //     inherits(Mont, Red);
    
    //     Mont.prototype.convertTo = function convertTo (num) {
    //       return this.imod(num.ushln(this.shift));
    //     };
    
    //     Mont.prototype.convertFrom = function convertFrom (num) {
    //       var r = this.imod(num.mul(this.rinv));
    //       r.red = null;
    //       return r;
    //     };
    
    //     Mont.prototype.imul = function imul (a, b) {
    //       if (a.isZero() || b.isZero()) {
    //         a.words[0] = 0;
    //         a.length = 1;
    //         return a;
    //       }
    
    //       var t = a.imul(b);
    //       var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    //       var u = t.isub(c).iushrn(this.shift);
    //       var res = u;
    
    //       if (u.cmp(this.m) >= 0) {
    //         res = u.isub(this.m);
    //       } else if (u.cmpn(0) < 0) {
    //         res = u.iadd(this.m);
    //       }
    
    //       return res._forceRed(this);
    //     };
    
    //     Mont.prototype.mul = function mul (a, b) {
    //       if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
    
    //       var t = a.mul(b);
    //       var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    //       var u = t.isub(c).iushrn(this.shift);
    //       var res = u;
    //       if (u.cmp(this.m) >= 0) {
    //         res = u.isub(this.m);
    //       } else if (u.cmpn(0) < 0) {
    //         res = u.iadd(this.m);
    //       }
    
    //       return res._forceRed(this);
    //     };
    
    //     Mont.prototype.invm = function invm (a) {
    //       // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    //       var res = this.imod(a._invmp(this.m).mul(this.r2));
    //       return res._forceRed(this);
    //     };
    //   })(module, commonjsGlobal);
    //   }(bn));
    
    //   var BN$9 = bn.exports;
    
    //   var Layout$3 = {};
    
    //   /**
    //    * Base class for layout objects.
    //    *
    //    * **NOTE** This is an abstract base class; you can create instances
    //    * if it amuses you, but they won't support the {@link
    //    * Layout#encode|encode} or {@link Layout#decode|decode} functions.
    //    *
    //    * @param {Number} span - Initializer for {@link Layout#span|span}.  The
    //    * parameter must be an integer; a negative value signifies that the
    //    * span is {@link Layout#getSpan|value-specific}.
    //    *
    //    * @param {string} [property] - Initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @abstract
    //    */
    //   class Layout$2 {
    //     constructor(span, property) {
    //       if (!Number.isInteger(span)) {
    //         throw new TypeError('span must be an integer');
    //       }
    
    //       /** The span of the layout in bytes.
    //        *
    //        * Positive values are generally expected.
    //        *
    //        * Zero will only appear in {@link Constant}s and in {@link
    //        * Sequence}s where the {@link Sequence#count|count} is zero.
    //        *
    //        * A negative value indicates that the span is value-specific, and
    //        * must be obtained using {@link Layout#getSpan|getSpan}. */
    //       this.span = span;
    
    //       /** The property name used when this layout is represented in an
    //        * Object.
    //        *
    //        * Used only for layouts that {@link Layout#decode|decode} to Object
    //        * instances.  If left undefined the span of the unnamed layout will
    //        * be treated as padding: it will not be mutated by {@link
    //        * Layout#encode|encode} nor represented as a property in the
    //        * decoded Object. */
    //       this.property = property;
    //     }
    
    //     /** Function to create an Object into which decoded properties will
    //      * be written.
    //      *
    //      * Used only for layouts that {@link Layout#decode|decode} to Object
    //      * instances, which means:
    //      * * {@link Structure}
    //      * * {@link Union}
    //      * * {@link VariantLayout}
    //      * * {@link BitStructure}
    //      *
    //      * If left undefined the JavaScript representation of these layouts
    //      * will be Object instances.
    //      *
    //      * See {@link bindConstructorLayout}.
    //      */
    //     makeDestinationObject() {
    //       return {};
    //     }
    
    //     /**
    //      * Decode from a Buffer into an JavaScript value.
    //      *
    //      * @param {Buffer} b - the buffer from which encoded data is read.
    //      *
    //      * @param {Number} [offset] - the offset at which the encoded data
    //      * starts.  If absent a zero offset is inferred.
    //      *
    //      * @returns {(Number|Array|Object)} - the value of the decoded data.
    //      *
    //      * @abstract
    //      */
    //     decode(b, offset) {
    //       throw new Error('Layout is abstract');
    //     }
    
    //     /**
    //      * Encode a JavaScript value into a Buffer.
    //      *
    //      * @param {(Number|Array|Object)} src - the value to be encoded into
    //      * the buffer.  The type accepted depends on the (sub-)type of {@link
    //      * Layout}.
    //      *
    //      * @param {Buffer} b - the buffer into which encoded data will be
    //      * written.
    //      *
    //      * @param {Number} [offset] - the offset at which the encoded data
    //      * starts.  If absent a zero offset is inferred.
    //      *
    //      * @returns {Number} - the number of bytes encoded, including the
    //      * space skipped for internal padding, but excluding data such as
    //      * {@link Sequence#count|lengths} when stored {@link
    //      * ExternalLayout|externally}.  This is the adjustment to `offset`
    //      * producing the offset where data for the next layout would be
    //      * written.
    //      *
    //      * @abstract
    //      */
    //     encode(src, b, offset) {
    //       throw new Error('Layout is abstract');
    //     }
    
    //     /**
    //      * Calculate the span of a specific instance of a layout.
    //      *
    //      * @param {Buffer} b - the buffer that contains an encoded instance.
    //      *
    //      * @param {Number} [offset] - the offset at which the encoded instance
    //      * starts.  If absent a zero offset is inferred.
    //      *
    //      * @return {Number} - the number of bytes covered by the layout
    //      * instance.  If this method is not overridden in a subclass the
    //      * definition-time constant {@link Layout#span|span} will be
    //      * returned.
    //      *
    //      * @throws {RangeError} - if the length of the value cannot be
    //      * determined.
    //      */
    //     getSpan(b, offset) {
    //       if (0 > this.span) {
    //         throw new RangeError('indeterminate span');
    //       }
    //       return this.span;
    //     }
    
    //     /**
    //      * Replicate the layout using a new property.
    //      *
    //      * This function must be used to get a structurally-equivalent layout
    //      * with a different name since all {@link Layout} instances are
    //      * immutable.
    //      *
    //      * **NOTE** This is a shallow copy.  All fields except {@link
    //      * Layout#property|property} are strictly equal to the origin layout.
    //      *
    //      * @param {String} property - the value for {@link
    //      * Layout#property|property} in the replica.
    //      *
    //      * @returns {Layout} - the copy with {@link Layout#property|property}
    //      * set to `property`.
    //      */
    //     replicate(property) {
    //       const rv = Object.create(this.constructor.prototype);
    //       Object.assign(rv, this);
    //       rv.property = property;
    //       return rv;
    //     }
    
    //     /**
    //      * Create an object from layout properties and an array of values.
    //      *
    //      * **NOTE** This function returns `undefined` if invoked on a layout
    //      * that does not return its value as an Object.  Objects are
    //      * returned for things that are a {@link Structure}, which includes
    //      * {@link VariantLayout|variant layouts} if they are structures, and
    //      * excludes {@link Union}s.  If you want this feature for a union
    //      * you must use {@link Union.getVariant|getVariant} to select the
    //      * desired layout.
    //      *
    //      * @param {Array} values - an array of values that correspond to the
    //      * default order for properties.  As with {@link Layout#decode|decode}
    //      * layout elements that have no property name are skipped when
    //      * iterating over the array values.  Only the top-level properties are
    //      * assigned; arguments are not assigned to properties of contained
    //      * layouts.  Any unused values are ignored.
    //      *
    //      * @return {(Object|undefined)}
    //      */
    //     fromArray(values) {
    //       return undefined;
    //     }
    //   }
    //   Layout$3.Layout = Layout$2;
    
    //   /* Provide text that carries a name (such as for a function that will
    //    * be throwing an error) annotated with the property of a given layout
    //    * (such as one for which the value was unacceptable).
    //    *
    //    * @ignore */
    //   function nameWithProperty$1(name, lo) {
    //     if (lo.property) {
    //       return name + '[' + lo.property + ']';
    //     }
    //     return name;
    //   }
    //   Layout$3.nameWithProperty = nameWithProperty$1;
    
    //   /**
    //    * Augment a class so that instances can be encoded/decoded using a
    //    * given layout.
    //    *
    //    * Calling this function couples `Class` with `layout` in several ways:
    //    *
    //    * * `Class.layout_` becomes a static member property equal to `layout`;
    //    * * `layout.boundConstructor_` becomes a static member property equal
    //    *    to `Class`;
    //    * * The {@link Layout#makeDestinationObject|makeDestinationObject()}
    //    *   property of `layout` is set to a function that returns a `new
    //    *   Class()`;
    //    * * `Class.decode(b, offset)` becomes a static member function that
    //    *   delegates to {@link Layout#decode|layout.decode}.  The
    //    *   synthesized function may be captured and extended.
    //    * * `Class.prototype.encode(b, offset)` provides an instance member
    //    *   function that delegates to {@link Layout#encode|layout.encode}
    //    *   with `src` set to `this`.  The synthesized function may be
    //    *   captured and extended, but when the extension is invoked `this`
    //    *   must be explicitly bound to the instance.
    //    *
    //    * @param {class} Class - a JavaScript class with a nullary
    //    * constructor.
    //    *
    //    * @param {Layout} layout - the {@link Layout} instance used to encode
    //    * instances of `Class`.
    //    */
    //   function bindConstructorLayout$1(Class, layout) {
    //     if ('function' !== typeof Class) {
    //       throw new TypeError('Class must be constructor');
    //     }
    //     if (Class.hasOwnProperty('layout_')) {
    //       throw new Error('Class is already bound to a layout');
    //     }
    //     if (!(layout && (layout instanceof Layout$2))) {
    //       throw new TypeError('layout must be a Layout');
    //     }
    //     if (layout.hasOwnProperty('boundConstructor_')) {
    //       throw new Error('layout is already bound to a constructor');
    //     }
    //     Class.layout_ = layout;
    //     layout.boundConstructor_ = Class;
    //     layout.makeDestinationObject = (() => new Class());
    //     Object.defineProperty(Class.prototype, 'encode', {
    //       value: function(b, offset) {
    //         return layout.encode(this, b, offset);
    //       },
    //       writable: true,
    //     });
    //     Object.defineProperty(Class, 'decode', {
    //       value: function(b, offset) {
    //         return layout.decode(b, offset);
    //       },
    //       writable: true,
    //     });
    //   }
    //   Layout$3.bindConstructorLayout = bindConstructorLayout$1;
    
    //   /**
    //    * An object that behaves like a layout but does not consume space
    //    * within its containing layout.
    //    *
    //    * This is primarily used to obtain metadata about a member, such as a
    //    * {@link OffsetLayout} that can provide data about a {@link
    //    * Layout#getSpan|value-specific span}.
    //    *
    //    * **NOTE** This is an abstract base class; you can create instances
    //    * if it amuses you, but they won't support {@link
    //    * ExternalLayout#isCount|isCount} or other {@link Layout} functions.
    //    *
    //    * @param {Number} span - initializer for {@link Layout#span|span}.
    //    * The parameter can range from 1 through 6.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @abstract
    //    * @augments {Layout}
    //    */
    //   class ExternalLayout$1 extends Layout$2 {
    //     /**
    //      * Return `true` iff the external layout decodes to an unsigned
    //      * integer layout.
    //      *
    //      * In that case it can be used as the source of {@link
    //      * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
    //      * or as {@link UnionLayoutDiscriminator#layout|external union
    //      * discriminators}.
    //      *
    //      * @abstract
    //      */
    //     isCount() {
    //       throw new Error('ExternalLayout is abstract');
    //     }
    //   }
    
    //   /**
    //    * An {@link ExternalLayout} that determines its {@link
    //    * Layout#decode|value} based on offset into and length of the buffer
    //    * on which it is invoked.
    //    *
    //    * *Factory*: {@link module:Layout.greedy|greedy}
    //    *
    //    * @param {Number} [elementSpan] - initializer for {@link
    //    * GreedyCount#elementSpan|elementSpan}.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {ExternalLayout}
    //    */
    //   class GreedyCount$1 extends ExternalLayout$1 {
    //     constructor(elementSpan, property) {
    //       if (undefined === elementSpan) {
    //         elementSpan = 1;
    //       }
    //       if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {
    //         throw new TypeError('elementSpan must be a (positive) integer');
    //       }
    //       super(-1, property);
    
    //       /** The layout for individual elements of the sequence.  The value
    //        * must be a positive integer.  If not provided, the value will be
    //        * 1. */
    //       this.elementSpan = elementSpan;
    //     }
    
    //     /** @override */
    //     isCount() {
    //       return true;
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const rem = b.length - offset;
    //       return Math.floor(rem / this.elementSpan);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       return 0;
    //     }
    //   }
    
    //   /**
    //    * An {@link ExternalLayout} that supports accessing a {@link Layout}
    //    * at a fixed offset from the start of another Layout.  The offset may
    //    * be before, within, or after the base layout.
    //    *
    //    * *Factory*: {@link module:Layout.offset|offset}
    //    *
    //    * @param {Layout} layout - initializer for {@link
    //    * OffsetLayout#layout|layout}, modulo `property`.
    //    *
    //    * @param {Number} [offset] - Initializes {@link
    //    * OffsetLayout#offset|offset}.  Defaults to zero.
    //    *
    //    * @param {string} [property] - Optional new property name for a
    //    * {@link Layout#replicate| replica} of `layout` to be used as {@link
    //    * OffsetLayout#layout|layout}.  If not provided the `layout` is used
    //    * unchanged.
    //    *
    //    * @augments {Layout}
    //    */
    //   class OffsetLayout$1 extends ExternalLayout$1 {
    //     constructor(layout, offset, property) {
    //       if (!(layout instanceof Layout$2)) {
    //         throw new TypeError('layout must be a Layout');
    //       }
    
    //       if (undefined === offset) {
    //         offset = 0;
    //       } else if (!Number.isInteger(offset)) {
    //         throw new TypeError('offset must be integer or undefined');
    //       }
    
    //       super(layout.span, property || layout.property);
    
    //       /** The subordinated layout. */
    //       this.layout = layout;
    
    //       /** The location of {@link OffsetLayout#layout} relative to the
    //        * start of another layout.
    //        *
    //        * The value may be positive or negative, but an error will thrown
    //        * if at the point of use it goes outside the span of the Buffer
    //        * being accessed.  */
    //       this.offset = offset;
    //     }
    
    //     /** @override */
    //     isCount() {
    //       return ((this.layout instanceof UInt$1)
    //               || (this.layout instanceof UIntBE$1));
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       return this.layout.decode(b, offset + this.offset);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       return this.layout.encode(src, b, offset + this.offset);
    //     }
    //   }
    
    //   /**
    //    * Represent an unsigned integer in little-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.u8|u8}, {@link
    //    *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link
    //    *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link
    //    *  module:Layout.u48|u48}
    //    *
    //    * @param {Number} span - initializer for {@link Layout#span|span}.
    //    * The parameter can range from 1 through 6.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class UInt$1 extends Layout$2 {
    //     constructor(span, property) {
    //       super(span, property);
    //       if (6 < this.span) {
    //         throw new RangeError('span must not exceed 6 bytes');
    //       }
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       return b.readUIntLE(offset, this.span);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       b.writeUIntLE(src, offset, this.span);
    //       return this.span;
    //     }
    //   }
    
    //   /**
    //    * Represent an unsigned integer in big-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.u8be|u8be}, {@link
    //    * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},
    //    * {@link module:Layout.u32be|u32be}, {@link
    //    * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}
    //    *
    //    * @param {Number} span - initializer for {@link Layout#span|span}.
    //    * The parameter can range from 1 through 6.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class UIntBE$1 extends Layout$2 {
    //     constructor(span, property) {
    //       super( span, property);
    //       if (6 < this.span) {
    //         throw new RangeError('span must not exceed 6 bytes');
    //       }
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       return b.readUIntBE(offset, this.span);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       b.writeUIntBE(src, offset, this.span);
    //       return this.span;
    //     }
    //   }
    
    //   /**
    //    * Represent a signed integer in little-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.s8|s8}, {@link
    //    *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link
    //    *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link
    //    *  module:Layout.s48|s48}
    //    *
    //    * @param {Number} span - initializer for {@link Layout#span|span}.
    //    * The parameter can range from 1 through 6.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class Int$1 extends Layout$2 {
    //     constructor(span, property) {
    //       super(span, property);
    //       if (6 < this.span) {
    //         throw new RangeError('span must not exceed 6 bytes');
    //       }
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       return b.readIntLE(offset, this.span);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       b.writeIntLE(src, offset, this.span);
    //       return this.span;
    //     }
    //   }
    
    //   /**
    //    * Represent a signed integer in big-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.s8be|s8be}, {@link
    //    * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},
    //    * {@link module:Layout.s32be|s32be}, {@link
    //    * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}
    //    *
    //    * @param {Number} span - initializer for {@link Layout#span|span}.
    //    * The parameter can range from 1 through 6.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class IntBE$1 extends Layout$2 {
    //     constructor(span, property) {
    //       super(span, property);
    //       if (6 < this.span) {
    //         throw new RangeError('span must not exceed 6 bytes');
    //       }
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       return b.readIntBE(offset, this.span);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       b.writeIntBE(src, offset, this.span);
    //       return this.span;
    //     }
    //   }
    
    //   const V2E32$1 = Math.pow(2, 32);
    
    //   /* True modulus high and low 32-bit words, where low word is always
    //    * non-negative. */
    //   function divmodInt64$1(src) {
    //     const hi32 = Math.floor(src / V2E32$1);
    //     const lo32 = src - (hi32 * V2E32$1);
    //     return {hi32, lo32};
    //   }
    //   /* Reconstruct Number from quotient and non-negative remainder */
    //   function roundedInt64$1(hi32, lo32) {
    //     return hi32 * V2E32$1 + lo32;
    //   }
    
    //   /**
    //    * Represent an unsigned 64-bit integer in little-endian format when
    //    * encoded and as a near integral JavaScript Number when decoded.
    //    *
    //    * *Factory*: {@link module:Layout.nu64|nu64}
    //    *
    //    * **NOTE** Values with magnitude greater than 2^52 may not decode to
    //    * the exact value of the encoded representation.
    //    *
    //    * @augments {Layout}
    //    */
    //   class NearUInt64$1 extends Layout$2 {
    //     constructor(property) {
    //       super(8, property);
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const lo32 = b.readUInt32LE(offset);
    //       const hi32 = b.readUInt32LE(offset + 4);
    //       return roundedInt64$1(hi32, lo32);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const split = divmodInt64$1(src);
    //       b.writeUInt32LE(split.lo32, offset);
    //       b.writeUInt32LE(split.hi32, offset + 4);
    //       return 8;
    //     }
    //   }
    
    //   /**
    //    * Represent an unsigned 64-bit integer in big-endian format when
    //    * encoded and as a near integral JavaScript Number when decoded.
    //    *
    //    * *Factory*: {@link module:Layout.nu64be|nu64be}
    //    *
    //    * **NOTE** Values with magnitude greater than 2^52 may not decode to
    //    * the exact value of the encoded representation.
    //    *
    //    * @augments {Layout}
    //    */
    //   class NearUInt64BE$1 extends Layout$2 {
    //     constructor(property) {
    //       super(8, property);
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const hi32 = b.readUInt32BE(offset);
    //       const lo32 = b.readUInt32BE(offset + 4);
    //       return roundedInt64$1(hi32, lo32);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const split = divmodInt64$1(src);
    //       b.writeUInt32BE(split.hi32, offset);
    //       b.writeUInt32BE(split.lo32, offset + 4);
    //       return 8;
    //     }
    //   }
    
    //   /**
    //    * Represent a signed 64-bit integer in little-endian format when
    //    * encoded and as a near integral JavaScript Number when decoded.
    //    *
    //    * *Factory*: {@link module:Layout.ns64|ns64}
    //    *
    //    * **NOTE** Values with magnitude greater than 2^52 may not decode to
    //    * the exact value of the encoded representation.
    //    *
    //    * @augments {Layout}
    //    */
    //   class NearInt64$1 extends Layout$2 {
    //     constructor(property) {
    //       super(8, property);
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const lo32 = b.readUInt32LE(offset);
    //       const hi32 = b.readInt32LE(offset + 4);
    //       return roundedInt64$1(hi32, lo32);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const split = divmodInt64$1(src);
    //       b.writeUInt32LE(split.lo32, offset);
    //       b.writeInt32LE(split.hi32, offset + 4);
    //       return 8;
    //     }
    //   }
    
    //   /**
    //    * Represent a signed 64-bit integer in big-endian format when
    //    * encoded and as a near integral JavaScript Number when decoded.
    //    *
    //    * *Factory*: {@link module:Layout.ns64be|ns64be}
    //    *
    //    * **NOTE** Values with magnitude greater than 2^52 may not decode to
    //    * the exact value of the encoded representation.
    //    *
    //    * @augments {Layout}
    //    */
    //   class NearInt64BE$1 extends Layout$2 {
    //     constructor(property) {
    //       super(8, property);
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const hi32 = b.readInt32BE(offset);
    //       const lo32 = b.readUInt32BE(offset + 4);
    //       return roundedInt64$1(hi32, lo32);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const split = divmodInt64$1(src);
    //       b.writeInt32BE(split.hi32, offset);
    //       b.writeUInt32BE(split.lo32, offset + 4);
    //       return 8;
    //     }
    //   }
    
    //   /**
    //    * Represent a 32-bit floating point number in little-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.f32|f32}
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class Float$1 extends Layout$2 {
    //     constructor(property) {
    //       super(4, property);
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       return b.readFloatLE(offset);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       b.writeFloatLE(src, offset);
    //       return 4;
    //     }
    //   }
    
    //   /**
    //    * Represent a 32-bit floating point number in big-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.f32be|f32be}
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class FloatBE$1 extends Layout$2 {
    //     constructor(property) {
    //       super(4, property);
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       return b.readFloatBE(offset);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       b.writeFloatBE(src, offset);
    //       return 4;
    //     }
    //   }
    
    //   /**
    //    * Represent a 64-bit floating point number in little-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.f64|f64}
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class Double$1 extends Layout$2 {
    //     constructor(property) {
    //       super(8, property);
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       return b.readDoubleLE(offset);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       b.writeDoubleLE(src, offset);
    //       return 8;
    //     }
    //   }
    
    //   /**
    //    * Represent a 64-bit floating point number in big-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.f64be|f64be}
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class DoubleBE$1 extends Layout$2 {
    //     constructor(property) {
    //       super(8, property);
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       return b.readDoubleBE(offset);
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       b.writeDoubleBE(src, offset);
    //       return 8;
    //     }
    //   }
    
    //   /**
    //    * Represent a contiguous sequence of a specific layout as an Array.
    //    *
    //    * *Factory*: {@link module:Layout.seq|seq}
    //    *
    //    * @param {Layout} elementLayout - initializer for {@link
    //    * Sequence#elementLayout|elementLayout}.
    //    *
    //    * @param {(Number|ExternalLayout)} count - initializer for {@link
    //    * Sequence#count|count}.  The parameter must be either a positive
    //    * integer or an instance of {@link ExternalLayout}.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class Sequence$1 extends Layout$2 {
    //     constructor(elementLayout, count, property) {
    //       if (!(elementLayout instanceof Layout$2)) {
    //         throw new TypeError('elementLayout must be a Layout');
    //       }
    //       if (!(((count instanceof ExternalLayout$1) && count.isCount())
    //             || (Number.isInteger(count) && (0 <= count)))) {
    //         throw new TypeError('count must be non-negative integer '
    //                             + 'or an unsigned integer ExternalLayout');
    //       }
    //       let span = -1;
    //       if ((!(count instanceof ExternalLayout$1))
    //           && (0 < elementLayout.span)) {
    //         span = count * elementLayout.span;
    //       }
    
    //       super(span, property);
    
    //       /** The layout for individual elements of the sequence. */
    //       this.elementLayout = elementLayout;
    
    //       /** The number of elements in the sequence.
    //        *
    //        * This will be either a non-negative integer or an instance of
    //        * {@link ExternalLayout} for which {@link
    //        * ExternalLayout#isCount|isCount()} is `true`. */
    //       this.count = count;
    //     }
    
    //     /** @override */
    //     getSpan(b, offset) {
    //       if (0 <= this.span) {
    //         return this.span;
    //       }
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       let span = 0;
    //       let count = this.count;
    //       if (count instanceof ExternalLayout$1) {
    //         count = count.decode(b, offset);
    //       }
    //       if (0 < this.elementLayout.span) {
    //         span = count * this.elementLayout.span;
    //       } else {
    //         let idx = 0;
    //         while (idx < count) {
    //           span += this.elementLayout.getSpan(b, offset + span);
    //           ++idx;
    //         }
    //       }
    //       return span;
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const rv = [];
    //       let i = 0;
    //       let count = this.count;
    //       if (count instanceof ExternalLayout$1) {
    //         count = count.decode(b, offset);
    //       }
    //       while (i < count) {
    //         rv.push(this.elementLayout.decode(b, offset));
    //         offset += this.elementLayout.getSpan(b, offset);
    //         i += 1;
    //       }
    //       return rv;
    //     }
    
    //     /** Implement {@link Layout#encode|encode} for {@link Sequence}.
    //      *
    //      * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
    //      * the unused space in the buffer is left unchanged.  If `src` is
    //      * longer than {@link Sequence#count|count} the unneeded elements are
    //      * ignored.
    //      *
    //      * **NOTE** If {@link Layout#count|count} is an instance of {@link
    //      * ExternalLayout} then the length of `src` will be encoded as the
    //      * count after `src` is encoded. */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const elo = this.elementLayout;
    //       const span = src.reduce((span, v) => {
    //         return span + elo.encode(v, b, offset + span);
    //       }, 0);
    //       if (this.count instanceof ExternalLayout$1) {
    //         this.count.encode(src.length, b, offset);
    //       }
    //       return span;
    //     }
    //   }
    
    //   /**
    //    * Represent a contiguous sequence of arbitrary layout elements as an
    //    * Object.
    //    *
    //    * *Factory*: {@link module:Layout.struct|struct}
    //    *
    //    * **NOTE** The {@link Layout#span|span} of the structure is variable
    //    * if any layout in {@link Structure#fields|fields} has a variable
    //    * span.  When {@link Layout#encode|encoding} we must have a value for
    //    * all variable-length fields, or we wouldn't be able to figure out
    //    * how much space to use for storage.  We can only identify the value
    //    * for a field when it has a {@link Layout#property|property}.  As
    //    * such, although a structure may contain both unnamed fields and
    //    * variable-length fields, it cannot contain an unnamed
    //    * variable-length field.
    //    *
    //    * @param {Layout[]} fields - initializer for {@link
    //    * Structure#fields|fields}.  An error is raised if this contains a
    //    * variable-length field for which a {@link Layout#property|property}
    //    * is not defined.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @param {Boolean} [decodePrefixes] - initializer for {@link
    //    * Structure#decodePrefixes|property}.
    //    *
    //    * @throws {Error} - if `fields` contains an unnamed variable-length
    //    * layout.
    //    *
    //    * @augments {Layout}
    //    */
    //   class Structure$1 extends Layout$2 {
    //     constructor(fields, property, decodePrefixes) {
    //       if (!(Array.isArray(fields)
    //             && fields.reduce((acc, v) => acc && (v instanceof Layout$2), true))) {
    //         throw new TypeError('fields must be array of Layout instances');
    //       }
    //       if (('boolean' === typeof property)
    //           && (undefined === decodePrefixes)) {
    //         decodePrefixes = property;
    //         property = undefined;
    //       }
    
    //       /* Verify absence of unnamed variable-length fields. */
    //       for (const fd of fields) {
    //         if ((0 > fd.span)
    //             && (undefined === fd.property)) {
    //           throw new Error('fields cannot contain unnamed variable-length layout');
    //         }
    //       }
    
    //       let span = -1;
    //       try {
    //         span = fields.reduce((span, fd) => span + fd.getSpan(), 0);
    //       } catch (e) {
    //       }
    //       super(span, property);
    
    //       /** The sequence of {@link Layout} values that comprise the
    //        * structure.
    //        *
    //        * The individual elements need not be the same type, and may be
    //        * either scalar or aggregate layouts.  If a member layout leaves
    //        * its {@link Layout#property|property} undefined the
    //        * corresponding region of the buffer associated with the element
    //        * will not be mutated.
    //        *
    //        * @type {Layout[]} */
    //       this.fields = fields;
    
    //       /** Control behavior of {@link Layout#decode|decode()} given short
    //        * buffers.
    //        *
    //        * In some situations a structure many be extended with additional
    //        * fields over time, with older installations providing only a
    //        * prefix of the full structure.  If this property is `true`
    //        * decoding will accept those buffers and leave subsequent fields
    //        * undefined, as long as the buffer ends at a field boundary.
    //        * Defaults to `false`. */
    //       this.decodePrefixes = !!decodePrefixes;
    //     }
    
    //     /** @override */
    //     getSpan(b, offset) {
    //       if (0 <= this.span) {
    //         return this.span;
    //       }
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       let span = 0;
    //       try {
    //         span = this.fields.reduce((span, fd) => {
    //           const fsp = fd.getSpan(b, offset);
    //           offset += fsp;
    //           return span + fsp;
    //         }, 0);
    //       } catch (e) {
    //         throw new RangeError('indeterminate span');
    //       }
    //       return span;
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const dest = this.makeDestinationObject();
    //       for (const fd of this.fields) {
    //         if (undefined !== fd.property) {
    //           dest[fd.property] = fd.decode(b, offset);
    //         }
    //         offset += fd.getSpan(b, offset);
    //         if (this.decodePrefixes
    //             && (b.length === offset)) {
    //           break;
    //         }
    //       }
    //       return dest;
    //     }
    
    //     /** Implement {@link Layout#encode|encode} for {@link Structure}.
    //      *
    //      * If `src` is missing a property for a member with a defined {@link
    //      * Layout#property|property} the corresponding region of the buffer is
    //      * left unmodified. */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const firstOffset = offset;
    //       let lastOffset = 0;
    //       let lastWrote = 0;
    //       for (const fd of this.fields) {
    //         let span = fd.span;
    //         lastWrote = (0 < span) ? span : 0;
    //         if (undefined !== fd.property) {
    //           const fv = src[fd.property];
    //           if (undefined !== fv) {
    //             lastWrote = fd.encode(fv, b, offset);
    //             if (0 > span) {
    //               /* Read the as-encoded span, which is not necessarily the
    //                * same as what we wrote. */
    //               span = fd.getSpan(b, offset);
    //             }
    //           }
    //         }
    //         lastOffset = offset;
    //         offset += span;
    //       }
    //       /* Use (lastOffset + lastWrote) instead of offset because the last
    //        * item may have had a dynamic length and we don't want to include
    //        * the padding between it and the end of the space reserved for
    //        * it. */
    //       return (lastOffset + lastWrote) - firstOffset;
    //     }
    
    //     /** @override */
    //     fromArray(values) {
    //       const dest = this.makeDestinationObject();
    //       for (const fd of this.fields) {
    //         if ((undefined !== fd.property)
    //             && (0 < values.length)) {
    //           dest[fd.property] = values.shift();
    //         }
    //       }
    //       return dest;
    //     }
    
    //     /**
    //      * Get access to the layout of a given property.
    //      *
    //      * @param {String} property - the structure member of interest.
    //      *
    //      * @return {Layout} - the layout associated with `property`, or
    //      * undefined if there is no such property.
    //      */
    //     layoutFor(property) {
    //       if ('string' !== typeof property) {
    //         throw new TypeError('property must be string');
    //       }
    //       for (const fd of this.fields) {
    //         if (fd.property === property) {
    //           return fd;
    //         }
    //       }
    //     }
    
    //     /**
    //      * Get the offset of a structure member.
    //      *
    //      * @param {String} property - the structure member of interest.
    //      *
    //      * @return {Number} - the offset in bytes to the start of `property`
    //      * within the structure, or undefined if `property` is not a field
    //      * within the structure.  If the property is a member but follows a
    //      * variable-length structure member a negative number will be
    //      * returned.
    //      */
    //     offsetOf(property) {
    //       if ('string' !== typeof property) {
    //         throw new TypeError('property must be string');
    //       }
    //       let offset = 0;
    //       for (const fd of this.fields) {
    //         if (fd.property === property) {
    //           return offset;
    //         }
    //         if (0 > fd.span) {
    //           offset = -1;
    //         } else if (0 <= offset) {
    //           offset += fd.span;
    //         }
    //       }
    //     }
    //   }
    
    //   /**
    //    * An object that can provide a {@link
    //    * Union#discriminator|discriminator} API for {@link Union}.
    //    *
    //    * **NOTE** This is an abstract base class; you can create instances
    //    * if it amuses you, but they won't support the {@link
    //    * UnionDiscriminator#encode|encode} or {@link
    //    * UnionDiscriminator#decode|decode} functions.
    //    *
    //    * @param {string} [property] - Default for {@link
    //    * UnionDiscriminator#property|property}.
    //    *
    //    * @abstract
    //    */
    //   class UnionDiscriminator$1 {
    //     constructor(property) {
    //       /** The {@link Layout#property|property} to be used when the
    //        * discriminator is referenced in isolation (generally when {@link
    //        * Union#decode|Union decode} cannot delegate to a specific
    //        * variant). */
    //       this.property = property;
    //     }
    
    //     /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
    //      *
    //      * The implementation of this method need not reference the buffer if
    //      * variant information is available through other means. */
    //     decode() {
    //       throw new Error('UnionDiscriminator is abstract');
    //     }
    
    //     /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
    //      *
    //      * The implementation of this method need not store the value if
    //      * variant information is maintained through other means. */
    //     encode() {
    //       throw new Error('UnionDiscriminator is abstract');
    //     }
    //   }
    
    //   /**
    //    * An object that can provide a {@link
    //    * UnionDiscriminator|discriminator API} for {@link Union} using an
    //    * unsigned integral {@link Layout} instance located either inside or
    //    * outside the union.
    //    *
    //    * @param {ExternalLayout} layout - initializes {@link
    //    * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link
    //    * ExternalLayout#isCount|isCount()}.
    //    *
    //    * @param {string} [property] - Default for {@link
    //    * UnionDiscriminator#property|property}, superseding the property
    //    * from `layout`, but defaulting to `variant` if neither `property`
    //    * nor layout provide a property name.
    //    *
    //    * @augments {UnionDiscriminator}
    //    */
    //   class UnionLayoutDiscriminator$1 extends UnionDiscriminator$1 {
    //     constructor(layout, property) {
    //       if (!((layout instanceof ExternalLayout$1)
    //             && layout.isCount())) {
    //         throw new TypeError('layout must be an unsigned integer ExternalLayout');
    //       }
    
    //       super(property || layout.property || 'variant');
    
    //       /** The {@link ExternalLayout} used to access the discriminator
    //        * value. */
    //       this.layout = layout;
    //     }
    
    //     /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
    //     decode(b, offset) {
    //       return this.layout.decode(b, offset);
    //     }
    
    //     /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
    //     encode(src, b, offset) {
    //       return this.layout.encode(src, b, offset);
    //     }
    //   }
    
    //   /**
    //    * Represent any number of span-compatible layouts.
    //    *
    //    * *Factory*: {@link module:Layout.union|union}
    //    *
    //    * If the union has a {@link Union#defaultLayout|default layout} that
    //    * layout must have a non-negative {@link Layout#span|span}.  The span
    //    * of a fixed-span union includes its {@link
    //    * Union#discriminator|discriminator} if the variant is a {@link
    //    * Union#usesPrefixDiscriminator|prefix of the union}, plus the span
    //    * of its {@link Union#defaultLayout|default layout}.
    //    *
    //    * If the union does not have a default layout then the encoded span
    //    * of the union depends on the encoded span of its variant (which may
    //    * be fixed or variable).
    //    *
    //    * {@link VariantLayout#layout|Variant layout}s are added through
    //    * {@link Union#addVariant|addVariant}.  If the union has a default
    //    * layout, the span of the {@link VariantLayout#layout|layout
    //    * contained by the variant} must not exceed the span of the {@link
    //    * Union#defaultLayout|default layout} (minus the span of a {@link
    //    * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The
    //    * span of the variant will equal the span of the union itself.
    //    *
    //    * The variant for a buffer can only be identified from the {@link
    //    * Union#discriminator|discriminator} {@link
    //    * UnionDiscriminator#property|property} (in the case of the {@link
    //    * Union#defaultLayout|default layout}), or by using {@link
    //    * Union#getVariant|getVariant} and examining the resulting {@link
    //    * VariantLayout} instance.
    //    *
    //    * A variant compatible with a JavaScript object can be identified
    //    * using {@link Union#getSourceVariant|getSourceVariant}.
    //    *
    //    * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to
    //    * identify the layout used to interpret the union contents.  The
    //    * parameter must be an instance of {@link UnionDiscriminator}, an
    //    * {@link ExternalLayout} that satisfies {@link
    //    * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link
    //    * UIntBE}).  When a non-external layout element is passed the layout
    //    * appears at the start of the union.  In all cases the (synthesized)
    //    * {@link UnionDiscriminator} instance is recorded as {@link
    //    * Union#discriminator|discriminator}.
    //    *
    //    * @param {(Layout|null)} defaultLayout - initializer for {@link
    //    * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.
    //    * If `null` there is no default layout: the union has data-dependent
    //    * length and attempts to decode or encode unrecognized variants will
    //    * throw an exception.  A {@link Layout} instance must have a
    //    * non-negative {@link Layout#span|span}, and if it lacks a {@link
    //    * Layout#property|property} the {@link
    //    * Union#defaultLayout|defaultLayout} will be a {@link
    //    * Layout#replicate|replica} with property `content`.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class Union$1 extends Layout$2 {
    //     constructor(discr, defaultLayout, property) {
    //       const upv = ((discr instanceof UInt$1)
    //                  || (discr instanceof UIntBE$1));
    //       if (upv) {
    //         discr = new UnionLayoutDiscriminator$1(new OffsetLayout$1(discr));
    //       } else if ((discr instanceof ExternalLayout$1)
    //                  && discr.isCount()) {
    //         discr = new UnionLayoutDiscriminator$1(discr);
    //       } else if (!(discr instanceof UnionDiscriminator$1)) {
    //         throw new TypeError('discr must be a UnionDiscriminator '
    //                             + 'or an unsigned integer layout');
    //       }
    //       if (undefined === defaultLayout) {
    //         defaultLayout = null;
    //       }
    //       if (!((null === defaultLayout)
    //             || (defaultLayout instanceof Layout$2))) {
    //         throw new TypeError('defaultLayout must be null or a Layout');
    //       }
    //       if (null !== defaultLayout) {
    //         if (0 > defaultLayout.span) {
    //           throw new Error('defaultLayout must have constant span');
    //         }
    //         if (undefined === defaultLayout.property) {
    //           defaultLayout = defaultLayout.replicate('content');
    //         }
    //       }
    
    //       /* The union span can be estimated only if there's a default
    //        * layout.  The union spans its default layout, plus any prefix
    //        * variant layout.  By construction both layouts, if present, have
    //        * non-negative span. */
    //       let span = -1;
    //       if (defaultLayout) {
    //         span = defaultLayout.span;
    //         if ((0 <= span) && upv) {
    //           span += discr.layout.span;
    //         }
    //       }
    //       super(span, property);
    
    //       /** The interface for the discriminator value in isolation.
    //        *
    //        * This a {@link UnionDiscriminator} either passed to the
    //        * constructor or synthesized from the `discr` constructor
    //        * argument.  {@link
    //        * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be
    //        * `true` iff the `discr` parameter was a non-offset {@link
    //        * Layout} instance. */
    //       this.discriminator = discr;
    
    //       /** `true` if the {@link Union#discriminator|discriminator} is the
    //        * first field in the union.
    //        *
    //        * If `false` the discriminator is obtained from somewhere
    //        * else. */
    //       this.usesPrefixDiscriminator = upv;
    
    //       /** The layout for non-discriminator content when the value of the
    //        * discriminator is not recognized.
    //        *
    //        * This is the value passed to the constructor.  It is
    //        * structurally equivalent to the second component of {@link
    //        * Union#layout|layout} but may have a different property
    //        * name. */
    //       this.defaultLayout = defaultLayout;
    
    //       /** A registry of allowed variants.
    //        *
    //        * The keys are unsigned integers which should be compatible with
    //        * {@link Union.discriminator|discriminator}.  The property value
    //        * is the corresponding {@link VariantLayout} instances assigned
    //        * to this union by {@link Union#addVariant|addVariant}.
    //        *
    //        * **NOTE** The registry remains mutable so that variants can be
    //        * {@link Union#addVariant|added} at any time.  Users should not
    //        * manipulate the content of this property. */
    //       this.registry = {};
    
    //       /* Private variable used when invoking getSourceVariant */
    //       let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
    
    //       /** Function to infer the variant selected by a source object.
    //        *
    //        * Defaults to {@link
    //        * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may
    //        * be overridden using {@link
    //        * Union#configGetSourceVariant|configGetSourceVariant}.
    //        *
    //        * @param {Object} src - as with {@link
    //        * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
    //        *
    //        * @returns {(undefined|VariantLayout)} The default variant
    //        * (`undefined`) or first registered variant that uses a property
    //        * available in `src`. */
    //       this.getSourceVariant = function(src) {
    //         return boundGetSourceVariant(src);
    //       };
    
    //       /** Function to override the implementation of {@link
    //        * Union#getSourceVariant|getSourceVariant}.
    //        *
    //        * Use this if the desired variant cannot be identified using the
    //        * algorithm of {@link
    //        * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
    //        *
    //        * **NOTE** The provided function will be invoked bound to this
    //        * Union instance, providing local access to {@link
    //        * Union#registry|registry}.
    //        *
    //        * @param {Function} gsv - a function that follows the API of
    //        * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */
    //       this.configGetSourceVariant = function(gsv) {
    //         boundGetSourceVariant = gsv.bind(this);
    //       };
    //     }
    
    //     /** @override */
    //     getSpan(b, offset) {
    //       if (0 <= this.span) {
    //         return this.span;
    //       }
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       /* Default layouts always have non-negative span, so we don't have
    //        * one and we have to recognize the variant which will in turn
    //        * determine the span. */
    //       const vlo = this.getVariant(b, offset);
    //       if (!vlo) {
    //         throw new Error('unable to determine span for unrecognized variant');
    //       }
    //       return vlo.getSpan(b, offset);
    //     }
    
    //     /**
    //      * Method to infer a registered Union variant compatible with `src`.
    //      *
    //      * The first satisified rule in the following sequence defines the
    //      * return value:
    //      * * If `src` has properties matching the Union discriminator and
    //      *   the default layout, `undefined` is returned regardless of the
    //      *   value of the discriminator property (this ensures the default
    //      *   layout will be used);
    //      * * If `src` has a property matching the Union discriminator, the
    //      *   value of the discriminator identifies a registered variant, and
    //      *   either (a) the variant has no layout, or (b) `src` has the
    //      *   variant's property, then the variant is returned (because the
    //      *   source satisfies the constraints of the variant it identifies);
    //      * * If `src` does not have a property matching the Union
    //      *   discriminator, but does have a property matching a registered
    //      *   variant, then the variant is returned (because the source
    //      *   matches a variant without an explicit conflict);
    //      * * An error is thrown (because we either can't identify a variant,
    //      *   or we were explicitly told the variant but can't satisfy it).
    //      *
    //      * @param {Object} src - an object presumed to be compatible with
    //      * the content of the Union.
    //      *
    //      * @return {(undefined|VariantLayout)} - as described above.
    //      *
    //      * @throws {Error} - if `src` cannot be associated with a default or
    //      * registered variant.
    //      */
    //     defaultGetSourceVariant(src) {
    //       if (src.hasOwnProperty(this.discriminator.property)) {
    //         if (this.defaultLayout
    //             && src.hasOwnProperty(this.defaultLayout.property)) {
    //           return undefined;
    //         }
    //         const vlo = this.registry[src[this.discriminator.property]];
    //         if (vlo
    //             && ((!vlo.layout)
    //                 || src.hasOwnProperty(vlo.property))) {
    //           return vlo;
    //         }
    //       } else {
    //         for (const tag in this.registry) {
    //           const vlo = this.registry[tag];
    //           if (src.hasOwnProperty(vlo.property)) {
    //             return vlo;
    //           }
    //         }
    //       }
    //       throw new Error('unable to infer src variant');
    //     }
    
    //     /** Implement {@link Layout#decode|decode} for {@link Union}.
    //      *
    //      * If the variant is {@link Union#addVariant|registered} the return
    //      * value is an instance of that variant, with no explicit
    //      * discriminator.  Otherwise the {@link Union#defaultLayout|default
    //      * layout} is used to decode the content. */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       let dest;
    //       const dlo = this.discriminator;
    //       const discr = dlo.decode(b, offset);
    //       let clo = this.registry[discr];
    //       if (undefined === clo) {
    //         let contentOffset = 0;
    //         clo = this.defaultLayout;
    //         if (this.usesPrefixDiscriminator) {
    //           contentOffset = dlo.layout.span;
    //         }
    //         dest = this.makeDestinationObject();
    //         dest[dlo.property] = discr;
    //         dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);
    //       } else {
    //         dest = clo.decode(b, offset);
    //       }
    //       return dest;
    //     }
    
    //     /** Implement {@link Layout#encode|encode} for {@link Union}.
    //      *
    //      * This API assumes the `src` object is consistent with the union's
    //      * {@link Union#defaultLayout|default layout}.  To encode variants
    //      * use the appropriate variant-specific {@link VariantLayout#encode}
    //      * method. */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const vlo = this.getSourceVariant(src);
    //       if (undefined === vlo) {
    //         const dlo = this.discriminator;
    //         const clo = this.defaultLayout;
    //         let contentOffset = 0;
    //         if (this.usesPrefixDiscriminator) {
    //           contentOffset = dlo.layout.span;
    //         }
    //         dlo.encode(src[dlo.property], b, offset);
    //         return contentOffset + clo.encode(src[clo.property], b,
    //                                           offset + contentOffset);
    //       }
    //       return vlo.encode(src, b, offset);
    //     }
    
    //     /** Register a new variant structure within a union.  The newly
    //      * created variant is returned.
    //      *
    //      * @param {Number} variant - initializer for {@link
    //      * VariantLayout#variant|variant}.
    //      *
    //      * @param {Layout} layout - initializer for {@link
    //      * VariantLayout#layout|layout}.
    //      *
    //      * @param {String} property - initializer for {@link
    //      * Layout#property|property}.
    //      *
    //      * @return {VariantLayout} */
    //     addVariant(variant, layout, property) {
    //       const rv = new VariantLayout$1(this, variant, layout, property);
    //       this.registry[variant] = rv;
    //       return rv;
    //     }
    
    //     /**
    //      * Get the layout associated with a registered variant.
    //      *
    //      * If `vb` does not produce a registered variant the function returns
    //      * `undefined`.
    //      *
    //      * @param {(Number|Buffer)} vb - either the variant number, or a
    //      * buffer from which the discriminator is to be read.
    //      *
    //      * @param {Number} offset - offset into `vb` for the start of the
    //      * union.  Used only when `vb` is an instance of {Buffer}.
    //      *
    //      * @return {({VariantLayout}|undefined)}
    //      */
    //     getVariant(vb, offset) {
    //       let variant = vb;
    //       if (buffer.Buffer.isBuffer(vb)) {
    //         if (undefined === offset) {
    //           offset = 0;
    //         }
    //         variant = this.discriminator.decode(vb, offset);
    //       }
    //       return this.registry[variant];
    //     }
    //   }
    
    //   /**
    //    * Represent a specific variant within a containing union.
    //    *
    //    * **NOTE** The {@link Layout#span|span} of the variant may include
    //    * the span of the {@link Union#discriminator|discriminator} used to
    //    * identify it, but values read and written using the variant strictly
    //    * conform to the content of {@link VariantLayout#layout|layout}.
    //    *
    //    * **NOTE** User code should not invoke this constructor directly.  Use
    //    * the union {@link Union#addVariant|addVariant} helper method.
    //    *
    //    * @param {Union} union - initializer for {@link
    //    * VariantLayout#union|union}.
    //    *
    //    * @param {Number} variant - initializer for {@link
    //    * VariantLayout#variant|variant}.
    //    *
    //    * @param {Layout} [layout] - initializer for {@link
    //    * VariantLayout#layout|layout}.  If absent the variant carries no
    //    * data.
    //    *
    //    * @param {String} [property] - initializer for {@link
    //    * Layout#property|property}.  Unlike many other layouts, variant
    //    * layouts normally include a property name so they can be identified
    //    * within their containing {@link Union}.  The property identifier may
    //    * be absent only if `layout` is is absent.
    //    *
    //    * @augments {Layout}
    //    */
    //   class VariantLayout$1 extends Layout$2 {
    //     constructor(union, variant, layout, property) {
    //       if (!(union instanceof Union$1)) {
    //         throw new TypeError('union must be a Union');
    //       }
    //       if ((!Number.isInteger(variant)) || (0 > variant)) {
    //         throw new TypeError('variant must be a (non-negative) integer');
    //       }
    //       if (('string' === typeof layout)
    //           && (undefined === property)) {
    //         property = layout;
    //         layout = null;
    //       }
    //       if (layout) {
    //         if (!(layout instanceof Layout$2)) {
    //           throw new TypeError('layout must be a Layout');
    //         }
    //         if ((null !== union.defaultLayout)
    //             && (0 <= layout.span)
    //             && (layout.span > union.defaultLayout.span)) {
    //           throw new Error('variant span exceeds span of containing union');
    //         }
    //         if ('string' !== typeof property) {
    //           throw new TypeError('variant must have a String property');
    //         }
    //       }
    //       let span = union.span;
    //       if (0 > union.span) {
    //         span = layout ? layout.span : 0;
    //         if ((0 <= span) && union.usesPrefixDiscriminator) {
    //           span += union.discriminator.layout.span;
    //         }
    //       }
    //       super(span, property);
    
    //       /** The {@link Union} to which this variant belongs. */
    //       this.union = union;
    
    //       /** The unsigned integral value identifying this variant within
    //        * the {@link Union#discriminator|discriminator} of the containing
    //        * union. */
    //       this.variant = variant;
    
    //       /** The {@link Layout} to be used when reading/writing the
    //        * non-discriminator part of the {@link
    //        * VariantLayout#union|union}.  If `null` the variant carries no
    //        * data. */
    //       this.layout = layout || null;
    //     }
    
    //     /** @override */
    //     getSpan(b, offset) {
    //       if (0 <= this.span) {
    //         /* Will be equal to the containing union span if that is not
    //          * variable. */
    //         return this.span;
    //       }
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       let contentOffset = 0;
    //       if (this.union.usesPrefixDiscriminator) {
    //         contentOffset = this.union.discriminator.layout.span;
    //       }
    //       /* Span is defined solely by the variant (and prefix discriminator) */
    //       return contentOffset + this.layout.getSpan(b, offset + contentOffset);
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       const dest = this.makeDestinationObject();
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       if (this !== this.union.getVariant(b, offset)) {
    //         throw new Error('variant mismatch');
    //       }
    //       let contentOffset = 0;
    //       if (this.union.usesPrefixDiscriminator) {
    //         contentOffset = this.union.discriminator.layout.span;
    //       }
    //       if (this.layout) {
    //         dest[this.property] = this.layout.decode(b, offset + contentOffset);
    //       } else if (this.property) {
    //         dest[this.property] = true;
    //       } else if (this.union.usesPrefixDiscriminator) {
    //         dest[this.union.discriminator.property] = this.variant;
    //       }
    //       return dest;
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       let contentOffset = 0;
    //       if (this.union.usesPrefixDiscriminator) {
    //         contentOffset = this.union.discriminator.layout.span;
    //       }
    //       if (this.layout
    //           && (!src.hasOwnProperty(this.property))) {
    //         throw new TypeError('variant lacks property ' + this.property);
    //       }
    //       this.union.discriminator.encode(this.variant, b, offset);
    //       let span = contentOffset;
    //       if (this.layout) {
    //         this.layout.encode(src[this.property], b, offset + contentOffset);
    //         span += this.layout.getSpan(b, offset + contentOffset);
    //         if ((0 <= this.union.span)
    //             && (span > this.union.span)) {
    //           throw new Error('encoded variant overruns containing union');
    //         }
    //       }
    //       return span;
    //     }
    
    //     /** Delegate {@link Layout#fromArray|fromArray} to {@link
    //      * VariantLayout#layout|layout}. */
    //     fromArray(values) {
    //       if (this.layout) {
    //         return this.layout.fromArray(values);
    //       }
    //     }
    //   }
    
    //   /** JavaScript chose to define bitwise operations as operating on
    //    * signed 32-bit values in 2's complement form, meaning any integer
    //    * with bit 31 set is going to look negative.  For right shifts that's
    //    * not a problem, because `>>>` is a logical shift, but for every
    //    * other bitwise operator we have to compensate for possible negative
    //    * results. */
    //   function fixBitwiseResult$1(v) {
    //     if (0 > v) {
    //       v += 0x100000000;
    //     }
    //     return v;
    //   }
    
    //   /**
    //    * Contain a sequence of bit fields as an unsigned integer.
    //    *
    //    * *Factory*: {@link module:Layout.bits|bits}
    //    *
    //    * This is a container element; within it there are {@link BitField}
    //    * instances that provide the extracted properties.  The container
    //    * simply defines the aggregate representation and its bit ordering.
    //    * The representation is an object containing properties with numeric
    //    * or {@link Boolean} values.
    //    *
    //    * {@link BitField}s are added with the {@link
    //    * BitStructure#addField|addField} and {@link
    //    * BitStructure#addBoolean|addBoolean} methods.
    
    //    * @param {Layout} word - initializer for {@link
    //    * BitStructure#word|word}.  The parameter must be an instance of
    //    * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.
    //    *
    //    * @param {bool} [msb] - `true` if the bit numbering starts at the
    //    * most significant bit of the containing word; `false` (default) if
    //    * it starts at the least significant bit of the containing word.  If
    //    * the parameter at this position is a string and `property` is
    //    * `undefined` the value of this argument will instead be used as the
    //    * value of `property`.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class BitStructure$1 extends Layout$2 {
    //     constructor(word, msb, property) {
    //       if (!((word instanceof UInt$1)
    //             || (word instanceof UIntBE$1))) {
    //         throw new TypeError('word must be a UInt or UIntBE layout');
    //       }
    //       if (('string' === typeof msb)
    //           && (undefined === property)) {
    //         property = msb;
    //         msb = undefined;
    //       }
    //       if (4 < word.span) {
    //         throw new RangeError('word cannot exceed 32 bits');
    //       }
    //       super(word.span, property);
    
    //       /** The layout used for the packed value.  {@link BitField}
    //        * instances are packed sequentially depending on {@link
    //        * BitStructure#msb|msb}. */
    //       this.word = word;
    
    //       /** Whether the bit sequences are packed starting at the most
    //        * significant bit growing down (`true`), or the least significant
    //        * bit growing up (`false`).
    //        *
    //        * **NOTE** Regardless of this value, the least significant bit of
    //        * any {@link BitField} value is the least significant bit of the
    //        * corresponding section of the packed value. */
    //       this.msb = !!msb;
    
    //       /** The sequence of {@link BitField} layouts that comprise the
    //        * packed structure.
    //        *
    //        * **NOTE** The array remains mutable to allow fields to be {@link
    //        * BitStructure#addField|added} after construction.  Users should
    //        * not manipulate the content of this property.*/
    //       this.fields = [];
    
    //       /* Storage for the value.  Capture a variable instead of using an
    //        * instance property because we don't want anything to change the
    //        * value without going through the mutator. */
    //       let value = 0;
    //       this._packedSetValue = function(v) {
    //         value = fixBitwiseResult$1(v);
    //         return this;
    //       };
    //       this._packedGetValue = function() {
    //         return value;
    //       };
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       const dest = this.makeDestinationObject();
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const value = this.word.decode(b, offset);
    //       this._packedSetValue(value);
    //       for (const fd of this.fields) {
    //         if (undefined !== fd.property) {
    //           dest[fd.property] = fd.decode(value);
    //         }
    //       }
    //       return dest;
    //     }
    
    //     /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
    //      *
    //      * If `src` is missing a property for a member with a defined {@link
    //      * Layout#property|property} the corresponding region of the packed
    //      * value is left unmodified.  Unused bits are also left unmodified. */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       const value = this.word.decode(b, offset);
    //       this._packedSetValue(value);
    //       for (const fd of this.fields) {
    //         if (undefined !== fd.property) {
    //           const fv = src[fd.property];
    //           if (undefined !== fv) {
    //             fd.encode(fv);
    //           }
    //         }
    //       }
    //       return this.word.encode(this._packedGetValue(), b, offset);
    //     }
    
    //     /** Register a new bitfield with a containing bit structure.  The
    //      * resulting bitfield is returned.
    //      *
    //      * @param {Number} bits - initializer for {@link BitField#bits|bits}.
    //      *
    //      * @param {string} property - initializer for {@link
    //      * Layout#property|property}.
    //      *
    //      * @return {BitField} */
    //     addField(bits, property) {
    //       const bf = new BitField$1(this, bits, property);
    //       this.fields.push(bf);
    //       return bf;
    //     }
    
    //     /** As with {@link BitStructure#addField|addField} for single-bit
    //      * fields with `boolean` value representation.
    //      *
    //      * @param {string} property - initializer for {@link
    //      * Layout#property|property}.
    //      *
    //      * @return {Boolean} */
    //     addBoolean(property) {
    //       // This is my Boolean, not the Javascript one.
    //       // eslint-disable-next-line no-new-wrappers
    //       const bf = new Boolean$2(this, property);
    //       this.fields.push(bf);
    //       return bf;
    //     }
    
    //     /**
    //      * Get access to the bit field for a given property.
    //      *
    //      * @param {String} property - the bit field of interest.
    //      *
    //      * @return {BitField} - the field associated with `property`, or
    //      * undefined if there is no such property.
    //      */
    //     fieldFor(property) {
    //       if ('string' !== typeof property) {
    //         throw new TypeError('property must be string');
    //       }
    //       for (const fd of this.fields) {
    //         if (fd.property === property) {
    //           return fd;
    //         }
    //       }
    //     }
    //   }
    
    //   /**
    //    * Represent a sequence of bits within a {@link BitStructure}.
    //    *
    //    * All bit field values are represented as unsigned integers.
    //    *
    //    * **NOTE** User code should not invoke this constructor directly.
    //    * Use the container {@link BitStructure#addField|addField} helper
    //    * method.
    //    *
    //    * **NOTE** BitField instances are not instances of {@link Layout}
    //    * since {@link Layout#span|span} measures 8-bit units.
    //    *
    //    * @param {BitStructure} container - initializer for {@link
    //    * BitField#container|container}.
    //    *
    //    * @param {Number} bits - initializer for {@link BitField#bits|bits}.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    */
    //   class BitField$1 {
    //     constructor(container, bits, property) {
    //       if (!(container instanceof BitStructure$1)) {
    //         throw new TypeError('container must be a BitStructure');
    //       }
    //       if ((!Number.isInteger(bits)) || (0 >= bits)) {
    //         throw new TypeError('bits must be positive integer');
    //       }
    //       const totalBits = 8 * container.span;
    //       const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
    //       if ((bits + usedBits) > totalBits) {
    //         throw new Error('bits too long for span remainder ('
    //                         + (totalBits - usedBits) + ' of '
    //                         + totalBits + ' remain)');
    //       }
    
    //       /** The {@link BitStructure} instance to which this bit field
    //        * belongs. */
    //       this.container = container;
    
    //       /** The span of this value in bits. */
    //       this.bits = bits;
    
    //       /** A mask of {@link BitField#bits|bits} bits isolating value bits
    //        * that fit within the field.
    //        *
    //        * That is, it masks a value that has not yet been shifted into
    //        * position within its containing packed integer. */
    //       this.valueMask = (1 << bits) - 1;
    //       if (32 === bits) { // shifted value out of range
    //         this.valueMask = 0xFFFFFFFF;
    //       }
    
    //       /** The offset of the value within the containing packed unsigned
    //        * integer.  The least significant bit of the packed value is at
    //        * offset zero, regardless of bit ordering used. */
    //       this.start = usedBits;
    //       if (this.container.msb) {
    //         this.start = totalBits - usedBits - bits;
    //       }
    
    //       /** A mask of {@link BitField#bits|bits} isolating the field value
    //        * within the containing packed unsigned integer. */
    //       this.wordMask = fixBitwiseResult$1(this.valueMask << this.start);
    
    //       /** The property name used when this bitfield is represented in an
    //        * Object.
    //        *
    //        * Intended to be functionally equivalent to {@link
    //        * Layout#property}.
    //        *
    //        * If left undefined the corresponding span of bits will be
    //        * treated as padding: it will not be mutated by {@link
    //        * Layout#encode|encode} nor represented as a property in the
    //        * decoded Object. */
    //       this.property = property;
    //     }
    
    //     /** Store a value into the corresponding subsequence of the containing
    //      * bit field. */
    //     decode() {
    //       const word = this.container._packedGetValue();
    //       const wordValue = fixBitwiseResult$1(word & this.wordMask);
    //       const value = wordValue >>> this.start;
    //       return value;
    //     }
    
    //     /** Store a value into the corresponding subsequence of the containing
    //      * bit field.
    //      *
    //      * **NOTE** This is not a specialization of {@link
    //      * Layout#encode|Layout.encode} and there is no return value. */
    //     encode(value) {
    //       if ((!Number.isInteger(value))
    //           || (value !== fixBitwiseResult$1(value & this.valueMask))) {
    //         throw new TypeError(nameWithProperty$1('BitField.encode', this)
    //                             + ' value must be integer not exceeding ' + this.valueMask);
    //       }
    //       const word = this.container._packedGetValue();
    //       const wordValue = fixBitwiseResult$1(value << this.start);
    //       this.container._packedSetValue(fixBitwiseResult$1(word & ~this.wordMask)
    //                                      | wordValue);
    //     };
    //   }
    
    //   /**
    //    * Represent a single bit within a {@link BitStructure} as a
    //    * JavaScript boolean.
    //    *
    //    * **NOTE** User code should not invoke this constructor directly.
    //    * Use the container {@link BitStructure#addBoolean|addBoolean} helper
    //    * method.
    //    *
    //    * @param {BitStructure} container - initializer for {@link
    //    * BitField#container|container}.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {BitField}
    //    */
    //   /* eslint-disable no-extend-native */
    //   class Boolean$2 extends BitField$1 {
    //     constructor(container, property) {
    //       super(container, 1, property);
    //     }
    
    //     /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
    //      *
    //      * @returns {boolean} */
    //     decode(b, offset) {
    //       return !!BitField$1.prototype.decode.call(this, b, offset);
    //     }
    
    //     /** @override */
    //     encode(value) {
    //       if ('boolean' === typeof value) {
    //         // BitField requires integer values
    //         value = +value;
    //       }
    //       return BitField$1.prototype.encode.call(this, value);
    //     }
    //   }
    //   /* eslint-enable no-extend-native */
    
    //   /**
    //    * Contain a fixed-length block of arbitrary data, represented as a
    //    * Buffer.
    //    *
    //    * *Factory*: {@link module:Layout.blob|blob}
    //    *
    //    * @param {(Number|ExternalLayout)} length - initializes {@link
    //    * Blob#length|length}.
    //    *
    //    * @param {String} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class Blob$1 extends Layout$2 {
    //     constructor(length, property) {
    //       if (!(((length instanceof ExternalLayout$1) && length.isCount())
    //             || (Number.isInteger(length) && (0 <= length)))) {
    //         throw new TypeError('length must be positive integer '
    //                             + 'or an unsigned integer ExternalLayout');
    //       }
    
    //       let span = -1;
    //       if (!(length instanceof ExternalLayout$1)) {
    //         span = length;
    //       }
    //       super(span, property);
    
    //       /** The number of bytes in the blob.
    //        *
    //        * This may be a non-negative integer, or an instance of {@link
    //        * ExternalLayout} that satisfies {@link
    //        * ExternalLayout#isCount|isCount()}. */
    //       this.length = length;
    //     }
    
    //     /** @override */
    //     getSpan(b, offset) {
    //       let span = this.span;
    //       if (0 > span) {
    //         span = this.length.decode(b, offset);
    //       }
    //       return span;
    //     }
    
    //     /** @override */
    //     decode(b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       let span = this.span;
    //       if (0 > span) {
    //         span = this.length.decode(b, offset);
    //       }
    //       return b.slice(offset, offset + span);
    //     }
    
    //     /** Implement {@link Layout#encode|encode} for {@link Blob}.
    //      *
    //      * **NOTE** If {@link Layout#count|count} is an instance of {@link
    //      * ExternalLayout} then the length of `src` will be encoded as the
    //      * count after `src` is encoded. */
    //     encode(src, b, offset) {
    //       let span = this.length;
    //       if (this.length instanceof ExternalLayout$1) {
    //         span = src.length;
    //       }
    //       if (!(buffer.Buffer.isBuffer(src)
    //             && (span === src.length))) {
    //         throw new TypeError(nameWithProperty$1('Blob.encode', this)
    //                             + ' requires (length ' + span + ') Buffer as src');
    //       }
    //       if ((offset + span) > b.length) {
    //         throw new RangeError('encoding overruns Buffer');
    //       }
    //       b.write(src.toString('hex'), offset, span, 'hex');
    //       if (this.length instanceof ExternalLayout$1) {
    //         this.length.encode(span, b, offset);
    //       }
    //       return span;
    //     }
    //   }
    
    //   /**
    //    * Contain a `NUL`-terminated UTF8 string.
    //    *
    //    * *Factory*: {@link module:Layout.cstr|cstr}
    //    *
    //    * **NOTE** Any UTF8 string that incorporates a zero-valued byte will
    //    * not be correctly decoded by this layout.
    //    *
    //    * @param {String} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class CString$1 extends Layout$2 {
    //     constructor(property) {
    //       super(-1, property);
    //     }
    
    //     /** @override */
    //     getSpan(b, offset) {
    //       if (!buffer.Buffer.isBuffer(b)) {
    //         throw new TypeError('b must be a Buffer');
    //       }
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       let idx = offset;
    //       while ((idx < b.length) && (0 !== b[idx])) {
    //         idx += 1;
    //       }
    //       return 1 + idx - offset;
    //     }
    
    //     /** @override */
    //     decode(b, offset, dest) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       let span = this.getSpan(b, offset);
    //       return b.slice(offset, offset + span - 1).toString('utf-8');
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       /* Must force this to a string, lest it be a number and the
    //        * "utf8-encoding" below actually allocate a buffer of length
    //        * src */
    //       if ('string' !== typeof src) {
    //         src = src.toString();
    //       }
    //       const srcb = new buffer.Buffer(src, 'utf8');
    //       const span = srcb.length;
    //       if ((offset + span) > b.length) {
    //         throw new RangeError('encoding overruns Buffer');
    //       }
    //       srcb.copy(b, offset);
    //       b[offset + span] = 0;
    //       return span + 1;
    //     }
    //   }
    
    //   /**
    //    * Contain a UTF8 string with implicit length.
    //    *
    //    * *Factory*: {@link module:Layout.utf8|utf8}
    //    *
    //    * **NOTE** Because the length is implicit in the size of the buffer
    //    * this layout should be used only in isolation, or in a situation
    //    * where the length can be expressed by operating on a slice of the
    //    * containing buffer.
    //    *
    //    * @param {Number} [maxSpan] - the maximum length allowed for encoded
    //    * string content.  If not provided there is no bound on the allowed
    //    * content.
    //    *
    //    * @param {String} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class UTF8$1 extends Layout$2 {
    //     constructor(maxSpan, property) {
    //       if (('string' === typeof maxSpan)
    //           && (undefined === property)) {
    //         property = maxSpan;
    //         maxSpan = undefined;
    //       }
    //       if (undefined === maxSpan) {
    //         maxSpan = -1;
    //       } else if (!Number.isInteger(maxSpan)) {
    //         throw new TypeError('maxSpan must be an integer');
    //       }
    
    //       super(-1, property);
    
    //       /** The maximum span of the layout in bytes.
    //        *
    //        * Positive values are generally expected.  Zero is abnormal.
    //        * Attempts to encode or decode a value that exceeds this length
    //        * will throw a `RangeError`.
    //        *
    //        * A negative value indicates that there is no bound on the length
    //        * of the content. */
    //       this.maxSpan = maxSpan;
    //     }
    
    //     /** @override */
    //     getSpan(b, offset) {
    //       if (!buffer.Buffer.isBuffer(b)) {
    //         throw new TypeError('b must be a Buffer');
    //       }
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       return b.length - offset;
    //     }
    
    //     /** @override */
    //     decode(b, offset, dest) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       let span = this.getSpan(b, offset);
    //       if ((0 <= this.maxSpan)
    //           && (this.maxSpan < span)) {
    //         throw new RangeError('text length exceeds maxSpan');
    //       }
    //       return b.slice(offset, offset + span).toString('utf-8');
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       if (undefined === offset) {
    //         offset = 0;
    //       }
    //       /* Must force this to a string, lest it be a number and the
    //        * "utf8-encoding" below actually allocate a buffer of length
    //        * src */
    //       if ('string' !== typeof src) {
    //         src = src.toString();
    //       }
    //       const srcb = new buffer.Buffer(src, 'utf8');
    //       const span = srcb.length;
    //       if ((0 <= this.maxSpan)
    //           && (this.maxSpan < span)) {
    //         throw new RangeError('text length exceeds maxSpan');
    //       }
    //       if ((offset + span) > b.length) {
    //         throw new RangeError('encoding overruns Buffer');
    //       }
    //       srcb.copy(b, offset);
    //       return span;
    //     }
    //   }
    
    //   /**
    //    * Contain a constant value.
    //    *
    //    * This layout may be used in cases where a JavaScript value can be
    //    * inferred without an expression in the binary encoding.  An example
    //    * would be a {@link VariantLayout|variant layout} where the content
    //    * is implied by the union {@link Union#discriminator|discriminator}.
    //    *
    //    * @param {Object|Number|String} value - initializer for {@link
    //    * Constant#value|value}.  If the value is an object (or array) and
    //    * the application intends the object to remain unchanged regardless
    //    * of what is done to values decoded by this layout, the value should
    //    * be frozen prior passing it to this constructor.
    //    *
    //    * @param {String} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   class Constant$1 extends Layout$2 {
    //     constructor(value, property) {
    //       super(0, property);
    
    //       /** The value produced by this constant when the layout is {@link
    //        * Constant#decode|decoded}.
    //        *
    //        * Any JavaScript value including `null` and `undefined` is
    //        * permitted.
    //        *
    //        * **WARNING** If `value` passed in the constructor was not
    //        * frozen, it is possible for users of decoded values to change
    //        * the content of the value. */
    //       this.value = value;
    //     }
    
    //     /** @override */
    //     decode(b, offset, dest) {
    //       return this.value;
    //     }
    
    //     /** @override */
    //     encode(src, b, offset) {
    //       /* Constants take no space */
    //       return 0;
    //     }
    //   }
    
    //   Layout$3.ExternalLayout = ExternalLayout$1;
    //   Layout$3.GreedyCount = GreedyCount$1;
    //   Layout$3.OffsetLayout = OffsetLayout$1;
    //   Layout$3.UInt = UInt$1;
    //   Layout$3.UIntBE = UIntBE$1;
    //   Layout$3.Int = Int$1;
    //   Layout$3.IntBE = IntBE$1;
    //   Layout$3.Float = Float$1;
    //   Layout$3.FloatBE = FloatBE$1;
    //   Layout$3.Double = Double$1;
    //   Layout$3.DoubleBE = DoubleBE$1;
    //   Layout$3.Sequence = Sequence$1;
    //   Layout$3.Structure = Structure$1;
    //   Layout$3.UnionDiscriminator = UnionDiscriminator$1;
    //   Layout$3.UnionLayoutDiscriminator = UnionLayoutDiscriminator$1;
    //   Layout$3.Union = Union$1;
    //   Layout$3.VariantLayout = VariantLayout$1;
    //   Layout$3.BitStructure = BitStructure$1;
    //   Layout$3.BitField = BitField$1;
    //   Layout$3.Boolean = Boolean$2;
    //   Layout$3.Blob = Blob$1;
    //   Layout$3.CString = CString$1;
    //   Layout$3.UTF8 = UTF8$1;
    //   Layout$3.Constant = Constant$1;
    
    //   /** Factory for {@link GreedyCount}. */
    //   Layout$3.greedy = ((elementSpan, property) => new GreedyCount$1(elementSpan, property));
    
    //   /** Factory for {@link OffsetLayout}. */
    //   Layout$3.offset = ((layout, offset, property) => new OffsetLayout$1(layout, offset, property));
    
    //   /** Factory for {@link UInt|unsigned int layouts} spanning one
    //    * byte. */
    //   var u8$1 = Layout$3.u8 = (property => new UInt$1(1, property));
    
    //   /** Factory for {@link UInt|little-endian unsigned int layouts}
    //    * spanning two bytes. */
    //   Layout$3.u16 = (property => new UInt$1(2, property));
    
    //   /** Factory for {@link UInt|little-endian unsigned int layouts}
    //    * spanning three bytes. */
    //   Layout$3.u24 = (property => new UInt$1(3, property));
    
    //   /** Factory for {@link UInt|little-endian unsigned int layouts}
    //    * spanning four bytes. */
    //   var u32$1 = Layout$3.u32 = (property => new UInt$1(4, property));
    
    //   /** Factory for {@link UInt|little-endian unsigned int layouts}
    //    * spanning five bytes. */
    //   Layout$3.u40 = (property => new UInt$1(5, property));
    
    //   /** Factory for {@link UInt|little-endian unsigned int layouts}
    //    * spanning six bytes. */
    //   Layout$3.u48 = (property => new UInt$1(6, property));
    
    //   /** Factory for {@link NearUInt64|little-endian unsigned int
    //    * layouts} interpreted as Numbers. */
    //   Layout$3.nu64 = (property => new NearUInt64$1(property));
    
    //   /** Factory for {@link UInt|big-endian unsigned int layouts}
    //    * spanning two bytes. */
    //   Layout$3.u16be = (property => new UIntBE$1(2, property));
    
    //   /** Factory for {@link UInt|big-endian unsigned int layouts}
    //    * spanning three bytes. */
    //   Layout$3.u24be = (property => new UIntBE$1(3, property));
    
    //   /** Factory for {@link UInt|big-endian unsigned int layouts}
    //    * spanning four bytes. */
    //   Layout$3.u32be = (property => new UIntBE$1(4, property));
    
    //   /** Factory for {@link UInt|big-endian unsigned int layouts}
    //    * spanning five bytes. */
    //   Layout$3.u40be = (property => new UIntBE$1(5, property));
    
    //   /** Factory for {@link UInt|big-endian unsigned int layouts}
    //    * spanning six bytes. */
    //   Layout$3.u48be = (property => new UIntBE$1(6, property));
    
    //   /** Factory for {@link NearUInt64BE|big-endian unsigned int
    //    * layouts} interpreted as Numbers. */
    //   Layout$3.nu64be = (property => new NearUInt64BE$1(property));
    
    //   /** Factory for {@link Int|signed int layouts} spanning one
    //    * byte. */
    //   Layout$3.s8 = (property => new Int$1(1, property));
    
    //   /** Factory for {@link Int|little-endian signed int layouts}
    //    * spanning two bytes. */
    //   Layout$3.s16 = (property => new Int$1(2, property));
    
    //   /** Factory for {@link Int|little-endian signed int layouts}
    //    * spanning three bytes. */
    //   Layout$3.s24 = (property => new Int$1(3, property));
    
    //   /** Factory for {@link Int|little-endian signed int layouts}
    //    * spanning four bytes. */
    //   Layout$3.s32 = (property => new Int$1(4, property));
    
    //   /** Factory for {@link Int|little-endian signed int layouts}
    //    * spanning five bytes. */
    //   Layout$3.s40 = (property => new Int$1(5, property));
    
    //   /** Factory for {@link Int|little-endian signed int layouts}
    //    * spanning six bytes. */
    //   Layout$3.s48 = (property => new Int$1(6, property));
    
    //   /** Factory for {@link NearInt64|little-endian signed int layouts}
    //    * interpreted as Numbers. */
    //   Layout$3.ns64 = (property => new NearInt64$1(property));
    
    //   /** Factory for {@link Int|big-endian signed int layouts}
    //    * spanning two bytes. */
    //   Layout$3.s16be = (property => new IntBE$1(2, property));
    
    //   /** Factory for {@link Int|big-endian signed int layouts}
    //    * spanning three bytes. */
    //   Layout$3.s24be = (property => new IntBE$1(3, property));
    
    //   /** Factory for {@link Int|big-endian signed int layouts}
    //    * spanning four bytes. */
    //   Layout$3.s32be = (property => new IntBE$1(4, property));
    
    //   /** Factory for {@link Int|big-endian signed int layouts}
    //    * spanning five bytes. */
    //   Layout$3.s40be = (property => new IntBE$1(5, property));
    
    //   /** Factory for {@link Int|big-endian signed int layouts}
    //    * spanning six bytes. */
    //   Layout$3.s48be = (property => new IntBE$1(6, property));
    
    //   /** Factory for {@link NearInt64BE|big-endian signed int layouts}
    //    * interpreted as Numbers. */
    //   Layout$3.ns64be = (property => new NearInt64BE$1(property));
    
    //   /** Factory for {@link Float|little-endian 32-bit floating point} values. */
    //   Layout$3.f32 = (property => new Float$1(property));
    
    //   /** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */
    //   Layout$3.f32be = (property => new FloatBE$1(property));
    
    //   /** Factory for {@link Double|little-endian 64-bit floating point} values. */
    //   Layout$3.f64 = (property => new Double$1(property));
    
    //   /** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */
    //   Layout$3.f64be = (property => new DoubleBE$1(property));
    
    //   /** Factory for {@link Structure} values. */
    //   var struct$1 = Layout$3.struct = ((fields, property, decodePrefixes) => new Structure$1(fields, property, decodePrefixes));
    
    //   /** Factory for {@link BitStructure} values. */
    //   Layout$3.bits = ((word, msb, property) => new BitStructure$1(word, msb, property));
    
    //   /** Factory for {@link Sequence} values. */
    //   Layout$3.seq = ((elementLayout, count, property) => new Sequence$1(elementLayout, count, property));
    
    //   /** Factory for {@link Union} values. */
    //   Layout$3.union = ((discr, defaultLayout, property) => new Union$1(discr, defaultLayout, property));
    
    //   /** Factory for {@link UnionLayoutDiscriminator} values. */
    //   Layout$3.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator$1(layout, property));
    
    //   /** Factory for {@link Blob} values. */
    //   var blob$1 = Layout$3.blob = ((length, property) => new Blob$1(length, property));
    
    //   /** Factory for {@link CString} values. */
    //   Layout$3.cstr = (property => new CString$1(property));
    
    //   /** Factory for {@link UTF8} values. */
    //   Layout$3.utf8 = ((maxSpan, property) => new UTF8$1(maxSpan, property));
    
    //   /** Factory for {@link Constant} values. */
    //   Layout$3.const = ((value, property) => new Constant$1(value, property));
    
    //   function _defineProperty(obj, key, value) {
    //     if (key in obj) {
    //       Object.defineProperty(obj, key, {
    //         value: value,
    //         enumerable: true,
    //         configurable: true,
    //         writable: true
    //       });
    //     } else {
    //       obj[key] = value;
    //     }
    
    //     return obj;
    //   }
    
    //   var naclFast = {exports: {}};
    
    //   (function (module) {
    //   (function(nacl) {
    
    //   // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
    //   // Public domain.
    //   //
    //   // Implementation derived from TweetNaCl version 20140427.
    //   // See for details: http://tweetnacl.cr.yp.to/
    
    //   var gf = function(init) {
    //     var i, r = new Float64Array(16);
    //     if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
    //     return r;
    //   };
    
    //   //  Pluggable, initialized in high-level API below.
    //   var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };
    
    //   var _0 = new Uint8Array(16);
    //   var _9 = new Uint8Array(32); _9[0] = 9;
    
    //   var gf0 = gf(),
    //       gf1 = gf([1]),
    //       _121665 = gf([0xdb41, 1]),
    //       D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    //       D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    //       X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    //       Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    //       I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);
    
    //   function ts64(x, i, h, l) {
    //     x[i]   = (h >> 24) & 0xff;
    //     x[i+1] = (h >> 16) & 0xff;
    //     x[i+2] = (h >>  8) & 0xff;
    //     x[i+3] = h & 0xff;
    //     x[i+4] = (l >> 24)  & 0xff;
    //     x[i+5] = (l >> 16)  & 0xff;
    //     x[i+6] = (l >>  8)  & 0xff;
    //     x[i+7] = l & 0xff;
    //   }
    
    //   function vn(x, xi, y, yi, n) {
    //     var i,d = 0;
    //     for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
    //     return (1 & ((d - 1) >>> 8)) - 1;
    //   }
    
    //   function crypto_verify_16(x, xi, y, yi) {
    //     return vn(x,xi,y,yi,16);
    //   }
    
    //   function crypto_verify_32(x, xi, y, yi) {
    //     return vn(x,xi,y,yi,32);
    //   }
    
    //   function core_salsa20(o, p, k, c) {
    //     var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
    //         j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
    //         j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
    //         j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
    //         j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
    //         j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
    //         j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
    //         j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
    //         j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
    //         j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
    //         j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
    //         j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
    //         j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
    //         j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
    //         j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
    //         j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;
    
    //     var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
    //         x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
    //         x15 = j15, u;
    
    //     for (var i = 0; i < 20; i += 2) {
    //       u = x0 + x12 | 0;
    //       x4 ^= u<<7 | u>>>(32-7);
    //       u = x4 + x0 | 0;
    //       x8 ^= u<<9 | u>>>(32-9);
    //       u = x8 + x4 | 0;
    //       x12 ^= u<<13 | u>>>(32-13);
    //       u = x12 + x8 | 0;
    //       x0 ^= u<<18 | u>>>(32-18);
    
    //       u = x5 + x1 | 0;
    //       x9 ^= u<<7 | u>>>(32-7);
    //       u = x9 + x5 | 0;
    //       x13 ^= u<<9 | u>>>(32-9);
    //       u = x13 + x9 | 0;
    //       x1 ^= u<<13 | u>>>(32-13);
    //       u = x1 + x13 | 0;
    //       x5 ^= u<<18 | u>>>(32-18);
    
    //       u = x10 + x6 | 0;
    //       x14 ^= u<<7 | u>>>(32-7);
    //       u = x14 + x10 | 0;
    //       x2 ^= u<<9 | u>>>(32-9);
    //       u = x2 + x14 | 0;
    //       x6 ^= u<<13 | u>>>(32-13);
    //       u = x6 + x2 | 0;
    //       x10 ^= u<<18 | u>>>(32-18);
    
    //       u = x15 + x11 | 0;
    //       x3 ^= u<<7 | u>>>(32-7);
    //       u = x3 + x15 | 0;
    //       x7 ^= u<<9 | u>>>(32-9);
    //       u = x7 + x3 | 0;
    //       x11 ^= u<<13 | u>>>(32-13);
    //       u = x11 + x7 | 0;
    //       x15 ^= u<<18 | u>>>(32-18);
    
    //       u = x0 + x3 | 0;
    //       x1 ^= u<<7 | u>>>(32-7);
    //       u = x1 + x0 | 0;
    //       x2 ^= u<<9 | u>>>(32-9);
    //       u = x2 + x1 | 0;
    //       x3 ^= u<<13 | u>>>(32-13);
    //       u = x3 + x2 | 0;
    //       x0 ^= u<<18 | u>>>(32-18);
    
    //       u = x5 + x4 | 0;
    //       x6 ^= u<<7 | u>>>(32-7);
    //       u = x6 + x5 | 0;
    //       x7 ^= u<<9 | u>>>(32-9);
    //       u = x7 + x6 | 0;
    //       x4 ^= u<<13 | u>>>(32-13);
    //       u = x4 + x7 | 0;
    //       x5 ^= u<<18 | u>>>(32-18);
    
    //       u = x10 + x9 | 0;
    //       x11 ^= u<<7 | u>>>(32-7);
    //       u = x11 + x10 | 0;
    //       x8 ^= u<<9 | u>>>(32-9);
    //       u = x8 + x11 | 0;
    //       x9 ^= u<<13 | u>>>(32-13);
    //       u = x9 + x8 | 0;
    //       x10 ^= u<<18 | u>>>(32-18);
    
    //       u = x15 + x14 | 0;
    //       x12 ^= u<<7 | u>>>(32-7);
    //       u = x12 + x15 | 0;
    //       x13 ^= u<<9 | u>>>(32-9);
    //       u = x13 + x12 | 0;
    //       x14 ^= u<<13 | u>>>(32-13);
    //       u = x14 + x13 | 0;
    //       x15 ^= u<<18 | u>>>(32-18);
    //     }
    //      x0 =  x0 +  j0 | 0;
    //      x1 =  x1 +  j1 | 0;
    //      x2 =  x2 +  j2 | 0;
    //      x3 =  x3 +  j3 | 0;
    //      x4 =  x4 +  j4 | 0;
    //      x5 =  x5 +  j5 | 0;
    //      x6 =  x6 +  j6 | 0;
    //      x7 =  x7 +  j7 | 0;
    //      x8 =  x8 +  j8 | 0;
    //      x9 =  x9 +  j9 | 0;
    //     x10 = x10 + j10 | 0;
    //     x11 = x11 + j11 | 0;
    //     x12 = x12 + j12 | 0;
    //     x13 = x13 + j13 | 0;
    //     x14 = x14 + j14 | 0;
    //     x15 = x15 + j15 | 0;
    
    //     o[ 0] = x0 >>>  0 & 0xff;
    //     o[ 1] = x0 >>>  8 & 0xff;
    //     o[ 2] = x0 >>> 16 & 0xff;
    //     o[ 3] = x0 >>> 24 & 0xff;
    
    //     o[ 4] = x1 >>>  0 & 0xff;
    //     o[ 5] = x1 >>>  8 & 0xff;
    //     o[ 6] = x1 >>> 16 & 0xff;
    //     o[ 7] = x1 >>> 24 & 0xff;
    
    //     o[ 8] = x2 >>>  0 & 0xff;
    //     o[ 9] = x2 >>>  8 & 0xff;
    //     o[10] = x2 >>> 16 & 0xff;
    //     o[11] = x2 >>> 24 & 0xff;
    
    //     o[12] = x3 >>>  0 & 0xff;
    //     o[13] = x3 >>>  8 & 0xff;
    //     o[14] = x3 >>> 16 & 0xff;
    //     o[15] = x3 >>> 24 & 0xff;
    
    //     o[16] = x4 >>>  0 & 0xff;
    //     o[17] = x4 >>>  8 & 0xff;
    //     o[18] = x4 >>> 16 & 0xff;
    //     o[19] = x4 >>> 24 & 0xff;
    
    //     o[20] = x5 >>>  0 & 0xff;
    //     o[21] = x5 >>>  8 & 0xff;
    //     o[22] = x5 >>> 16 & 0xff;
    //     o[23] = x5 >>> 24 & 0xff;
    
    //     o[24] = x6 >>>  0 & 0xff;
    //     o[25] = x6 >>>  8 & 0xff;
    //     o[26] = x6 >>> 16 & 0xff;
    //     o[27] = x6 >>> 24 & 0xff;
    
    //     o[28] = x7 >>>  0 & 0xff;
    //     o[29] = x7 >>>  8 & 0xff;
    //     o[30] = x7 >>> 16 & 0xff;
    //     o[31] = x7 >>> 24 & 0xff;
    
    //     o[32] = x8 >>>  0 & 0xff;
    //     o[33] = x8 >>>  8 & 0xff;
    //     o[34] = x8 >>> 16 & 0xff;
    //     o[35] = x8 >>> 24 & 0xff;
    
    //     o[36] = x9 >>>  0 & 0xff;
    //     o[37] = x9 >>>  8 & 0xff;
    //     o[38] = x9 >>> 16 & 0xff;
    //     o[39] = x9 >>> 24 & 0xff;
    
    //     o[40] = x10 >>>  0 & 0xff;
    //     o[41] = x10 >>>  8 & 0xff;
    //     o[42] = x10 >>> 16 & 0xff;
    //     o[43] = x10 >>> 24 & 0xff;
    
    //     o[44] = x11 >>>  0 & 0xff;
    //     o[45] = x11 >>>  8 & 0xff;
    //     o[46] = x11 >>> 16 & 0xff;
    //     o[47] = x11 >>> 24 & 0xff;
    
    //     o[48] = x12 >>>  0 & 0xff;
    //     o[49] = x12 >>>  8 & 0xff;
    //     o[50] = x12 >>> 16 & 0xff;
    //     o[51] = x12 >>> 24 & 0xff;
    
    //     o[52] = x13 >>>  0 & 0xff;
    //     o[53] = x13 >>>  8 & 0xff;
    //     o[54] = x13 >>> 16 & 0xff;
    //     o[55] = x13 >>> 24 & 0xff;
    
    //     o[56] = x14 >>>  0 & 0xff;
    //     o[57] = x14 >>>  8 & 0xff;
    //     o[58] = x14 >>> 16 & 0xff;
    //     o[59] = x14 >>> 24 & 0xff;
    
    //     o[60] = x15 >>>  0 & 0xff;
    //     o[61] = x15 >>>  8 & 0xff;
    //     o[62] = x15 >>> 16 & 0xff;
    //     o[63] = x15 >>> 24 & 0xff;
    //   }
    
    //   function core_hsalsa20(o,p,k,c) {
    //     var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
    //         j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
    //         j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
    //         j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
    //         j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
    //         j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
    //         j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
    //         j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
    //         j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
    //         j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
    //         j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
    //         j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
    //         j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
    //         j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
    //         j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
    //         j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;
    
    //     var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
    //         x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
    //         x15 = j15, u;
    
    //     for (var i = 0; i < 20; i += 2) {
    //       u = x0 + x12 | 0;
    //       x4 ^= u<<7 | u>>>(32-7);
    //       u = x4 + x0 | 0;
    //       x8 ^= u<<9 | u>>>(32-9);
    //       u = x8 + x4 | 0;
    //       x12 ^= u<<13 | u>>>(32-13);
    //       u = x12 + x8 | 0;
    //       x0 ^= u<<18 | u>>>(32-18);
    
    //       u = x5 + x1 | 0;
    //       x9 ^= u<<7 | u>>>(32-7);
    //       u = x9 + x5 | 0;
    //       x13 ^= u<<9 | u>>>(32-9);
    //       u = x13 + x9 | 0;
    //       x1 ^= u<<13 | u>>>(32-13);
    //       u = x1 + x13 | 0;
    //       x5 ^= u<<18 | u>>>(32-18);
    
    //       u = x10 + x6 | 0;
    //       x14 ^= u<<7 | u>>>(32-7);
    //       u = x14 + x10 | 0;
    //       x2 ^= u<<9 | u>>>(32-9);
    //       u = x2 + x14 | 0;
    //       x6 ^= u<<13 | u>>>(32-13);
    //       u = x6 + x2 | 0;
    //       x10 ^= u<<18 | u>>>(32-18);
    
    //       u = x15 + x11 | 0;
    //       x3 ^= u<<7 | u>>>(32-7);
    //       u = x3 + x15 | 0;
    //       x7 ^= u<<9 | u>>>(32-9);
    //       u = x7 + x3 | 0;
    //       x11 ^= u<<13 | u>>>(32-13);
    //       u = x11 + x7 | 0;
    //       x15 ^= u<<18 | u>>>(32-18);
    
    //       u = x0 + x3 | 0;
    //       x1 ^= u<<7 | u>>>(32-7);
    //       u = x1 + x0 | 0;
    //       x2 ^= u<<9 | u>>>(32-9);
    //       u = x2 + x1 | 0;
    //       x3 ^= u<<13 | u>>>(32-13);
    //       u = x3 + x2 | 0;
    //       x0 ^= u<<18 | u>>>(32-18);
    
    //       u = x5 + x4 | 0;
    //       x6 ^= u<<7 | u>>>(32-7);
    //       u = x6 + x5 | 0;
    //       x7 ^= u<<9 | u>>>(32-9);
    //       u = x7 + x6 | 0;
    //       x4 ^= u<<13 | u>>>(32-13);
    //       u = x4 + x7 | 0;
    //       x5 ^= u<<18 | u>>>(32-18);
    
    //       u = x10 + x9 | 0;
    //       x11 ^= u<<7 | u>>>(32-7);
    //       u = x11 + x10 | 0;
    //       x8 ^= u<<9 | u>>>(32-9);
    //       u = x8 + x11 | 0;
    //       x9 ^= u<<13 | u>>>(32-13);
    //       u = x9 + x8 | 0;
    //       x10 ^= u<<18 | u>>>(32-18);
    
    //       u = x15 + x14 | 0;
    //       x12 ^= u<<7 | u>>>(32-7);
    //       u = x12 + x15 | 0;
    //       x13 ^= u<<9 | u>>>(32-9);
    //       u = x13 + x12 | 0;
    //       x14 ^= u<<13 | u>>>(32-13);
    //       u = x14 + x13 | 0;
    //       x15 ^= u<<18 | u>>>(32-18);
    //     }
    
    //     o[ 0] = x0 >>>  0 & 0xff;
    //     o[ 1] = x0 >>>  8 & 0xff;
    //     o[ 2] = x0 >>> 16 & 0xff;
    //     o[ 3] = x0 >>> 24 & 0xff;
    
    //     o[ 4] = x5 >>>  0 & 0xff;
    //     o[ 5] = x5 >>>  8 & 0xff;
    //     o[ 6] = x5 >>> 16 & 0xff;
    //     o[ 7] = x5 >>> 24 & 0xff;
    
    //     o[ 8] = x10 >>>  0 & 0xff;
    //     o[ 9] = x10 >>>  8 & 0xff;
    //     o[10] = x10 >>> 16 & 0xff;
    //     o[11] = x10 >>> 24 & 0xff;
    
    //     o[12] = x15 >>>  0 & 0xff;
    //     o[13] = x15 >>>  8 & 0xff;
    //     o[14] = x15 >>> 16 & 0xff;
    //     o[15] = x15 >>> 24 & 0xff;
    
    //     o[16] = x6 >>>  0 & 0xff;
    //     o[17] = x6 >>>  8 & 0xff;
    //     o[18] = x6 >>> 16 & 0xff;
    //     o[19] = x6 >>> 24 & 0xff;
    
    //     o[20] = x7 >>>  0 & 0xff;
    //     o[21] = x7 >>>  8 & 0xff;
    //     o[22] = x7 >>> 16 & 0xff;
    //     o[23] = x7 >>> 24 & 0xff;
    
    //     o[24] = x8 >>>  0 & 0xff;
    //     o[25] = x8 >>>  8 & 0xff;
    //     o[26] = x8 >>> 16 & 0xff;
    //     o[27] = x8 >>> 24 & 0xff;
    
    //     o[28] = x9 >>>  0 & 0xff;
    //     o[29] = x9 >>>  8 & 0xff;
    //     o[30] = x9 >>> 16 & 0xff;
    //     o[31] = x9 >>> 24 & 0xff;
    //   }
    
    //   function crypto_core_salsa20(out,inp,k,c) {
    //     core_salsa20(out,inp,k,c);
    //   }
    
    //   function crypto_core_hsalsa20(out,inp,k,c) {
    //     core_hsalsa20(out,inp,k,c);
    //   }
    
    //   var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    //               // "expand 32-byte k"
    
    //   function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
    //     var z = new Uint8Array(16), x = new Uint8Array(64);
    //     var u, i;
    //     for (i = 0; i < 16; i++) z[i] = 0;
    //     for (i = 0; i < 8; i++) z[i] = n[i];
    //     while (b >= 64) {
    //       crypto_core_salsa20(x,z,k,sigma);
    //       for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    //       u = 1;
    //       for (i = 8; i < 16; i++) {
    //         u = u + (z[i] & 0xff) | 0;
    //         z[i] = u & 0xff;
    //         u >>>= 8;
    //       }
    //       b -= 64;
    //       cpos += 64;
    //       mpos += 64;
    //     }
    //     if (b > 0) {
    //       crypto_core_salsa20(x,z,k,sigma);
    //       for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    //     }
    //     return 0;
    //   }
    
    //   function crypto_stream_salsa20(c,cpos,b,n,k) {
    //     var z = new Uint8Array(16), x = new Uint8Array(64);
    //     var u, i;
    //     for (i = 0; i < 16; i++) z[i] = 0;
    //     for (i = 0; i < 8; i++) z[i] = n[i];
    //     while (b >= 64) {
    //       crypto_core_salsa20(x,z,k,sigma);
    //       for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    //       u = 1;
    //       for (i = 8; i < 16; i++) {
    //         u = u + (z[i] & 0xff) | 0;
    //         z[i] = u & 0xff;
    //         u >>>= 8;
    //       }
    //       b -= 64;
    //       cpos += 64;
    //     }
    //     if (b > 0) {
    //       crypto_core_salsa20(x,z,k,sigma);
    //       for (i = 0; i < b; i++) c[cpos+i] = x[i];
    //     }
    //     return 0;
    //   }
    
    //   function crypto_stream(c,cpos,d,n,k) {
    //     var s = new Uint8Array(32);
    //     crypto_core_hsalsa20(s,n,k,sigma);
    //     var sn = new Uint8Array(8);
    //     for (var i = 0; i < 8; i++) sn[i] = n[i+16];
    //     return crypto_stream_salsa20(c,cpos,d,sn,s);
    //   }
    
    //   function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
    //     var s = new Uint8Array(32);
    //     crypto_core_hsalsa20(s,n,k,sigma);
    //     var sn = new Uint8Array(8);
    //     for (var i = 0; i < 8; i++) sn[i] = n[i+16];
    //     return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
    //   }
    
    //   /*
    //   * Port of Andrew Moon's Poly1305-donna-16. Public domain.
    //   * https://github.com/floodyberry/poly1305-donna
    //   */
    
    //   var poly1305 = function(key) {
    //     this.buffer = new Uint8Array(16);
    //     this.r = new Uint16Array(10);
    //     this.h = new Uint16Array(10);
    //     this.pad = new Uint16Array(8);
    //     this.leftover = 0;
    //     this.fin = 0;
    
    //     var t0, t1, t2, t3, t4, t5, t6, t7;
    
    //     t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
    //     t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    //     t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
    //     t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    //     t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
    //     this.r[5] = ((t4 >>>  1)) & 0x1ffe;
    //     t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    //     t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
    //     t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    //     this.r[9] = ((t7 >>>  5)) & 0x007f;
    
    //     this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
    //     this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
    //     this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
    //     this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
    //     this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
    //     this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
    //     this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
    //     this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
    //   };
    
    //   poly1305.prototype.blocks = function(m, mpos, bytes) {
    //     var hibit = this.fin ? 0 : (1 << 11);
    //     var t0, t1, t2, t3, t4, t5, t6, t7, c;
    //     var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
    
    //     var h0 = this.h[0],
    //         h1 = this.h[1],
    //         h2 = this.h[2],
    //         h3 = this.h[3],
    //         h4 = this.h[4],
    //         h5 = this.h[5],
    //         h6 = this.h[6],
    //         h7 = this.h[7],
    //         h8 = this.h[8],
    //         h9 = this.h[9];
    
    //     var r0 = this.r[0],
    //         r1 = this.r[1],
    //         r2 = this.r[2],
    //         r3 = this.r[3],
    //         r4 = this.r[4],
    //         r5 = this.r[5],
    //         r6 = this.r[6],
    //         r7 = this.r[7],
    //         r8 = this.r[8],
    //         r9 = this.r[9];
    
    //     while (bytes >= 16) {
    //       t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    //       t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    //       t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    //       t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    //       t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    //       h5 += ((t4 >>>  1)) & 0x1fff;
    //       t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    //       t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    //       t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    //       h9 += ((t7 >>> 5)) | hibit;
    
    //       c = 0;
    
    //       d0 = c;
    //       d0 += h0 * r0;
    //       d0 += h1 * (5 * r9);
    //       d0 += h2 * (5 * r8);
    //       d0 += h3 * (5 * r7);
    //       d0 += h4 * (5 * r6);
    //       c = (d0 >>> 13); d0 &= 0x1fff;
    //       d0 += h5 * (5 * r5);
    //       d0 += h6 * (5 * r4);
    //       d0 += h7 * (5 * r3);
    //       d0 += h8 * (5 * r2);
    //       d0 += h9 * (5 * r1);
    //       c += (d0 >>> 13); d0 &= 0x1fff;
    
    //       d1 = c;
    //       d1 += h0 * r1;
    //       d1 += h1 * r0;
    //       d1 += h2 * (5 * r9);
    //       d1 += h3 * (5 * r8);
    //       d1 += h4 * (5 * r7);
    //       c = (d1 >>> 13); d1 &= 0x1fff;
    //       d1 += h5 * (5 * r6);
    //       d1 += h6 * (5 * r5);
    //       d1 += h7 * (5 * r4);
    //       d1 += h8 * (5 * r3);
    //       d1 += h9 * (5 * r2);
    //       c += (d1 >>> 13); d1 &= 0x1fff;
    
    //       d2 = c;
    //       d2 += h0 * r2;
    //       d2 += h1 * r1;
    //       d2 += h2 * r0;
    //       d2 += h3 * (5 * r9);
    //       d2 += h4 * (5 * r8);
    //       c = (d2 >>> 13); d2 &= 0x1fff;
    //       d2 += h5 * (5 * r7);
    //       d2 += h6 * (5 * r6);
    //       d2 += h7 * (5 * r5);
    //       d2 += h8 * (5 * r4);
    //       d2 += h9 * (5 * r3);
    //       c += (d2 >>> 13); d2 &= 0x1fff;
    
    //       d3 = c;
    //       d3 += h0 * r3;
    //       d3 += h1 * r2;
    //       d3 += h2 * r1;
    //       d3 += h3 * r0;
    //       d3 += h4 * (5 * r9);
    //       c = (d3 >>> 13); d3 &= 0x1fff;
    //       d3 += h5 * (5 * r8);
    //       d3 += h6 * (5 * r7);
    //       d3 += h7 * (5 * r6);
    //       d3 += h8 * (5 * r5);
    //       d3 += h9 * (5 * r4);
    //       c += (d3 >>> 13); d3 &= 0x1fff;
    
    //       d4 = c;
    //       d4 += h0 * r4;
    //       d4 += h1 * r3;
    //       d4 += h2 * r2;
    //       d4 += h3 * r1;
    //       d4 += h4 * r0;
    //       c = (d4 >>> 13); d4 &= 0x1fff;
    //       d4 += h5 * (5 * r9);
    //       d4 += h6 * (5 * r8);
    //       d4 += h7 * (5 * r7);
    //       d4 += h8 * (5 * r6);
    //       d4 += h9 * (5 * r5);
    //       c += (d4 >>> 13); d4 &= 0x1fff;
    
    //       d5 = c;
    //       d5 += h0 * r5;
    //       d5 += h1 * r4;
    //       d5 += h2 * r3;
    //       d5 += h3 * r2;
    //       d5 += h4 * r1;
    //       c = (d5 >>> 13); d5 &= 0x1fff;
    //       d5 += h5 * r0;
    //       d5 += h6 * (5 * r9);
    //       d5 += h7 * (5 * r8);
    //       d5 += h8 * (5 * r7);
    //       d5 += h9 * (5 * r6);
    //       c += (d5 >>> 13); d5 &= 0x1fff;
    
    //       d6 = c;
    //       d6 += h0 * r6;
    //       d6 += h1 * r5;
    //       d6 += h2 * r4;
    //       d6 += h3 * r3;
    //       d6 += h4 * r2;
    //       c = (d6 >>> 13); d6 &= 0x1fff;
    //       d6 += h5 * r1;
    //       d6 += h6 * r0;
    //       d6 += h7 * (5 * r9);
    //       d6 += h8 * (5 * r8);
    //       d6 += h9 * (5 * r7);
    //       c += (d6 >>> 13); d6 &= 0x1fff;
    
    //       d7 = c;
    //       d7 += h0 * r7;
    //       d7 += h1 * r6;
    //       d7 += h2 * r5;
    //       d7 += h3 * r4;
    //       d7 += h4 * r3;
    //       c = (d7 >>> 13); d7 &= 0x1fff;
    //       d7 += h5 * r2;
    //       d7 += h6 * r1;
    //       d7 += h7 * r0;
    //       d7 += h8 * (5 * r9);
    //       d7 += h9 * (5 * r8);
    //       c += (d7 >>> 13); d7 &= 0x1fff;
    
    //       d8 = c;
    //       d8 += h0 * r8;
    //       d8 += h1 * r7;
    //       d8 += h2 * r6;
    //       d8 += h3 * r5;
    //       d8 += h4 * r4;
    //       c = (d8 >>> 13); d8 &= 0x1fff;
    //       d8 += h5 * r3;
    //       d8 += h6 * r2;
    //       d8 += h7 * r1;
    //       d8 += h8 * r0;
    //       d8 += h9 * (5 * r9);
    //       c += (d8 >>> 13); d8 &= 0x1fff;
    
    //       d9 = c;
    //       d9 += h0 * r9;
    //       d9 += h1 * r8;
    //       d9 += h2 * r7;
    //       d9 += h3 * r6;
    //       d9 += h4 * r5;
    //       c = (d9 >>> 13); d9 &= 0x1fff;
    //       d9 += h5 * r4;
    //       d9 += h6 * r3;
    //       d9 += h7 * r2;
    //       d9 += h8 * r1;
    //       d9 += h9 * r0;
    //       c += (d9 >>> 13); d9 &= 0x1fff;
    
    //       c = (((c << 2) + c)) | 0;
    //       c = (c + d0) | 0;
    //       d0 = c & 0x1fff;
    //       c = (c >>> 13);
    //       d1 += c;
    
    //       h0 = d0;
    //       h1 = d1;
    //       h2 = d2;
    //       h3 = d3;
    //       h4 = d4;
    //       h5 = d5;
    //       h6 = d6;
    //       h7 = d7;
    //       h8 = d8;
    //       h9 = d9;
    
    //       mpos += 16;
    //       bytes -= 16;
    //     }
    //     this.h[0] = h0;
    //     this.h[1] = h1;
    //     this.h[2] = h2;
    //     this.h[3] = h3;
    //     this.h[4] = h4;
    //     this.h[5] = h5;
    //     this.h[6] = h6;
    //     this.h[7] = h7;
    //     this.h[8] = h8;
    //     this.h[9] = h9;
    //   };
    
    //   poly1305.prototype.finish = function(mac, macpos) {
    //     var g = new Uint16Array(10);
    //     var c, mask, f, i;
    
    //     if (this.leftover) {
    //       i = this.leftover;
    //       this.buffer[i++] = 1;
    //       for (; i < 16; i++) this.buffer[i] = 0;
    //       this.fin = 1;
    //       this.blocks(this.buffer, 0, 16);
    //     }
    
    //     c = this.h[1] >>> 13;
    //     this.h[1] &= 0x1fff;
    //     for (i = 2; i < 10; i++) {
    //       this.h[i] += c;
    //       c = this.h[i] >>> 13;
    //       this.h[i] &= 0x1fff;
    //     }
    //     this.h[0] += (c * 5);
    //     c = this.h[0] >>> 13;
    //     this.h[0] &= 0x1fff;
    //     this.h[1] += c;
    //     c = this.h[1] >>> 13;
    //     this.h[1] &= 0x1fff;
    //     this.h[2] += c;
    
    //     g[0] = this.h[0] + 5;
    //     c = g[0] >>> 13;
    //     g[0] &= 0x1fff;
    //     for (i = 1; i < 10; i++) {
    //       g[i] = this.h[i] + c;
    //       c = g[i] >>> 13;
    //       g[i] &= 0x1fff;
    //     }
    //     g[9] -= (1 << 13);
    
    //     mask = (c ^ 1) - 1;
    //     for (i = 0; i < 10; i++) g[i] &= mask;
    //     mask = ~mask;
    //     for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];
    
    //     this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
    //     this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
    //     this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
    //     this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
    //     this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
    //     this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
    //     this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
    //     this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;
    
    //     f = this.h[0] + this.pad[0];
    //     this.h[0] = f & 0xffff;
    //     for (i = 1; i < 8; i++) {
    //       f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    //       this.h[i] = f & 0xffff;
    //     }
    
    //     mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
    //     mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
    //     mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
    //     mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
    //     mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
    //     mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
    //     mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
    //     mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
    //     mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
    //     mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
    //     mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
    //     mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
    //     mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
    //     mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
    //     mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
    //     mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
    //   };
    
    //   poly1305.prototype.update = function(m, mpos, bytes) {
    //     var i, want;
    
    //     if (this.leftover) {
    //       want = (16 - this.leftover);
    //       if (want > bytes)
    //         want = bytes;
    //       for (i = 0; i < want; i++)
    //         this.buffer[this.leftover + i] = m[mpos+i];
    //       bytes -= want;
    //       mpos += want;
    //       this.leftover += want;
    //       if (this.leftover < 16)
    //         return;
    //       this.blocks(this.buffer, 0, 16);
    //       this.leftover = 0;
    //     }
    
    //     if (bytes >= 16) {
    //       want = bytes - (bytes % 16);
    //       this.blocks(m, mpos, want);
    //       mpos += want;
    //       bytes -= want;
    //     }
    
    //     if (bytes) {
    //       for (i = 0; i < bytes; i++)
    //         this.buffer[this.leftover + i] = m[mpos+i];
    //       this.leftover += bytes;
    //     }
    //   };
    
    //   function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
    //     var s = new poly1305(k);
    //     s.update(m, mpos, n);
    //     s.finish(out, outpos);
    //     return 0;
    //   }
    
    //   function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
    //     var x = new Uint8Array(16);
    //     crypto_onetimeauth(x,0,m,mpos,n,k);
    //     return crypto_verify_16(h,hpos,x,0);
    //   }
    
    //   function crypto_secretbox(c,m,d,n,k) {
    //     var i;
    //     if (d < 32) return -1;
    //     crypto_stream_xor(c,0,m,0,d,n,k);
    //     crypto_onetimeauth(c, 16, c, 32, d - 32, c);
    //     for (i = 0; i < 16; i++) c[i] = 0;
    //     return 0;
    //   }
    
    //   function crypto_secretbox_open(m,c,d,n,k) {
    //     var i;
    //     var x = new Uint8Array(32);
    //     if (d < 32) return -1;
    //     crypto_stream(x,0,32,n,k);
    //     if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
    //     crypto_stream_xor(m,0,c,0,d,n,k);
    //     for (i = 0; i < 32; i++) m[i] = 0;
    //     return 0;
    //   }
    
    //   function set25519(r, a) {
    //     var i;
    //     for (i = 0; i < 16; i++) r[i] = a[i]|0;
    //   }
    
    //   function car25519(o) {
    //     var i, v, c = 1;
    //     for (i = 0; i < 16; i++) {
    //       v = o[i] + c + 65535;
    //       c = Math.floor(v / 65536);
    //       o[i] = v - c * 65536;
    //     }
    //     o[0] += c-1 + 37 * (c-1);
    //   }
    
    //   function sel25519(p, q, b) {
    //     var t, c = ~(b-1);
    //     for (var i = 0; i < 16; i++) {
    //       t = c & (p[i] ^ q[i]);
    //       p[i] ^= t;
    //       q[i] ^= t;
    //     }
    //   }
    
    //   function pack25519(o, n) {
    //     var i, j, b;
    //     var m = gf(), t = gf();
    //     for (i = 0; i < 16; i++) t[i] = n[i];
    //     car25519(t);
    //     car25519(t);
    //     car25519(t);
    //     for (j = 0; j < 2; j++) {
    //       m[0] = t[0] - 0xffed;
    //       for (i = 1; i < 15; i++) {
    //         m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
    //         m[i-1] &= 0xffff;
    //       }
    //       m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    //       b = (m[15]>>16) & 1;
    //       m[14] &= 0xffff;
    //       sel25519(t, m, 1-b);
    //     }
    //     for (i = 0; i < 16; i++) {
    //       o[2*i] = t[i] & 0xff;
    //       o[2*i+1] = t[i]>>8;
    //     }
    //   }
    
    //   function neq25519(a, b) {
    //     var c = new Uint8Array(32), d = new Uint8Array(32);
    //     pack25519(c, a);
    //     pack25519(d, b);
    //     return crypto_verify_32(c, 0, d, 0);
    //   }
    
    //   function par25519(a) {
    //     var d = new Uint8Array(32);
    //     pack25519(d, a);
    //     return d[0] & 1;
    //   }
    
    //   function unpack25519(o, n) {
    //     var i;
    //     for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
    //     o[15] &= 0x7fff;
    //   }
    
    //   function A(o, a, b) {
    //     for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
    //   }
    
    //   function Z(o, a, b) {
    //     for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
    //   }
    
    //   function M(o, a, b) {
    //     var v, c,
    //        t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
    //        t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    //       t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    //       t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    //       b0 = b[0],
    //       b1 = b[1],
    //       b2 = b[2],
    //       b3 = b[3],
    //       b4 = b[4],
    //       b5 = b[5],
    //       b6 = b[6],
    //       b7 = b[7],
    //       b8 = b[8],
    //       b9 = b[9],
    //       b10 = b[10],
    //       b11 = b[11],
    //       b12 = b[12],
    //       b13 = b[13],
    //       b14 = b[14],
    //       b15 = b[15];
    
    //     v = a[0];
    //     t0 += v * b0;
    //     t1 += v * b1;
    //     t2 += v * b2;
    //     t3 += v * b3;
    //     t4 += v * b4;
    //     t5 += v * b5;
    //     t6 += v * b6;
    //     t7 += v * b7;
    //     t8 += v * b8;
    //     t9 += v * b9;
    //     t10 += v * b10;
    //     t11 += v * b11;
    //     t12 += v * b12;
    //     t13 += v * b13;
    //     t14 += v * b14;
    //     t15 += v * b15;
    //     v = a[1];
    //     t1 += v * b0;
    //     t2 += v * b1;
    //     t3 += v * b2;
    //     t4 += v * b3;
    //     t5 += v * b4;
    //     t6 += v * b5;
    //     t7 += v * b6;
    //     t8 += v * b7;
    //     t9 += v * b8;
    //     t10 += v * b9;
    //     t11 += v * b10;
    //     t12 += v * b11;
    //     t13 += v * b12;
    //     t14 += v * b13;
    //     t15 += v * b14;
    //     t16 += v * b15;
    //     v = a[2];
    //     t2 += v * b0;
    //     t3 += v * b1;
    //     t4 += v * b2;
    //     t5 += v * b3;
    //     t6 += v * b4;
    //     t7 += v * b5;
    //     t8 += v * b6;
    //     t9 += v * b7;
    //     t10 += v * b8;
    //     t11 += v * b9;
    //     t12 += v * b10;
    //     t13 += v * b11;
    //     t14 += v * b12;
    //     t15 += v * b13;
    //     t16 += v * b14;
    //     t17 += v * b15;
    //     v = a[3];
    //     t3 += v * b0;
    //     t4 += v * b1;
    //     t5 += v * b2;
    //     t6 += v * b3;
    //     t7 += v * b4;
    //     t8 += v * b5;
    //     t9 += v * b6;
    //     t10 += v * b7;
    //     t11 += v * b8;
    //     t12 += v * b9;
    //     t13 += v * b10;
    //     t14 += v * b11;
    //     t15 += v * b12;
    //     t16 += v * b13;
    //     t17 += v * b14;
    //     t18 += v * b15;
    //     v = a[4];
    //     t4 += v * b0;
    //     t5 += v * b1;
    //     t6 += v * b2;
    //     t7 += v * b3;
    //     t8 += v * b4;
    //     t9 += v * b5;
    //     t10 += v * b6;
    //     t11 += v * b7;
    //     t12 += v * b8;
    //     t13 += v * b9;
    //     t14 += v * b10;
    //     t15 += v * b11;
    //     t16 += v * b12;
    //     t17 += v * b13;
    //     t18 += v * b14;
    //     t19 += v * b15;
    //     v = a[5];
    //     t5 += v * b0;
    //     t6 += v * b1;
    //     t7 += v * b2;
    //     t8 += v * b3;
    //     t9 += v * b4;
    //     t10 += v * b5;
    //     t11 += v * b6;
    //     t12 += v * b7;
    //     t13 += v * b8;
    //     t14 += v * b9;
    //     t15 += v * b10;
    //     t16 += v * b11;
    //     t17 += v * b12;
    //     t18 += v * b13;
    //     t19 += v * b14;
    //     t20 += v * b15;
    //     v = a[6];
    //     t6 += v * b0;
    //     t7 += v * b1;
    //     t8 += v * b2;
    //     t9 += v * b3;
    //     t10 += v * b4;
    //     t11 += v * b5;
    //     t12 += v * b6;
    //     t13 += v * b7;
    //     t14 += v * b8;
    //     t15 += v * b9;
    //     t16 += v * b10;
    //     t17 += v * b11;
    //     t18 += v * b12;
    //     t19 += v * b13;
    //     t20 += v * b14;
    //     t21 += v * b15;
    //     v = a[7];
    //     t7 += v * b0;
    //     t8 += v * b1;
    //     t9 += v * b2;
    //     t10 += v * b3;
    //     t11 += v * b4;
    //     t12 += v * b5;
    //     t13 += v * b6;
    //     t14 += v * b7;
    //     t15 += v * b8;
    //     t16 += v * b9;
    //     t17 += v * b10;
    //     t18 += v * b11;
    //     t19 += v * b12;
    //     t20 += v * b13;
    //     t21 += v * b14;
    //     t22 += v * b15;
    //     v = a[8];
    //     t8 += v * b0;
    //     t9 += v * b1;
    //     t10 += v * b2;
    //     t11 += v * b3;
    //     t12 += v * b4;
    //     t13 += v * b5;
    //     t14 += v * b6;
    //     t15 += v * b7;
    //     t16 += v * b8;
    //     t17 += v * b9;
    //     t18 += v * b10;
    //     t19 += v * b11;
    //     t20 += v * b12;
    //     t21 += v * b13;
    //     t22 += v * b14;
    //     t23 += v * b15;
    //     v = a[9];
    //     t9 += v * b0;
    //     t10 += v * b1;
    //     t11 += v * b2;
    //     t12 += v * b3;
    //     t13 += v * b4;
    //     t14 += v * b5;
    //     t15 += v * b6;
    //     t16 += v * b7;
    //     t17 += v * b8;
    //     t18 += v * b9;
    //     t19 += v * b10;
    //     t20 += v * b11;
    //     t21 += v * b12;
    //     t22 += v * b13;
    //     t23 += v * b14;
    //     t24 += v * b15;
    //     v = a[10];
    //     t10 += v * b0;
    //     t11 += v * b1;
    //     t12 += v * b2;
    //     t13 += v * b3;
    //     t14 += v * b4;
    //     t15 += v * b5;
    //     t16 += v * b6;
    //     t17 += v * b7;
    //     t18 += v * b8;
    //     t19 += v * b9;
    //     t20 += v * b10;
    //     t21 += v * b11;
    //     t22 += v * b12;
    //     t23 += v * b13;
    //     t24 += v * b14;
    //     t25 += v * b15;
    //     v = a[11];
    //     t11 += v * b0;
    //     t12 += v * b1;
    //     t13 += v * b2;
    //     t14 += v * b3;
    //     t15 += v * b4;
    //     t16 += v * b5;
    //     t17 += v * b6;
    //     t18 += v * b7;
    //     t19 += v * b8;
    //     t20 += v * b9;
    //     t21 += v * b10;
    //     t22 += v * b11;
    //     t23 += v * b12;
    //     t24 += v * b13;
    //     t25 += v * b14;
    //     t26 += v * b15;
    //     v = a[12];
    //     t12 += v * b0;
    //     t13 += v * b1;
    //     t14 += v * b2;
    //     t15 += v * b3;
    //     t16 += v * b4;
    //     t17 += v * b5;
    //     t18 += v * b6;
    //     t19 += v * b7;
    //     t20 += v * b8;
    //     t21 += v * b9;
    //     t22 += v * b10;
    //     t23 += v * b11;
    //     t24 += v * b12;
    //     t25 += v * b13;
    //     t26 += v * b14;
    //     t27 += v * b15;
    //     v = a[13];
    //     t13 += v * b0;
    //     t14 += v * b1;
    //     t15 += v * b2;
    //     t16 += v * b3;
    //     t17 += v * b4;
    //     t18 += v * b5;
    //     t19 += v * b6;
    //     t20 += v * b7;
    //     t21 += v * b8;
    //     t22 += v * b9;
    //     t23 += v * b10;
    //     t24 += v * b11;
    //     t25 += v * b12;
    //     t26 += v * b13;
    //     t27 += v * b14;
    //     t28 += v * b15;
    //     v = a[14];
    //     t14 += v * b0;
    //     t15 += v * b1;
    //     t16 += v * b2;
    //     t17 += v * b3;
    //     t18 += v * b4;
    //     t19 += v * b5;
    //     t20 += v * b6;
    //     t21 += v * b7;
    //     t22 += v * b8;
    //     t23 += v * b9;
    //     t24 += v * b10;
    //     t25 += v * b11;
    //     t26 += v * b12;
    //     t27 += v * b13;
    //     t28 += v * b14;
    //     t29 += v * b15;
    //     v = a[15];
    //     t15 += v * b0;
    //     t16 += v * b1;
    //     t17 += v * b2;
    //     t18 += v * b3;
    //     t19 += v * b4;
    //     t20 += v * b5;
    //     t21 += v * b6;
    //     t22 += v * b7;
    //     t23 += v * b8;
    //     t24 += v * b9;
    //     t25 += v * b10;
    //     t26 += v * b11;
    //     t27 += v * b12;
    //     t28 += v * b13;
    //     t29 += v * b14;
    //     t30 += v * b15;
    
    //     t0  += 38 * t16;
    //     t1  += 38 * t17;
    //     t2  += 38 * t18;
    //     t3  += 38 * t19;
    //     t4  += 38 * t20;
    //     t5  += 38 * t21;
    //     t6  += 38 * t22;
    //     t7  += 38 * t23;
    //     t8  += 38 * t24;
    //     t9  += 38 * t25;
    //     t10 += 38 * t26;
    //     t11 += 38 * t27;
    //     t12 += 38 * t28;
    //     t13 += 38 * t29;
    //     t14 += 38 * t30;
    //     // t15 left as is
    
    //     // first car
    //     c = 1;
    //     v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
    //     v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
    //     v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
    //     v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
    //     v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
    //     v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
    //     v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
    //     v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
    //     v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
    //     v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
    //     v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
    //     v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
    //     v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
    //     v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
    //     v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
    //     v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
    //     t0 += c-1 + 37 * (c-1);
    
    //     // second car
    //     c = 1;
    //     v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
    //     v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
    //     v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
    //     v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
    //     v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
    //     v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
    //     v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
    //     v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
    //     v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
    //     v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
    //     v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
    //     v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
    //     v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
    //     v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
    //     v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
    //     v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
    //     t0 += c-1 + 37 * (c-1);
    
    //     o[ 0] = t0;
    //     o[ 1] = t1;
    //     o[ 2] = t2;
    //     o[ 3] = t3;
    //     o[ 4] = t4;
    //     o[ 5] = t5;
    //     o[ 6] = t6;
    //     o[ 7] = t7;
    //     o[ 8] = t8;
    //     o[ 9] = t9;
    //     o[10] = t10;
    //     o[11] = t11;
    //     o[12] = t12;
    //     o[13] = t13;
    //     o[14] = t14;
    //     o[15] = t15;
    //   }
    
    //   function S(o, a) {
    //     M(o, a, a);
    //   }
    
    //   function inv25519(o, i) {
    //     var c = gf();
    //     var a;
    //     for (a = 0; a < 16; a++) c[a] = i[a];
    //     for (a = 253; a >= 0; a--) {
    //       S(c, c);
    //       if(a !== 2 && a !== 4) M(c, c, i);
    //     }
    //     for (a = 0; a < 16; a++) o[a] = c[a];
    //   }
    
    //   function pow2523(o, i) {
    //     var c = gf();
    //     var a;
    //     for (a = 0; a < 16; a++) c[a] = i[a];
    //     for (a = 250; a >= 0; a--) {
    //         S(c, c);
    //         if(a !== 1) M(c, c, i);
    //     }
    //     for (a = 0; a < 16; a++) o[a] = c[a];
    //   }
    
    //   function crypto_scalarmult(q, n, p) {
    //     var z = new Uint8Array(32);
    //     var x = new Float64Array(80), r, i;
    //     var a = gf(), b = gf(), c = gf(),
    //         d = gf(), e = gf(), f = gf();
    //     for (i = 0; i < 31; i++) z[i] = n[i];
    //     z[31]=(n[31]&127)|64;
    //     z[0]&=248;
    //     unpack25519(x,p);
    //     for (i = 0; i < 16; i++) {
    //       b[i]=x[i];
    //       d[i]=a[i]=c[i]=0;
    //     }
    //     a[0]=d[0]=1;
    //     for (i=254; i>=0; --i) {
    //       r=(z[i>>>3]>>>(i&7))&1;
    //       sel25519(a,b,r);
    //       sel25519(c,d,r);
    //       A(e,a,c);
    //       Z(a,a,c);
    //       A(c,b,d);
    //       Z(b,b,d);
    //       S(d,e);
    //       S(f,a);
    //       M(a,c,a);
    //       M(c,b,e);
    //       A(e,a,c);
    //       Z(a,a,c);
    //       S(b,a);
    //       Z(c,d,f);
    //       M(a,c,_121665);
    //       A(a,a,d);
    //       M(c,c,a);
    //       M(a,d,f);
    //       M(d,b,x);
    //       S(b,e);
    //       sel25519(a,b,r);
    //       sel25519(c,d,r);
    //     }
    //     for (i = 0; i < 16; i++) {
    //       x[i+16]=a[i];
    //       x[i+32]=c[i];
    //       x[i+48]=b[i];
    //       x[i+64]=d[i];
    //     }
    //     var x32 = x.subarray(32);
    //     var x16 = x.subarray(16);
    //     inv25519(x32,x32);
    //     M(x16,x16,x32);
    //     pack25519(q,x16);
    //     return 0;
    //   }
    
    //   function crypto_scalarmult_base(q, n) {
    //     return crypto_scalarmult(q, n, _9);
    //   }
    
    //   function crypto_box_keypair(y, x) {
    //     randombytes(x, 32);
    //     return crypto_scalarmult_base(y, x);
    //   }
    
    //   function crypto_box_beforenm(k, y, x) {
    //     var s = new Uint8Array(32);
    //     crypto_scalarmult(s, x, y);
    //     return crypto_core_hsalsa20(k, _0, s, sigma);
    //   }
    
    //   var crypto_box_afternm = crypto_secretbox;
    //   var crypto_box_open_afternm = crypto_secretbox_open;
    
    //   function crypto_box(c, m, d, n, y, x) {
    //     var k = new Uint8Array(32);
    //     crypto_box_beforenm(k, y, x);
    //     return crypto_box_afternm(c, m, d, n, k);
    //   }
    
    //   function crypto_box_open(m, c, d, n, y, x) {
    //     var k = new Uint8Array(32);
    //     crypto_box_beforenm(k, y, x);
    //     return crypto_box_open_afternm(m, c, d, n, k);
    //   }
    
    //   var K = [
    //     0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
    //     0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
    //     0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
    //     0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
    //     0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
    //     0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
    //     0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
    //     0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
    //     0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
    //     0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
    //     0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
    //     0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
    //     0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
    //     0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
    //     0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
    //     0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
    //     0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
    //     0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
    //     0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
    //     0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
    //     0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
    //     0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
    //     0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
    //     0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
    //     0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
    //     0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
    //     0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
    //     0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
    //     0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
    //     0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
    //     0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
    //     0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
    //     0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
    //     0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
    //     0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
    //     0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
    //     0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
    //     0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
    //     0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
    //     0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
    //   ];
    
    //   function crypto_hashblocks_hl(hh, hl, m, n) {
    //     var wh = new Int32Array(16), wl = new Int32Array(16),
    //         bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
    //         bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
    //         th, tl, i, j, h, l, a, b, c, d;
    
    //     var ah0 = hh[0],
    //         ah1 = hh[1],
    //         ah2 = hh[2],
    //         ah3 = hh[3],
    //         ah4 = hh[4],
    //         ah5 = hh[5],
    //         ah6 = hh[6],
    //         ah7 = hh[7],
    
    //         al0 = hl[0],
    //         al1 = hl[1],
    //         al2 = hl[2],
    //         al3 = hl[3],
    //         al4 = hl[4],
    //         al5 = hl[5],
    //         al6 = hl[6],
    //         al7 = hl[7];
    
    //     var pos = 0;
    //     while (n >= 128) {
    //       for (i = 0; i < 16; i++) {
    //         j = 8 * i + pos;
    //         wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
    //         wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    //       }
    //       for (i = 0; i < 80; i++) {
    //         bh0 = ah0;
    //         bh1 = ah1;
    //         bh2 = ah2;
    //         bh3 = ah3;
    //         bh4 = ah4;
    //         bh5 = ah5;
    //         bh6 = ah6;
    //         bh7 = ah7;
    
    //         bl0 = al0;
    //         bl1 = al1;
    //         bl2 = al2;
    //         bl3 = al3;
    //         bl4 = al4;
    //         bl5 = al5;
    //         bl6 = al6;
    //         bl7 = al7;
    
    //         // add
    //         h = ah7;
    //         l = al7;
    
    //         a = l & 0xffff; b = l >>> 16;
    //         c = h & 0xffff; d = h >>> 16;
    
    //         // Sigma1
    //         h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
    //         l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));
    
    //         a += l & 0xffff; b += l >>> 16;
    //         c += h & 0xffff; d += h >>> 16;
    
    //         // Ch
    //         h = (ah4 & ah5) ^ (~ah4 & ah6);
    //         l = (al4 & al5) ^ (~al4 & al6);
    
    //         a += l & 0xffff; b += l >>> 16;
    //         c += h & 0xffff; d += h >>> 16;
    
    //         // K
    //         h = K[i*2];
    //         l = K[i*2+1];
    
    //         a += l & 0xffff; b += l >>> 16;
    //         c += h & 0xffff; d += h >>> 16;
    
    //         // w
    //         h = wh[i%16];
    //         l = wl[i%16];
    
    //         a += l & 0xffff; b += l >>> 16;
    //         c += h & 0xffff; d += h >>> 16;
    
    //         b += a >>> 16;
    //         c += b >>> 16;
    //         d += c >>> 16;
    
    //         th = c & 0xffff | d << 16;
    //         tl = a & 0xffff | b << 16;
    
    //         // add
    //         h = th;
    //         l = tl;
    
    //         a = l & 0xffff; b = l >>> 16;
    //         c = h & 0xffff; d = h >>> 16;
    
    //         // Sigma0
    //         h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
    //         l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));
    
    //         a += l & 0xffff; b += l >>> 16;
    //         c += h & 0xffff; d += h >>> 16;
    
    //         // Maj
    //         h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
    //         l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);
    
    //         a += l & 0xffff; b += l >>> 16;
    //         c += h & 0xffff; d += h >>> 16;
    
    //         b += a >>> 16;
    //         c += b >>> 16;
    //         d += c >>> 16;
    
    //         bh7 = (c & 0xffff) | (d << 16);
    //         bl7 = (a & 0xffff) | (b << 16);
    
    //         // add
    //         h = bh3;
    //         l = bl3;
    
    //         a = l & 0xffff; b = l >>> 16;
    //         c = h & 0xffff; d = h >>> 16;
    
    //         h = th;
    //         l = tl;
    
    //         a += l & 0xffff; b += l >>> 16;
    //         c += h & 0xffff; d += h >>> 16;
    
    //         b += a >>> 16;
    //         c += b >>> 16;
    //         d += c >>> 16;
    
    //         bh3 = (c & 0xffff) | (d << 16);
    //         bl3 = (a & 0xffff) | (b << 16);
    
    //         ah1 = bh0;
    //         ah2 = bh1;
    //         ah3 = bh2;
    //         ah4 = bh3;
    //         ah5 = bh4;
    //         ah6 = bh5;
    //         ah7 = bh6;
    //         ah0 = bh7;
    
    //         al1 = bl0;
    //         al2 = bl1;
    //         al3 = bl2;
    //         al4 = bl3;
    //         al5 = bl4;
    //         al6 = bl5;
    //         al7 = bl6;
    //         al0 = bl7;
    
    //         if (i%16 === 15) {
    //           for (j = 0; j < 16; j++) {
    //             // add
    //             h = wh[j];
    //             l = wl[j];
    
    //             a = l & 0xffff; b = l >>> 16;
    //             c = h & 0xffff; d = h >>> 16;
    
    //             h = wh[(j+9)%16];
    //             l = wl[(j+9)%16];
    
    //             a += l & 0xffff; b += l >>> 16;
    //             c += h & 0xffff; d += h >>> 16;
    
    //             // sigma0
    //             th = wh[(j+1)%16];
    //             tl = wl[(j+1)%16];
    //             h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
    //             l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));
    
    //             a += l & 0xffff; b += l >>> 16;
    //             c += h & 0xffff; d += h >>> 16;
    
    //             // sigma1
    //             th = wh[(j+14)%16];
    //             tl = wl[(j+14)%16];
    //             h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
    //             l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));
    
    //             a += l & 0xffff; b += l >>> 16;
    //             c += h & 0xffff; d += h >>> 16;
    
    //             b += a >>> 16;
    //             c += b >>> 16;
    //             d += c >>> 16;
    
    //             wh[j] = (c & 0xffff) | (d << 16);
    //             wl[j] = (a & 0xffff) | (b << 16);
    //           }
    //         }
    //       }
    
    //       // add
    //       h = ah0;
    //       l = al0;
    
    //       a = l & 0xffff; b = l >>> 16;
    //       c = h & 0xffff; d = h >>> 16;
    
    //       h = hh[0];
    //       l = hl[0];
    
    //       a += l & 0xffff; b += l >>> 16;
    //       c += h & 0xffff; d += h >>> 16;
    
    //       b += a >>> 16;
    //       c += b >>> 16;
    //       d += c >>> 16;
    
    //       hh[0] = ah0 = (c & 0xffff) | (d << 16);
    //       hl[0] = al0 = (a & 0xffff) | (b << 16);
    
    //       h = ah1;
    //       l = al1;
    
    //       a = l & 0xffff; b = l >>> 16;
    //       c = h & 0xffff; d = h >>> 16;
    
    //       h = hh[1];
    //       l = hl[1];
    
    //       a += l & 0xffff; b += l >>> 16;
    //       c += h & 0xffff; d += h >>> 16;
    
    //       b += a >>> 16;
    //       c += b >>> 16;
    //       d += c >>> 16;
    
    //       hh[1] = ah1 = (c & 0xffff) | (d << 16);
    //       hl[1] = al1 = (a & 0xffff) | (b << 16);
    
    //       h = ah2;
    //       l = al2;
    
    //       a = l & 0xffff; b = l >>> 16;
    //       c = h & 0xffff; d = h >>> 16;
    
    //       h = hh[2];
    //       l = hl[2];
    
    //       a += l & 0xffff; b += l >>> 16;
    //       c += h & 0xffff; d += h >>> 16;
    
    //       b += a >>> 16;
    //       c += b >>> 16;
    //       d += c >>> 16;
    
    //       hh[2] = ah2 = (c & 0xffff) | (d << 16);
    //       hl[2] = al2 = (a & 0xffff) | (b << 16);
    
    //       h = ah3;
    //       l = al3;
    
    //       a = l & 0xffff; b = l >>> 16;
    //       c = h & 0xffff; d = h >>> 16;
    
    //       h = hh[3];
    //       l = hl[3];
    
    //       a += l & 0xffff; b += l >>> 16;
    //       c += h & 0xffff; d += h >>> 16;
    
    //       b += a >>> 16;
    //       c += b >>> 16;
    //       d += c >>> 16;
    
    //       hh[3] = ah3 = (c & 0xffff) | (d << 16);
    //       hl[3] = al3 = (a & 0xffff) | (b << 16);
    
    //       h = ah4;
    //       l = al4;
    
    //       a = l & 0xffff; b = l >>> 16;
    //       c = h & 0xffff; d = h >>> 16;
    
    //       h = hh[4];
    //       l = hl[4];
    
    //       a += l & 0xffff; b += l >>> 16;
    //       c += h & 0xffff; d += h >>> 16;
    
    //       b += a >>> 16;
    //       c += b >>> 16;
    //       d += c >>> 16;
    
    //       hh[4] = ah4 = (c & 0xffff) | (d << 16);
    //       hl[4] = al4 = (a & 0xffff) | (b << 16);
    
    //       h = ah5;
    //       l = al5;
    
    //       a = l & 0xffff; b = l >>> 16;
    //       c = h & 0xffff; d = h >>> 16;
    
    //       h = hh[5];
    //       l = hl[5];
    
    //       a += l & 0xffff; b += l >>> 16;
    //       c += h & 0xffff; d += h >>> 16;
    
    //       b += a >>> 16;
    //       c += b >>> 16;
    //       d += c >>> 16;
    
    //       hh[5] = ah5 = (c & 0xffff) | (d << 16);
    //       hl[5] = al5 = (a & 0xffff) | (b << 16);
    
    //       h = ah6;
    //       l = al6;
    
    //       a = l & 0xffff; b = l >>> 16;
    //       c = h & 0xffff; d = h >>> 16;
    
    //       h = hh[6];
    //       l = hl[6];
    
    //       a += l & 0xffff; b += l >>> 16;
    //       c += h & 0xffff; d += h >>> 16;
    
    //       b += a >>> 16;
    //       c += b >>> 16;
    //       d += c >>> 16;
    
    //       hh[6] = ah6 = (c & 0xffff) | (d << 16);
    //       hl[6] = al6 = (a & 0xffff) | (b << 16);
    
    //       h = ah7;
    //       l = al7;
    
    //       a = l & 0xffff; b = l >>> 16;
    //       c = h & 0xffff; d = h >>> 16;
    
    //       h = hh[7];
    //       l = hl[7];
    
    //       a += l & 0xffff; b += l >>> 16;
    //       c += h & 0xffff; d += h >>> 16;
    
    //       b += a >>> 16;
    //       c += b >>> 16;
    //       d += c >>> 16;
    
    //       hh[7] = ah7 = (c & 0xffff) | (d << 16);
    //       hl[7] = al7 = (a & 0xffff) | (b << 16);
    
    //       pos += 128;
    //       n -= 128;
    //     }
    
    //     return n;
    //   }
    
    //   function crypto_hash(out, m, n) {
    //     var hh = new Int32Array(8),
    //         hl = new Int32Array(8),
    //         x = new Uint8Array(256),
    //         i, b = n;
    
    //     hh[0] = 0x6a09e667;
    //     hh[1] = 0xbb67ae85;
    //     hh[2] = 0x3c6ef372;
    //     hh[3] = 0xa54ff53a;
    //     hh[4] = 0x510e527f;
    //     hh[5] = 0x9b05688c;
    //     hh[6] = 0x1f83d9ab;
    //     hh[7] = 0x5be0cd19;
    
    //     hl[0] = 0xf3bcc908;
    //     hl[1] = 0x84caa73b;
    //     hl[2] = 0xfe94f82b;
    //     hl[3] = 0x5f1d36f1;
    //     hl[4] = 0xade682d1;
    //     hl[5] = 0x2b3e6c1f;
    //     hl[6] = 0xfb41bd6b;
    //     hl[7] = 0x137e2179;
    
    //     crypto_hashblocks_hl(hh, hl, m, n);
    //     n %= 128;
    
    //     for (i = 0; i < n; i++) x[i] = m[b-n+i];
    //     x[n] = 128;
    
    //     n = 256-128*(n<112?1:0);
    //     x[n-9] = 0;
    //     ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
    //     crypto_hashblocks_hl(hh, hl, x, n);
    
    //     for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);
    
    //     return 0;
    //   }
    
    //   function add(p, q) {
    //     var a = gf(), b = gf(), c = gf(),
    //         d = gf(), e = gf(), f = gf(),
    //         g = gf(), h = gf(), t = gf();
    
    //     Z(a, p[1], p[0]);
    //     Z(t, q[1], q[0]);
    //     M(a, a, t);
    //     A(b, p[0], p[1]);
    //     A(t, q[0], q[1]);
    //     M(b, b, t);
    //     M(c, p[3], q[3]);
    //     M(c, c, D2);
    //     M(d, p[2], q[2]);
    //     A(d, d, d);
    //     Z(e, b, a);
    //     Z(f, d, c);
    //     A(g, d, c);
    //     A(h, b, a);
    
    //     M(p[0], e, f);
    //     M(p[1], h, g);
    //     M(p[2], g, f);
    //     M(p[3], e, h);
    //   }
    
    //   function cswap(p, q, b) {
    //     var i;
    //     for (i = 0; i < 4; i++) {
    //       sel25519(p[i], q[i], b);
    //     }
    //   }
    
    //   function pack(r, p) {
    //     var tx = gf(), ty = gf(), zi = gf();
    //     inv25519(zi, p[2]);
    //     M(tx, p[0], zi);
    //     M(ty, p[1], zi);
    //     pack25519(r, ty);
    //     r[31] ^= par25519(tx) << 7;
    //   }
    
    //   function scalarmult(p, q, s) {
    //     var b, i;
    //     set25519(p[0], gf0);
    //     set25519(p[1], gf1);
    //     set25519(p[2], gf1);
    //     set25519(p[3], gf0);
    //     for (i = 255; i >= 0; --i) {
    //       b = (s[(i/8)|0] >> (i&7)) & 1;
    //       cswap(p, q, b);
    //       add(q, p);
    //       add(p, p);
    //       cswap(p, q, b);
    //     }
    //   }
    
    //   function scalarbase(p, s) {
    //     var q = [gf(), gf(), gf(), gf()];
    //     set25519(q[0], X);
    //     set25519(q[1], Y);
    //     set25519(q[2], gf1);
    //     M(q[3], X, Y);
    //     scalarmult(p, q, s);
    //   }
    
    //   function crypto_sign_keypair(pk, sk, seeded) {
    //     var d = new Uint8Array(64);
    //     var p = [gf(), gf(), gf(), gf()];
    //     var i;
    
    //     if (!seeded) randombytes(sk, 32);
    //     crypto_hash(d, sk, 32);
    //     d[0] &= 248;
    //     d[31] &= 127;
    //     d[31] |= 64;
    
    //     scalarbase(p, d);
    //     pack(pk, p);
    
    //     for (i = 0; i < 32; i++) sk[i+32] = pk[i];
    //     return 0;
    //   }
    
    //   var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);
    
    //   function modL(r, x) {
    //     var carry, i, j, k;
    //     for (i = 63; i >= 32; --i) {
    //       carry = 0;
    //       for (j = i - 32, k = i - 12; j < k; ++j) {
    //         x[j] += carry - 16 * x[i] * L[j - (i - 32)];
    //         carry = Math.floor((x[j] + 128) / 256);
    //         x[j] -= carry * 256;
    //       }
    //       x[j] += carry;
    //       x[i] = 0;
    //     }
    //     carry = 0;
    //     for (j = 0; j < 32; j++) {
    //       x[j] += carry - (x[31] >> 4) * L[j];
    //       carry = x[j] >> 8;
    //       x[j] &= 255;
    //     }
    //     for (j = 0; j < 32; j++) x[j] -= carry * L[j];
    //     for (i = 0; i < 32; i++) {
    //       x[i+1] += x[i] >> 8;
    //       r[i] = x[i] & 255;
    //     }
    //   }
    
    //   function reduce(r) {
    //     var x = new Float64Array(64), i;
    //     for (i = 0; i < 64; i++) x[i] = r[i];
    //     for (i = 0; i < 64; i++) r[i] = 0;
    //     modL(r, x);
    //   }
    
    //   // Note: difference from C - smlen returned, not passed as argument.
    //   function crypto_sign(sm, m, n, sk) {
    //     var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
    //     var i, j, x = new Float64Array(64);
    //     var p = [gf(), gf(), gf(), gf()];
    
    //     crypto_hash(d, sk, 32);
    //     d[0] &= 248;
    //     d[31] &= 127;
    //     d[31] |= 64;
    
    //     var smlen = n + 64;
    //     for (i = 0; i < n; i++) sm[64 + i] = m[i];
    //     for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
    
    //     crypto_hash(r, sm.subarray(32), n+32);
    //     reduce(r);
    //     scalarbase(p, r);
    //     pack(sm, p);
    
    //     for (i = 32; i < 64; i++) sm[i] = sk[i];
    //     crypto_hash(h, sm, n + 64);
    //     reduce(h);
    
    //     for (i = 0; i < 64; i++) x[i] = 0;
    //     for (i = 0; i < 32; i++) x[i] = r[i];
    //     for (i = 0; i < 32; i++) {
    //       for (j = 0; j < 32; j++) {
    //         x[i+j] += h[i] * d[j];
    //       }
    //     }
    
    //     modL(sm.subarray(32), x);
    //     return smlen;
    //   }
    
    //   function unpackneg(r, p) {
    //     var t = gf(), chk = gf(), num = gf(),
    //         den = gf(), den2 = gf(), den4 = gf(),
    //         den6 = gf();
    
    //     set25519(r[2], gf1);
    //     unpack25519(r[1], p);
    //     S(num, r[1]);
    //     M(den, num, D);
    //     Z(num, num, r[2]);
    //     A(den, r[2], den);
    
    //     S(den2, den);
    //     S(den4, den2);
    //     M(den6, den4, den2);
    //     M(t, den6, num);
    //     M(t, t, den);
    
    //     pow2523(t, t);
    //     M(t, t, num);
    //     M(t, t, den);
    //     M(t, t, den);
    //     M(r[0], t, den);
    
    //     S(chk, r[0]);
    //     M(chk, chk, den);
    //     if (neq25519(chk, num)) M(r[0], r[0], I);
    
    //     S(chk, r[0]);
    //     M(chk, chk, den);
    //     if (neq25519(chk, num)) return -1;
    
    //     if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);
    
    //     M(r[3], r[0], r[1]);
    //     return 0;
    //   }
    
    //   function crypto_sign_open(m, sm, n, pk) {
    //     var i;
    //     var t = new Uint8Array(32), h = new Uint8Array(64);
    //     var p = [gf(), gf(), gf(), gf()],
    //         q = [gf(), gf(), gf(), gf()];
    
    //     if (n < 64) return -1;
    
    //     if (unpackneg(q, pk)) return -1;
    
    //     for (i = 0; i < n; i++) m[i] = sm[i];
    //     for (i = 0; i < 32; i++) m[i+32] = pk[i];
    //     crypto_hash(h, m, n);
    //     reduce(h);
    //     scalarmult(p, q, h);
    
    //     scalarbase(q, sm.subarray(32));
    //     add(p, q);
    //     pack(t, p);
    
    //     n -= 64;
    //     if (crypto_verify_32(sm, 0, t, 0)) {
    //       for (i = 0; i < n; i++) m[i] = 0;
    //       return -1;
    //     }
    
    //     for (i = 0; i < n; i++) m[i] = sm[i + 64];
    //     return n;
    //   }
    
    //   var crypto_secretbox_KEYBYTES = 32,
    //       crypto_secretbox_NONCEBYTES = 24,
    //       crypto_secretbox_ZEROBYTES = 32,
    //       crypto_secretbox_BOXZEROBYTES = 16,
    //       crypto_scalarmult_BYTES = 32,
    //       crypto_scalarmult_SCALARBYTES = 32,
    //       crypto_box_PUBLICKEYBYTES = 32,
    //       crypto_box_SECRETKEYBYTES = 32,
    //       crypto_box_BEFORENMBYTES = 32,
    //       crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    //       crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    //       crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    //       crypto_sign_BYTES = 64,
    //       crypto_sign_PUBLICKEYBYTES = 32,
    //       crypto_sign_SECRETKEYBYTES = 64,
    //       crypto_sign_SEEDBYTES = 32,
    //       crypto_hash_BYTES = 64;
    
    //   nacl.lowlevel = {
    //     crypto_core_hsalsa20: crypto_core_hsalsa20,
    //     crypto_stream_xor: crypto_stream_xor,
    //     crypto_stream: crypto_stream,
    //     crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
    //     crypto_stream_salsa20: crypto_stream_salsa20,
    //     crypto_onetimeauth: crypto_onetimeauth,
    //     crypto_onetimeauth_verify: crypto_onetimeauth_verify,
    //     crypto_verify_16: crypto_verify_16,
    //     crypto_verify_32: crypto_verify_32,
    //     crypto_secretbox: crypto_secretbox,
    //     crypto_secretbox_open: crypto_secretbox_open,
    //     crypto_scalarmult: crypto_scalarmult,
    //     crypto_scalarmult_base: crypto_scalarmult_base,
    //     crypto_box_beforenm: crypto_box_beforenm,
    //     crypto_box_afternm: crypto_box_afternm,
    //     crypto_box: crypto_box,
    //     crypto_box_open: crypto_box_open,
    //     crypto_box_keypair: crypto_box_keypair,
    //     crypto_hash: crypto_hash,
    //     crypto_sign: crypto_sign,
    //     crypto_sign_keypair: crypto_sign_keypair,
    //     crypto_sign_open: crypto_sign_open,
    
    //     crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
    //     crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
    //     crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
    //     crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
    //     crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
    //     crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
    //     crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
    //     crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
    //     crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
    //     crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
    //     crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
    //     crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
    //     crypto_sign_BYTES: crypto_sign_BYTES,
    //     crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
    //     crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
    //     crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
    //     crypto_hash_BYTES: crypto_hash_BYTES,
    
    //     gf: gf,
    //     D: D,
    //     L: L,
    //     pack25519: pack25519,
    //     unpack25519: unpack25519,
    //     M: M,
    //     A: A,
    //     S: S,
    //     Z: Z,
    //     pow2523: pow2523,
    //     add: add,
    //     set25519: set25519,
    //     modL: modL,
    //     scalarmult: scalarmult,
    //     scalarbase: scalarbase,
    //   };
    
    //   /* High-level API */
    
    //   function checkLengths(k, n) {
    //     if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
    //     if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
    //   }
    
    //   function checkBoxLengths(pk, sk) {
    //     if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
    //     if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
    //   }
    
    //   function checkArrayTypes() {
    //     for (var i = 0; i < arguments.length; i++) {
    //       if (!(arguments[i] instanceof Uint8Array))
    //         throw new TypeError('unexpected type, use Uint8Array');
    //     }
    //   }
    
    //   function cleanup(arr) {
    //     for (var i = 0; i < arr.length; i++) arr[i] = 0;
    //   }
    
    //   nacl.randomBytes = function(n) {
    //     var b = new Uint8Array(n);
    //     randombytes(b, n);
    //     return b;
    //   };
    
    //   nacl.secretbox = function(msg, nonce, key) {
    //     checkArrayTypes(msg, nonce, key);
    //     checkLengths(key, nonce);
    //     var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
    //     var c = new Uint8Array(m.length);
    //     for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
    //     crypto_secretbox(c, m, m.length, nonce, key);
    //     return c.subarray(crypto_secretbox_BOXZEROBYTES);
    //   };
    
    //   nacl.secretbox.open = function(box, nonce, key) {
    //     checkArrayTypes(box, nonce, key);
    //     checkLengths(key, nonce);
    //     var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
    //     var m = new Uint8Array(c.length);
    //     for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
    //     if (c.length < 32) return null;
    //     if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
    //     return m.subarray(crypto_secretbox_ZEROBYTES);
    //   };
    
    //   nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    //   nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    //   nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    
    //   nacl.scalarMult = function(n, p) {
    //     checkArrayTypes(n, p);
    //     if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
    //     if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
    //     var q = new Uint8Array(crypto_scalarmult_BYTES);
    //     crypto_scalarmult(q, n, p);
    //     return q;
    //   };
    
    //   nacl.scalarMult.base = function(n) {
    //     checkArrayTypes(n);
    //     if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
    //     var q = new Uint8Array(crypto_scalarmult_BYTES);
    //     crypto_scalarmult_base(q, n);
    //     return q;
    //   };
    
    //   nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    //   nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    
    //   nacl.box = function(msg, nonce, publicKey, secretKey) {
    //     var k = nacl.box.before(publicKey, secretKey);
    //     return nacl.secretbox(msg, nonce, k);
    //   };
    
    //   nacl.box.before = function(publicKey, secretKey) {
    //     checkArrayTypes(publicKey, secretKey);
    //     checkBoxLengths(publicKey, secretKey);
    //     var k = new Uint8Array(crypto_box_BEFORENMBYTES);
    //     crypto_box_beforenm(k, publicKey, secretKey);
    //     return k;
    //   };
    
    //   nacl.box.after = nacl.secretbox;
    
    //   nacl.box.open = function(msg, nonce, publicKey, secretKey) {
    //     var k = nacl.box.before(publicKey, secretKey);
    //     return nacl.secretbox.open(msg, nonce, k);
    //   };
    
    //   nacl.box.open.after = nacl.secretbox.open;
    
    //   nacl.box.keyPair = function() {
    //     var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
    //     var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
    //     crypto_box_keypair(pk, sk);
    //     return {publicKey: pk, secretKey: sk};
    //   };
    
    //   nacl.box.keyPair.fromSecretKey = function(secretKey) {
    //     checkArrayTypes(secretKey);
    //     if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    //       throw new Error('bad secret key size');
    //     var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
    //     crypto_scalarmult_base(pk, secretKey);
    //     return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
    //   };
    
    //   nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    //   nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    //   nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    //   nacl.box.nonceLength = crypto_box_NONCEBYTES;
    //   nacl.box.overheadLength = nacl.secretbox.overheadLength;
    
    //   nacl.sign = function(msg, secretKey) {
    //     checkArrayTypes(msg, secretKey);
    //     if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    //       throw new Error('bad secret key size');
    //     var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
    //     crypto_sign(signedMsg, msg, msg.length, secretKey);
    //     return signedMsg;
    //   };
    
    //   nacl.sign.open = function(signedMsg, publicKey) {
    //     checkArrayTypes(signedMsg, publicKey);
    //     if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    //       throw new Error('bad public key size');
    //     var tmp = new Uint8Array(signedMsg.length);
    //     var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
    //     if (mlen < 0) return null;
    //     var m = new Uint8Array(mlen);
    //     for (var i = 0; i < m.length; i++) m[i] = tmp[i];
    //     return m;
    //   };
    
    //   nacl.sign.detached = function(msg, secretKey) {
    //     var signedMsg = nacl.sign(msg, secretKey);
    //     var sig = new Uint8Array(crypto_sign_BYTES);
    //     for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
    //     return sig;
    //   };
    
    //   nacl.sign.detached.verify = function(msg, sig, publicKey) {
    //     checkArrayTypes(msg, sig, publicKey);
    //     if (sig.length !== crypto_sign_BYTES)
    //       throw new Error('bad signature size');
    //     if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    //       throw new Error('bad public key size');
    //     var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
    //     var m = new Uint8Array(crypto_sign_BYTES + msg.length);
    //     var i;
    //     for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
    //     for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
    //     return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
    //   };
    
    //   nacl.sign.keyPair = function() {
    //     var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
    //     var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
    //     crypto_sign_keypair(pk, sk);
    //     return {publicKey: pk, secretKey: sk};
    //   };
    
    //   nacl.sign.keyPair.fromSecretKey = function(secretKey) {
    //     checkArrayTypes(secretKey);
    //     if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    //       throw new Error('bad secret key size');
    //     var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
    //     for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
    //     return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
    //   };
    
    //   nacl.sign.keyPair.fromSeed = function(seed) {
    //     checkArrayTypes(seed);
    //     if (seed.length !== crypto_sign_SEEDBYTES)
    //       throw new Error('bad seed size');
    //     var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
    //     var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
    //     for (var i = 0; i < 32; i++) sk[i] = seed[i];
    //     crypto_sign_keypair(pk, sk, true);
    //     return {publicKey: pk, secretKey: sk};
    //   };
    
    //   nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    //   nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    //   nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    //   nacl.sign.signatureLength = crypto_sign_BYTES;
    
    //   nacl.hash = function(msg) {
    //     checkArrayTypes(msg);
    //     var h = new Uint8Array(crypto_hash_BYTES);
    //     crypto_hash(h, msg, msg.length);
    //     return h;
    //   };
    
    //   nacl.hash.hashLength = crypto_hash_BYTES;
    
    //   nacl.verify = function(x, y) {
    //     checkArrayTypes(x, y);
    //     // Zero length arguments are considered not equal.
    //     if (x.length === 0 || y.length === 0) return false;
    //     if (x.length !== y.length) return false;
    //     return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
    //   };
    
    //   nacl.setPRNG = function(fn) {
    //     randombytes = fn;
    //   };
    
    //   (function() {
    //     // Initialize PRNG if environment provides CSPRNG.
    //     // If not, methods calling randombytes will throw.
    //     var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
    //     if (crypto && crypto.getRandomValues) {
    //       // Browsers.
    //       var QUOTA = 65536;
    //       nacl.setPRNG(function(x, n) {
    //         var i, v = new Uint8Array(n);
    //         for (i = 0; i < n; i += QUOTA) {
    //           crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
    //         }
    //         for (i = 0; i < n; i++) x[i] = v[i];
    //         cleanup(v);
    //       });
    //     } else if (typeof commonjsRequire !== 'undefined') {
    //       // Node.js.
    //       crypto = require$$0$1;
    //       if (crypto && crypto.randomBytes) {
    //         nacl.setPRNG(function(x, n) {
    //           var i, v = crypto.randomBytes(n);
    //           for (i = 0; i < n; i++) x[i] = v[i];
    //           cleanup(v);
    //         });
    //       }
    //     }
    //   })();
    
    //   })(module.exports ? module.exports : (self.nacl = self.nacl || {}));
    //   }(naclFast));
    
    //   var nacl__default = naclFast.exports;
    
    //   var safeBuffer = {exports: {}};
    
    //   /* eslint-disable node/no-deprecated-api */
    
    //   (function (module, exports) {
    //   var buffer$1 = buffer;
    //   var Buffer = buffer$1.Buffer;
    
    //   // alternative to using Object.keys for old browsers
    //   function copyProps (src, dst) {
    //     for (var key in src) {
    //       dst[key] = src[key];
    //     }
    //   }
    //   if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    //     module.exports = buffer$1;
    //   } else {
    //     // Copy properties from require('buffer')
    //     copyProps(buffer$1, exports);
    //     exports.Buffer = SafeBuffer;
    //   }
    
    //   function SafeBuffer (arg, encodingOrOffset, length) {
    //     return Buffer(arg, encodingOrOffset, length)
    //   }
    
    //   // Copy static methods from Buffer
    //   copyProps(Buffer, SafeBuffer);
    
    //   SafeBuffer.from = function (arg, encodingOrOffset, length) {
    //     if (typeof arg === 'number') {
    //       throw new TypeError('Argument must not be a number')
    //     }
    //     return Buffer(arg, encodingOrOffset, length)
    //   };
    
    //   SafeBuffer.alloc = function (size, fill, encoding) {
    //     if (typeof size !== 'number') {
    //       throw new TypeError('Argument must be a number')
    //     }
    //     var buf = Buffer(size);
    //     if (fill !== undefined) {
    //       if (typeof encoding === 'string') {
    //         buf.fill(fill, encoding);
    //       } else {
    //         buf.fill(fill);
    //       }
    //     } else {
    //       buf.fill(0);
    //     }
    //     return buf
    //   };
    
    //   SafeBuffer.allocUnsafe = function (size) {
    //     if (typeof size !== 'number') {
    //       throw new TypeError('Argument must be a number')
    //     }
    //     return Buffer(size)
    //   };
    
    //   SafeBuffer.allocUnsafeSlow = function (size) {
    //     if (typeof size !== 'number') {
    //       throw new TypeError('Argument must be a number')
    //     }
    //     return buffer$1.SlowBuffer(size)
    //   };
    //   }(safeBuffer, safeBuffer.exports));
    
    //   // base-x encoding / decoding
    //   // Copyright (c) 2018 base-x contributors
    //   // Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
    //   // Distributed under the MIT software license, see the accompanying
    //   // file LICENSE or http://www.opensource.org/licenses/mit-license.php.
    //   // @ts-ignore
    //   var _Buffer = safeBuffer.exports.Buffer;
    //   function base$1 (ALPHABET) {
    //     if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
    //     var BASE_MAP = new Uint8Array(256);
    //     for (var j = 0; j < BASE_MAP.length; j++) {
    //       BASE_MAP[j] = 255;
    //     }
    //     for (var i = 0; i < ALPHABET.length; i++) {
    //       var x = ALPHABET.charAt(i);
    //       var xc = x.charCodeAt(0);
    //       if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    //       BASE_MAP[xc] = i;
    //     }
    //     var BASE = ALPHABET.length;
    //     var LEADER = ALPHABET.charAt(0);
    //     var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
    //     var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
    //     function encode (source) {
    //       if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source); }
    //       if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
    //       if (source.length === 0) { return '' }
    //           // Skip & count leading zeroes.
    //       var zeroes = 0;
    //       var length = 0;
    //       var pbegin = 0;
    //       var pend = source.length;
    //       while (pbegin !== pend && source[pbegin] === 0) {
    //         pbegin++;
    //         zeroes++;
    //       }
    //           // Allocate enough space in big-endian base58 representation.
    //       var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
    //       var b58 = new Uint8Array(size);
    //           // Process the bytes.
    //       while (pbegin !== pend) {
    //         var carry = source[pbegin];
    //               // Apply "b58 = b58 * 256 + ch".
    //         var i = 0;
    //         for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
    //           carry += (256 * b58[it1]) >>> 0;
    //           b58[it1] = (carry % BASE) >>> 0;
    //           carry = (carry / BASE) >>> 0;
    //         }
    //         if (carry !== 0) { throw new Error('Non-zero carry') }
    //         length = i;
    //         pbegin++;
    //       }
    //           // Skip leading zeroes in base58 result.
    //       var it2 = size - length;
    //       while (it2 !== size && b58[it2] === 0) {
    //         it2++;
    //       }
    //           // Translate the result into a string.
    //       var str = LEADER.repeat(zeroes);
    //       for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
    //       return str
    //     }
    //     function decodeUnsafe (source) {
    //       if (typeof source !== 'string') { throw new TypeError('Expected String') }
    //       if (source.length === 0) { return _Buffer.alloc(0) }
    //       var psz = 0;
    //           // Skip leading spaces.
    //       if (source[psz] === ' ') { return }
    //           // Skip and count leading '1's.
    //       var zeroes = 0;
    //       var length = 0;
    //       while (source[psz] === LEADER) {
    //         zeroes++;
    //         psz++;
    //       }
    //           // Allocate enough space in big-endian base256 representation.
    //       var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
    //       var b256 = new Uint8Array(size);
    //           // Process the characters.
    //       while (source[psz]) {
    //               // Decode character
    //         var carry = BASE_MAP[source.charCodeAt(psz)];
    //               // Invalid character
    //         if (carry === 255) { return }
    //         var i = 0;
    //         for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
    //           carry += (BASE * b256[it3]) >>> 0;
    //           b256[it3] = (carry % 256) >>> 0;
    //           carry = (carry / 256) >>> 0;
    //         }
    //         if (carry !== 0) { throw new Error('Non-zero carry') }
    //         length = i;
    //         psz++;
    //       }
    //           // Skip trailing spaces.
    //       if (source[psz] === ' ') { return }
    //           // Skip leading zeroes in b256.
    //       var it4 = size - length;
    //       while (it4 !== size && b256[it4] === 0) {
    //         it4++;
    //       }
    //       var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
    //       vch.fill(0x00, 0, zeroes);
    //       var j = zeroes;
    //       while (it4 !== size) {
    //         vch[j++] = b256[it4++];
    //       }
    //       return vch
    //     }
    //     function decode (string) {
    //       var buffer = decodeUnsafe(string);
    //       if (buffer) { return buffer }
    //       throw new Error('Non-base' + BASE + ' character')
    //     }
    //     return {
    //       encode: encode,
    //       decodeUnsafe: decodeUnsafe,
    //       decode: decode
    //     }
    //   }
    //   var src = base$1;
    
    //   var basex = src;
    //   var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    
    //   var bs58 = basex(ALPHABET);
    
    //   var bs58$1 = bs58;
    
    //   var browser$1 = {};
    
    //   /* eslint-env browser */
    
    //   // Ponyfill for `globalThis`
    //   const _globalThis = (() => {
    //       if (typeof globalThis !== 'undefined') {
    //           return globalThis;
    //       }
    
    //       if (typeof self !== 'undefined') {
    //           return self;
    //       }
    
    //       /* istanbul ignore next */
    //       if (typeof window !== 'undefined') {
    //           return window;
    //       }
    
    //       /* istanbul ignore next */
    //       if (typeof commonjsGlobal !== 'undefined') {
    //           return commonjsGlobal;
    //       }
    //   })();
    
    //   const bufferToHex = buffer => {
    //       const view = new DataView(buffer);
    
    //       let hexCodes = '';
    //       for (let i = 0; i < view.byteLength; i += 4) {
    //           hexCodes += view.getUint32(i).toString(16).padStart(8, '0');
    //       }
    
    //       return hexCodes;
    //   };
    
    //   const create$1 = algorithm => async (buffer, options) => {
    //       if (typeof buffer === 'string') {
    //           buffer = new _globalThis.TextEncoder().encode(buffer);
    //       }
    
    //       options = {
    //           outputFormat: 'hex',
    //           ...options
    //       };
    
    //       const hash = await _globalThis.crypto.subtle.digest(algorithm, buffer);
    
    //       return options.outputFormat === 'hex' ? bufferToHex(hash) : hash;
    //   };
    
    //   browser$1.sha1 = create$1('SHA-1');
    //   var sha256 = browser$1.sha256 = create$1('SHA-256');
    //   browser$1.sha384 = create$1('SHA-384');
    //   browser$1.sha512 = create$1('SHA-512');
    
    //   var lib$1 = {};
    
    //   // This is free and unencumbered software released into the public domain.
    //   // See LICENSE.md for more information.
    
    //   //
    //   // Utilities
    //   //
    
    //   /**
    //    * @param {number} a The number to test.
    //    * @param {number} min The minimum value in the range, inclusive.
    //    * @param {number} max The maximum value in the range, inclusive.
    //    * @return {boolean} True if a >= min and a <= max.
    //    */
    //   function inRange(a, min, max) {
    //     return min <= a && a <= max;
    //   }
    
    //   /**
    //    * @param {*} o
    //    * @return {Object}
    //    */
    //   function ToDictionary(o) {
    //     if (o === undefined) return {};
    //     if (o === Object(o)) return o;
    //     throw TypeError('Could not convert argument to dictionary');
    //   }
    
    //   /**
    //    * @param {string} string Input string of UTF-16 code units.
    //    * @return {!Array.<number>} Code points.
    //    */
    //   function stringToCodePoints(string) {
    //     // https://heycam.github.io/webidl/#dfn-obtain-unicode
    
    //     // 1. Let S be the DOMString value.
    //     var s = String(string);
    
    //     // 2. Let n be the length of S.
    //     var n = s.length;
    
    //     // 3. Initialize i to 0.
    //     var i = 0;
    
    //     // 4. Initialize U to be an empty sequence of Unicode characters.
    //     var u = [];
    
    //     // 5. While i < n:
    //     while (i < n) {
    
    //       // 1. Let c be the code unit in S at index i.
    //       var c = s.charCodeAt(i);
    
    //       // 2. Depending on the value of c:
    
    //       // c < 0xD800 or c > 0xDFFF
    //       if (c < 0xD800 || c > 0xDFFF) {
    //         // Append to U the Unicode character with code point c.
    //         u.push(c);
    //       }
    
    //       // 0xDC00  c  0xDFFF
    //       else if (0xDC00 <= c && c <= 0xDFFF) {
    //         // Append to U a U+FFFD REPLACEMENT CHARACTER.
    //         u.push(0xFFFD);
    //       }
    
    //       // 0xD800  c  0xDBFF
    //       else if (0xD800 <= c && c <= 0xDBFF) {
    //         // 1. If i = n1, then append to U a U+FFFD REPLACEMENT
    //         // CHARACTER.
    //         if (i === n - 1) {
    //           u.push(0xFFFD);
    //         }
    //         // 2. Otherwise, i < n1:
    //         else {
    //           // 1. Let d be the code unit in S at index i+1.
    //           var d = string.charCodeAt(i + 1);
    
    //           // 2. If 0xDC00  d  0xDFFF, then:
    //           if (0xDC00 <= d && d <= 0xDFFF) {
    //             // 1. Let a be c & 0x3FF.
    //             var a = c & 0x3FF;
    
    //             // 2. Let b be d & 0x3FF.
    //             var b = d & 0x3FF;
    
    //             // 3. Append to U the Unicode character with code point
    //             // 2^16+2^10*a+b.
    //             u.push(0x10000 + (a << 10) + b);
    
    //             // 4. Set i to i+1.
    //             i += 1;
    //           }
    
    //           // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a
    //           // U+FFFD REPLACEMENT CHARACTER.
    //           else  {
    //             u.push(0xFFFD);
    //           }
    //         }
    //       }
    
    //       // 3. Set i to i+1.
    //       i += 1;
    //     }
    
    //     // 6. Return U.
    //     return u;
    //   }
    
    //   /**
    //    * @param {!Array.<number>} code_points Array of code points.
    //    * @return {string} string String of UTF-16 code units.
    //    */
    //   function codePointsToString(code_points) {
    //     var s = '';
    //     for (var i = 0; i < code_points.length; ++i) {
    //       var cp = code_points[i];
    //       if (cp <= 0xFFFF) {
    //         s += String.fromCharCode(cp);
    //       } else {
    //         cp -= 0x10000;
    //         s += String.fromCharCode((cp >> 10) + 0xD800,
    //                                  (cp & 0x3FF) + 0xDC00);
    //       }
    //     }
    //     return s;
    //   }
    
    
    //   //
    //   // Implementation of Encoding specification
    //   // https://encoding.spec.whatwg.org/
    //   //
    
    //   //
    //   // 3. Terminology
    //   //
    
    //   /**
    //    * End-of-stream is a special token that signifies no more tokens
    //    * are in the stream.
    //    * @const
    //    */ var end_of_stream = -1;
    
    //   /**
    //    * A stream represents an ordered sequence of tokens.
    //    *
    //    * @constructor
    //    * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the
    //    * stream.
    //    */
    //   function Stream(tokens) {
    //     /** @type {!Array.<number>} */
    //     this.tokens = [].slice.call(tokens);
    //   }
    
    //   Stream.prototype = {
    //     /**
    //      * @return {boolean} True if end-of-stream has been hit.
    //      */
    //     endOfStream: function() {
    //       return !this.tokens.length;
    //     },
    
    //     /**
    //      * When a token is read from a stream, the first token in the
    //      * stream must be returned and subsequently removed, and
    //      * end-of-stream must be returned otherwise.
    //      *
    //      * @return {number} Get the next token from the stream, or
    //      * end_of_stream.
    //      */
    //      read: function() {
    //       if (!this.tokens.length)
    //         return end_of_stream;
    //        return this.tokens.shift();
    //      },
    
    //     /**
    //      * When one or more tokens are prepended to a stream, those tokens
    //      * must be inserted, in given order, before the first token in the
    //      * stream.
    //      *
    //      * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
    //      */
    //     prepend: function(token) {
    //       if (Array.isArray(token)) {
    //         var tokens = /**@type {!Array.<number>}*/(token);
    //         while (tokens.length)
    //           this.tokens.unshift(tokens.pop());
    //       } else {
    //         this.tokens.unshift(token);
    //       }
    //     },
    
    //     /**
    //      * When one or more tokens are pushed to a stream, those tokens
    //      * must be inserted, in given order, after the last token in the
    //      * stream.
    //      *
    //      * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
    //      */
    //     push: function(token) {
    //       if (Array.isArray(token)) {
    //         var tokens = /**@type {!Array.<number>}*/(token);
    //         while (tokens.length)
    //           this.tokens.push(tokens.shift());
    //       } else {
    //         this.tokens.push(token);
    //       }
    //     }
    //   };
    
    //   //
    //   // 4. Encodings
    //   //
    
    //   // 4.1 Encoders and decoders
    
    //   /** @const */
    //   var finished = -1;
    
    //   /**
    //    * @param {boolean} fatal If true, decoding errors raise an exception.
    //    * @param {number=} opt_code_point Override the standard fallback code point.
    //    * @return {number} The code point to insert on a decoding error.
    //    */
    //   function decoderError(fatal, opt_code_point) {
    //     if (fatal)
    //       throw TypeError('Decoder error');
    //     return opt_code_point || 0xFFFD;
    //   }
    
    //   //
    //   // 7. API
    //   //
    
    //   /** @const */ var DEFAULT_ENCODING = 'utf-8';
    
    //   // 7.1 Interface TextDecoder
    
    //   /**
    //    * @constructor
    //    * @param {string=} encoding The label of the encoding;
    //    *     defaults to 'utf-8'.
    //    * @param {Object=} options
    //    */
    //   function TextDecoder$1(encoding, options) {
    //     if (!(this instanceof TextDecoder$1)) {
    //       return new TextDecoder$1(encoding, options);
    //     }
    //     encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
    //     if (encoding !== DEFAULT_ENCODING) {
    //       throw new Error('Encoding not supported. Only utf-8 is supported');
    //     }
    //     options = ToDictionary(options);
    
    //     /** @private @type {boolean} */
    //     this._streaming = false;
    //     /** @private @type {boolean} */
    //     this._BOMseen = false;
    //     /** @private @type {?Decoder} */
    //     this._decoder = null;
    //     /** @private @type {boolean} */
    //     this._fatal = Boolean(options['fatal']);
    //     /** @private @type {boolean} */
    //     this._ignoreBOM = Boolean(options['ignoreBOM']);
    
    //     Object.defineProperty(this, 'encoding', {value: 'utf-8'});
    //     Object.defineProperty(this, 'fatal', {value: this._fatal});
    //     Object.defineProperty(this, 'ignoreBOM', {value: this._ignoreBOM});
    //   }
    
    //   TextDecoder$1.prototype = {
    //     /**
    //      * @param {ArrayBufferView=} input The buffer of bytes to decode.
    //      * @param {Object=} options
    //      * @return {string} The decoded string.
    //      */
    //     decode: function decode(input, options) {
    //       var bytes;
    //       if (typeof input === 'object' && input instanceof ArrayBuffer) {
    //         bytes = new Uint8Array(input);
    //       } else if (typeof input === 'object' && 'buffer' in input &&
    //                  input.buffer instanceof ArrayBuffer) {
    //         bytes = new Uint8Array(input.buffer,
    //                                input.byteOffset,
    //                                input.byteLength);
    //       } else {
    //         bytes = new Uint8Array(0);
    //       }
    
    //       options = ToDictionary(options);
    
    //       if (!this._streaming) {
    //         this._decoder = new UTF8Decoder({fatal: this._fatal});
    //         this._BOMseen = false;
    //       }
    //       this._streaming = Boolean(options['stream']);
    
    //       var input_stream = new Stream(bytes);
    
    //       var code_points = [];
    
    //       /** @type {?(number|!Array.<number>)} */
    //       var result;
    
    //       while (!input_stream.endOfStream()) {
    //         result = this._decoder.handler(input_stream, input_stream.read());
    //         if (result === finished)
    //           break;
    //         if (result === null)
    //           continue;
    //         if (Array.isArray(result))
    //           code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));
    //         else
    //           code_points.push(result);
    //       }
    //       if (!this._streaming) {
    //         do {
    //           result = this._decoder.handler(input_stream, input_stream.read());
    //           if (result === finished)
    //             break;
    //           if (result === null)
    //             continue;
    //           if (Array.isArray(result))
    //             code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));
    //           else
    //             code_points.push(result);
    //         } while (!input_stream.endOfStream());
    //         this._decoder = null;
    //       }
    
    //       if (code_points.length) {
    //         // If encoding is one of utf-8, utf-16be, and utf-16le, and
    //         // ignore BOM flag and BOM seen flag are unset, run these
    //         // subsubsteps:
    //         if (['utf-8'].indexOf(this.encoding) !== -1 &&
    //             !this._ignoreBOM && !this._BOMseen) {
    //           // If token is U+FEFF, set BOM seen flag.
    //           if (code_points[0] === 0xFEFF) {
    //             this._BOMseen = true;
    //             code_points.shift();
    //           } else {
    //             // Otherwise, if token is not end-of-stream, set BOM seen
    //             // flag and append token to output.
    //             this._BOMseen = true;
    //           }
    //         }
    //       }
    
    //       return codePointsToString(code_points);
    //     }
    //   };
    
    //   // 7.2 Interface TextEncoder
    
    //   /**
    //    * @constructor
    //    * @param {string=} encoding The label of the encoding;
    //    *     defaults to 'utf-8'.
    //    * @param {Object=} options
    //    */
    //   function TextEncoder$1(encoding, options) {
    //     if (!(this instanceof TextEncoder$1))
    //       return new TextEncoder$1(encoding, options);
    //     encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
    //     if (encoding !== DEFAULT_ENCODING) {
    //       throw new Error('Encoding not supported. Only utf-8 is supported');
    //     }
    //     options = ToDictionary(options);
    
    //     /** @private @type {boolean} */
    //     this._streaming = false;
    //     /** @private @type {?Encoder} */
    //     this._encoder = null;
    //     /** @private @type {{fatal: boolean}} */
    //     this._options = {fatal: Boolean(options['fatal'])};
    
    //     Object.defineProperty(this, 'encoding', {value: 'utf-8'});
    //   }
    
    //   TextEncoder$1.prototype = {
    //     /**
    //      * @param {string=} opt_string The string to encode.
    //      * @param {Object=} options
    //      * @return {Uint8Array} Encoded bytes, as a Uint8Array.
    //      */
    //     encode: function encode(opt_string, options) {
    //       opt_string = opt_string ? String(opt_string) : '';
    //       options = ToDictionary(options);
    
    //       // NOTE: This option is nonstandard. None of the encodings
    //       // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,
    //       // so streaming is not necessary.
    //       if (!this._streaming)
    //         this._encoder = new UTF8Encoder(this._options);
    //       this._streaming = Boolean(options['stream']);
    
    //       var bytes = [];
    //       var input_stream = new Stream(stringToCodePoints(opt_string));
    //       /** @type {?(number|!Array.<number>)} */
    //       var result;
    //       while (!input_stream.endOfStream()) {
    //         result = this._encoder.handler(input_stream, input_stream.read());
    //         if (result === finished)
    //           break;
    //         if (Array.isArray(result))
    //           bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));
    //         else
    //           bytes.push(result);
    //       }
    //       if (!this._streaming) {
    //         while (true) {
    //           result = this._encoder.handler(input_stream, input_stream.read());
    //           if (result === finished)
    //             break;
    //           if (Array.isArray(result))
    //             bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));
    //           else
    //             bytes.push(result);
    //         }
    //         this._encoder = null;
    //       }
    //       return new Uint8Array(bytes);
    //     }
    //   };
    
    //   //
    //   // 8. The encoding
    //   //
    
    //   // 8.1 utf-8
    
    //   /**
    //    * @constructor
    //    * @implements {Decoder}
    //    * @param {{fatal: boolean}} options
    //    */
    //   function UTF8Decoder(options) {
    //     var fatal = options.fatal;
    
    //     // utf-8's decoder's has an associated utf-8 code point, utf-8
    //     // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8
    //     // lower boundary (initially 0x80), and a utf-8 upper boundary
    //     // (initially 0xBF).
    //     var /** @type {number} */ utf8_code_point = 0,
    //         /** @type {number} */ utf8_bytes_seen = 0,
    //         /** @type {number} */ utf8_bytes_needed = 0,
    //         /** @type {number} */ utf8_lower_boundary = 0x80,
    //         /** @type {number} */ utf8_upper_boundary = 0xBF;
    
    //     /**
    //      * @param {Stream} stream The stream of bytes being decoded.
    //      * @param {number} bite The next byte read from the stream.
    //      * @return {?(number|!Array.<number>)} The next code point(s)
    //      *     decoded, or null if not enough data exists in the input
    //      *     stream to decode a complete code point.
    //      */
    //     this.handler = function(stream, bite) {
    //       // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,
    //       // set utf-8 bytes needed to 0 and return error.
    //       if (bite === end_of_stream && utf8_bytes_needed !== 0) {
    //         utf8_bytes_needed = 0;
    //         return decoderError(fatal);
    //       }
    
    //       // 2. If byte is end-of-stream, return finished.
    //       if (bite === end_of_stream)
    //         return finished;
    
    //       // 3. If utf-8 bytes needed is 0, based on byte:
    //       if (utf8_bytes_needed === 0) {
    
    //         // 0x00 to 0x7F
    //         if (inRange(bite, 0x00, 0x7F)) {
    //           // Return a code point whose value is byte.
    //           return bite;
    //         }
    
    //         // 0xC2 to 0xDF
    //         if (inRange(bite, 0xC2, 0xDF)) {
    //           // Set utf-8 bytes needed to 1 and utf-8 code point to byte
    //           //  0xC0.
    //           utf8_bytes_needed = 1;
    //           utf8_code_point = bite - 0xC0;
    //         }
    
    //         // 0xE0 to 0xEF
    //         else if (inRange(bite, 0xE0, 0xEF)) {
    //           // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.
    //           if (bite === 0xE0)
    //             utf8_lower_boundary = 0xA0;
    //           // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.
    //           if (bite === 0xED)
    //             utf8_upper_boundary = 0x9F;
    //           // 3. Set utf-8 bytes needed to 2 and utf-8 code point to
    //           // byte  0xE0.
    //           utf8_bytes_needed = 2;
    //           utf8_code_point = bite - 0xE0;
    //         }
    
    //         // 0xF0 to 0xF4
    //         else if (inRange(bite, 0xF0, 0xF4)) {
    //           // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.
    //           if (bite === 0xF0)
    //             utf8_lower_boundary = 0x90;
    //           // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.
    //           if (bite === 0xF4)
    //             utf8_upper_boundary = 0x8F;
    //           // 3. Set utf-8 bytes needed to 3 and utf-8 code point to
    //           // byte  0xF0.
    //           utf8_bytes_needed = 3;
    //           utf8_code_point = bite - 0xF0;
    //         }
    
    //         // Otherwise
    //         else {
    //           // Return error.
    //           return decoderError(fatal);
    //         }
    
    //         // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code
    //         // point to utf-8 code point << (6  utf-8 bytes needed) and
    //         // return continue.
    //         utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);
    //         return null;
    //       }
    
    //       // 4. If byte is not in the range utf-8 lower boundary to utf-8
    //       // upper boundary, run these substeps:
    //       if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
    
    //         // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8
    //         // bytes seen to 0, set utf-8 lower boundary to 0x80, and set
    //         // utf-8 upper boundary to 0xBF.
    //         utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    //         utf8_lower_boundary = 0x80;
    //         utf8_upper_boundary = 0xBF;
    
    //         // 2. Prepend byte to stream.
    //         stream.prepend(bite);
    
    //         // 3. Return error.
    //         return decoderError(fatal);
    //       }
    
    //       // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary
    //       // to 0xBF.
    //       utf8_lower_boundary = 0x80;
    //       utf8_upper_boundary = 0xBF;
    
    //       // 6. Increase utf-8 bytes seen by one and set utf-8 code point
    //       // to utf-8 code point + (byte  0x80) << (6  (utf-8 bytes
    //       // needed  utf-8 bytes seen)).
    //       utf8_bytes_seen += 1;
    //       utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed - utf8_bytes_seen));
    
    //       // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,
    //       // continue.
    //       if (utf8_bytes_seen !== utf8_bytes_needed)
    //         return null;
    
    //       // 8. Let code point be utf-8 code point.
    //       var code_point = utf8_code_point;
    
    //       // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes
    //       // seen to 0.
    //       utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    
    //       // 10. Return a code point whose value is code point.
    //       return code_point;
    //     };
    //   }
    
    //   /**
    //    * @constructor
    //    * @implements {Encoder}
    //    * @param {{fatal: boolean}} options
    //    */
    //   function UTF8Encoder(options) {
    //     options.fatal;
    //     /**
    //      * @param {Stream} stream Input stream.
    //      * @param {number} code_point Next code point read from the stream.
    //      * @return {(number|!Array.<number>)} Byte(s) to emit.
    //      */
    //     this.handler = function(stream, code_point) {
    //       // 1. If code point is end-of-stream, return finished.
    //       if (code_point === end_of_stream)
    //         return finished;
    
    //       // 2. If code point is in the range U+0000 to U+007F, return a
    //       // byte whose value is code point.
    //       if (inRange(code_point, 0x0000, 0x007f))
    //         return code_point;
    
    //       // 3. Set count and offset based on the range code point is in:
    //       var count, offset;
    //       // U+0080 to U+07FF:    1 and 0xC0
    //       if (inRange(code_point, 0x0080, 0x07FF)) {
    //         count = 1;
    //         offset = 0xC0;
    //       }
    //       // U+0800 to U+FFFF:    2 and 0xE0
    //       else if (inRange(code_point, 0x0800, 0xFFFF)) {
    //         count = 2;
    //         offset = 0xE0;
    //       }
    //       // U+10000 to U+10FFFF: 3 and 0xF0
    //       else if (inRange(code_point, 0x10000, 0x10FFFF)) {
    //         count = 3;
    //         offset = 0xF0;
    //       }
    
    //       // 4.Let bytes be a byte sequence whose first byte is (code
    //       // point >> (6  count)) + offset.
    //       var bytes = [(code_point >> (6 * count)) + offset];
    
    //       // 5. Run these substeps while count is greater than 0:
    //       while (count > 0) {
    
    //         // 1. Set temp to code point >> (6  (count  1)).
    //         var temp = code_point >> (6 * (count - 1));
    
    //         // 2. Append to bytes 0x80 | (temp & 0x3F).
    //         bytes.push(0x80 | (temp & 0x3F));
    
    //         // 3. Decrease count by one.
    //         count -= 1;
    //       }
    
    //       // 6. Return bytes bytes, in order.
    //       return bytes;
    //     };
    //   }
    
    //   var encoding_lib = /*#__PURE__*/Object.freeze({
    //     __proto__: null,
    //     TextEncoder: TextEncoder$1,
    //     TextDecoder: TextDecoder$1
    //   });
    
    //   var require$$2 = /*@__PURE__*/getAugmentedNamespace(encoding_lib);
    
    //   var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    //       if (k2 === undefined) k2 = k;
    //       Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    //   }) : (function(o, m, k, k2) {
    //       if (k2 === undefined) k2 = k;
    //       o[k2] = m[k];
    //   }));
    //   var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    //       Object.defineProperty(o, "default", { enumerable: true, value: v });
    //   }) : function(o, v) {
    //       o["default"] = v;
    //   });
    //   var __decorate = (commonjsGlobal && commonjsGlobal.__decorate) || function (decorators, target, key, desc) {
    //       var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    //       if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    //       else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    //       return c > 3 && r && Object.defineProperty(target, key, r), r;
    //   };
    //   var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    //       if (mod && mod.__esModule) return mod;
    //       var result = {};
    //       if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    //       __setModuleDefault(result, mod);
    //       return result;
    //   };
    //   var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    //       return (mod && mod.__esModule) ? mod : { "default": mod };
    //   };
    //   Object.defineProperty(lib$1, "__esModule", { value: true });
    //   var deserializeUnchecked_1 = lib$1.deserializeUnchecked = deserialize_1 = lib$1.deserialize = serialize_1 = lib$1.serialize = lib$1.BinaryReader = lib$1.BinaryWriter = lib$1.BorshError = lib$1.baseDecode = lib$1.baseEncode = void 0;
    //   const bn_js_1 = __importDefault(bn.exports);
    //   const bs58_1 = __importDefault(bs58);
    //   // TODO: Make sure this polyfill not included when not required
    //   const encoding = __importStar(require$$2);
    //   const TextDecoder = (typeof commonjsGlobal.TextDecoder !== 'function') ? encoding.TextDecoder : commonjsGlobal.TextDecoder;
    //   const textDecoder = new TextDecoder('utf-8', { fatal: true });
    //   function baseEncode(value) {
    //       if (typeof (value) === 'string') {
    //           value = buffer.Buffer.from(value, 'utf8');
    //       }
    //       return bs58_1.default.encode(buffer.Buffer.from(value));
    //   }
    //   lib$1.baseEncode = baseEncode;
    //   function baseDecode(value) {
    //       return buffer.Buffer.from(bs58_1.default.decode(value));
    //   }
    //   lib$1.baseDecode = baseDecode;
    //   const INITIAL_LENGTH = 1024;
    //   class BorshError extends Error {
    //       constructor(message) {
    //           super(message);
    //           this.fieldPath = [];
    //           this.originalMessage = message;
    //       }
    //       addToFieldPath(fieldName) {
    //           this.fieldPath.splice(0, 0, fieldName);
    //           // NOTE: Modifying message directly as jest doesn't use .toString()
    //           this.message = this.originalMessage + ': ' + this.fieldPath.join('.');
    //       }
    //   }
    //   lib$1.BorshError = BorshError;
    //   /// Binary encoder.
    //   class BinaryWriter {
    //       constructor() {
    //           this.buf = buffer.Buffer.alloc(INITIAL_LENGTH);
    //           this.length = 0;
    //       }
    //       maybeResize() {
    //           if (this.buf.length < 16 + this.length) {
    //               this.buf = buffer.Buffer.concat([this.buf, buffer.Buffer.alloc(INITIAL_LENGTH)]);
    //           }
    //       }
    //       writeU8(value) {
    //           this.maybeResize();
    //           this.buf.writeUInt8(value, this.length);
    //           this.length += 1;
    //       }
    //       writeU16(value) {
    //           this.maybeResize();
    //           this.buf.writeUInt16LE(value, this.length);
    //           this.length += 2;
    //       }
    //       writeU32(value) {
    //           this.maybeResize();
    //           this.buf.writeUInt32LE(value, this.length);
    //           this.length += 4;
    //       }
    //       writeU64(value) {
    //           this.maybeResize();
    //           this.writeBuffer(buffer.Buffer.from(new bn_js_1.default(value).toArray('le', 8)));
    //       }
    //       writeU128(value) {
    //           this.maybeResize();
    //           this.writeBuffer(buffer.Buffer.from(new bn_js_1.default(value).toArray('le', 16)));
    //       }
    //       writeU256(value) {
    //           this.maybeResize();
    //           this.writeBuffer(buffer.Buffer.from(new bn_js_1.default(value).toArray('le', 32)));
    //       }
    //       writeU512(value) {
    //           this.maybeResize();
    //           this.writeBuffer(buffer.Buffer.from(new bn_js_1.default(value).toArray('le', 64)));
    //       }
    //       writeBuffer(buffer$1) {
    //           // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser
    //           this.buf = buffer.Buffer.concat([buffer.Buffer.from(this.buf.subarray(0, this.length)), buffer$1, buffer.Buffer.alloc(INITIAL_LENGTH)]);
    //           this.length += buffer$1.length;
    //       }
    //       writeString(str) {
    //           this.maybeResize();
    //           const b = buffer.Buffer.from(str, 'utf8');
    //           this.writeU32(b.length);
    //           this.writeBuffer(b);
    //       }
    //       writeFixedArray(array) {
    //           this.writeBuffer(buffer.Buffer.from(array));
    //       }
    //       writeArray(array, fn) {
    //           this.maybeResize();
    //           this.writeU32(array.length);
    //           for (const elem of array) {
    //               this.maybeResize();
    //               fn(elem);
    //           }
    //       }
    //       toArray() {
    //           return this.buf.subarray(0, this.length);
    //       }
    //   }
    //   lib$1.BinaryWriter = BinaryWriter;
    //   function handlingRangeError(target, propertyKey, propertyDescriptor) {
    //       const originalMethod = propertyDescriptor.value;
    //       propertyDescriptor.value = function (...args) {
    //           try {
    //               return originalMethod.apply(this, args);
    //           }
    //           catch (e) {
    //               if (e instanceof RangeError) {
    //                   const code = e.code;
    //                   if (['ERR_BUFFER_OUT_OF_BOUNDS', 'ERR_OUT_OF_RANGE'].indexOf(code) >= 0) {
    //                       throw new BorshError('Reached the end of buffer when deserializing');
    //                   }
    //               }
    //               throw e;
    //           }
    //       };
    //   }
    //   class BinaryReader {
    //       constructor(buf) {
    //           this.buf = buf;
    //           this.offset = 0;
    //       }
    //       readU8() {
    //           const value = this.buf.readUInt8(this.offset);
    //           this.offset += 1;
    //           return value;
    //       }
    //       readU16() {
    //           const value = this.buf.readUInt16LE(this.offset);
    //           this.offset += 2;
    //           return value;
    //       }
    //       readU32() {
    //           const value = this.buf.readUInt32LE(this.offset);
    //           this.offset += 4;
    //           return value;
    //       }
    //       readU64() {
    //           const buf = this.readBuffer(8);
    //           return new bn_js_1.default(buf, 'le');
    //       }
    //       readU128() {
    //           const buf = this.readBuffer(16);
    //           return new bn_js_1.default(buf, 'le');
    //       }
    //       readU256() {
    //           const buf = this.readBuffer(32);
    //           return new bn_js_1.default(buf, 'le');
    //       }
    //       readU512() {
    //           const buf = this.readBuffer(64);
    //           return new bn_js_1.default(buf, 'le');
    //       }
    //       readBuffer(len) {
    //           if ((this.offset + len) > this.buf.length) {
    //               throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
    //           }
    //           const result = this.buf.slice(this.offset, this.offset + len);
    //           this.offset += len;
    //           return result;
    //       }
    //       readString() {
    //           const len = this.readU32();
    //           const buf = this.readBuffer(len);
    //           try {
    //               // NOTE: Using TextDecoder to fail on invalid UTF-8
    //               return textDecoder.decode(buf);
    //           }
    //           catch (e) {
    //               throw new BorshError(`Error decoding UTF-8 string: ${e}`);
    //           }
    //       }
    //       readFixedArray(len) {
    //           return new Uint8Array(this.readBuffer(len));
    //       }
    //       readArray(fn) {
    //           const len = this.readU32();
    //           const result = Array();
    //           for (let i = 0; i < len; ++i) {
    //               result.push(fn());
    //           }
    //           return result;
    //       }
    //   }
    //   __decorate([
    //       handlingRangeError
    //   ], BinaryReader.prototype, "readU8", null);
    //   __decorate([
    //       handlingRangeError
    //   ], BinaryReader.prototype, "readU16", null);
    //   __decorate([
    //       handlingRangeError
    //   ], BinaryReader.prototype, "readU32", null);
    //   __decorate([
    //       handlingRangeError
    //   ], BinaryReader.prototype, "readU64", null);
    //   __decorate([
    //       handlingRangeError
    //   ], BinaryReader.prototype, "readU128", null);
    //   __decorate([
    //       handlingRangeError
    //   ], BinaryReader.prototype, "readU256", null);
    //   __decorate([
    //       handlingRangeError
    //   ], BinaryReader.prototype, "readU512", null);
    //   __decorate([
    //       handlingRangeError
    //   ], BinaryReader.prototype, "readString", null);
    //   __decorate([
    //       handlingRangeError
    //   ], BinaryReader.prototype, "readFixedArray", null);
    //   __decorate([
    //       handlingRangeError
    //   ], BinaryReader.prototype, "readArray", null);
    //   lib$1.BinaryReader = BinaryReader;
    //   function capitalizeFirstLetter(string) {
    //       return string.charAt(0).toUpperCase() + string.slice(1);
    //   }
    //   function serializeField(schema, fieldName, value, fieldType, writer) {
    //       try {
    //           // TODO: Handle missing values properly (make sure they never result in just skipped write)
    //           if (typeof fieldType === 'string') {
    //               writer[`write${capitalizeFirstLetter(fieldType)}`](value);
    //           }
    //           else if (fieldType instanceof Array) {
    //               if (typeof fieldType[0] === 'number') {
    //                   if (value.length !== fieldType[0]) {
    //                       throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
    //                   }
    //                   writer.writeFixedArray(value);
    //               }
    //               else {
    //                   writer.writeArray(value, (item) => { serializeField(schema, fieldName, item, fieldType[0], writer); });
    //               }
    //           }
    //           else if (fieldType.kind !== undefined) {
    //               switch (fieldType.kind) {
    //                   case 'option': {
    //                       if (value === null || value === undefined) {
    //                           writer.writeU8(0);
    //                       }
    //                       else {
    //                           writer.writeU8(1);
    //                           serializeField(schema, fieldName, value, fieldType.type, writer);
    //                       }
    //                       break;
    //                   }
    //                   default: throw new BorshError(`FieldType ${fieldType} unrecognized`);
    //               }
    //           }
    //           else {
    //               serializeStruct(schema, value, writer);
    //           }
    //       }
    //       catch (error) {
    //           if (error instanceof BorshError) {
    //               error.addToFieldPath(fieldName);
    //           }
    //           throw error;
    //       }
    //   }
    //   function serializeStruct(schema, obj, writer) {
    //       const structSchema = schema.get(obj.constructor);
    //       if (!structSchema) {
    //           throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
    //       }
    //       if (structSchema.kind === 'struct') {
    //           structSchema.fields.map(([fieldName, fieldType]) => {
    //               serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
    //           });
    //       }
    //       else if (structSchema.kind === 'enum') {
    //           const name = obj[structSchema.field];
    //           for (let idx = 0; idx < structSchema.values.length; ++idx) {
    //               const [fieldName, fieldType] = structSchema.values[idx];
    //               if (fieldName === name) {
    //                   writer.writeU8(idx);
    //                   serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
    //                   break;
    //               }
    //           }
    //       }
    //       else {
    //           throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
    //       }
    //   }
    //   /// Serialize given object using schema of the form:
    //   /// { class_name -> [ [field_name, field_type], .. ], .. }
    //   function serialize(schema, obj) {
    //       const writer = new BinaryWriter();
    //       serializeStruct(schema, obj, writer);
    //       return writer.toArray();
    //   }
    //   var serialize_1 = lib$1.serialize = serialize;
    //   function deserializeField(schema, fieldName, fieldType, reader) {
    //       try {
    //           if (typeof fieldType === 'string') {
    //               return reader[`read${capitalizeFirstLetter(fieldType)}`]();
    //           }
    //           if (fieldType instanceof Array) {
    //               if (typeof fieldType[0] === 'number') {
    //                   return reader.readFixedArray(fieldType[0]);
    //               }
    //               return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
    //           }
    //           if (fieldType.kind === 'option') {
    //               const option = reader.readU8();
    //               if (option) {
    //                   return deserializeField(schema, fieldName, fieldType.type, reader);
    //               }
    //               return undefined;
    //           }
    //           return deserializeStruct(schema, fieldType, reader);
    //       }
    //       catch (error) {
    //           if (error instanceof BorshError) {
    //               error.addToFieldPath(fieldName);
    //           }
    //           throw error;
    //       }
    //   }
    //   function deserializeStruct(schema, classType, reader) {
    //       const structSchema = schema.get(classType);
    //       if (!structSchema) {
    //           throw new BorshError(`Class ${classType.name} is missing in schema`);
    //       }
    //       if (structSchema.kind === 'struct') {
    //           const result = {};
    //           for (const [fieldName, fieldType] of schema.get(classType).fields) {
    //               result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
    //           }
    //           return new classType(result);
    //       }
    //       if (structSchema.kind === 'enum') {
    //           const idx = reader.readU8();
    //           if (idx >= structSchema.values.length) {
    //               throw new BorshError(`Enum index: ${idx} is out of range`);
    //           }
    //           const [fieldName, fieldType] = structSchema.values[idx];
    //           const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
    //           return new classType({ [fieldName]: fieldValue });
    //       }
    //       throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
    //   }
    //   /// Deserializes object from bytes using schema.
    //   function deserialize(schema, classType, buffer) {
    //       const reader = new BinaryReader(buffer);
    //       const result = deserializeStruct(schema, classType, reader);
    //       if (reader.offset < buffer.length) {
    //           throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
    //       }
    //       return result;
    //   }
    //   var deserialize_1 = lib$1.deserialize = deserialize;
    //   /// Deserializes object from bytes using schema, without checking the length read
    //   function deserializeUnchecked(schema, classType, buffer) {
    //       const reader = new BinaryReader(buffer);
    //       return deserializeStruct(schema, classType, reader);
    //   }
    //   deserializeUnchecked_1 = lib$1.deserializeUnchecked = deserializeUnchecked;
    
    //   var Layout$1 = {};
    
    //   /* The MIT License (MIT)
    //    *
    //    * Copyright 2015-2018 Peter A. Bigot
    //    *
    //    * Permission is hereby granted, free of charge, to any person obtaining a copy
    //    * of this software and associated documentation files (the "Software"), to deal
    //    * in the Software without restriction, including without limitation the rights
    //    * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    //    * copies of the Software, and to permit persons to whom the Software is
    //    * furnished to do so, subject to the following conditions:
    //    *
    //    * The above copyright notice and this permission notice shall be included in
    //    * all copies or substantial portions of the Software.
    //    *
    //    * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    //    * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    //    * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    //    * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    //    * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    //    * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    //    * THE SOFTWARE.
    //    */
    //   var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    //       var extendStatics = function (d, b) {
    //           extendStatics = Object.setPrototypeOf ||
    //               ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    //               function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    //           return extendStatics(d, b);
    //       };
    //       return function (d, b) {
    //           if (typeof b !== "function" && b !== null)
    //               throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    //           extendStatics(d, b);
    //           function __() { this.constructor = d; }
    //           d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    //       };
    //   })();
    //   Layout$1.__esModule = true;
    //   Layout$1.s16 = Layout$1.s8 = Layout$1.nu64be = Layout$1.u48be = Layout$1.u40be = Layout$1.u32be = Layout$1.u24be = Layout$1.u16be = nu64 = Layout$1.nu64 = Layout$1.u48 = Layout$1.u40 = u32 = Layout$1.u32 = Layout$1.u24 = u16 = Layout$1.u16 = u8 = Layout$1.u8 = offset = Layout$1.offset = Layout$1.greedy = Layout$1.Constant = Layout$1.UTF8 = Layout$1.CString = Layout$1.Blob = Layout$1.Boolean = Layout$1.BitField = Layout$1.BitStructure = Layout$1.VariantLayout = Layout$1.Union = Layout$1.UnionLayoutDiscriminator = Layout$1.UnionDiscriminator = Layout$1.Structure = Layout$1.Sequence = Layout$1.DoubleBE = Layout$1.Double = Layout$1.FloatBE = Layout$1.Float = Layout$1.NearInt64BE = Layout$1.NearInt64 = Layout$1.NearUInt64BE = Layout$1.NearUInt64 = Layout$1.IntBE = Layout$1.Int = Layout$1.UIntBE = Layout$1.UInt = Layout$1.OffsetLayout = Layout$1.GreedyCount = Layout$1.ExternalLayout = Layout$1.bindConstructorLayout = Layout$1.nameWithProperty = Layout$1.Layout = Layout$1.uint8ArrayToBuffer = Layout$1.checkUint8Array = void 0;
    //   Layout$1.constant = Layout$1.utf8 = Layout$1.cstr = blob = Layout$1.blob = Layout$1.unionLayoutDiscriminator = Layout$1.union = seq = Layout$1.seq = Layout$1.bits = struct = Layout$1.struct = Layout$1.f64be = Layout$1.f64 = Layout$1.f32be = Layout$1.f32 = Layout$1.ns64be = Layout$1.s48be = Layout$1.s40be = Layout$1.s32be = Layout$1.s24be = Layout$1.s16be = ns64 = Layout$1.ns64 = Layout$1.s48 = Layout$1.s40 = Layout$1.s32 = Layout$1.s24 = void 0;
    //   var buffer_1 = buffer;
    //   /* Check if a value is a Uint8Array.
    //    *
    //    * @ignore */
    //   function checkUint8Array(b) {
    //       if (!(b instanceof Uint8Array)) {
    //           throw new TypeError('b must be a Uint8Array');
    //       }
    //   }
    //   Layout$1.checkUint8Array = checkUint8Array;
    //   /* Create a Buffer instance from a Uint8Array.
    //    *
    //    * @ignore */
    //   function uint8ArrayToBuffer(b) {
    //       checkUint8Array(b);
    //       return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
    //   }
    //   Layout$1.uint8ArrayToBuffer = uint8ArrayToBuffer;
    //   /**
    //    * Base class for layout objects.
    //    *
    //    * **NOTE** This is an abstract base class; you can create instances
    //    * if it amuses you, but they won't support the {@link
    //    * Layout#encode|encode} or {@link Layout#decode|decode} functions.
    //    *
    //    * @param {Number} span - Initializer for {@link Layout#span|span}.  The
    //    * parameter must be an integer; a negative value signifies that the
    //    * span is {@link Layout#getSpan|value-specific}.
    //    *
    //    * @param {string} [property] - Initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @abstract
    //    */
    //   var Layout = /** @class */ (function () {
    //       function Layout(span, property) {
    //           if (!Number.isInteger(span)) {
    //               throw new TypeError('span must be an integer');
    //           }
    //           /** The span of the layout in bytes.
    //            *
    //            * Positive values are generally expected.
    //            *
    //            * Zero will only appear in {@link Constant}s and in {@link
    //            * Sequence}s where the {@link Sequence#count|count} is zero.
    //            *
    //            * A negative value indicates that the span is value-specific, and
    //            * must be obtained using {@link Layout#getSpan|getSpan}. */
    //           this.span = span;
    //           /** The property name used when this layout is represented in an
    //            * Object.
    //            *
    //            * Used only for layouts that {@link Layout#decode|decode} to Object
    //            * instances.  If left undefined the span of the unnamed layout will
    //            * be treated as padding: it will not be mutated by {@link
    //            * Layout#encode|encode} nor represented as a property in the
    //            * decoded Object. */
    //           this.property = property;
    //       }
    //       /** Function to create an Object into which decoded properties will
    //        * be written.
    //        *
    //        * Used only for layouts that {@link Layout#decode|decode} to Object
    //        * instances, which means:
    //        * * {@link Structure}
    //        * * {@link Union}
    //        * * {@link VariantLayout}
    //        * * {@link BitStructure}
    //        *
    //        * If left undefined the JavaScript representation of these layouts
    //        * will be Object instances.
    //        *
    //        * See {@link bindConstructorLayout}.
    //        */
    //       Layout.prototype.makeDestinationObject = function () {
    //           return {};
    //       };
    //       /**
    //        * Decode from a Uint8Array into a JavaScript value.
    //        *
    //        * @param {Uint8Array} b - the buffer from which encoded data is read.
    //        *
    //        * @param {Number} [offset] - the offset at which the encoded data
    //        * starts.  If absent a zero offset is inferred.
    //        *
    //        * @returns {(Number|Array|Object)} - the value of the decoded data.
    //        *
    //        * @abstract
    //        */
    //       Layout.prototype.decode = function (b, offset) {
    //           throw new Error('Layout is abstract');
    //       };
    //       /**
    //        * Encode a JavaScript value into a Uint8Array.
    //        *
    //        * @param {(Number|Array|Object)} src - the value to be encoded into
    //        * the buffer.  The type accepted depends on the (sub-)type of {@link
    //        * Layout}.
    //        *
    //        * @param {Uint8Array} b - the buffer into which encoded data will be
    //        * written.
    //        *
    //        * @param {Number} [offset] - the offset at which the encoded data
    //        * starts.  If absent a zero offset is inferred.
    //        *
    //        * @returns {Number} - the number of bytes encoded, including the
    //        * space skipped for internal padding, but excluding data such as
    //        * {@link Sequence#count|lengths} when stored {@link
    //        * ExternalLayout|externally}.  This is the adjustment to `offset`
    //        * producing the offset where data for the next layout would be
    //        * written.
    //        *
    //        * @abstract
    //        */
    //       Layout.prototype.encode = function (src, b, offset) {
    //           throw new Error('Layout is abstract');
    //       };
    //       /**
    //        * Calculate the span of a specific instance of a layout.
    //        *
    //        * @param {Uint8Array} b - the buffer that contains an encoded instance.
    //        *
    //        * @param {Number} [offset] - the offset at which the encoded instance
    //        * starts.  If absent a zero offset is inferred.
    //        *
    //        * @return {Number} - the number of bytes covered by the layout
    //        * instance.  If this method is not overridden in a subclass the
    //        * definition-time constant {@link Layout#span|span} will be
    //        * returned.
    //        *
    //        * @throws {RangeError} - if the length of the value cannot be
    //        * determined.
    //        */
    //       Layout.prototype.getSpan = function (b, offset) {
    //           if (0 > this.span) {
    //               throw new RangeError('indeterminate span');
    //           }
    //           return this.span;
    //       };
    //       /**
    //        * Replicate the layout using a new property.
    //        *
    //        * This function must be used to get a structurally-equivalent layout
    //        * with a different name since all {@link Layout} instances are
    //        * immutable.
    //        *
    //        * **NOTE** This is a shallow copy.  All fields except {@link
    //        * Layout#property|property} are strictly equal to the origin layout.
    //        *
    //        * @param {String} property - the value for {@link
    //        * Layout#property|property} in the replica.
    //        *
    //        * @returns {Layout} - the copy with {@link Layout#property|property}
    //        * set to `property`.
    //        */
    //       Layout.prototype.replicate = function (property) {
    //           var rv = Object.create(this.constructor.prototype);
    //           Object.assign(rv, this);
    //           rv.property = property;
    //           return rv;
    //       };
    //       /**
    //        * Create an object from layout properties and an array of values.
    //        *
    //        * **NOTE** This function returns `undefined` if invoked on a layout
    //        * that does not return its value as an Object.  Objects are
    //        * returned for things that are a {@link Structure}, which includes
    //        * {@link VariantLayout|variant layouts} if they are structures, and
    //        * excludes {@link Union}s.  If you want this feature for a union
    //        * you must use {@link Union.getVariant|getVariant} to select the
    //        * desired layout.
    //        *
    //        * @param {Array} values - an array of values that correspond to the
    //        * default order for properties.  As with {@link Layout#decode|decode}
    //        * layout elements that have no property name are skipped when
    //        * iterating over the array values.  Only the top-level properties are
    //        * assigned; arguments are not assigned to properties of contained
    //        * layouts.  Any unused values are ignored.
    //        *
    //        * @return {(Object|undefined)}
    //        */
    //       Layout.prototype.fromArray = function (values) {
    //           return undefined;
    //       };
    //       return Layout;
    //   }());
    //   Layout$1.Layout = Layout;
    //   /* Provide text that carries a name (such as for a function that will
    //    * be throwing an error) annotated with the property of a given layout
    //    * (such as one for which the value was unacceptable).
    //    *
    //    * @ignore */
    //   function nameWithProperty(name, lo) {
    //       if (lo.property) {
    //           return name + '[' + lo.property + ']';
    //       }
    //       return name;
    //   }
    //   Layout$1.nameWithProperty = nameWithProperty;
    //   /**
    //    * Augment a class so that instances can be encoded/decoded using a
    //    * given layout.
    //    *
    //    * Calling this function couples `Class` with `layout` in several ways:
    //    *
    //    * * `Class.layout_` becomes a static member property equal to `layout`;
    //    * * `layout.boundConstructor_` becomes a static member property equal
    //    *    to `Class`;
    //    * * The {@link Layout#makeDestinationObject|makeDestinationObject()}
    //    *   property of `layout` is set to a function that returns a `new
    //    *   Class()`;
    //    * * `Class.decode(b, offset)` becomes a static member function that
    //    *   delegates to {@link Layout#decode|layout.decode}.  The
    //    *   synthesized function may be captured and extended.
    //    * * `Class.prototype.encode(b, offset)` provides an instance member
    //    *   function that delegates to {@link Layout#encode|layout.encode}
    //    *   with `src` set to `this`.  The synthesized function may be
    //    *   captured and extended, but when the extension is invoked `this`
    //    *   must be explicitly bound to the instance.
    //    *
    //    * @param {class} Class - a JavaScript class with a nullary
    //    * constructor.
    //    *
    //    * @param {Layout} layout - the {@link Layout} instance used to encode
    //    * instances of `Class`.
    //    */
    //   function bindConstructorLayout(Class, layout) {
    //       if ('function' !== typeof Class) {
    //           throw new TypeError('Class must be constructor');
    //       }
    //       if (Object.prototype.hasOwnProperty.call(Class, 'layout_')) {
    //           throw new Error('Class is already bound to a layout');
    //       }
    //       if (!(layout && (layout instanceof Layout))) {
    //           throw new TypeError('layout must be a Layout');
    //       }
    //       if (Object.prototype.hasOwnProperty.call(layout, 'boundConstructor_')) {
    //           throw new Error('layout is already bound to a constructor');
    //       }
    //       Class.layout_ = layout;
    //       layout.boundConstructor_ = Class;
    //       layout.makeDestinationObject = (function () { return new Class(); });
    //       Object.defineProperty(Class.prototype, 'encode', {
    //           value: function (b, offset) {
    //               return layout.encode(this, b, offset);
    //           },
    //           writable: true
    //       });
    //       Object.defineProperty(Class, 'decode', {
    //           value: function (b, offset) {
    //               return layout.decode(b, offset);
    //           },
    //           writable: true
    //       });
    //   }
    //   Layout$1.bindConstructorLayout = bindConstructorLayout;
    //   /**
    //    * An object that behaves like a layout but does not consume space
    //    * within its containing layout.
    //    *
    //    * This is primarily used to obtain metadata about a member, such as a
    //    * {@link OffsetLayout} that can provide data about a {@link
    //    * Layout#getSpan|value-specific span}.
    //    *
    //    * **NOTE** This is an abstract base class; you can create instances
    //    * if it amuses you, but they won't support {@link
    //    * ExternalLayout#isCount|isCount} or other {@link Layout} functions.
    //    *
    //    * @param {Number} span - initializer for {@link Layout#span|span}.
    //    * The parameter can range from 1 through 6.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @abstract
    //    * @augments {Layout}
    //    */
    //   var ExternalLayout = /** @class */ (function (_super) {
    //       __extends(ExternalLayout, _super);
    //       function ExternalLayout() {
    //           return _super !== null && _super.apply(this, arguments) || this;
    //       }
    //       /**
    //        * Return `true` iff the external layout decodes to an unsigned
    //        * integer layout.
    //        *
    //        * In that case it can be used as the source of {@link
    //        * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
    //        * or as {@link UnionLayoutDiscriminator#layout|external union
    //        * discriminators}.
    //        *
    //        * @abstract
    //        */
    //       ExternalLayout.prototype.isCount = function () {
    //           throw new Error('ExternalLayout is abstract');
    //       };
    //       return ExternalLayout;
    //   }(Layout));
    //   Layout$1.ExternalLayout = ExternalLayout;
    //   /**
    //    * An {@link ExternalLayout} that determines its {@link
    //    * Layout#decode|value} based on offset into and length of the buffer
    //    * on which it is invoked.
    //    *
    //    * *Factory*: {@link module:Layout.greedy|greedy}
    //    *
    //    * @param {Number} [elementSpan] - initializer for {@link
    //    * GreedyCount#elementSpan|elementSpan}.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {ExternalLayout}
    //    */
    //   var GreedyCount = /** @class */ (function (_super) {
    //       __extends(GreedyCount, _super);
    //       function GreedyCount(elementSpan, property) {
    //           var _this = this;
    //           if (undefined === elementSpan) {
    //               elementSpan = 1;
    //           }
    //           if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {
    //               throw new TypeError('elementSpan must be a (positive) integer');
    //           }
    //           _this = _super.call(this, -1, property) || this;
    //           /** The layout for individual elements of the sequence.  The value
    //            * must be a positive integer.  If not provided, the value will be
    //            * 1. */
    //           _this.elementSpan = elementSpan;
    //           return _this;
    //       }
    //       /** @override */
    //       GreedyCount.prototype.isCount = function () {
    //           return true;
    //       };
    //       /** @override */
    //       GreedyCount.prototype.decode = function (b, offset) {
    //           checkUint8Array(b);
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var rem = b.length - offset;
    //           return Math.floor(rem / this.elementSpan);
    //       };
    //       /** @override */
    //       GreedyCount.prototype.encode = function (src, b, offset) {
    //           return 0;
    //       };
    //       return GreedyCount;
    //   }(ExternalLayout));
    //   Layout$1.GreedyCount = GreedyCount;
    //   /**
    //    * An {@link ExternalLayout} that supports accessing a {@link Layout}
    //    * at a fixed offset from the start of another Layout.  The offset may
    //    * be before, within, or after the base layout.
    //    *
    //    * *Factory*: {@link module:Layout.offset|offset}
    //    *
    //    * @param {Layout} layout - initializer for {@link
    //    * OffsetLayout#layout|layout}, modulo `property`.
    //    *
    //    * @param {Number} [offset] - Initializes {@link
    //    * OffsetLayout#offset|offset}.  Defaults to zero.
    //    *
    //    * @param {string} [property] - Optional new property name for a
    //    * {@link Layout#replicate| replica} of `layout` to be used as {@link
    //    * OffsetLayout#layout|layout}.  If not provided the `layout` is used
    //    * unchanged.
    //    *
    //    * @augments {Layout}
    //    */
    //   var OffsetLayout = /** @class */ (function (_super) {
    //       __extends(OffsetLayout, _super);
    //       function OffsetLayout(layout, offset, property) {
    //           var _this = this;
    //           if (!(layout instanceof Layout)) {
    //               throw new TypeError('layout must be a Layout');
    //           }
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           else if (!Number.isInteger(offset)) {
    //               throw new TypeError('offset must be integer or undefined');
    //           }
    //           _this = _super.call(this, layout.span, property || layout.property) || this;
    //           /** The subordinated layout. */
    //           _this.layout = layout;
    //           /** The location of {@link OffsetLayout#layout} relative to the
    //            * start of another layout.
    //            *
    //            * The value may be positive or negative, but an error will thrown
    //            * if at the point of use it goes outside the span of the Uint8Array
    //            * being accessed.  */
    //           _this.offset = offset;
    //           return _this;
    //       }
    //       /** @override */
    //       OffsetLayout.prototype.isCount = function () {
    //           return ((this.layout instanceof UInt)
    //               || (this.layout instanceof UIntBE));
    //       };
    //       /** @override */
    //       OffsetLayout.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           return this.layout.decode(b, offset + this.offset);
    //       };
    //       /** @override */
    //       OffsetLayout.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           return this.layout.encode(src, b, offset + this.offset);
    //       };
    //       return OffsetLayout;
    //   }(ExternalLayout));
    //   Layout$1.OffsetLayout = OffsetLayout;
    //   /**
    //    * Represent an unsigned integer in little-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.u8|u8}, {@link
    //    *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link
    //    *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link
    //    *  module:Layout.u48|u48}
    //    *
    //    * @param {Number} span - initializer for {@link Layout#span|span}.
    //    * The parameter can range from 1 through 6.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var UInt = /** @class */ (function (_super) {
    //       __extends(UInt, _super);
    //       function UInt(span, property) {
    //           var _this = _super.call(this, span, property) || this;
    //           if (6 < _this.span) {
    //               throw new RangeError('span must not exceed 6 bytes');
    //           }
    //           return _this;
    //       }
    //       /** @override */
    //       UInt.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);
    //       };
    //       /** @override */
    //       UInt.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);
    //           return this.span;
    //       };
    //       return UInt;
    //   }(Layout));
    //   Layout$1.UInt = UInt;
    //   /**
    //    * Represent an unsigned integer in big-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.u8be|u8be}, {@link
    //    * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},
    //    * {@link module:Layout.u32be|u32be}, {@link
    //    * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}
    //    *
    //    * @param {Number} span - initializer for {@link Layout#span|span}.
    //    * The parameter can range from 1 through 6.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var UIntBE = /** @class */ (function (_super) {
    //       __extends(UIntBE, _super);
    //       function UIntBE(span, property) {
    //           var _this = _super.call(this, span, property) || this;
    //           if (6 < _this.span) {
    //               throw new RangeError('span must not exceed 6 bytes');
    //           }
    //           return _this;
    //       }
    //       /** @override */
    //       UIntBE.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);
    //       };
    //       /** @override */
    //       UIntBE.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);
    //           return this.span;
    //       };
    //       return UIntBE;
    //   }(Layout));
    //   Layout$1.UIntBE = UIntBE;
    //   /**
    //    * Represent a signed integer in little-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.s8|s8}, {@link
    //    *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link
    //    *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link
    //    *  module:Layout.s48|s48}
    //    *
    //    * @param {Number} span - initializer for {@link Layout#span|span}.
    //    * The parameter can range from 1 through 6.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var Int = /** @class */ (function (_super) {
    //       __extends(Int, _super);
    //       function Int(span, property) {
    //           var _this = _super.call(this, span, property) || this;
    //           if (6 < _this.span) {
    //               throw new RangeError('span must not exceed 6 bytes');
    //           }
    //           return _this;
    //       }
    //       /** @override */
    //       Int.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           return uint8ArrayToBuffer(b).readIntLE(offset, this.span);
    //       };
    //       /** @override */
    //       Int.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);
    //           return this.span;
    //       };
    //       return Int;
    //   }(Layout));
    //   Layout$1.Int = Int;
    //   /**
    //    * Represent a signed integer in big-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.s8be|s8be}, {@link
    //    * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},
    //    * {@link module:Layout.s32be|s32be}, {@link
    //    * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}
    //    *
    //    * @param {Number} span - initializer for {@link Layout#span|span}.
    //    * The parameter can range from 1 through 6.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var IntBE = /** @class */ (function (_super) {
    //       __extends(IntBE, _super);
    //       function IntBE(span, property) {
    //           var _this = _super.call(this, span, property) || this;
    //           if (6 < _this.span) {
    //               throw new RangeError('span must not exceed 6 bytes');
    //           }
    //           return _this;
    //       }
    //       /** @override */
    //       IntBE.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           return uint8ArrayToBuffer(b).readIntBE(offset, this.span);
    //       };
    //       /** @override */
    //       IntBE.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);
    //           return this.span;
    //       };
    //       return IntBE;
    //   }(Layout));
    //   Layout$1.IntBE = IntBE;
    //   var V2E32 = Math.pow(2, 32);
    //   /* True modulus high and low 32-bit words, where low word is always
    //    * non-negative. */
    //   function divmodInt64(src) {
    //       var hi32 = Math.floor(src / V2E32);
    //       var lo32 = src - (hi32 * V2E32);
    //       return { hi32: hi32, lo32: lo32 };
    //   }
    //   /* Reconstruct Number from quotient and non-negative remainder */
    //   function roundedInt64(hi32, lo32) {
    //       return hi32 * V2E32 + lo32;
    //   }
    //   /**
    //    * Represent an unsigned 64-bit integer in little-endian format when
    //    * encoded and as a near integral JavaScript Number when decoded.
    //    *
    //    * *Factory*: {@link module:Layout.nu64|nu64}
    //    *
    //    * **NOTE** Values with magnitude greater than 2^52 may not decode to
    //    * the exact value of the encoded representation.
    //    *
    //    * @augments {Layout}
    //    */
    //   var NearUInt64 = /** @class */ (function (_super) {
    //       __extends(NearUInt64, _super);
    //       function NearUInt64(property) {
    //           return _super.call(this, 8, property) || this;
    //       }
    //       /** @override */
    //       NearUInt64.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var buffer = uint8ArrayToBuffer(b);
    //           var lo32 = buffer.readUInt32LE(offset);
    //           var hi32 = buffer.readUInt32LE(offset + 4);
    //           return roundedInt64(hi32, lo32);
    //       };
    //       /** @override */
    //       NearUInt64.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var split = divmodInt64(src);
    //           var buffer = uint8ArrayToBuffer(b);
    //           buffer.writeUInt32LE(split.lo32, offset);
    //           buffer.writeUInt32LE(split.hi32, offset + 4);
    //           return 8;
    //       };
    //       return NearUInt64;
    //   }(Layout));
    //   Layout$1.NearUInt64 = NearUInt64;
    //   /**
    //    * Represent an unsigned 64-bit integer in big-endian format when
    //    * encoded and as a near integral JavaScript Number when decoded.
    //    *
    //    * *Factory*: {@link module:Layout.nu64be|nu64be}
    //    *
    //    * **NOTE** Values with magnitude greater than 2^52 may not decode to
    //    * the exact value of the encoded representation.
    //    *
    //    * @augments {Layout}
    //    */
    //   var NearUInt64BE = /** @class */ (function (_super) {
    //       __extends(NearUInt64BE, _super);
    //       function NearUInt64BE(property) {
    //           return _super.call(this, 8, property) || this;
    //       }
    //       /** @override */
    //       NearUInt64BE.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var buffer = uint8ArrayToBuffer(b);
    //           var hi32 = buffer.readUInt32BE(offset);
    //           var lo32 = buffer.readUInt32BE(offset + 4);
    //           return roundedInt64(hi32, lo32);
    //       };
    //       /** @override */
    //       NearUInt64BE.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var split = divmodInt64(src);
    //           var buffer = uint8ArrayToBuffer(b);
    //           buffer.writeUInt32BE(split.hi32, offset);
    //           buffer.writeUInt32BE(split.lo32, offset + 4);
    //           return 8;
    //       };
    //       return NearUInt64BE;
    //   }(Layout));
    //   Layout$1.NearUInt64BE = NearUInt64BE;
    //   /**
    //    * Represent a signed 64-bit integer in little-endian format when
    //    * encoded and as a near integral JavaScript Number when decoded.
    //    *
    //    * *Factory*: {@link module:Layout.ns64|ns64}
    //    *
    //    * **NOTE** Values with magnitude greater than 2^52 may not decode to
    //    * the exact value of the encoded representation.
    //    *
    //    * @augments {Layout}
    //    */
    //   var NearInt64 = /** @class */ (function (_super) {
    //       __extends(NearInt64, _super);
    //       function NearInt64(property) {
    //           return _super.call(this, 8, property) || this;
    //       }
    //       /** @override */
    //       NearInt64.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var buffer = uint8ArrayToBuffer(b);
    //           var lo32 = buffer.readUInt32LE(offset);
    //           var hi32 = buffer.readInt32LE(offset + 4);
    //           return roundedInt64(hi32, lo32);
    //       };
    //       /** @override */
    //       NearInt64.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var split = divmodInt64(src);
    //           var buffer = uint8ArrayToBuffer(b);
    //           buffer.writeUInt32LE(split.lo32, offset);
    //           buffer.writeInt32LE(split.hi32, offset + 4);
    //           return 8;
    //       };
    //       return NearInt64;
    //   }(Layout));
    //   Layout$1.NearInt64 = NearInt64;
    //   /**
    //    * Represent a signed 64-bit integer in big-endian format when
    //    * encoded and as a near integral JavaScript Number when decoded.
    //    *
    //    * *Factory*: {@link module:Layout.ns64be|ns64be}
    //    *
    //    * **NOTE** Values with magnitude greater than 2^52 may not decode to
    //    * the exact value of the encoded representation.
    //    *
    //    * @augments {Layout}
    //    */
    //   var NearInt64BE = /** @class */ (function (_super) {
    //       __extends(NearInt64BE, _super);
    //       function NearInt64BE(property) {
    //           return _super.call(this, 8, property) || this;
    //       }
    //       /** @override */
    //       NearInt64BE.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var buffer = uint8ArrayToBuffer(b);
    //           var hi32 = buffer.readInt32BE(offset);
    //           var lo32 = buffer.readUInt32BE(offset + 4);
    //           return roundedInt64(hi32, lo32);
    //       };
    //       /** @override */
    //       NearInt64BE.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var split = divmodInt64(src);
    //           var buffer = uint8ArrayToBuffer(b);
    //           buffer.writeInt32BE(split.hi32, offset);
    //           buffer.writeUInt32BE(split.lo32, offset + 4);
    //           return 8;
    //       };
    //       return NearInt64BE;
    //   }(Layout));
    //   Layout$1.NearInt64BE = NearInt64BE;
    //   /**
    //    * Represent a 32-bit floating point number in little-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.f32|f32}
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var Float = /** @class */ (function (_super) {
    //       __extends(Float, _super);
    //       function Float(property) {
    //           return _super.call(this, 4, property) || this;
    //       }
    //       /** @override */
    //       Float.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           return uint8ArrayToBuffer(b).readFloatLE(offset);
    //       };
    //       /** @override */
    //       Float.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           uint8ArrayToBuffer(b).writeFloatLE(src, offset);
    //           return 4;
    //       };
    //       return Float;
    //   }(Layout));
    //   Layout$1.Float = Float;
    //   /**
    //    * Represent a 32-bit floating point number in big-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.f32be|f32be}
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var FloatBE = /** @class */ (function (_super) {
    //       __extends(FloatBE, _super);
    //       function FloatBE(property) {
    //           return _super.call(this, 4, property) || this;
    //       }
    //       /** @override */
    //       FloatBE.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           return uint8ArrayToBuffer(b).readFloatBE(offset);
    //       };
    //       /** @override */
    //       FloatBE.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           uint8ArrayToBuffer(b).writeFloatBE(src, offset);
    //           return 4;
    //       };
    //       return FloatBE;
    //   }(Layout));
    //   Layout$1.FloatBE = FloatBE;
    //   /**
    //    * Represent a 64-bit floating point number in little-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.f64|f64}
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var Double = /** @class */ (function (_super) {
    //       __extends(Double, _super);
    //       function Double(property) {
    //           return _super.call(this, 8, property) || this;
    //       }
    //       /** @override */
    //       Double.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           return uint8ArrayToBuffer(b).readDoubleLE(offset);
    //       };
    //       /** @override */
    //       Double.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           uint8ArrayToBuffer(b).writeDoubleLE(src, offset);
    //           return 8;
    //       };
    //       return Double;
    //   }(Layout));
    //   Layout$1.Double = Double;
    //   /**
    //    * Represent a 64-bit floating point number in big-endian format.
    //    *
    //    * *Factory*: {@link module:Layout.f64be|f64be}
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var DoubleBE = /** @class */ (function (_super) {
    //       __extends(DoubleBE, _super);
    //       function DoubleBE(property) {
    //           return _super.call(this, 8, property) || this;
    //       }
    //       /** @override */
    //       DoubleBE.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           return uint8ArrayToBuffer(b).readDoubleBE(offset);
    //       };
    //       /** @override */
    //       DoubleBE.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           uint8ArrayToBuffer(b).writeDoubleBE(src, offset);
    //           return 8;
    //       };
    //       return DoubleBE;
    //   }(Layout));
    //   Layout$1.DoubleBE = DoubleBE;
    //   /**
    //    * Represent a contiguous sequence of a specific layout as an Array.
    //    *
    //    * *Factory*: {@link module:Layout.seq|seq}
    //    *
    //    * @param {Layout} elementLayout - initializer for {@link
    //    * Sequence#elementLayout|elementLayout}.
    //    *
    //    * @param {(Number|ExternalLayout)} count - initializer for {@link
    //    * Sequence#count|count}.  The parameter must be either a positive
    //    * integer or an instance of {@link ExternalLayout}.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var Sequence = /** @class */ (function (_super) {
    //       __extends(Sequence, _super);
    //       function Sequence(elementLayout, count, property) {
    //           var _this = this;
    //           if (!(elementLayout instanceof Layout)) {
    //               throw new TypeError('elementLayout must be a Layout');
    //           }
    //           if (!(((count instanceof ExternalLayout) && count.isCount())
    //               || (Number.isInteger(count) && (0 <= count)))) {
    //               throw new TypeError('count must be non-negative integer '
    //                   + 'or an unsigned integer ExternalLayout');
    //           }
    //           var span = -1;
    //           if ((!(count instanceof ExternalLayout))
    //               && (0 < elementLayout.span)) {
    //               span = count * elementLayout.span;
    //           }
    //           _this = _super.call(this, span, property) || this;
    //           /** The layout for individual elements of the sequence. */
    //           _this.elementLayout = elementLayout;
    //           /** The number of elements in the sequence.
    //            *
    //            * This will be either a non-negative integer or an instance of
    //            * {@link ExternalLayout} for which {@link
    //            * ExternalLayout#isCount|isCount()} is `true`. */
    //           _this.count = count;
    //           return _this;
    //       }
    //       /** @override */
    //       Sequence.prototype.getSpan = function (b, offset) {
    //           if (0 <= this.span) {
    //               return this.span;
    //           }
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var span = 0;
    //           var count = this.count;
    //           if (count instanceof ExternalLayout) {
    //               count = count.decode(b, offset);
    //           }
    //           if (0 < this.elementLayout.span) {
    //               span = count * this.elementLayout.span;
    //           }
    //           else {
    //               var idx = 0;
    //               while (idx < count) {
    //                   span += this.elementLayout.getSpan(b, offset + span);
    //                   ++idx;
    //               }
    //           }
    //           return span;
    //       };
    //       /** @override */
    //       Sequence.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var rv = [];
    //           var i = 0;
    //           var count = this.count;
    //           if (count instanceof ExternalLayout) {
    //               count = count.decode(b, offset);
    //           }
    //           while (i < count) {
    //               rv.push(this.elementLayout.decode(b, offset));
    //               offset += this.elementLayout.getSpan(b, offset);
    //               i += 1;
    //           }
    //           return rv;
    //       };
    //       /** Implement {@link Layout#encode|encode} for {@link Sequence}.
    //        *
    //        * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
    //        * the unused space in the buffer is left unchanged.  If `src` is
    //        * longer than {@link Sequence#count|count} the unneeded elements are
    //        * ignored.
    //        *
    //        * **NOTE** If {@link Layout#count|count} is an instance of {@link
    //        * ExternalLayout} then the length of `src` will be encoded as the
    //        * count after `src` is encoded. */
    //       Sequence.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var elo = this.elementLayout;
    //           var span = src.reduce(function (span, v) {
    //               return span + elo.encode(v, b, offset + span);
    //           }, 0);
    //           if (this.count instanceof ExternalLayout) {
    //               this.count.encode(src.length, b, offset);
    //           }
    //           return span;
    //       };
    //       return Sequence;
    //   }(Layout));
    //   Layout$1.Sequence = Sequence;
    //   /**
    //    * Represent a contiguous sequence of arbitrary layout elements as an
    //    * Object.
    //    *
    //    * *Factory*: {@link module:Layout.struct|struct}
    //    *
    //    * **NOTE** The {@link Layout#span|span} of the structure is variable
    //    * if any layout in {@link Structure#fields|fields} has a variable
    //    * span.  When {@link Layout#encode|encoding} we must have a value for
    //    * all variable-length fields, or we wouldn't be able to figure out
    //    * how much space to use for storage.  We can only identify the value
    //    * for a field when it has a {@link Layout#property|property}.  As
    //    * such, although a structure may contain both unnamed fields and
    //    * variable-length fields, it cannot contain an unnamed
    //    * variable-length field.
    //    *
    //    * @param {Layout[]} fields - initializer for {@link
    //    * Structure#fields|fields}.  An error is raised if this contains a
    //    * variable-length field for which a {@link Layout#property|property}
    //    * is not defined.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @param {Boolean} [decodePrefixes] - initializer for {@link
    //    * Structure#decodePrefixes|property}.
    //    *
    //    * @throws {Error} - if `fields` contains an unnamed variable-length
    //    * layout.
    //    *
    //    * @augments {Layout}
    //    */
    //   var Structure = /** @class */ (function (_super) {
    //       __extends(Structure, _super);
    //       function Structure(fields, property, decodePrefixes) {
    //           var _this = this;
    //           if (!(Array.isArray(fields)
    //               && fields.reduce(function (acc, v) { return acc && (v instanceof Layout); }, true))) {
    //               throw new TypeError('fields must be array of Layout instances');
    //           }
    //           if (('boolean' === typeof property)
    //               && (undefined === decodePrefixes)) {
    //               decodePrefixes = property;
    //               property = undefined;
    //           }
    //           /* Verify absence of unnamed variable-length fields. */
    //           for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
    //               var fd = fields_1[_i];
    //               if ((0 > fd.span)
    //                   && (undefined === fd.property)) {
    //                   throw new Error('fields cannot contain unnamed variable-length layout');
    //               }
    //           }
    //           var span = -1;
    //           try {
    //               span = fields.reduce(function (span, fd) { return span + fd.getSpan(); }, 0);
    //           }
    //           catch (e) {
    //               // ignore error
    //           }
    //           _this = _super.call(this, span, property) || this;
    //           /** The sequence of {@link Layout} values that comprise the
    //            * structure.
    //            *
    //            * The individual elements need not be the same type, and may be
    //            * either scalar or aggregate layouts.  If a member layout leaves
    //            * its {@link Layout#property|property} undefined the
    //            * corresponding region of the buffer associated with the element
    //            * will not be mutated.
    //            *
    //            * @type {Layout[]} */
    //           _this.fields = fields;
    //           /** Control behavior of {@link Layout#decode|decode()} given short
    //            * buffers.
    //            *
    //            * In some situations a structure many be extended with additional
    //            * fields over time, with older installations providing only a
    //            * prefix of the full structure.  If this property is `true`
    //            * decoding will accept those buffers and leave subsequent fields
    //            * undefined, as long as the buffer ends at a field boundary.
    //            * Defaults to `false`. */
    //           _this.decodePrefixes = !!decodePrefixes;
    //           return _this;
    //       }
    //       /** @override */
    //       Structure.prototype.getSpan = function (b, offset) {
    //           if (0 <= this.span) {
    //               return this.span;
    //           }
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var span = 0;
    //           try {
    //               span = this.fields.reduce(function (span, fd) {
    //                   var fsp = fd.getSpan(b, offset);
    //                   offset += fsp;
    //                   return span + fsp;
    //               }, 0);
    //           }
    //           catch (e) {
    //               throw new RangeError('indeterminate span');
    //           }
    //           return span;
    //       };
    //       /** @override */
    //       Structure.prototype.decode = function (b, offset) {
    //           checkUint8Array(b);
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var dest = this.makeDestinationObject();
    //           for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {
    //               var fd = _a[_i];
    //               if (undefined !== fd.property) {
    //                   dest[fd.property] = fd.decode(b, offset);
    //               }
    //               offset += fd.getSpan(b, offset);
    //               if (this.decodePrefixes
    //                   && (b.length === offset)) {
    //                   break;
    //               }
    //           }
    //           return dest;
    //       };
    //       /** Implement {@link Layout#encode|encode} for {@link Structure}.
    //        *
    //        * If `src` is missing a property for a member with a defined {@link
    //        * Layout#property|property} the corresponding region of the buffer is
    //        * left unmodified. */
    //       Structure.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var firstOffset = offset;
    //           var lastOffset = 0;
    //           var lastWrote = 0;
    //           for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {
    //               var fd = _a[_i];
    //               var span = fd.span;
    //               lastWrote = (0 < span) ? span : 0;
    //               if (undefined !== fd.property) {
    //                   var fv = src[fd.property];
    //                   if (undefined !== fv) {
    //                       lastWrote = fd.encode(fv, b, offset);
    //                       if (0 > span) {
    //                           /* Read the as-encoded span, which is not necessarily the
    //                            * same as what we wrote. */
    //                           span = fd.getSpan(b, offset);
    //                       }
    //                   }
    //               }
    //               lastOffset = offset;
    //               offset += span;
    //           }
    //           /* Use (lastOffset + lastWrote) instead of offset because the last
    //            * item may have had a dynamic length and we don't want to include
    //            * the padding between it and the end of the space reserved for
    //            * it. */
    //           return (lastOffset + lastWrote) - firstOffset;
    //       };
    //       /** @override */
    //       Structure.prototype.fromArray = function (values) {
    //           var dest = this.makeDestinationObject();
    //           for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {
    //               var fd = _a[_i];
    //               if ((undefined !== fd.property)
    //                   && (0 < values.length)) {
    //                   dest[fd.property] = values.shift();
    //               }
    //           }
    //           return dest;
    //       };
    //       /**
    //        * Get access to the layout of a given property.
    //        *
    //        * @param {String} property - the structure member of interest.
    //        *
    //        * @return {Layout} - the layout associated with `property`, or
    //        * undefined if there is no such property.
    //        */
    //       Structure.prototype.layoutFor = function (property) {
    //           if ('string' !== typeof property) {
    //               throw new TypeError('property must be string');
    //           }
    //           for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {
    //               var fd = _a[_i];
    //               if (fd.property === property) {
    //                   return fd;
    //               }
    //           }
    //           return undefined;
    //       };
    //       /**
    //        * Get the offset of a structure member.
    //        *
    //        * @param {String} property - the structure member of interest.
    //        *
    //        * @return {Number} - the offset in bytes to the start of `property`
    //        * within the structure, or undefined if `property` is not a field
    //        * within the structure.  If the property is a member but follows a
    //        * variable-length structure member a negative number will be
    //        * returned.
    //        */
    //       Structure.prototype.offsetOf = function (property) {
    //           if ('string' !== typeof property) {
    //               throw new TypeError('property must be string');
    //           }
    //           var offset = 0;
    //           for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {
    //               var fd = _a[_i];
    //               if (fd.property === property) {
    //                   return offset;
    //               }
    //               if (0 > fd.span) {
    //                   offset = -1;
    //               }
    //               else if (0 <= offset) {
    //                   offset += fd.span;
    //               }
    //           }
    //           return undefined;
    //       };
    //       return Structure;
    //   }(Layout));
    //   Layout$1.Structure = Structure;
    //   /**
    //    * An object that can provide a {@link
    //    * Union#discriminator|discriminator} API for {@link Union}.
    //    *
    //    * **NOTE** This is an abstract base class; you can create instances
    //    * if it amuses you, but they won't support the {@link
    //    * UnionDiscriminator#encode|encode} or {@link
    //    * UnionDiscriminator#decode|decode} functions.
    //    *
    //    * @param {string} [property] - Default for {@link
    //    * UnionDiscriminator#property|property}.
    //    *
    //    * @abstract
    //    */
    //   var UnionDiscriminator = /** @class */ (function () {
    //       function UnionDiscriminator(property) {
    //           /** The {@link Layout#property|property} to be used when the
    //            * discriminator is referenced in isolation (generally when {@link
    //            * Union#decode|Union decode} cannot delegate to a specific
    //            * variant). */
    //           this.property = property;
    //       }
    //       /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
    //        *
    //        * The implementation of this method need not reference the buffer if
    //        * variant information is available through other means. */
    //       UnionDiscriminator.prototype.decode = function (b, offset) {
    //           throw new Error('UnionDiscriminator is abstract');
    //       };
    //       /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
    //        *
    //        * The implementation of this method need not store the value if
    //        * variant information is maintained through other means. */
    //       UnionDiscriminator.prototype.encode = function (src, b, offset) {
    //           throw new Error('UnionDiscriminator is abstract');
    //       };
    //       return UnionDiscriminator;
    //   }());
    //   Layout$1.UnionDiscriminator = UnionDiscriminator;
    //   /**
    //    * An object that can provide a {@link
    //    * UnionDiscriminator|discriminator API} for {@link Union} using an
    //    * unsigned integral {@link Layout} instance located either inside or
    //    * outside the union.
    //    *
    //    * @param {ExternalLayout} layout - initializes {@link
    //    * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link
    //    * ExternalLayout#isCount|isCount()}.
    //    *
    //    * @param {string} [property] - Default for {@link
    //    * UnionDiscriminator#property|property}, superseding the property
    //    * from `layout`, but defaulting to `variant` if neither `property`
    //    * nor layout provide a property name.
    //    *
    //    * @augments {UnionDiscriminator}
    //    */
    //   var UnionLayoutDiscriminator = /** @class */ (function (_super) {
    //       __extends(UnionLayoutDiscriminator, _super);
    //       function UnionLayoutDiscriminator(layout, property) {
    //           var _this = this;
    //           if (!((layout instanceof ExternalLayout)
    //               && layout.isCount())) {
    //               throw new TypeError('layout must be an unsigned integer ExternalLayout');
    //           }
    //           _this = _super.call(this, property || layout.property || 'variant') || this;
    //           /** The {@link ExternalLayout} used to access the discriminator
    //            * value. */
    //           _this.layout = layout;
    //           return _this;
    //       }
    //       /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
    //       UnionLayoutDiscriminator.prototype.decode = function (b, offset) {
    //           return this.layout.decode(b, offset);
    //       };
    //       /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
    //       UnionLayoutDiscriminator.prototype.encode = function (src, b, offset) {
    //           return this.layout.encode(src, b, offset);
    //       };
    //       return UnionLayoutDiscriminator;
    //   }(UnionDiscriminator));
    //   Layout$1.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
    //   /**
    //    * Represent any number of span-compatible layouts.
    //    *
    //    * *Factory*: {@link module:Layout.union|union}
    //    *
    //    * If the union has a {@link Union#defaultLayout|default layout} that
    //    * layout must have a non-negative {@link Layout#span|span}.  The span
    //    * of a fixed-span union includes its {@link
    //    * Union#discriminator|discriminator} if the variant is a {@link
    //    * Union#usesPrefixDiscriminator|prefix of the union}, plus the span
    //    * of its {@link Union#defaultLayout|default layout}.
    //    *
    //    * If the union does not have a default layout then the encoded span
    //    * of the union depends on the encoded span of its variant (which may
    //    * be fixed or variable).
    //    *
    //    * {@link VariantLayout#layout|Variant layout}s are added through
    //    * {@link Union#addVariant|addVariant}.  If the union has a default
    //    * layout, the span of the {@link VariantLayout#layout|layout
    //    * contained by the variant} must not exceed the span of the {@link
    //    * Union#defaultLayout|default layout} (minus the span of a {@link
    //    * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The
    //    * span of the variant will equal the span of the union itself.
    //    *
    //    * The variant for a buffer can only be identified from the {@link
    //    * Union#discriminator|discriminator} {@link
    //    * UnionDiscriminator#property|property} (in the case of the {@link
    //    * Union#defaultLayout|default layout}), or by using {@link
    //    * Union#getVariant|getVariant} and examining the resulting {@link
    //    * VariantLayout} instance.
    //    *
    //    * A variant compatible with a JavaScript object can be identified
    //    * using {@link Union#getSourceVariant|getSourceVariant}.
    //    *
    //    * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to
    //    * identify the layout used to interpret the union contents.  The
    //    * parameter must be an instance of {@link UnionDiscriminator}, an
    //    * {@link ExternalLayout} that satisfies {@link
    //    * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link
    //    * UIntBE}).  When a non-external layout element is passed the layout
    //    * appears at the start of the union.  In all cases the (synthesized)
    //    * {@link UnionDiscriminator} instance is recorded as {@link
    //    * Union#discriminator|discriminator}.
    //    *
    //    * @param {(Layout|null)} defaultLayout - initializer for {@link
    //    * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.
    //    * If `null` there is no default layout: the union has data-dependent
    //    * length and attempts to decode or encode unrecognized variants will
    //    * throw an exception.  A {@link Layout} instance must have a
    //    * non-negative {@link Layout#span|span}, and if it lacks a {@link
    //    * Layout#property|property} the {@link
    //    * Union#defaultLayout|defaultLayout} will be a {@link
    //    * Layout#replicate|replica} with property `content`.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var Union = /** @class */ (function (_super) {
    //       __extends(Union, _super);
    //       function Union(discr, defaultLayout, property) {
    //           var _this = this;
    //           var upv = ((discr instanceof UInt)
    //               || (discr instanceof UIntBE));
    //           var discriminator;
    //           if (upv) {
    //               discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
    //           }
    //           else if ((discr instanceof ExternalLayout)
    //               && discr.isCount()) {
    //               discriminator = new UnionLayoutDiscriminator(discr);
    //           }
    //           else if (!(discr instanceof UnionDiscriminator)) {
    //               throw new TypeError('discr must be a UnionDiscriminator '
    //                   + 'or an unsigned integer layout');
    //           }
    //           else {
    //               discriminator = discr;
    //           }
    //           if (undefined === defaultLayout) {
    //               defaultLayout = null;
    //           }
    //           if (!((null === defaultLayout)
    //               || (defaultLayout instanceof Layout))) {
    //               throw new TypeError('defaultLayout must be null or a Layout');
    //           }
    //           if (null !== defaultLayout) {
    //               if (0 > defaultLayout.span) {
    //                   throw new Error('defaultLayout must have constant span');
    //               }
    //               if (undefined === defaultLayout.property) {
    //                   defaultLayout = defaultLayout.replicate('content');
    //               }
    //           }
    //           /* The union span can be estimated only if there's a default
    //            * layout.  The union spans its default layout, plus any prefix
    //            * variant layout.  By construction both layouts, if present, have
    //            * non-negative span. */
    //           var span = -1;
    //           if (defaultLayout) {
    //               span = defaultLayout.span;
    //               if ((0 <= span) && upv) {
    //                   span += discriminator.layout.span;
    //               }
    //           }
    //           _this = _super.call(this, span, property) || this;
    //           /** The interface for the discriminator value in isolation.
    //            *
    //            * This a {@link UnionDiscriminator} either passed to the
    //            * constructor or synthesized from the `discr` constructor
    //            * argument.  {@link
    //            * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be
    //            * `true` iff the `discr` parameter was a non-offset {@link
    //            * Layout} instance. */
    //           _this.discriminator = discriminator;
    //           /** `true` if the {@link Union#discriminator|discriminator} is the
    //            * first field in the union.
    //            *
    //            * If `false` the discriminator is obtained from somewhere
    //            * else. */
    //           _this.usesPrefixDiscriminator = upv;
    //           /** The layout for non-discriminator content when the value of the
    //            * discriminator is not recognized.
    //            *
    //            * This is the value passed to the constructor.  It is
    //            * structurally equivalent to the second component of {@link
    //            * Union#layout|layout} but may have a different property
    //            * name. */
    //           _this.defaultLayout = defaultLayout;
    //           /** A registry of allowed variants.
    //            *
    //            * The keys are unsigned integers which should be compatible with
    //            * {@link Union.discriminator|discriminator}.  The property value
    //            * is the corresponding {@link VariantLayout} instances assigned
    //            * to this union by {@link Union#addVariant|addVariant}.
    //            *
    //            * **NOTE** The registry remains mutable so that variants can be
    //            * {@link Union#addVariant|added} at any time.  Users should not
    //            * manipulate the content of this property. */
    //           _this.registry = {};
    //           /* Private variable used when invoking getSourceVariant */
    //           var boundGetSourceVariant = _this.defaultGetSourceVariant.bind(_this);
    //           /** Function to infer the variant selected by a source object.
    //            *
    //            * Defaults to {@link
    //            * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may
    //            * be overridden using {@link
    //            * Union#configGetSourceVariant|configGetSourceVariant}.
    //            *
    //            * @param {Object} src - as with {@link
    //            * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
    //            *
    //            * @returns {(undefined|VariantLayout)} The default variant
    //            * (`undefined`) or first registered variant that uses a property
    //            * available in `src`. */
    //           _this.getSourceVariant = function (src) {
    //               return boundGetSourceVariant(src);
    //           };
    //           /** Function to override the implementation of {@link
    //            * Union#getSourceVariant|getSourceVariant}.
    //            *
    //            * Use this if the desired variant cannot be identified using the
    //            * algorithm of {@link
    //            * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
    //            *
    //            * **NOTE** The provided function will be invoked bound to this
    //            * Union instance, providing local access to {@link
    //            * Union#registry|registry}.
    //            *
    //            * @param {Function} gsv - a function that follows the API of
    //            * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */
    //           _this.configGetSourceVariant = function (gsv) {
    //               boundGetSourceVariant = gsv.bind(this);
    //           };
    //           return _this;
    //       }
    //       /** @override */
    //       Union.prototype.getSpan = function (b, offset) {
    //           if (0 <= this.span) {
    //               return this.span;
    //           }
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           /* Default layouts always have non-negative span, so we don't have
    //            * one and we have to recognize the variant which will in turn
    //            * determine the span. */
    //           var vlo = this.getVariant(b, offset);
    //           if (!vlo) {
    //               throw new Error('unable to determine span for unrecognized variant');
    //           }
    //           return vlo.getSpan(b, offset);
    //       };
    //       /**
    //        * Method to infer a registered Union variant compatible with `src`.
    //        *
    //        * The first satisfied rule in the following sequence defines the
    //        * return value:
    //        * * If `src` has properties matching the Union discriminator and
    //        *   the default layout, `undefined` is returned regardless of the
    //        *   value of the discriminator property (this ensures the default
    //        *   layout will be used);
    //        * * If `src` has a property matching the Union discriminator, the
    //        *   value of the discriminator identifies a registered variant, and
    //        *   either (a) the variant has no layout, or (b) `src` has the
    //        *   variant's property, then the variant is returned (because the
    //        *   source satisfies the constraints of the variant it identifies);
    //        * * If `src` does not have a property matching the Union
    //        *   discriminator, but does have a property matching a registered
    //        *   variant, then the variant is returned (because the source
    //        *   matches a variant without an explicit conflict);
    //        * * An error is thrown (because we either can't identify a variant,
    //        *   or we were explicitly told the variant but can't satisfy it).
    //        *
    //        * @param {Object} src - an object presumed to be compatible with
    //        * the content of the Union.
    //        *
    //        * @return {(undefined|VariantLayout)} - as described above.
    //        *
    //        * @throws {Error} - if `src` cannot be associated with a default or
    //        * registered variant.
    //        */
    //       Union.prototype.defaultGetSourceVariant = function (src) {
    //           if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
    //               if (this.defaultLayout && this.defaultLayout.property
    //                   && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
    //                   return undefined;
    //               }
    //               var vlo = this.registry[src[this.discriminator.property]];
    //               if (vlo
    //                   && ((!vlo.layout)
    //                       || (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)))) {
    //                   return vlo;
    //               }
    //           }
    //           else {
    //               for (var tag in this.registry) {
    //                   var vlo = this.registry[tag];
    //                   if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
    //                       return vlo;
    //                   }
    //               }
    //           }
    //           throw new Error('unable to infer src variant');
    //       };
    //       /** Implement {@link Layout#decode|decode} for {@link Union}.
    //        *
    //        * If the variant is {@link Union#addVariant|registered} the return
    //        * value is an instance of that variant, with no explicit
    //        * discriminator.  Otherwise the {@link Union#defaultLayout|default
    //        * layout} is used to decode the content. */
    //       Union.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var dest;
    //           var dlo = this.discriminator;
    //           var discr = dlo.decode(b, offset);
    //           var clo = this.registry[discr];
    //           if (undefined === clo) {
    //               var defaultLayout = this.defaultLayout;
    //               var contentOffset = 0;
    //               if (this.usesPrefixDiscriminator) {
    //                   contentOffset = dlo.layout.span;
    //               }
    //               dest = this.makeDestinationObject();
    //               dest[dlo.property] = discr;
    //               dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);
    //           }
    //           else {
    //               dest = clo.decode(b, offset);
    //           }
    //           return dest;
    //       };
    //       /** Implement {@link Layout#encode|encode} for {@link Union}.
    //        *
    //        * This API assumes the `src` object is consistent with the union's
    //        * {@link Union#defaultLayout|default layout}.  To encode variants
    //        * use the appropriate variant-specific {@link VariantLayout#encode}
    //        * method. */
    //       Union.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var vlo = this.getSourceVariant(src);
    //           if (undefined === vlo) {
    //               var dlo = this.discriminator;
    //               // this.defaultLayout is not undefined when vlo is undefined
    //               var clo = this.defaultLayout;
    //               var contentOffset = 0;
    //               if (this.usesPrefixDiscriminator) {
    //                   contentOffset = dlo.layout.span;
    //               }
    //               dlo.encode(src[dlo.property], b, offset);
    //               // clo.property is not undefined when vlo is undefined
    //               return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);
    //           }
    //           return vlo.encode(src, b, offset);
    //       };
    //       /** Register a new variant structure within a union.  The newly
    //        * created variant is returned.
    //        *
    //        * @param {Number} variant - initializer for {@link
    //        * VariantLayout#variant|variant}.
    //        *
    //        * @param {Layout} layout - initializer for {@link
    //        * VariantLayout#layout|layout}.
    //        *
    //        * @param {String} property - initializer for {@link
    //        * Layout#property|property}.
    //        *
    //        * @return {VariantLayout} */
    //       Union.prototype.addVariant = function (variant, layout, property) {
    //           var rv = new VariantLayout(this, variant, layout, property);
    //           this.registry[variant] = rv;
    //           return rv;
    //       };
    //       /**
    //        * Get the layout associated with a registered variant.
    //        *
    //        * If `vb` does not produce a registered variant the function returns
    //        * `undefined`.
    //        *
    //        * @param {(Number|Uint8Array)} vb - either the variant number, or a
    //        * buffer from which the discriminator is to be read.
    //        *
    //        * @param {Number} offset - offset into `vb` for the start of the
    //        * union.  Used only when `vb` is an instance of {Uint8Array}.
    //        *
    //        * @return {({VariantLayout}|undefined)}
    //        */
    //       Union.prototype.getVariant = function (vb, offset) {
    //           var variant;
    //           if (vb instanceof Uint8Array) {
    //               if (undefined === offset) {
    //                   offset = 0;
    //               }
    //               variant = this.discriminator.decode(vb, offset);
    //           }
    //           else {
    //               variant = vb;
    //           }
    //           return this.registry[variant];
    //       };
    //       return Union;
    //   }(Layout));
    //   Layout$1.Union = Union;
    //   /**
    //    * Represent a specific variant within a containing union.
    //    *
    //    * **NOTE** The {@link Layout#span|span} of the variant may include
    //    * the span of the {@link Union#discriminator|discriminator} used to
    //    * identify it, but values read and written using the variant strictly
    //    * conform to the content of {@link VariantLayout#layout|layout}.
    //    *
    //    * **NOTE** User code should not invoke this constructor directly.  Use
    //    * the union {@link Union#addVariant|addVariant} helper method.
    //    *
    //    * @param {Union} union - initializer for {@link
    //    * VariantLayout#union|union}.
    //    *
    //    * @param {Number} variant - initializer for {@link
    //    * VariantLayout#variant|variant}.
    //    *
    //    * @param {Layout} [layout] - initializer for {@link
    //    * VariantLayout#layout|layout}.  If absent the variant carries no
    //    * data.
    //    *
    //    * @param {String} [property] - initializer for {@link
    //    * Layout#property|property}.  Unlike many other layouts, variant
    //    * layouts normally include a property name so they can be identified
    //    * within their containing {@link Union}.  The property identifier may
    //    * be absent only if `layout` is is absent.
    //    *
    //    * @augments {Layout}
    //    */
    //   var VariantLayout = /** @class */ (function (_super) {
    //       __extends(VariantLayout, _super);
    //       function VariantLayout(union, variant, layout, property) {
    //           var _this = this;
    //           if (!(union instanceof Union)) {
    //               throw new TypeError('union must be a Union');
    //           }
    //           if ((!Number.isInteger(variant)) || (0 > variant)) {
    //               throw new TypeError('variant must be a (non-negative) integer');
    //           }
    //           if (('string' === typeof layout)
    //               && (undefined === property)) {
    //               property = layout;
    //               layout = null;
    //           }
    //           if (layout) {
    //               if (!(layout instanceof Layout)) {
    //                   throw new TypeError('layout must be a Layout');
    //               }
    //               if ((null !== union.defaultLayout)
    //                   && (0 <= layout.span)
    //                   && (layout.span > union.defaultLayout.span)) {
    //                   throw new Error('variant span exceeds span of containing union');
    //               }
    //               if ('string' !== typeof property) {
    //                   throw new TypeError('variant must have a String property');
    //               }
    //           }
    //           var span = union.span;
    //           if (0 > union.span) {
    //               span = layout ? layout.span : 0;
    //               if ((0 <= span) && union.usesPrefixDiscriminator) {
    //                   span += union.discriminator.layout.span;
    //               }
    //           }
    //           _this = _super.call(this, span, property) || this;
    //           /** The {@link Union} to which this variant belongs. */
    //           _this.union = union;
    //           /** The unsigned integral value identifying this variant within
    //            * the {@link Union#discriminator|discriminator} of the containing
    //            * union. */
    //           _this.variant = variant;
    //           /** The {@link Layout} to be used when reading/writing the
    //            * non-discriminator part of the {@link
    //            * VariantLayout#union|union}.  If `null` the variant carries no
    //            * data. */
    //           _this.layout = layout || null;
    //           return _this;
    //       }
    //       /** @override */
    //       VariantLayout.prototype.getSpan = function (b, offset) {
    //           if (0 <= this.span) {
    //               /* Will be equal to the containing union span if that is not
    //                * variable. */
    //               return this.span;
    //           }
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var contentOffset = 0;
    //           if (this.union.usesPrefixDiscriminator) {
    //               contentOffset = this.union.discriminator.layout.span;
    //           }
    //           /* Span is defined solely by the variant (and prefix discriminator) */
    //           var span = 0;
    //           if (this.layout) {
    //               span = this.layout.getSpan(b, offset + contentOffset);
    //           }
    //           return contentOffset + span;
    //       };
    //       /** @override */
    //       VariantLayout.prototype.decode = function (b, offset) {
    //           var dest = this.makeDestinationObject();
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           if (this !== this.union.getVariant(b, offset)) {
    //               throw new Error('variant mismatch');
    //           }
    //           var contentOffset = 0;
    //           if (this.union.usesPrefixDiscriminator) {
    //               contentOffset = this.union.discriminator.layout.span;
    //           }
    //           // VariantLayout property is never undefined
    //           var property = this.property;
    //           if (this.layout) {
    //               dest[property] = this.layout.decode(b, offset + contentOffset);
    //           }
    //           else if (property) {
    //               dest[property] = true;
    //           }
    //           else if (this.union.usesPrefixDiscriminator) {
    //               dest[this.union.discriminator.property] = this.variant;
    //           }
    //           return dest;
    //       };
    //       /** @override */
    //       VariantLayout.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var contentOffset = 0;
    //           if (this.union.usesPrefixDiscriminator) {
    //               contentOffset = this.union.discriminator.layout.span;
    //           }
    //           // VariantLayout property is never undefined
    //           var property = this.property;
    //           if (this.layout
    //               && (!Object.prototype.hasOwnProperty.call(src, property))) {
    //               throw new TypeError('variant lacks property ' + property);
    //           }
    //           this.union.discriminator.encode(this.variant, b, offset);
    //           var span = contentOffset;
    //           if (this.layout) {
    //               this.layout.encode(src[property], b, offset + contentOffset);
    //               span += this.layout.getSpan(b, offset + contentOffset);
    //               if ((0 <= this.union.span)
    //                   && (span > this.union.span)) {
    //                   throw new Error('encoded variant overruns containing union');
    //               }
    //           }
    //           return span;
    //       };
    //       /** Delegate {@link Layout#fromArray|fromArray} to {@link
    //        * VariantLayout#layout|layout}. */
    //       VariantLayout.prototype.fromArray = function (values) {
    //           if (this.layout) {
    //               return this.layout.fromArray(values);
    //           }
    //           return undefined;
    //       };
    //       return VariantLayout;
    //   }(Layout));
    //   Layout$1.VariantLayout = VariantLayout;
    //   /** JavaScript chose to define bitwise operations as operating on
    //    * signed 32-bit values in 2's complement form, meaning any integer
    //    * with bit 31 set is going to look negative.  For right shifts that's
    //    * not a problem, because `>>>` is a logical shift, but for every
    //    * other bitwise operator we have to compensate for possible negative
    //    * results. */
    //   function fixBitwiseResult(v) {
    //       if (0 > v) {
    //           v += 0x100000000;
    //       }
    //       return v;
    //   }
    //   /**
    //    * Contain a sequence of bit fields as an unsigned integer.
    //    *
    //    * *Factory*: {@link module:Layout.bits|bits}
    //    *
    //    * This is a container element; within it there are {@link BitField}
    //    * instances that provide the extracted properties.  The container
    //    * simply defines the aggregate representation and its bit ordering.
    //    * The representation is an object containing properties with numeric
    //    * or {@link Boolean} values.
    //    *
    //    * {@link BitField}s are added with the {@link
    //    * BitStructure#addField|addField} and {@link
    //    * BitStructure#addBoolean|addBoolean} methods.
    
    //    * @param {Layout} word - initializer for {@link
    //    * BitStructure#word|word}.  The parameter must be an instance of
    //    * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.
    //    *
    //    * @param {bool} [msb] - `true` if the bit numbering starts at the
    //    * most significant bit of the containing word; `false` (default) if
    //    * it starts at the least significant bit of the containing word.  If
    //    * the parameter at this position is a string and `property` is
    //    * `undefined` the value of this argument will instead be used as the
    //    * value of `property`.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var BitStructure = /** @class */ (function (_super) {
    //       __extends(BitStructure, _super);
    //       function BitStructure(word, msb, property) {
    //           var _this = this;
    //           if (!((word instanceof UInt)
    //               || (word instanceof UIntBE))) {
    //               throw new TypeError('word must be a UInt or UIntBE layout');
    //           }
    //           if (('string' === typeof msb)
    //               && (undefined === property)) {
    //               property = msb;
    //               msb = false;
    //           }
    //           if (4 < word.span) {
    //               throw new RangeError('word cannot exceed 32 bits');
    //           }
    //           _this = _super.call(this, word.span, property) || this;
    //           /** The layout used for the packed value.  {@link BitField}
    //            * instances are packed sequentially depending on {@link
    //            * BitStructure#msb|msb}. */
    //           _this.word = word;
    //           /** Whether the bit sequences are packed starting at the most
    //            * significant bit growing down (`true`), or the least significant
    //            * bit growing up (`false`).
    //            *
    //            * **NOTE** Regardless of this value, the least significant bit of
    //            * any {@link BitField} value is the least significant bit of the
    //            * corresponding section of the packed value. */
    //           _this.msb = !!msb;
    //           /** The sequence of {@link BitField} layouts that comprise the
    //            * packed structure.
    //            *
    //            * **NOTE** The array remains mutable to allow fields to be {@link
    //            * BitStructure#addField|added} after construction.  Users should
    //            * not manipulate the content of this property.*/
    //           _this.fields = [];
    //           /* Storage for the value.  Capture a variable instead of using an
    //            * instance property because we don't want anything to change the
    //            * value without going through the mutator. */
    //           var value = 0;
    //           _this._packedSetValue = function (v) {
    //               value = fixBitwiseResult(v);
    //               return this;
    //           };
    //           _this._packedGetValue = function () {
    //               return value;
    //           };
    //           return _this;
    //       }
    //       /** @override */
    //       BitStructure.prototype.decode = function (b, offset) {
    //           var dest = this.makeDestinationObject();
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var value = this.word.decode(b, offset);
    //           this._packedSetValue(value);
    //           for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {
    //               var fd = _a[_i];
    //               if (undefined !== fd.property) {
    //                   dest[fd.property] = fd.decode(value);
    //               }
    //           }
    //           return dest;
    //       };
    //       /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
    //        *
    //        * If `src` is missing a property for a member with a defined {@link
    //        * Layout#property|property} the corresponding region of the packed
    //        * value is left unmodified.  Unused bits are also left unmodified. */
    //       BitStructure.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var value = this.word.decode(b, offset);
    //           this._packedSetValue(value);
    //           for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {
    //               var fd = _a[_i];
    //               if (undefined !== fd.property) {
    //                   var fv = src[fd.property];
    //                   if (undefined !== fv) {
    //                       fd.encode(fv);
    //                   }
    //               }
    //           }
    //           return this.word.encode(this._packedGetValue(), b, offset);
    //       };
    //       /** Register a new bitfield with a containing bit structure.  The
    //        * resulting bitfield is returned.
    //        *
    //        * @param {Number} bits - initializer for {@link BitField#bits|bits}.
    //        *
    //        * @param {string} property - initializer for {@link
    //        * Layout#property|property}.
    //        *
    //        * @return {BitField} */
    //       BitStructure.prototype.addField = function (bits, property) {
    //           var bf = new BitField(this, bits, property);
    //           this.fields.push(bf);
    //           return bf;
    //       };
    //       /** As with {@link BitStructure#addField|addField} for single-bit
    //        * fields with `boolean` value representation.
    //        *
    //        * @param {string} property - initializer for {@link
    //        * Layout#property|property}.
    //        *
    //        * @return {Boolean} */
    //       BitStructure.prototype.addBoolean = function (property) {
    //           // This is my Boolean, not the Javascript one.
    //           // eslint-disable-next-line no-new-wrappers
    //           var bf = new Boolean$1(this, property);
    //           this.fields.push(bf);
    //           return bf;
    //       };
    //       /**
    //        * Get access to the bit field for a given property.
    //        *
    //        * @param {String} property - the bit field of interest.
    //        *
    //        * @return {BitField} - the field associated with `property`, or
    //        * undefined if there is no such property.
    //        */
    //       BitStructure.prototype.fieldFor = function (property) {
    //           if ('string' !== typeof property) {
    //               throw new TypeError('property must be string');
    //           }
    //           for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {
    //               var fd = _a[_i];
    //               if (fd.property === property) {
    //                   return fd;
    //               }
    //           }
    //           return undefined;
    //       };
    //       return BitStructure;
    //   }(Layout));
    //   Layout$1.BitStructure = BitStructure;
    //   /**
    //    * Represent a sequence of bits within a {@link BitStructure}.
    //    *
    //    * All bit field values are represented as unsigned integers.
    //    *
    //    * **NOTE** User code should not invoke this constructor directly.
    //    * Use the container {@link BitStructure#addField|addField} helper
    //    * method.
    //    *
    //    * **NOTE** BitField instances are not instances of {@link Layout}
    //    * since {@link Layout#span|span} measures 8-bit units.
    //    *
    //    * @param {BitStructure} container - initializer for {@link
    //    * BitField#container|container}.
    //    *
    //    * @param {Number} bits - initializer for {@link BitField#bits|bits}.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    */
    //   var BitField = /** @class */ (function () {
    //       function BitField(container, bits, property) {
    //           if (!(container instanceof BitStructure)) {
    //               throw new TypeError('container must be a BitStructure');
    //           }
    //           if ((!Number.isInteger(bits)) || (0 >= bits)) {
    //               throw new TypeError('bits must be positive integer');
    //           }
    //           var totalBits = 8 * container.span;
    //           var usedBits = container.fields.reduce(function (sum, fd) { return sum + fd.bits; }, 0);
    //           if ((bits + usedBits) > totalBits) {
    //               throw new Error('bits too long for span remainder ('
    //                   + (totalBits - usedBits) + ' of '
    //                   + totalBits + ' remain)');
    //           }
    //           /** The {@link BitStructure} instance to which this bit field
    //            * belongs. */
    //           this.container = container;
    //           /** The span of this value in bits. */
    //           this.bits = bits;
    //           /** A mask of {@link BitField#bits|bits} bits isolating value bits
    //            * that fit within the field.
    //            *
    //            * That is, it masks a value that has not yet been shifted into
    //            * position within its containing packed integer. */
    //           this.valueMask = (1 << bits) - 1;
    //           if (32 === bits) { // shifted value out of range
    //               this.valueMask = 0xFFFFFFFF;
    //           }
    //           /** The offset of the value within the containing packed unsigned
    //            * integer.  The least significant bit of the packed value is at
    //            * offset zero, regardless of bit ordering used. */
    //           this.start = usedBits;
    //           if (this.container.msb) {
    //               this.start = totalBits - usedBits - bits;
    //           }
    //           /** A mask of {@link BitField#bits|bits} isolating the field value
    //            * within the containing packed unsigned integer. */
    //           this.wordMask = fixBitwiseResult(this.valueMask << this.start);
    //           /** The property name used when this bitfield is represented in an
    //            * Object.
    //            *
    //            * Intended to be functionally equivalent to {@link
    //            * Layout#property}.
    //            *
    //            * If left undefined the corresponding span of bits will be
    //            * treated as padding: it will not be mutated by {@link
    //            * Layout#encode|encode} nor represented as a property in the
    //            * decoded Object. */
    //           this.property = property;
    //       }
    //       /** Store a value into the corresponding subsequence of the containing
    //        * bit field. */
    //       BitField.prototype.decode = function (b, offset) {
    //           var word = this.container._packedGetValue();
    //           var wordValue = fixBitwiseResult(word & this.wordMask);
    //           var value = wordValue >>> this.start;
    //           return value;
    //       };
    //       /** Store a value into the corresponding subsequence of the containing
    //        * bit field.
    //        *
    //        * **NOTE** This is not a specialization of {@link
    //        * Layout#encode|Layout.encode} and there is no return value. */
    //       BitField.prototype.encode = function (value) {
    //           if ((!Number.isInteger(value))
    //               || (value !== fixBitwiseResult(value & this.valueMask))) {
    //               throw new TypeError(nameWithProperty('BitField.encode', this)
    //                   + ' value must be integer not exceeding ' + this.valueMask);
    //           }
    //           var word = this.container._packedGetValue();
    //           var wordValue = fixBitwiseResult(value << this.start);
    //           this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)
    //               | wordValue);
    //       };
    //       return BitField;
    //   }());
    //   Layout$1.BitField = BitField;
    //   /**
    //    * Represent a single bit within a {@link BitStructure} as a
    //    * JavaScript boolean.
    //    *
    //    * **NOTE** User code should not invoke this constructor directly.
    //    * Use the container {@link BitStructure#addBoolean|addBoolean} helper
    //    * method.
    //    *
    //    * @param {BitStructure} container - initializer for {@link
    //    * BitField#container|container}.
    //    *
    //    * @param {string} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {BitField}
    //    */
    //   /* eslint-disable no-extend-native */
    //   var Boolean$1 = /** @class */ (function (_super) {
    //       __extends(Boolean, _super);
    //       function Boolean(container, property) {
    //           return _super.call(this, container, 1, property) || this;
    //       }
    //       /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
    //        *
    //        * @returns {boolean} */
    //       Boolean.prototype.decode = function (b, offset) {
    //           return !!BitField.prototype.decode.call(this, b, offset);
    //       };
    //       /** @override */
    //       Boolean.prototype.encode = function (value) {
    //           if ('boolean' === typeof value) {
    //               // BitField requires integer values
    //               value = +value;
    //           }
    //           return BitField.prototype.encode.call(this, value);
    //       };
    //       return Boolean;
    //   }(BitField));
    //   Layout$1.Boolean = Boolean$1;
    //   /* eslint-enable no-extend-native */
    //   /**
    //    * Contain a fixed-length block of arbitrary data, represented as a
    //    * Uint8Array.
    //    *
    //    * *Factory*: {@link module:Layout.blob|blob}
    //    *
    //    * @param {(Number|ExternalLayout)} length - initializes {@link
    //    * Blob#length|length}.
    //    *
    //    * @param {String} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var Blob = /** @class */ (function (_super) {
    //       __extends(Blob, _super);
    //       function Blob(length, property) {
    //           var _this = this;
    //           if (!(((length instanceof ExternalLayout) && length.isCount())
    //               || (Number.isInteger(length) && (0 <= length)))) {
    //               throw new TypeError('length must be positive integer '
    //                   + 'or an unsigned integer ExternalLayout');
    //           }
    //           var span = -1;
    //           if (!(length instanceof ExternalLayout)) {
    //               span = length;
    //           }
    //           _this = _super.call(this, span, property) || this;
    //           /** The number of bytes in the blob.
    //            *
    //            * This may be a non-negative integer, or an instance of {@link
    //            * ExternalLayout} that satisfies {@link
    //            * ExternalLayout#isCount|isCount()}. */
    //           _this.length = length;
    //           return _this;
    //       }
    //       /** @override */
    //       Blob.prototype.getSpan = function (b, offset) {
    //           var span = this.span;
    //           if (0 > span) {
    //               span = this.length.decode(b, offset);
    //           }
    //           return span;
    //       };
    //       /** @override */
    //       Blob.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var span = this.span;
    //           if (0 > span) {
    //               span = this.length.decode(b, offset);
    //           }
    //           return uint8ArrayToBuffer(b).slice(offset, offset + span);
    //       };
    //       /** Implement {@link Layout#encode|encode} for {@link Blob}.
    //        *
    //        * **NOTE** If {@link Layout#count|count} is an instance of {@link
    //        * ExternalLayout} then the length of `src` will be encoded as the
    //        * count after `src` is encoded. */
    //       Blob.prototype.encode = function (src, b, offset) {
    //           var span = this.length;
    //           if (this.length instanceof ExternalLayout) {
    //               span = src.length;
    //           }
    //           if (!(src instanceof Uint8Array && span === src.length)) {
    //               throw new TypeError(nameWithProperty('Blob.encode', this)
    //                   + ' requires (length ' + span + ') Uint8Array as src');
    //           }
    //           if ((offset + span) > b.length) {
    //               throw new RangeError('encoding overruns Uint8Array');
    //           }
    //           var srcBuffer = uint8ArrayToBuffer(src);
    //           uint8ArrayToBuffer(b).write(srcBuffer.toString('hex'), offset, span, 'hex');
    //           if (this.length instanceof ExternalLayout) {
    //               this.length.encode(span, b, offset);
    //           }
    //           return span;
    //       };
    //       return Blob;
    //   }(Layout));
    //   Layout$1.Blob = Blob;
    //   /**
    //    * Contain a `NUL`-terminated UTF8 string.
    //    *
    //    * *Factory*: {@link module:Layout.cstr|cstr}
    //    *
    //    * **NOTE** Any UTF8 string that incorporates a zero-valued byte will
    //    * not be correctly decoded by this layout.
    //    *
    //    * @param {String} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var CString = /** @class */ (function (_super) {
    //       __extends(CString, _super);
    //       function CString(property) {
    //           return _super.call(this, -1, property) || this;
    //       }
    //       /** @override */
    //       CString.prototype.getSpan = function (b, offset) {
    //           checkUint8Array(b);
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var idx = offset;
    //           while ((idx < b.length) && (0 !== b[idx])) {
    //               idx += 1;
    //           }
    //           return 1 + idx - offset;
    //       };
    //       /** @override */
    //       CString.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var span = this.getSpan(b, offset);
    //           return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString('utf-8');
    //       };
    //       /** @override */
    //       CString.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           /* Must force this to a string, lest it be a number and the
    //            * "utf8-encoding" below actually allocate a buffer of length
    //            * src */
    //           if ('string' !== typeof src) {
    //               src = src.toString();
    //           }
    //           var srcb = buffer_1.Buffer.from(src, 'utf8');
    //           var span = srcb.length;
    //           if ((offset + span) > b.length) {
    //               throw new RangeError('encoding overruns Buffer');
    //           }
    //           var buffer = uint8ArrayToBuffer(b);
    //           srcb.copy(buffer, offset);
    //           buffer[offset + span] = 0;
    //           return span + 1;
    //       };
    //       return CString;
    //   }(Layout));
    //   Layout$1.CString = CString;
    //   /**
    //    * Contain a UTF8 string with implicit length.
    //    *
    //    * *Factory*: {@link module:Layout.utf8|utf8}
    //    *
    //    * **NOTE** Because the length is implicit in the size of the buffer
    //    * this layout should be used only in isolation, or in a situation
    //    * where the length can be expressed by operating on a slice of the
    //    * containing buffer.
    //    *
    //    * @param {Number} [maxSpan] - the maximum length allowed for encoded
    //    * string content.  If not provided there is no bound on the allowed
    //    * content.
    //    *
    //    * @param {String} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var UTF8 = /** @class */ (function (_super) {
    //       __extends(UTF8, _super);
    //       function UTF8(maxSpan, property) {
    //           var _this = this;
    //           if (('string' === typeof maxSpan) && (undefined === property)) {
    //               property = maxSpan;
    //               maxSpan = undefined;
    //           }
    //           if (undefined === maxSpan) {
    //               maxSpan = -1;
    //           }
    //           else if (!Number.isInteger(maxSpan)) {
    //               throw new TypeError('maxSpan must be an integer');
    //           }
    //           _this = _super.call(this, -1, property) || this;
    //           /** The maximum span of the layout in bytes.
    //            *
    //            * Positive values are generally expected.  Zero is abnormal.
    //            * Attempts to encode or decode a value that exceeds this length
    //            * will throw a `RangeError`.
    //            *
    //            * A negative value indicates that there is no bound on the length
    //            * of the content. */
    //           _this.maxSpan = maxSpan;
    //           return _this;
    //       }
    //       /** @override */
    //       UTF8.prototype.getSpan = function (b, offset) {
    //           checkUint8Array(b);
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           return b.length - offset;
    //       };
    //       /** @override */
    //       UTF8.prototype.decode = function (b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           var span = this.getSpan(b, offset);
    //           if ((0 <= this.maxSpan)
    //               && (this.maxSpan < span)) {
    //               throw new RangeError('text length exceeds maxSpan');
    //           }
    //           return uint8ArrayToBuffer(b).slice(offset, offset + span).toString('utf-8');
    //       };
    //       /** @override */
    //       UTF8.prototype.encode = function (src, b, offset) {
    //           if (undefined === offset) {
    //               offset = 0;
    //           }
    //           /* Must force this to a string, lest it be a number and the
    //            * "utf8-encoding" below actually allocate a buffer of length
    //            * src */
    //           if ('string' !== typeof src) {
    //               src = src.toString();
    //           }
    //           var srcb = buffer_1.Buffer.from(src, 'utf8');
    //           var span = srcb.length;
    //           if ((0 <= this.maxSpan)
    //               && (this.maxSpan < span)) {
    //               throw new RangeError('text length exceeds maxSpan');
    //           }
    //           if ((offset + span) > b.length) {
    //               throw new RangeError('encoding overruns Buffer');
    //           }
    //           srcb.copy(uint8ArrayToBuffer(b), offset);
    //           return span;
    //       };
    //       return UTF8;
    //   }(Layout));
    //   Layout$1.UTF8 = UTF8;
    //   /**
    //    * Contain a constant value.
    //    *
    //    * This layout may be used in cases where a JavaScript value can be
    //    * inferred without an expression in the binary encoding.  An example
    //    * would be a {@link VariantLayout|variant layout} where the content
    //    * is implied by the union {@link Union#discriminator|discriminator}.
    //    *
    //    * @param {Object|Number|String} value - initializer for {@link
    //    * Constant#value|value}.  If the value is an object (or array) and
    //    * the application intends the object to remain unchanged regardless
    //    * of what is done to values decoded by this layout, the value should
    //    * be frozen prior passing it to this constructor.
    //    *
    //    * @param {String} [property] - initializer for {@link
    //    * Layout#property|property}.
    //    *
    //    * @augments {Layout}
    //    */
    //   var Constant = /** @class */ (function (_super) {
    //       __extends(Constant, _super);
    //       function Constant(value, property) {
    //           var _this = _super.call(this, 0, property) || this;
    //           /** The value produced by this constant when the layout is {@link
    //            * Constant#decode|decoded}.
    //            *
    //            * Any JavaScript value including `null` and `undefined` is
    //            * permitted.
    //            *
    //            * **WARNING** If `value` passed in the constructor was not
    //            * frozen, it is possible for users of decoded values to change
    //            * the content of the value. */
    //           _this.value = value;
    //           return _this;
    //       }
    //       /** @override */
    //       Constant.prototype.decode = function (b, offset) {
    //           return this.value;
    //       };
    //       /** @override */
    //       Constant.prototype.encode = function (src, b, offset) {
    //           /* Constants take no space */
    //           return 0;
    //       };
    //       return Constant;
    //   }(Layout));
    //   Layout$1.Constant = Constant;
    //   /** Factory for {@link GreedyCount}. */
    //   Layout$1.greedy = (function (elementSpan, property) { return new GreedyCount(elementSpan, property); });
    //   /** Factory for {@link OffsetLayout}. */
    //   var offset = Layout$1.offset = (function (layout, offset, property) { return new OffsetLayout(layout, offset, property); });
    //   /** Factory for {@link UInt|unsigned int layouts} spanning one
    //    * byte. */
    //   var u8 = Layout$1.u8 = (function (property) { return new UInt(1, property); });
    //   /** Factory for {@link UInt|little-endian unsigned int layouts}
    //    * spanning two bytes. */
    //   var u16 = Layout$1.u16 = (function (property) { return new UInt(2, property); });
    //   /** Factory for {@link UInt|little-endian unsigned int layouts}
    //    * spanning three bytes. */
    //   Layout$1.u24 = (function (property) { return new UInt(3, property); });
    //   /** Factory for {@link UInt|little-endian unsigned int layouts}
    //    * spanning four bytes. */
    //   var u32 = Layout$1.u32 = (function (property) { return new UInt(4, property); });
    //   /** Factory for {@link UInt|little-endian unsigned int layouts}
    //    * spanning five bytes. */
    //   Layout$1.u40 = (function (property) { return new UInt(5, property); });
    //   /** Factory for {@link UInt|little-endian unsigned int layouts}
    //    * spanning six bytes. */
    //   Layout$1.u48 = (function (property) { return new UInt(6, property); });
    //   /** Factory for {@link NearUInt64|little-endian unsigned int
    //    * layouts} interpreted as Numbers. */
    //   var nu64 = Layout$1.nu64 = (function (property) { return new NearUInt64(property); });
    //   /** Factory for {@link UInt|big-endian unsigned int layouts}
    //    * spanning two bytes. */
    //   Layout$1.u16be = (function (property) { return new UIntBE(2, property); });
    //   /** Factory for {@link UInt|big-endian unsigned int layouts}
    //    * spanning three bytes. */
    //   Layout$1.u24be = (function (property) { return new UIntBE(3, property); });
    //   /** Factory for {@link UInt|big-endian unsigned int layouts}
    //    * spanning four bytes. */
    //   Layout$1.u32be = (function (property) { return new UIntBE(4, property); });
    //   /** Factory for {@link UInt|big-endian unsigned int layouts}
    //    * spanning five bytes. */
    //   Layout$1.u40be = (function (property) { return new UIntBE(5, property); });
    //   /** Factory for {@link UInt|big-endian unsigned int layouts}
    //    * spanning six bytes. */
    //   Layout$1.u48be = (function (property) { return new UIntBE(6, property); });
    //   /** Factory for {@link NearUInt64BE|big-endian unsigned int
    //    * layouts} interpreted as Numbers. */
    //   Layout$1.nu64be = (function (property) { return new NearUInt64BE(property); });
    //   /** Factory for {@link Int|signed int layouts} spanning one
    //    * byte. */
    //   Layout$1.s8 = (function (property) { return new Int(1, property); });
    //   /** Factory for {@link Int|little-endian signed int layouts}
    //    * spanning two bytes. */
    //   Layout$1.s16 = (function (property) { return new Int(2, property); });
    //   /** Factory for {@link Int|little-endian signed int layouts}
    //    * spanning three bytes. */
    //   Layout$1.s24 = (function (property) { return new Int(3, property); });
    //   /** Factory for {@link Int|little-endian signed int layouts}
    //    * spanning four bytes. */
    //   Layout$1.s32 = (function (property) { return new Int(4, property); });
    //   /** Factory for {@link Int|little-endian signed int layouts}
    //    * spanning five bytes. */
    //   Layout$1.s40 = (function (property) { return new Int(5, property); });
    //   /** Factory for {@link Int|little-endian signed int layouts}
    //    * spanning six bytes. */
    //   Layout$1.s48 = (function (property) { return new Int(6, property); });
    //   /** Factory for {@link NearInt64|little-endian signed int layouts}
    //    * interpreted as Numbers. */
    //   var ns64 = Layout$1.ns64 = (function (property) { return new NearInt64(property); });
    //   /** Factory for {@link Int|big-endian signed int layouts}
    //    * spanning two bytes. */
    //   Layout$1.s16be = (function (property) { return new IntBE(2, property); });
    //   /** Factory for {@link Int|big-endian signed int layouts}
    //    * spanning three bytes. */
    //   Layout$1.s24be = (function (property) { return new IntBE(3, property); });
    //   /** Factory for {@link Int|big-endian signed int layouts}
    //    * spanning four bytes. */
    //   Layout$1.s32be = (function (property) { return new IntBE(4, property); });
    //   /** Factory for {@link Int|big-endian signed int layouts}
    //    * spanning five bytes. */
    //   Layout$1.s40be = (function (property) { return new IntBE(5, property); });
    //   /** Factory for {@link Int|big-endian signed int layouts}
    //    * spanning six bytes. */
    //   Layout$1.s48be = (function (property) { return new IntBE(6, property); });
    //   /** Factory for {@link NearInt64BE|big-endian signed int layouts}
    //    * interpreted as Numbers. */
    //   Layout$1.ns64be = (function (property) { return new NearInt64BE(property); });
    //   /** Factory for {@link Float|little-endian 32-bit floating point} values. */
    //   Layout$1.f32 = (function (property) { return new Float(property); });
    //   /** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */
    //   Layout$1.f32be = (function (property) { return new FloatBE(property); });
    //   /** Factory for {@link Double|little-endian 64-bit floating point} values. */
    //   Layout$1.f64 = (function (property) { return new Double(property); });
    //   /** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */
    //   Layout$1.f64be = (function (property) { return new DoubleBE(property); });
    //   /** Factory for {@link Structure} values. */
    //   var struct = Layout$1.struct = (function (fields, property, decodePrefixes) {
    //       return new Structure(fields, property, decodePrefixes);
    //   });
    //   /** Factory for {@link BitStructure} values. */
    //   Layout$1.bits = (function (word, msb, property) { return new BitStructure(word, msb, property); });
    //   /** Factory for {@link Sequence} values. */
    //   var seq = Layout$1.seq = (function (elementLayout, count, property) {
    //       return new Sequence(elementLayout, count, property);
    //   });
    //   /** Factory for {@link Union} values. */
    //   Layout$1.union = (function (discr, defaultLayout, property) {
    //       return new Union(discr, defaultLayout, property);
    //   });
    //   /** Factory for {@link UnionLayoutDiscriminator} values. */
    //   Layout$1.unionLayoutDiscriminator = (function (layout, property) { return new UnionLayoutDiscriminator(layout, property); });
    //   /** Factory for {@link Blob} values. */
    //   var blob = Layout$1.blob = (function (length, property) { return new Blob(length, property); });
    //   /** Factory for {@link CString} values. */
    //   Layout$1.cstr = (function (property) { return new CString(property); });
    //   /** Factory for {@link UTF8} values. */
    //   Layout$1.utf8 = (function (maxSpan, property) { return new UTF8(maxSpan, property); });
    //   /** Factory for {@link Constant} values. */
    //   Layout$1.constant = (function (value, property) { return new Constant(value, property); });
    
    //   /**
    //    * A `StructFailure` represents a single specific failure in validation.
    //    */
    
    //   /**
    //    * `StructError` objects are thrown (or returned) when validation fails.
    //    *
    //    * Validation logic is design to exit early for maximum performance. The error
    //    * represents the first error encountered during validation. For more detail,
    //    * the `error.failures` property is a generator function that can be run to
    //    * continue validation and receive all the failures in the data.
    //    */
    //   class StructError extends TypeError {
    //     constructor(failure, failures) {
    //       let cached;
    //       const {
    //         message,
    //         ...rest
    //       } = failure;
    //       const {
    //         path
    //       } = failure;
    //       const msg = path.length === 0 ? message : "At path: " + path.join('.') + " -- " + message;
    //       super(msg);
    //       Object.assign(this, rest);
    //       this.name = this.constructor.name;
    
    //       this.failures = () => {
    //         var _cached;
    
    //         return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
    //       };
    //     }
    
    //   }
    
    //   /**
    //    * Check if a value is an iterator.
    //    */
    //   function isIterable(x) {
    //     return isObject(x) && typeof x[Symbol.iterator] === 'function';
    //   }
    //   /**
    //    * Check if a value is a plain object.
    //    */
    
    
    //   function isObject(x) {
    //     return typeof x === 'object' && x != null;
    //   }
    //   /**
    //    * Return a value as a printable string.
    //    */
    
    //   function print(value) {
    //     return typeof value === 'string' ? JSON.stringify(value) : "" + value;
    //   }
    //   /**
    //    * Shifts (removes and returns) the first value from the `input` iterator.
    //    * Like `Array.prototype.shift()` but for an `Iterator`.
    //    */
    
    //   function shiftIterator(input) {
    //     const {
    //       done,
    //       value
    //     } = input.next();
    //     return done ? undefined : value;
    //   }
    //   /**
    //    * Convert a single validation result to a failure.
    //    */
    
    //   function toFailure(result, context, struct, value) {
    //     if (result === true) {
    //       return;
    //     } else if (result === false) {
    //       result = {};
    //     } else if (typeof result === 'string') {
    //       result = {
    //         message: result
    //       };
    //     }
    
    //     const {
    //       path,
    //       branch
    //     } = context;
    //     const {
    //       type
    //     } = struct;
    //     const {
    //       refinement,
    //       message = "Expected a value of type `" + type + "`" + (refinement ? " with refinement `" + refinement + "`" : '') + ", but received: `" + print(value) + "`"
    //     } = result;
    //     return {
    //       value,
    //       type,
    //       refinement,
    //       key: path[path.length - 1],
    //       path,
    //       branch,
    //       ...result,
    //       message
    //     };
    //   }
    //   /**
    //    * Convert a validation result to an iterable of failures.
    //    */
    
    //   function* toFailures(result, context, struct, value) {
    //     if (!isIterable(result)) {
    //       result = [result];
    //     }
    
    //     for (const r of result) {
    //       const failure = toFailure(r, context, struct, value);
    
    //       if (failure) {
    //         yield failure;
    //       }
    //     }
    //   }
    //   /**
    //    * Check a value against a struct, traversing deeply into nested values, and
    //    * returning an iterator of failures or success.
    //    */
    
    //   function* run(value, struct, options = {}) {
    //     const {
    //       path = [],
    //       branch = [value],
    //       coerce = false,
    //       mask = false
    //     } = options;
    //     const ctx = {
    //       path,
    //       branch
    //     };
    
    //     if (coerce) {
    //       value = struct.coercer(value, ctx);
    
    //       if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {
    //         for (const key in value) {
    //           if (struct.schema[key] === undefined) {
    //             delete value[key];
    //           }
    //         }
    //       }
    //     }
    
    //     let valid = true;
    
    //     for (const failure of struct.validator(value, ctx)) {
    //       valid = false;
    //       yield [failure, undefined];
    //     }
    
    //     for (let [k, v, s] of struct.entries(value, ctx)) {
    //       const ts = run(v, s, {
    //         path: k === undefined ? path : [...path, k],
    //         branch: k === undefined ? branch : [...branch, v],
    //         coerce,
    //         mask
    //       });
    
    //       for (const t of ts) {
    //         if (t[0]) {
    //           valid = false;
    //           yield [t[0], undefined];
    //         } else if (coerce) {
    //           v = t[1];
    
    //           if (k === undefined) {
    //             value = v;
    //           } else if (value instanceof Map) {
    //             value.set(k, v);
    //           } else if (value instanceof Set) {
    //             value.add(v);
    //           } else if (isObject(value)) {
    //             value[k] = v;
    //           }
    //         }
    //       }
    //     }
    
    //     if (valid) {
    //       for (const failure of struct.refiner(value, ctx)) {
    //         valid = false;
    //         yield [failure, undefined];
    //       }
    //     }
    
    //     if (valid) {
    //       yield [undefined, value];
    //     }
    //   }
    
    //   /**
    //    * `Struct` objects encapsulate the validation logic for a specific type of
    //    * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
    //    * validate unknown input data against the struct.
    //    */
    
    //   class Struct$1 {
    //     constructor(props) {
    //       const {
    //         type,
    //         schema,
    //         validator,
    //         refiner,
    //         coercer = value => value,
    //         entries = function* () {}
    //       } = props;
    //       this.type = type;
    //       this.schema = schema;
    //       this.entries = entries;
    //       this.coercer = coercer;
    
    //       if (validator) {
    //         this.validator = (value, context) => {
    //           const result = validator(value, context);
    //           return toFailures(result, context, this, value);
    //         };
    //       } else {
    //         this.validator = () => [];
    //       }
    
    //       if (refiner) {
    //         this.refiner = (value, context) => {
    //           const result = refiner(value, context);
    //           return toFailures(result, context, this, value);
    //         };
    //       } else {
    //         this.refiner = () => [];
    //       }
    //     }
    //     /**
    //      * Assert that a value passes the struct's validation, throwing if it doesn't.
    //      */
    
    
    //     assert(value) {
    //       return assert$i(value, this);
    //     }
    //     /**
    //      * Create a value with the struct's coercion logic, then validate it.
    //      */
    
    
    //     create(value) {
    //       return create(value, this);
    //     }
    //     /**
    //      * Check if a value passes the struct's validation.
    //      */
    
    
    //     is(value) {
    //       return is(value, this);
    //     }
    //     /**
    //      * Mask a value, coercing and validating it, but returning only the subset of
    //      * properties defined by the struct's schema.
    //      */
    
    
    //     mask(value) {
    //       return mask(value, this);
    //     }
    //     /**
    //      * Validate a value with the struct's validation logic, returning a tuple
    //      * representing the result.
    //      *
    //      * You may optionally pass `true` for the `withCoercion` argument to coerce
    //      * the value before attempting to validate it. If you do, the result will
    //      * contain the coerced result when successful.
    //      */
    
    
    //     validate(value, options = {}) {
    //       return validate(value, this, options);
    //     }
    
    //   }
    //   /**
    //    * Assert that a value passes a struct, throwing if it doesn't.
    //    */
    
    //   function assert$i(value, struct) {
    //     const result = validate(value, struct);
    
    //     if (result[0]) {
    //       throw result[0];
    //     }
    //   }
    //   /**
    //    * Create a value with the coercion logic of struct and validate it.
    //    */
    
    //   function create(value, struct) {
    //     const result = validate(value, struct, {
    //       coerce: true
    //     });
    
    //     if (result[0]) {
    //       throw result[0];
    //     } else {
    //       return result[1];
    //     }
    //   }
    //   /**
    //    * Mask a value, returning only the subset of properties defined by a struct.
    //    */
    
    //   function mask(value, struct) {
    //     const result = validate(value, struct, {
    //       coerce: true,
    //       mask: true
    //     });
    
    //     if (result[0]) {
    //       throw result[0];
    //     } else {
    //       return result[1];
    //     }
    //   }
    //   /**
    //    * Check if a value passes a struct.
    //    */
    
    //   function is(value, struct) {
    //     const result = validate(value, struct);
    //     return !result[0];
    //   }
    //   /**
    //    * Validate a value against a struct, returning an error if invalid, or the
    //    * value (with potential coercion) if valid.
    //    */
    
    //   function validate(value, struct, options = {}) {
    //     const tuples = run(value, struct, options);
    //     const tuple = shiftIterator(tuples);
    
    //     if (tuple[0]) {
    //       const error = new StructError(tuple[0], function* () {
    //         for (const t of tuples) {
    //           if (t[0]) {
    //             yield t[0];
    //           }
    //         }
    //       });
    //       return [error, undefined];
    //     } else {
    //       const v = tuple[1];
    //       return [undefined, v];
    //     }
    //   }
    //   /**
    //    * Define a new struct type with a custom validation function.
    //    */
    
    //   function define(name, validator) {
    //     return new Struct$1({
    //       type: name,
    //       schema: null,
    //       validator
    //     });
    //   }
    
    //   /**
    //    * Ensure that any value passes validation.
    //    */
    
    //   function any() {
    //     return define('any', () => true);
    //   }
    //   function array(Element) {
    //     return new Struct$1({
    //       type: 'array',
    //       schema: Element,
    
    //       *entries(value) {
    //         if (Element && Array.isArray(value)) {
    //           for (const [i, v] of value.entries()) {
    //             yield [i, v, Element];
    //           }
    //         }
    //       },
    
    //       coercer(value) {
    //         return Array.isArray(value) ? value.slice() : value;
    //       },
    
    //       validator(value) {
    //         return Array.isArray(value) || "Expected an array value, but received: " + print(value);
    //       }
    
    //     });
    //   }
    //   /**
    //    * Ensure that a value is a boolean.
    //    */
    
    //   function boolean() {
    //     return define('boolean', value => {
    //       return typeof value === 'boolean';
    //     });
    //   }
    //   /**
    //    * Ensure that a value is an instance of a specific class.
    //    */
    
    //   function instance(Class) {
    //     return define('instance', value => {
    //       return value instanceof Class || "Expected a `" + Class.name + "` instance, but received: " + print(value);
    //     });
    //   }
    //   function literal(constant) {
    //     const description = print(constant);
    //     const t = typeof constant;
    //     return new Struct$1({
    //       type: 'literal',
    //       schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,
    
    //       validator(value) {
    //         return value === constant || "Expected the literal `" + description + "`, but received: " + print(value);
    //       }
    
    //     });
    //   }
    //   /**
    //    * Ensure that no value ever passes validation.
    //    */
    
    //   function never() {
    //     return define('never', () => false);
    //   }
    //   /**
    //    * Augment an existing struct to allow `null` values.
    //    */
    
    //   function nullable(struct) {
    //     return new Struct$1({ ...struct,
    //       validator: (value, ctx) => value === null || struct.validator(value, ctx),
    //       refiner: (value, ctx) => value === null || struct.refiner(value, ctx)
    //     });
    //   }
    //   /**
    //    * Ensure that a value is a number.
    //    */
    
    //   function number() {
    //     return define('number', value => {
    //       return typeof value === 'number' && !isNaN(value) || "Expected a number, but received: " + print(value);
    //     });
    //   }
    //   /**
    //    * Augment a struct to allow `undefined` values.
    //    */
    
    //   function optional(struct) {
    //     return new Struct$1({ ...struct,
    //       validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
    //       refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)
    //     });
    //   }
    //   /**
    //    * Ensure that a value is an object with keys and values of specific types, but
    //    * without ensuring any specific shape of properties.
    //    *
    //    * Like TypeScript's `Record` utility.
    //    */
    
    //   function record(Key, Value) {
    //     return new Struct$1({
    //       type: 'record',
    //       schema: null,
    
    //       *entries(value) {
    //         if (isObject(value)) {
    //           for (const k in value) {
    //             const v = value[k];
    //             yield [k, k, Key];
    //             yield [k, v, Value];
    //           }
    //         }
    //       },
    
    //       validator(value) {
    //         return isObject(value) || "Expected an object, but received: " + print(value);
    //       }
    
    //     });
    //   }
    //   /**
    //    * Ensure that a value is a string.
    //    */
    
    //   function string() {
    //     return define('string', value => {
    //       return typeof value === 'string' || "Expected a string, but received: " + print(value);
    //     });
    //   }
    //   function tuple(Elements) {
    //     const Never = never();
    //     return new Struct$1({
    //       type: 'tuple',
    //       schema: null,
    
    //       *entries(value) {
    //         if (Array.isArray(value)) {
    //           const length = Math.max(Elements.length, value.length);
    
    //           for (let i = 0; i < length; i++) {
    //             yield [i, value[i], Elements[i] || Never];
    //           }
    //         }
    //       },
    
    //       validator(value) {
    //         return Array.isArray(value) || "Expected an array, but received: " + print(value);
    //       }
    
    //     });
    //   }
    //   /**
    //    * Ensure that a value has a set of known properties of specific types.
    //    *
    //    * Note: Unrecognized properties are allowed and untouched. This is similar to
    //    * how TypeScript's structural typing works.
    //    */
    
    //   function type(schema) {
    //     const keys = Object.keys(schema);
    //     return new Struct$1({
    //       type: 'type',
    //       schema,
    
    //       *entries(value) {
    //         if (isObject(value)) {
    //           for (const k of keys) {
    //             yield [k, value[k], schema[k]];
    //           }
    //         }
    //       },
    
    //       validator(value) {
    //         return isObject(value) || "Expected an object, but received: " + print(value);
    //       }
    
    //     });
    //   }
    //   function union(Structs) {
    //     const description = Structs.map(s => s.type).join(' | ');
    //     return new Struct$1({
    //       type: 'union',
    //       schema: null,
    
    //       validator(value, ctx) {
    //         const failures = [];
    
    //         for (const S of Structs) {
    //           const [...tuples] = run(value, S, ctx);
    //           const [first] = tuples;
    
    //           if (!first[0]) {
    //             return [];
    //           } else {
    //             for (const [failure] of tuples) {
    //               if (failure) {
    //                 failures.push(failure);
    //               }
    //             }
    //           }
    //         }
    
    //         return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value), ...failures];
    //       }
    
    //     });
    //   }
    //   /**
    //    * Ensure that any value passes validation, without widening its type to `any`.
    //    */
    
    //   function unknown() {
    //     return define('unknown', () => true);
    //   }
    
    //   /**
    //    * Augment a `Struct` to add an additional coercion step to its input.
    //    *
    //    * This allows you to transform input data before validating it, to increase the
    //    * likelihood that it passes validationfor example for default values, parsing
    //    * different formats, etc.
    //    *
    //    * Note: You must use `create(value, Struct)` on the value to have the coercion
    //    * take effect! Using simply `assert()` or `is()` will not use coercion.
    //    */
    
    //   function coerce(struct, condition, coercer) {
    //     return new Struct$1({ ...struct,
    //       coercer: (value, ctx) => {
    //         return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
    //       }
    //     });
    //   }
    
    //   const errors = {
    //     IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
    //     TWEAK_ADD:
    //       'The tweak was out of range or the resulted private key is invalid',
    //     TWEAK_MUL: 'The tweak was out of range or equal to zero',
    //     CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
    //     SECKEY_INVALID: 'Private Key is invalid',
    //     PUBKEY_PARSE: 'Public Key could not be parsed',
    //     PUBKEY_SERIALIZE: 'Public Key serialization error',
    //     PUBKEY_COMBINE: 'The sum of the public keys is not valid',
    //     SIG_PARSE: 'Signature could not be parsed',
    //     SIGN: 'The nonce generation function failed, or the private key was invalid',
    //     RECOVER: 'Public key could not be recover',
    //     ECDH: 'Scalar was invalid (zero or overflow)'
    //   };
    
    //   function assert$h (cond, msg) {
    //     if (!cond) throw new Error(msg)
    //   }
    
    //   function isUint8Array (name, value, length) {
    //     assert$h(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);
    
    //     if (length !== undefined) {
    //       if (Array.isArray(length)) {
    //         const numbers = length.join(', ');
    //         const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;
    //         assert$h(length.includes(value.length), msg);
    //       } else {
    //         const msg = `Expected ${name} to be an Uint8Array with length ${length}`;
    //         assert$h(value.length === length, msg);
    //       }
    //     }
    //   }
    
    //   function isCompressed (value) {
    //     assert$h(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean');
    //   }
    
    //   function getAssertedOutput (output = (len) => new Uint8Array(len), length) {
    //     if (typeof output === 'function') output = output(length);
    //     isUint8Array('output', output, length);
    //     return output
    //   }
    
    //   function toTypeString (value) {
    //     return Object.prototype.toString.call(value).slice(8, -1)
    //   }
    
    //   var lib = (secp256k1) => {
    //     return {
    //       contextRandomize (seed) {
    //         assert$h(
    //           seed === null || seed instanceof Uint8Array,
    //           'Expected seed to be an Uint8Array or null'
    //         );
    //         if (seed !== null) isUint8Array('seed', seed, 32);
    
    //         switch (secp256k1.contextRandomize(seed)) {
    //           case 1:
    //             throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)
    //         }
    //       },
    
    //       privateKeyVerify (seckey) {
    //         isUint8Array('private key', seckey, 32);
    
    //         return secp256k1.privateKeyVerify(seckey) === 0
    //       },
    
    //       privateKeyNegate (seckey) {
    //         isUint8Array('private key', seckey, 32);
    
    //         switch (secp256k1.privateKeyNegate(seckey)) {
    //           case 0:
    //             return seckey
    //           case 1:
    //             throw new Error(errors.IMPOSSIBLE_CASE)
    //         }
    //       },
    
    //       privateKeyTweakAdd (seckey, tweak) {
    //         isUint8Array('private key', seckey, 32);
    //         isUint8Array('tweak', tweak, 32);
    
    //         switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
    //           case 0:
    //             return seckey
    //           case 1:
    //             throw new Error(errors.TWEAK_ADD)
    //         }
    //       },
    
    //       privateKeyTweakMul (seckey, tweak) {
    //         isUint8Array('private key', seckey, 32);
    //         isUint8Array('tweak', tweak, 32);
    
    //         switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
    //           case 0:
    //             return seckey
    //           case 1:
    //             throw new Error(errors.TWEAK_MUL)
    //         }
    //       },
    
    //       publicKeyVerify (pubkey) {
    //         isUint8Array('public key', pubkey, [33, 65]);
    
    //         return secp256k1.publicKeyVerify(pubkey) === 0
    //       },
    
    //       publicKeyCreate (seckey, compressed = true, output) {
    //         isUint8Array('private key', seckey, 32);
    //         isCompressed(compressed);
    //         output = getAssertedOutput(output, compressed ? 33 : 65);
    
    //         switch (secp256k1.publicKeyCreate(output, seckey)) {
    //           case 0:
    //             return output
    //           case 1:
    //             throw new Error(errors.SECKEY_INVALID)
    //           case 2:
    //             throw new Error(errors.PUBKEY_SERIALIZE)
    //         }
    //       },
    
    //       publicKeyConvert (pubkey, compressed = true, output) {
    //         isUint8Array('public key', pubkey, [33, 65]);
    //         isCompressed(compressed);
    //         output = getAssertedOutput(output, compressed ? 33 : 65);
    
    //         switch (secp256k1.publicKeyConvert(output, pubkey)) {
    //           case 0:
    //             return output
    //           case 1:
    //             throw new Error(errors.PUBKEY_PARSE)
    //           case 2:
    //             throw new Error(errors.PUBKEY_SERIALIZE)
    //         }
    //       },
    
    //       publicKeyNegate (pubkey, compressed = true, output) {
    //         isUint8Array('public key', pubkey, [33, 65]);
    //         isCompressed(compressed);
    //         output = getAssertedOutput(output, compressed ? 33 : 65);
    
    //         switch (secp256k1.publicKeyNegate(output, pubkey)) {
    //           case 0:
    //             return output
    //           case 1:
    //             throw new Error(errors.PUBKEY_PARSE)
    //           case 2:
    //             throw new Error(errors.IMPOSSIBLE_CASE)
    //           case 3:
    //             throw new Error(errors.PUBKEY_SERIALIZE)
    //         }
    //       },
    
    //       publicKeyCombine (pubkeys, compressed = true, output) {
    //         assert$h(Array.isArray(pubkeys), 'Expected public keys to be an Array');
    //         assert$h(pubkeys.length > 0, 'Expected public keys array will have more than zero items');
    //         for (const pubkey of pubkeys) {
    //           isUint8Array('public key', pubkey, [33, 65]);
    //         }
    //         isCompressed(compressed);
    //         output = getAssertedOutput(output, compressed ? 33 : 65);
    
    //         switch (secp256k1.publicKeyCombine(output, pubkeys)) {
    //           case 0:
    //             return output
    //           case 1:
    //             throw new Error(errors.PUBKEY_PARSE)
    //           case 2:
    //             throw new Error(errors.PUBKEY_COMBINE)
    //           case 3:
    //             throw new Error(errors.PUBKEY_SERIALIZE)
    //         }
    //       },
    
    //       publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {
    //         isUint8Array('public key', pubkey, [33, 65]);
    //         isUint8Array('tweak', tweak, 32);
    //         isCompressed(compressed);
    //         output = getAssertedOutput(output, compressed ? 33 : 65);
    
    //         switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
    //           case 0:
    //             return output
    //           case 1:
    //             throw new Error(errors.PUBKEY_PARSE)
    //           case 2:
    //             throw new Error(errors.TWEAK_ADD)
    //         }
    //       },
    
    //       publicKeyTweakMul (pubkey, tweak, compressed = true, output) {
    //         isUint8Array('public key', pubkey, [33, 65]);
    //         isUint8Array('tweak', tweak, 32);
    //         isCompressed(compressed);
    //         output = getAssertedOutput(output, compressed ? 33 : 65);
    
    //         switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
    //           case 0:
    //             return output
    //           case 1:
    //             throw new Error(errors.PUBKEY_PARSE)
    //           case 2:
    //             throw new Error(errors.TWEAK_MUL)
    //         }
    //       },
    
    //       signatureNormalize (sig) {
    //         isUint8Array('signature', sig, 64);
    
    //         switch (secp256k1.signatureNormalize(sig)) {
    //           case 0:
    //             return sig
    //           case 1:
    //             throw new Error(errors.SIG_PARSE)
    //         }
    //       },
    
    //       signatureExport (sig, output) {
    //         isUint8Array('signature', sig, 64);
    //         output = getAssertedOutput(output, 72);
    
    //         const obj = { output, outputlen: 72 };
    //         switch (secp256k1.signatureExport(obj, sig)) {
    //           case 0:
    //             return output.slice(0, obj.outputlen)
    //           case 1:
    //             throw new Error(errors.SIG_PARSE)
    //           case 2:
    //             throw new Error(errors.IMPOSSIBLE_CASE)
    //         }
    //       },
    
    //       signatureImport (sig, output) {
    //         isUint8Array('signature', sig);
    //         output = getAssertedOutput(output, 64);
    
    //         switch (secp256k1.signatureImport(output, sig)) {
    //           case 0:
    //             return output
    //           case 1:
    //             throw new Error(errors.SIG_PARSE)
    //           case 2:
    //             throw new Error(errors.IMPOSSIBLE_CASE)
    //         }
    //       },
    
    //       ecdsaSign (msg32, seckey, options = {}, output) {
    //         isUint8Array('message', msg32, 32);
    //         isUint8Array('private key', seckey, 32);
    //         assert$h(toTypeString(options) === 'Object', 'Expected options to be an Object');
    //         if (options.data !== undefined) isUint8Array('options.data', options.data);
    //         if (options.noncefn !== undefined) assert$h(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function');
    //         output = getAssertedOutput(output, 64);
    
    //         const obj = { signature: output, recid: null };
    //         switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
    //           case 0:
    //             return obj
    //           case 1:
    //             throw new Error(errors.SIGN)
    //           case 2:
    //             throw new Error(errors.IMPOSSIBLE_CASE)
    //         }
    //       },
    
    //       ecdsaVerify (sig, msg32, pubkey) {
    //         isUint8Array('signature', sig, 64);
    //         isUint8Array('message', msg32, 32);
    //         isUint8Array('public key', pubkey, [33, 65]);
    
    //         switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
    //           case 0:
    //             return true
    //           case 3:
    //             return false
    //           case 1:
    //             throw new Error(errors.SIG_PARSE)
    //           case 2:
    //             throw new Error(errors.PUBKEY_PARSE)
    //         }
    //       },
    
    //       ecdsaRecover (sig, recid, msg32, compressed = true, output) {
    //         isUint8Array('signature', sig, 64);
    //         assert$h(
    //           toTypeString(recid) === 'Number' &&
    //             recid >= 0 &&
    //             recid <= 3,
    //           'Expected recovery id to be a Number within interval [0, 3]'
    //         );
    //         isUint8Array('message', msg32, 32);
    //         isCompressed(compressed);
    //         output = getAssertedOutput(output, compressed ? 33 : 65);
    
    //         switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
    //           case 0:
    //             return output
    //           case 1:
    //             throw new Error(errors.SIG_PARSE)
    //           case 2:
    //             throw new Error(errors.RECOVER)
    //           case 3:
    //             throw new Error(errors.IMPOSSIBLE_CASE)
    //         }
    //       },
    
    //       ecdh (pubkey, seckey, options = {}, output) {
    //         isUint8Array('public key', pubkey, [33, 65]);
    //         isUint8Array('private key', seckey, 32);
    //         assert$h(toTypeString(options) === 'Object', 'Expected options to be an Object');
    //         if (options.data !== undefined) isUint8Array('options.data', options.data);
    //         if (options.hashfn !== undefined) {
    //           assert$h(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function');
    //           if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32);
    //           if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32);
    //           isUint8Array('output', output);
    //         } else {
    //           output = getAssertedOutput(output, 32);
    //         }
    
    //         switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
    //           case 0:
    //             return output
    //           case 1:
    //             throw new Error(errors.PUBKEY_PARSE)
    //           case 2:
    //             throw new Error(errors.ECDH)
    //         }
    //       }
    //     }
    //   };
    
    //   var elliptic$2 = {};
    
    //   var name = "elliptic";
    //   var version = "6.5.4";
    //   var description = "EC cryptography";
    //   var main = "lib/elliptic.js";
    //   var files = [
    //       "lib"
    //   ];
    //   var scripts = {
    //       lint: "eslint lib test",
    //       "lint:fix": "npm run lint -- --fix",
    //       unit: "istanbul test _mocha --reporter=spec test/index.js",
    //       test: "npm run lint && npm run unit",
    //       version: "grunt dist && git add dist/"
    //   };
    //   var repository = {
    //       type: "git",
    //       url: "git@github.com:indutny/elliptic"
    //   };
    //   var keywords = [
    //       "EC",
    //       "Elliptic",
    //       "curve",
    //       "Cryptography"
    //   ];
    //   var author = "Fedor Indutny <fedor@indutny.com>";
    //   var license = "MIT";
    //   var bugs = {
    //       url: "https://github.com/indutny/elliptic/issues"
    //   };
    //   var homepage = "https://github.com/indutny/elliptic";
    //   var devDependencies = {
    //       brfs: "^2.0.2",
    //       coveralls: "^3.1.0",
    //       eslint: "^7.6.0",
    //       grunt: "^1.2.1",
    //       "grunt-browserify": "^5.3.0",
    //       "grunt-cli": "^1.3.2",
    //       "grunt-contrib-connect": "^3.0.0",
    //       "grunt-contrib-copy": "^1.0.0",
    //       "grunt-contrib-uglify": "^5.0.0",
    //       "grunt-mocha-istanbul": "^5.0.2",
    //       "grunt-saucelabs": "^9.0.1",
    //       istanbul: "^0.4.5",
    //       mocha: "^8.0.1"
    //   };
    //   var dependencies = {
    //       "bn.js": "^4.11.9",
    //       brorand: "^1.1.0",
    //       "hash.js": "^1.0.0",
    //       "hmac-drbg": "^1.0.1",
    //       inherits: "^2.0.4",
    //       "minimalistic-assert": "^1.0.1",
    //       "minimalistic-crypto-utils": "^1.0.1"
    //   };
    //   var require$$0 = {
    //       name: name,
    //       version: version,
    //       description: description,
    //       main: main,
    //       files: files,
    //       scripts: scripts,
    //       repository: repository,
    //       keywords: keywords,
    //       author: author,
    //       license: license,
    //       bugs: bugs,
    //       homepage: homepage,
    //       devDependencies: devDependencies,
    //       dependencies: dependencies
    //   };
    
    //   var utils$m = {};
    
    //   var minimalisticAssert = assert$g;
    
    //   function assert$g(val, msg) {
    //     if (!val)
    //       throw new Error(msg || 'Assertion failed');
    //   }
    
    //   assert$g.equal = function assertEqual(l, r, msg) {
    //     if (l != r)
    //       throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
    //   };
    
    //   var utils$l = {};
    
    //   (function (exports) {
    
    //   var utils = exports;
    
    //   function toArray(msg, enc) {
    //     if (Array.isArray(msg))
    //       return msg.slice();
    //     if (!msg)
    //       return [];
    //     var res = [];
    //     if (typeof msg !== 'string') {
    //       for (var i = 0; i < msg.length; i++)
    //         res[i] = msg[i] | 0;
    //       return res;
    //     }
    //     if (enc === 'hex') {
    //       msg = msg.replace(/[^a-z0-9]+/ig, '');
    //       if (msg.length % 2 !== 0)
    //         msg = '0' + msg;
    //       for (var i = 0; i < msg.length; i += 2)
    //         res.push(parseInt(msg[i] + msg[i + 1], 16));
    //     } else {
    //       for (var i = 0; i < msg.length; i++) {
    //         var c = msg.charCodeAt(i);
    //         var hi = c >> 8;
    //         var lo = c & 0xff;
    //         if (hi)
    //           res.push(hi, lo);
    //         else
    //           res.push(lo);
    //       }
    //     }
    //     return res;
    //   }
    //   utils.toArray = toArray;
    
    //   function zero2(word) {
    //     if (word.length === 1)
    //       return '0' + word;
    //     else
    //       return word;
    //   }
    //   utils.zero2 = zero2;
    
    //   function toHex(msg) {
    //     var res = '';
    //     for (var i = 0; i < msg.length; i++)
    //       res += zero2(msg[i].toString(16));
    //     return res;
    //   }
    //   utils.toHex = toHex;
    
    //   utils.encode = function encode(arr, enc) {
    //     if (enc === 'hex')
    //       return toHex(arr);
    //     else
    //       return arr;
    //   };
    //   }(utils$l));
    
    //   (function (exports) {
    
    //   var utils = exports;
    //   var BN = bn.exports;
    //   var minAssert = minimalisticAssert;
    //   var minUtils = utils$l;
    
    //   utils.assert = minAssert;
    //   utils.toArray = minUtils.toArray;
    //   utils.zero2 = minUtils.zero2;
    //   utils.toHex = minUtils.toHex;
    //   utils.encode = minUtils.encode;
    
    //   // Represent num in a w-NAF form
    //   function getNAF(num, w, bits) {
    //     var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    //     naf.fill(0);
    
    //     var ws = 1 << (w + 1);
    //     var k = num.clone();
    
    //     for (var i = 0; i < naf.length; i++) {
    //       var z;
    //       var mod = k.andln(ws - 1);
    //       if (k.isOdd()) {
    //         if (mod > (ws >> 1) - 1)
    //           z = (ws >> 1) - mod;
    //         else
    //           z = mod;
    //         k.isubn(z);
    //       } else {
    //         z = 0;
    //       }
    
    //       naf[i] = z;
    //       k.iushrn(1);
    //     }
    
    //     return naf;
    //   }
    //   utils.getNAF = getNAF;
    
    //   // Represent k1, k2 in a Joint Sparse Form
    //   function getJSF(k1, k2) {
    //     var jsf = [
    //       [],
    //       [],
    //     ];
    
    //     k1 = k1.clone();
    //     k2 = k2.clone();
    //     var d1 = 0;
    //     var d2 = 0;
    //     var m8;
    //     while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    //       // First phase
    //       var m14 = (k1.andln(3) + d1) & 3;
    //       var m24 = (k2.andln(3) + d2) & 3;
    //       if (m14 === 3)
    //         m14 = -1;
    //       if (m24 === 3)
    //         m24 = -1;
    //       var u1;
    //       if ((m14 & 1) === 0) {
    //         u1 = 0;
    //       } else {
    //         m8 = (k1.andln(7) + d1) & 7;
    //         if ((m8 === 3 || m8 === 5) && m24 === 2)
    //           u1 = -m14;
    //         else
    //           u1 = m14;
    //       }
    //       jsf[0].push(u1);
    
    //       var u2;
    //       if ((m24 & 1) === 0) {
    //         u2 = 0;
    //       } else {
    //         m8 = (k2.andln(7) + d2) & 7;
    //         if ((m8 === 3 || m8 === 5) && m14 === 2)
    //           u2 = -m24;
    //         else
    //           u2 = m24;
    //       }
    //       jsf[1].push(u2);
    
    //       // Second phase
    //       if (2 * d1 === u1 + 1)
    //         d1 = 1 - d1;
    //       if (2 * d2 === u2 + 1)
    //         d2 = 1 - d2;
    //       k1.iushrn(1);
    //       k2.iushrn(1);
    //     }
    
    //     return jsf;
    //   }
    //   utils.getJSF = getJSF;
    
    //   function cachedProperty(obj, name, computer) {
    //     var key = '_' + name;
    //     obj.prototype[name] = function cachedProperty() {
    //       return this[key] !== undefined ? this[key] :
    //         this[key] = computer.call(this);
    //     };
    //   }
    //   utils.cachedProperty = cachedProperty;
    
    //   function parseBytes(bytes) {
    //     return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    //       bytes;
    //   }
    //   utils.parseBytes = parseBytes;
    
    //   function intFromLE(bytes) {
    //     return new BN(bytes, 'hex', 'le');
    //   }
    //   utils.intFromLE = intFromLE;
    //   }(utils$m));
    
    //   var brorand = {exports: {}};
    
    //   var r$1;
    
    //   brorand.exports = function rand(len) {
    //     if (!r$1)
    //       r$1 = new Rand(null);
    
    //     return r$1.generate(len);
    //   };
    
    //   function Rand(rand) {
    //     this.rand = rand;
    //   }
    //   brorand.exports.Rand = Rand;
    
    //   Rand.prototype.generate = function generate(len) {
    //     return this._rand(len);
    //   };
    
    //   // Emulate crypto API using randy
    //   Rand.prototype._rand = function _rand(n) {
    //     if (this.rand.getBytes)
    //       return this.rand.getBytes(n);
    
    //     var res = new Uint8Array(n);
    //     for (var i = 0; i < res.length; i++)
    //       res[i] = this.rand.getByte();
    //     return res;
    //   };
    
    //   if (typeof self === 'object') {
    //     if (self.crypto && self.crypto.getRandomValues) {
    //       // Modern browsers
    //       Rand.prototype._rand = function _rand(n) {
    //         var arr = new Uint8Array(n);
    //         self.crypto.getRandomValues(arr);
    //         return arr;
    //       };
    //     } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    //       // IE
    //       Rand.prototype._rand = function _rand(n) {
    //         var arr = new Uint8Array(n);
    //         self.msCrypto.getRandomValues(arr);
    //         return arr;
    //       };
    
    //     // Safari's WebWorkers do not have `crypto`
    //     } else if (typeof window === 'object') {
    //       // Old junk
    //       Rand.prototype._rand = function() {
    //         throw new Error('Not implemented yet');
    //       };
    //     }
    //   } else {
    //     // Node.js or Web worker with no crypto support
    //     try {
    //       var crypto = require$$0$1;
    //       if (typeof crypto.randomBytes !== 'function')
    //         throw new Error('Not supported');
    
    //       Rand.prototype._rand = function _rand(n) {
    //         return crypto.randomBytes(n);
    //       };
    //     } catch (e) {
    //     }
    //   }
    
    //   var curve = {};
    
    //   var BN$8 = bn.exports;
    //   var utils$k = utils$m;
    //   var getNAF = utils$k.getNAF;
    //   var getJSF = utils$k.getJSF;
    //   var assert$f = utils$k.assert;
    
    //   function BaseCurve(type, conf) {
    //     this.type = type;
    //     this.p = new BN$8(conf.p, 16);
    
    //     // Use Montgomery, when there is no fast reduction for the prime
    //     this.red = conf.prime ? BN$8.red(conf.prime) : BN$8.mont(this.p);
    
    //     // Useful for many curves
    //     this.zero = new BN$8(0).toRed(this.red);
    //     this.one = new BN$8(1).toRed(this.red);
    //     this.two = new BN$8(2).toRed(this.red);
    
    //     // Curve configuration, optional
    //     this.n = conf.n && new BN$8(conf.n, 16);
    //     this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    
    //     // Temporary arrays
    //     this._wnafT1 = new Array(4);
    //     this._wnafT2 = new Array(4);
    //     this._wnafT3 = new Array(4);
    //     this._wnafT4 = new Array(4);
    
    //     this._bitLength = this.n ? this.n.bitLength() : 0;
    
    //     // Generalized Greg Maxwell's trick
    //     var adjustCount = this.n && this.p.div(this.n);
    //     if (!adjustCount || adjustCount.cmpn(100) > 0) {
    //       this.redN = null;
    //     } else {
    //       this._maxwellTrick = true;
    //       this.redN = this.n.toRed(this.red);
    //     }
    //   }
    //   var base = BaseCurve;
    
    //   BaseCurve.prototype.point = function point() {
    //     throw new Error('Not implemented');
    //   };
    
    //   BaseCurve.prototype.validate = function validate() {
    //     throw new Error('Not implemented');
    //   };
    
    //   BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    //     assert$f(p.precomputed);
    //     var doubles = p._getDoubles();
    
    //     var naf = getNAF(k, 1, this._bitLength);
    //     var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
    //     I /= 3;
    
    //     // Translate into more windowed form
    //     var repr = [];
    //     var j;
    //     var nafW;
    //     for (j = 0; j < naf.length; j += doubles.step) {
    //       nafW = 0;
    //       for (var l = j + doubles.step - 1; l >= j; l--)
    //         nafW = (nafW << 1) + naf[l];
    //       repr.push(nafW);
    //     }
    
    //     var a = this.jpoint(null, null, null);
    //     var b = this.jpoint(null, null, null);
    //     for (var i = I; i > 0; i--) {
    //       for (j = 0; j < repr.length; j++) {
    //         nafW = repr[j];
    //         if (nafW === i)
    //           b = b.mixedAdd(doubles.points[j]);
    //         else if (nafW === -i)
    //           b = b.mixedAdd(doubles.points[j].neg());
    //       }
    //       a = a.add(b);
    //     }
    //     return a.toP();
    //   };
    
    //   BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    //     var w = 4;
    
    //     // Precompute window
    //     var nafPoints = p._getNAFPoints(w);
    //     w = nafPoints.wnd;
    //     var wnd = nafPoints.points;
    
    //     // Get NAF form
    //     var naf = getNAF(k, w, this._bitLength);
    
    //     // Add `this`*(N+1) for every w-NAF index
    //     var acc = this.jpoint(null, null, null);
    //     for (var i = naf.length - 1; i >= 0; i--) {
    //       // Count zeroes
    //       for (var l = 0; i >= 0 && naf[i] === 0; i--)
    //         l++;
    //       if (i >= 0)
    //         l++;
    //       acc = acc.dblp(l);
    
    //       if (i < 0)
    //         break;
    //       var z = naf[i];
    //       assert$f(z !== 0);
    //       if (p.type === 'affine') {
    //         // J +- P
    //         if (z > 0)
    //           acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
    //         else
    //           acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    //       } else {
    //         // J +- J
    //         if (z > 0)
    //           acc = acc.add(wnd[(z - 1) >> 1]);
    //         else
    //           acc = acc.add(wnd[(-z - 1) >> 1].neg());
    //       }
    //     }
    //     return p.type === 'affine' ? acc.toP() : acc;
    //   };
    
    //   BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
    //     points,
    //     coeffs,
    //     len,
    //     jacobianResult) {
    //     var wndWidth = this._wnafT1;
    //     var wnd = this._wnafT2;
    //     var naf = this._wnafT3;
    
    //     // Fill all arrays
    //     var max = 0;
    //     var i;
    //     var j;
    //     var p;
    //     for (i = 0; i < len; i++) {
    //       p = points[i];
    //       var nafPoints = p._getNAFPoints(defW);
    //       wndWidth[i] = nafPoints.wnd;
    //       wnd[i] = nafPoints.points;
    //     }
    
    //     // Comb small window NAFs
    //     for (i = len - 1; i >= 1; i -= 2) {
    //       var a = i - 1;
    //       var b = i;
    //       if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
    //         naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
    //         naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
    //         max = Math.max(naf[a].length, max);
    //         max = Math.max(naf[b].length, max);
    //         continue;
    //       }
    
    //       var comb = [
    //         points[a], /* 1 */
    //         null, /* 3 */
    //         null, /* 5 */
    //         points[b], /* 7 */
    //       ];
    
    //       // Try to avoid Projective points, if possible
    //       if (points[a].y.cmp(points[b].y) === 0) {
    //         comb[1] = points[a].add(points[b]);
    //         comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    //       } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
    //         comb[1] = points[a].toJ().mixedAdd(points[b]);
    //         comb[2] = points[a].add(points[b].neg());
    //       } else {
    //         comb[1] = points[a].toJ().mixedAdd(points[b]);
    //         comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    //       }
    
    //       var index = [
    //         -3, /* -1 -1 */
    //         -1, /* -1 0 */
    //         -5, /* -1 1 */
    //         -7, /* 0 -1 */
    //         0, /* 0 0 */
    //         7, /* 0 1 */
    //         5, /* 1 -1 */
    //         1, /* 1 0 */
    //         3,  /* 1 1 */
    //       ];
    
    //       var jsf = getJSF(coeffs[a], coeffs[b]);
    //       max = Math.max(jsf[0].length, max);
    //       naf[a] = new Array(max);
    //       naf[b] = new Array(max);
    //       for (j = 0; j < max; j++) {
    //         var ja = jsf[0][j] | 0;
    //         var jb = jsf[1][j] | 0;
    
    //         naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
    //         naf[b][j] = 0;
    //         wnd[a] = comb;
    //       }
    //     }
    
    //     var acc = this.jpoint(null, null, null);
    //     var tmp = this._wnafT4;
    //     for (i = max; i >= 0; i--) {
    //       var k = 0;
    
    //       while (i >= 0) {
    //         var zero = true;
    //         for (j = 0; j < len; j++) {
    //           tmp[j] = naf[j][i] | 0;
    //           if (tmp[j] !== 0)
    //             zero = false;
    //         }
    //         if (!zero)
    //           break;
    //         k++;
    //         i--;
    //       }
    //       if (i >= 0)
    //         k++;
    //       acc = acc.dblp(k);
    //       if (i < 0)
    //         break;
    
    //       for (j = 0; j < len; j++) {
    //         var z = tmp[j];
    //         if (z === 0)
    //           continue;
    //         else if (z > 0)
    //           p = wnd[j][(z - 1) >> 1];
    //         else if (z < 0)
    //           p = wnd[j][(-z - 1) >> 1].neg();
    
    //         if (p.type === 'affine')
    //           acc = acc.mixedAdd(p);
    //         else
    //           acc = acc.add(p);
    //       }
    //     }
    //     // Zeroify references
    //     for (i = 0; i < len; i++)
    //       wnd[i] = null;
    
    //     if (jacobianResult)
    //       return acc;
    //     else
    //       return acc.toP();
    //   };
    
    //   function BasePoint(curve, type) {
    //     this.curve = curve;
    //     this.type = type;
    //     this.precomputed = null;
    //   }
    //   BaseCurve.BasePoint = BasePoint;
    
    //   BasePoint.prototype.eq = function eq(/*other*/) {
    //     throw new Error('Not implemented');
    //   };
    
    //   BasePoint.prototype.validate = function validate() {
    //     return this.curve.validate(this);
    //   };
    
    //   BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    //     bytes = utils$k.toArray(bytes, enc);
    
    //     var len = this.p.byteLength();
    
    //     // uncompressed, hybrid-odd, hybrid-even
    //     if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
    //         bytes.length - 1 === 2 * len) {
    //       if (bytes[0] === 0x06)
    //         assert$f(bytes[bytes.length - 1] % 2 === 0);
    //       else if (bytes[0] === 0x07)
    //         assert$f(bytes[bytes.length - 1] % 2 === 1);
    
    //       var res =  this.point(bytes.slice(1, 1 + len),
    //         bytes.slice(1 + len, 1 + 2 * len));
    
    //       return res;
    //     } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
    //                 bytes.length - 1 === len) {
    //       return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
    //     }
    //     throw new Error('Unknown point format');
    //   };
    
    //   BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    //     return this.encode(enc, true);
    //   };
    
    //   BasePoint.prototype._encode = function _encode(compact) {
    //     var len = this.curve.p.byteLength();
    //     var x = this.getX().toArray('be', len);
    
    //     if (compact)
    //       return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);
    
    //     return [ 0x04 ].concat(x, this.getY().toArray('be', len));
    //   };
    
    //   BasePoint.prototype.encode = function encode(enc, compact) {
    //     return utils$k.encode(this._encode(compact), enc);
    //   };
    
    //   BasePoint.prototype.precompute = function precompute(power) {
    //     if (this.precomputed)
    //       return this;
    
    //     var precomputed = {
    //       doubles: null,
    //       naf: null,
    //       beta: null,
    //     };
    //     precomputed.naf = this._getNAFPoints(8);
    //     precomputed.doubles = this._getDoubles(4, power);
    //     precomputed.beta = this._getBeta();
    //     this.precomputed = precomputed;
    
    //     return this;
    //   };
    
    //   BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    //     if (!this.precomputed)
    //       return false;
    
    //     var doubles = this.precomputed.doubles;
    //     if (!doubles)
    //       return false;
    
    //     return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    //   };
    
    //   BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    //     if (this.precomputed && this.precomputed.doubles)
    //       return this.precomputed.doubles;
    
    //     var doubles = [ this ];
    //     var acc = this;
    //     for (var i = 0; i < power; i += step) {
    //       for (var j = 0; j < step; j++)
    //         acc = acc.dbl();
    //       doubles.push(acc);
    //     }
    //     return {
    //       step: step,
    //       points: doubles,
    //     };
    //   };
    
    //   BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    //     if (this.precomputed && this.precomputed.naf)
    //       return this.precomputed.naf;
    
    //     var res = [ this ];
    //     var max = (1 << wnd) - 1;
    //     var dbl = max === 1 ? null : this.dbl();
    //     for (var i = 1; i < max; i++)
    //       res[i] = res[i - 1].add(dbl);
    //     return {
    //       wnd: wnd,
    //       points: res,
    //     };
    //   };
    
    //   BasePoint.prototype._getBeta = function _getBeta() {
    //     return null;
    //   };
    
    //   BasePoint.prototype.dblp = function dblp(k) {
    //     var r = this;
    //     for (var i = 0; i < k; i++)
    //       r = r.dbl();
    //     return r;
    //   };
    
    //   var inherits_browser$1 = {exports: {}};
    
    //   if (typeof Object.create === 'function') {
    //     // implementation from standard node.js 'util' module
    //     inherits_browser$1.exports = function inherits(ctor, superCtor) {
    //       if (superCtor) {
    //         ctor.super_ = superCtor;
    //         ctor.prototype = Object.create(superCtor.prototype, {
    //           constructor: {
    //             value: ctor,
    //             enumerable: false,
    //             writable: true,
    //             configurable: true
    //           }
    //         });
    //       }
    //     };
    //   } else {
    //     // old school shim for old browsers
    //     inherits_browser$1.exports = function inherits(ctor, superCtor) {
    //       if (superCtor) {
    //         ctor.super_ = superCtor;
    //         var TempCtor = function () {};
    //         TempCtor.prototype = superCtor.prototype;
    //         ctor.prototype = new TempCtor();
    //         ctor.prototype.constructor = ctor;
    //       }
    //     };
    //   }
    
    //   var utils$j = utils$m;
    //   var BN$7 = bn.exports;
    //   var inherits$3 = inherits_browser$1.exports;
    //   var Base$2 = base;
    
    //   var assert$e = utils$j.assert;
    
    //   function ShortCurve(conf) {
    //     Base$2.call(this, 'short', conf);
    
    //     this.a = new BN$7(conf.a, 16).toRed(this.red);
    //     this.b = new BN$7(conf.b, 16).toRed(this.red);
    //     this.tinv = this.two.redInvm();
    
    //     this.zeroA = this.a.fromRed().cmpn(0) === 0;
    //     this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    
    //     // If the curve is endomorphic, precalculate beta and lambda
    //     this.endo = this._getEndomorphism(conf);
    //     this._endoWnafT1 = new Array(4);
    //     this._endoWnafT2 = new Array(4);
    //   }
    //   inherits$3(ShortCurve, Base$2);
    //   var short = ShortCurve;
    
    //   ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    //     // No efficient endomorphism
    //     if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    //       return;
    
    //     // Compute beta and lambda, that lambda * P = (beta * Px; Py)
    //     var beta;
    //     var lambda;
    //     if (conf.beta) {
    //       beta = new BN$7(conf.beta, 16).toRed(this.red);
    //     } else {
    //       var betas = this._getEndoRoots(this.p);
    //       // Choose the smallest beta
    //       beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    //       beta = beta.toRed(this.red);
    //     }
    //     if (conf.lambda) {
    //       lambda = new BN$7(conf.lambda, 16);
    //     } else {
    //       // Choose the lambda that is matching selected beta
    //       var lambdas = this._getEndoRoots(this.n);
    //       if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
    //         lambda = lambdas[0];
    //       } else {
    //         lambda = lambdas[1];
    //         assert$e(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    //       }
    //     }
    
    //     // Get basis vectors, used for balanced length-two representation
    //     var basis;
    //     if (conf.basis) {
    //       basis = conf.basis.map(function(vec) {
    //         return {
    //           a: new BN$7(vec.a, 16),
    //           b: new BN$7(vec.b, 16),
    //         };
    //       });
    //     } else {
    //       basis = this._getEndoBasis(lambda);
    //     }
    
    //     return {
    //       beta: beta,
    //       lambda: lambda,
    //       basis: basis,
    //     };
    //   };
    
    //   ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    //     // Find roots of for x^2 + x + 1 in F
    //     // Root = (-1 +- Sqrt(-3)) / 2
    //     //
    //     var red = num === this.p ? this.red : BN$7.mont(num);
    //     var tinv = new BN$7(2).toRed(red).redInvm();
    //     var ntinv = tinv.redNeg();
    
    //     var s = new BN$7(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    
    //     var l1 = ntinv.redAdd(s).fromRed();
    //     var l2 = ntinv.redSub(s).fromRed();
    //     return [ l1, l2 ];
    //   };
    
    //   ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    //     // aprxSqrt >= sqrt(this.n)
    //     var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    
    //     // 3.74
    //     // Run EGCD, until r(L + 1) < aprxSqrt
    //     var u = lambda;
    //     var v = this.n.clone();
    //     var x1 = new BN$7(1);
    //     var y1 = new BN$7(0);
    //     var x2 = new BN$7(0);
    //     var y2 = new BN$7(1);
    
    //     // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
    //     var a0;
    //     var b0;
    //     // First vector
    //     var a1;
    //     var b1;
    //     // Second vector
    //     var a2;
    //     var b2;
    
    //     var prevR;
    //     var i = 0;
    //     var r;
    //     var x;
    //     while (u.cmpn(0) !== 0) {
    //       var q = v.div(u);
    //       r = v.sub(q.mul(u));
    //       x = x2.sub(q.mul(x1));
    //       var y = y2.sub(q.mul(y1));
    
    //       if (!a1 && r.cmp(aprxSqrt) < 0) {
    //         a0 = prevR.neg();
    //         b0 = x1;
    //         a1 = r.neg();
    //         b1 = x;
    //       } else if (a1 && ++i === 2) {
    //         break;
    //       }
    //       prevR = r;
    
    //       v = u;
    //       u = r;
    //       x2 = x1;
    //       x1 = x;
    //       y2 = y1;
    //       y1 = y;
    //     }
    //     a2 = r.neg();
    //     b2 = x;
    
    //     var len1 = a1.sqr().add(b1.sqr());
    //     var len2 = a2.sqr().add(b2.sqr());
    //     if (len2.cmp(len1) >= 0) {
    //       a2 = a0;
    //       b2 = b0;
    //     }
    
    //     // Normalize signs
    //     if (a1.negative) {
    //       a1 = a1.neg();
    //       b1 = b1.neg();
    //     }
    //     if (a2.negative) {
    //       a2 = a2.neg();
    //       b2 = b2.neg();
    //     }
    
    //     return [
    //       { a: a1, b: b1 },
    //       { a: a2, b: b2 },
    //     ];
    //   };
    
    //   ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    //     var basis = this.endo.basis;
    //     var v1 = basis[0];
    //     var v2 = basis[1];
    
    //     var c1 = v2.b.mul(k).divRound(this.n);
    //     var c2 = v1.b.neg().mul(k).divRound(this.n);
    
    //     var p1 = c1.mul(v1.a);
    //     var p2 = c2.mul(v2.a);
    //     var q1 = c1.mul(v1.b);
    //     var q2 = c2.mul(v2.b);
    
    //     // Calculate answer
    //     var k1 = k.sub(p1).sub(p2);
    //     var k2 = q1.add(q2).neg();
    //     return { k1: k1, k2: k2 };
    //   };
    
    //   ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    //     x = new BN$7(x, 16);
    //     if (!x.red)
    //       x = x.toRed(this.red);
    
    //     var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    //     var y = y2.redSqrt();
    //     if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    //       throw new Error('invalid point');
    
    //     // XXX Is there any way to tell if the number is odd without converting it
    //     // to non-red form?
    //     var isOdd = y.fromRed().isOdd();
    //     if (odd && !isOdd || !odd && isOdd)
    //       y = y.redNeg();
    
    //     return this.point(x, y);
    //   };
    
    //   ShortCurve.prototype.validate = function validate(point) {
    //     if (point.inf)
    //       return true;
    
    //     var x = point.x;
    //     var y = point.y;
    
    //     var ax = this.a.redMul(x);
    //     var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    //     return y.redSqr().redISub(rhs).cmpn(0) === 0;
    //   };
    
    //   ShortCurve.prototype._endoWnafMulAdd =
    //       function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    //         var npoints = this._endoWnafT1;
    //         var ncoeffs = this._endoWnafT2;
    //         for (var i = 0; i < points.length; i++) {
    //           var split = this._endoSplit(coeffs[i]);
    //           var p = points[i];
    //           var beta = p._getBeta();
    
    //           if (split.k1.negative) {
    //             split.k1.ineg();
    //             p = p.neg(true);
    //           }
    //           if (split.k2.negative) {
    //             split.k2.ineg();
    //             beta = beta.neg(true);
    //           }
    
    //           npoints[i * 2] = p;
    //           npoints[i * 2 + 1] = beta;
    //           ncoeffs[i * 2] = split.k1;
    //           ncoeffs[i * 2 + 1] = split.k2;
    //         }
    //         var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
    
    //         // Clean-up references to points and coefficients
    //         for (var j = 0; j < i * 2; j++) {
    //           npoints[j] = null;
    //           ncoeffs[j] = null;
    //         }
    //         return res;
    //       };
    
    //   function Point$2(curve, x, y, isRed) {
    //     Base$2.BasePoint.call(this, curve, 'affine');
    //     if (x === null && y === null) {
    //       this.x = null;
    //       this.y = null;
    //       this.inf = true;
    //     } else {
    //       this.x = new BN$7(x, 16);
    //       this.y = new BN$7(y, 16);
    //       // Force redgomery representation when loading from JSON
    //       if (isRed) {
    //         this.x.forceRed(this.curve.red);
    //         this.y.forceRed(this.curve.red);
    //       }
    //       if (!this.x.red)
    //         this.x = this.x.toRed(this.curve.red);
    //       if (!this.y.red)
    //         this.y = this.y.toRed(this.curve.red);
    //       this.inf = false;
    //     }
    //   }
    //   inherits$3(Point$2, Base$2.BasePoint);
    
    //   ShortCurve.prototype.point = function point(x, y, isRed) {
    //     return new Point$2(this, x, y, isRed);
    //   };
    
    //   ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    //     return Point$2.fromJSON(this, obj, red);
    //   };
    
    //   Point$2.prototype._getBeta = function _getBeta() {
    //     if (!this.curve.endo)
    //       return;
    
    //     var pre = this.precomputed;
    //     if (pre && pre.beta)
    //       return pre.beta;
    
    //     var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    //     if (pre) {
    //       var curve = this.curve;
    //       var endoMul = function(p) {
    //         return curve.point(p.x.redMul(curve.endo.beta), p.y);
    //       };
    //       pre.beta = beta;
    //       beta.precomputed = {
    //         beta: null,
    //         naf: pre.naf && {
    //           wnd: pre.naf.wnd,
    //           points: pre.naf.points.map(endoMul),
    //         },
    //         doubles: pre.doubles && {
    //           step: pre.doubles.step,
    //           points: pre.doubles.points.map(endoMul),
    //         },
    //       };
    //     }
    //     return beta;
    //   };
    
    //   Point$2.prototype.toJSON = function toJSON() {
    //     if (!this.precomputed)
    //       return [ this.x, this.y ];
    
    //     return [ this.x, this.y, this.precomputed && {
    //       doubles: this.precomputed.doubles && {
    //         step: this.precomputed.doubles.step,
    //         points: this.precomputed.doubles.points.slice(1),
    //       },
    //       naf: this.precomputed.naf && {
    //         wnd: this.precomputed.naf.wnd,
    //         points: this.precomputed.naf.points.slice(1),
    //       },
    //     } ];
    //   };
    
    //   Point$2.fromJSON = function fromJSON(curve, obj, red) {
    //     if (typeof obj === 'string')
    //       obj = JSON.parse(obj);
    //     var res = curve.point(obj[0], obj[1], red);
    //     if (!obj[2])
    //       return res;
    
    //     function obj2point(obj) {
    //       return curve.point(obj[0], obj[1], red);
    //     }
    
    //     var pre = obj[2];
    //     res.precomputed = {
    //       beta: null,
    //       doubles: pre.doubles && {
    //         step: pre.doubles.step,
    //         points: [ res ].concat(pre.doubles.points.map(obj2point)),
    //       },
    //       naf: pre.naf && {
    //         wnd: pre.naf.wnd,
    //         points: [ res ].concat(pre.naf.points.map(obj2point)),
    //       },
    //     };
    //     return res;
    //   };
    
    //   Point$2.prototype.inspect = function inspect() {
    //     if (this.isInfinity())
    //       return '<EC Point Infinity>';
    //     return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
    //         ' y: ' + this.y.fromRed().toString(16, 2) + '>';
    //   };
    
    //   Point$2.prototype.isInfinity = function isInfinity() {
    //     return this.inf;
    //   };
    
    //   Point$2.prototype.add = function add(p) {
    //     // O + P = P
    //     if (this.inf)
    //       return p;
    
    //     // P + O = P
    //     if (p.inf)
    //       return this;
    
    //     // P + P = 2P
    //     if (this.eq(p))
    //       return this.dbl();
    
    //     // P + (-P) = O
    //     if (this.neg().eq(p))
    //       return this.curve.point(null, null);
    
    //     // P + Q = O
    //     if (this.x.cmp(p.x) === 0)
    //       return this.curve.point(null, null);
    
    //     var c = this.y.redSub(p.y);
    //     if (c.cmpn(0) !== 0)
    //       c = c.redMul(this.x.redSub(p.x).redInvm());
    //     var nx = c.redSqr().redISub(this.x).redISub(p.x);
    //     var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    //     return this.curve.point(nx, ny);
    //   };
    
    //   Point$2.prototype.dbl = function dbl() {
    //     if (this.inf)
    //       return this;
    
    //     // 2P = O
    //     var ys1 = this.y.redAdd(this.y);
    //     if (ys1.cmpn(0) === 0)
    //       return this.curve.point(null, null);
    
    //     var a = this.curve.a;
    
    //     var x2 = this.x.redSqr();
    //     var dyinv = ys1.redInvm();
    //     var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    
    //     var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    //     var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    //     return this.curve.point(nx, ny);
    //   };
    
    //   Point$2.prototype.getX = function getX() {
    //     return this.x.fromRed();
    //   };
    
    //   Point$2.prototype.getY = function getY() {
    //     return this.y.fromRed();
    //   };
    
    //   Point$2.prototype.mul = function mul(k) {
    //     k = new BN$7(k, 16);
    //     if (this.isInfinity())
    //       return this;
    //     else if (this._hasDoubles(k))
    //       return this.curve._fixedNafMul(this, k);
    //     else if (this.curve.endo)
    //       return this.curve._endoWnafMulAdd([ this ], [ k ]);
    //     else
    //       return this.curve._wnafMul(this, k);
    //   };
    
    //   Point$2.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    //     var points = [ this, p2 ];
    //     var coeffs = [ k1, k2 ];
    //     if (this.curve.endo)
    //       return this.curve._endoWnafMulAdd(points, coeffs);
    //     else
    //       return this.curve._wnafMulAdd(1, points, coeffs, 2);
    //   };
    
    //   Point$2.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    //     var points = [ this, p2 ];
    //     var coeffs = [ k1, k2 ];
    //     if (this.curve.endo)
    //       return this.curve._endoWnafMulAdd(points, coeffs, true);
    //     else
    //       return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    //   };
    
    //   Point$2.prototype.eq = function eq(p) {
    //     return this === p ||
    //            this.inf === p.inf &&
    //                (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    //   };
    
    //   Point$2.prototype.neg = function neg(_precompute) {
    //     if (this.inf)
    //       return this;
    
    //     var res = this.curve.point(this.x, this.y.redNeg());
    //     if (_precompute && this.precomputed) {
    //       var pre = this.precomputed;
    //       var negate = function(p) {
    //         return p.neg();
    //       };
    //       res.precomputed = {
    //         naf: pre.naf && {
    //           wnd: pre.naf.wnd,
    //           points: pre.naf.points.map(negate),
    //         },
    //         doubles: pre.doubles && {
    //           step: pre.doubles.step,
    //           points: pre.doubles.points.map(negate),
    //         },
    //       };
    //     }
    //     return res;
    //   };
    
    //   Point$2.prototype.toJ = function toJ() {
    //     if (this.inf)
    //       return this.curve.jpoint(null, null, null);
    
    //     var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    //     return res;
    //   };
    
    //   function JPoint(curve, x, y, z) {
    //     Base$2.BasePoint.call(this, curve, 'jacobian');
    //     if (x === null && y === null && z === null) {
    //       this.x = this.curve.one;
    //       this.y = this.curve.one;
    //       this.z = new BN$7(0);
    //     } else {
    //       this.x = new BN$7(x, 16);
    //       this.y = new BN$7(y, 16);
    //       this.z = new BN$7(z, 16);
    //     }
    //     if (!this.x.red)
    //       this.x = this.x.toRed(this.curve.red);
    //     if (!this.y.red)
    //       this.y = this.y.toRed(this.curve.red);
    //     if (!this.z.red)
    //       this.z = this.z.toRed(this.curve.red);
    
    //     this.zOne = this.z === this.curve.one;
    //   }
    //   inherits$3(JPoint, Base$2.BasePoint);
    
    //   ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    //     return new JPoint(this, x, y, z);
    //   };
    
    //   JPoint.prototype.toP = function toP() {
    //     if (this.isInfinity())
    //       return this.curve.point(null, null);
    
    //     var zinv = this.z.redInvm();
    //     var zinv2 = zinv.redSqr();
    //     var ax = this.x.redMul(zinv2);
    //     var ay = this.y.redMul(zinv2).redMul(zinv);
    
    //     return this.curve.point(ax, ay);
    //   };
    
    //   JPoint.prototype.neg = function neg() {
    //     return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    //   };
    
    //   JPoint.prototype.add = function add(p) {
    //     // O + P = P
    //     if (this.isInfinity())
    //       return p;
    
    //     // P + O = P
    //     if (p.isInfinity())
    //       return this;
    
    //     // 12M + 4S + 7A
    //     var pz2 = p.z.redSqr();
    //     var z2 = this.z.redSqr();
    //     var u1 = this.x.redMul(pz2);
    //     var u2 = p.x.redMul(z2);
    //     var s1 = this.y.redMul(pz2.redMul(p.z));
    //     var s2 = p.y.redMul(z2.redMul(this.z));
    
    //     var h = u1.redSub(u2);
    //     var r = s1.redSub(s2);
    //     if (h.cmpn(0) === 0) {
    //       if (r.cmpn(0) !== 0)
    //         return this.curve.jpoint(null, null, null);
    //       else
    //         return this.dbl();
    //     }
    
    //     var h2 = h.redSqr();
    //     var h3 = h2.redMul(h);
    //     var v = u1.redMul(h2);
    
    //     var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    //     var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    //     var nz = this.z.redMul(p.z).redMul(h);
    
    //     return this.curve.jpoint(nx, ny, nz);
    //   };
    
    //   JPoint.prototype.mixedAdd = function mixedAdd(p) {
    //     // O + P = P
    //     if (this.isInfinity())
    //       return p.toJ();
    
    //     // P + O = P
    //     if (p.isInfinity())
    //       return this;
    
    //     // 8M + 3S + 7A
    //     var z2 = this.z.redSqr();
    //     var u1 = this.x;
    //     var u2 = p.x.redMul(z2);
    //     var s1 = this.y;
    //     var s2 = p.y.redMul(z2).redMul(this.z);
    
    //     var h = u1.redSub(u2);
    //     var r = s1.redSub(s2);
    //     if (h.cmpn(0) === 0) {
    //       if (r.cmpn(0) !== 0)
    //         return this.curve.jpoint(null, null, null);
    //       else
    //         return this.dbl();
    //     }
    
    //     var h2 = h.redSqr();
    //     var h3 = h2.redMul(h);
    //     var v = u1.redMul(h2);
    
    //     var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    //     var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    //     var nz = this.z.redMul(h);
    
    //     return this.curve.jpoint(nx, ny, nz);
    //   };
    
    //   JPoint.prototype.dblp = function dblp(pow) {
    //     if (pow === 0)
    //       return this;
    //     if (this.isInfinity())
    //       return this;
    //     if (!pow)
    //       return this.dbl();
    
    //     var i;
    //     if (this.curve.zeroA || this.curve.threeA) {
    //       var r = this;
    //       for (i = 0; i < pow; i++)
    //         r = r.dbl();
    //       return r;
    //     }
    
    //     // 1M + 2S + 1A + N * (4S + 5M + 8A)
    //     // N = 1 => 6M + 6S + 9A
    //     var a = this.curve.a;
    //     var tinv = this.curve.tinv;
    
    //     var jx = this.x;
    //     var jy = this.y;
    //     var jz = this.z;
    //     var jz4 = jz.redSqr().redSqr();
    
    //     // Reuse results
    //     var jyd = jy.redAdd(jy);
    //     for (i = 0; i < pow; i++) {
    //       var jx2 = jx.redSqr();
    //       var jyd2 = jyd.redSqr();
    //       var jyd4 = jyd2.redSqr();
    //       var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    
    //       var t1 = jx.redMul(jyd2);
    //       var nx = c.redSqr().redISub(t1.redAdd(t1));
    //       var t2 = t1.redISub(nx);
    //       var dny = c.redMul(t2);
    //       dny = dny.redIAdd(dny).redISub(jyd4);
    //       var nz = jyd.redMul(jz);
    //       if (i + 1 < pow)
    //         jz4 = jz4.redMul(jyd4);
    
    //       jx = nx;
    //       jz = nz;
    //       jyd = dny;
    //     }
    
    //     return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    //   };
    
    //   JPoint.prototype.dbl = function dbl() {
    //     if (this.isInfinity())
    //       return this;
    
    //     if (this.curve.zeroA)
    //       return this._zeroDbl();
    //     else if (this.curve.threeA)
    //       return this._threeDbl();
    //     else
    //       return this._dbl();
    //   };
    
    //   JPoint.prototype._zeroDbl = function _zeroDbl() {
    //     var nx;
    //     var ny;
    //     var nz;
    //     // Z = 1
    //     if (this.zOne) {
    //       // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //       //     #doubling-mdbl-2007-bl
    //       // 1M + 5S + 14A
    
    //       // XX = X1^2
    //       var xx = this.x.redSqr();
    //       // YY = Y1^2
    //       var yy = this.y.redSqr();
    //       // YYYY = YY^2
    //       var yyyy = yy.redSqr();
    //       // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    //       var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    //       s = s.redIAdd(s);
    //       // M = 3 * XX + a; a = 0
    //       var m = xx.redAdd(xx).redIAdd(xx);
    //       // T = M ^ 2 - 2*S
    //       var t = m.redSqr().redISub(s).redISub(s);
    
    //       // 8 * YYYY
    //       var yyyy8 = yyyy.redIAdd(yyyy);
    //       yyyy8 = yyyy8.redIAdd(yyyy8);
    //       yyyy8 = yyyy8.redIAdd(yyyy8);
    
    //       // X3 = T
    //       nx = t;
    //       // Y3 = M * (S - T) - 8 * YYYY
    //       ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    //       // Z3 = 2*Y1
    //       nz = this.y.redAdd(this.y);
    //     } else {
    //       // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //       //     #doubling-dbl-2009-l
    //       // 2M + 5S + 13A
    
    //       // A = X1^2
    //       var a = this.x.redSqr();
    //       // B = Y1^2
    //       var b = this.y.redSqr();
    //       // C = B^2
    //       var c = b.redSqr();
    //       // D = 2 * ((X1 + B)^2 - A - C)
    //       var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    //       d = d.redIAdd(d);
    //       // E = 3 * A
    //       var e = a.redAdd(a).redIAdd(a);
    //       // F = E^2
    //       var f = e.redSqr();
    
    //       // 8 * C
    //       var c8 = c.redIAdd(c);
    //       c8 = c8.redIAdd(c8);
    //       c8 = c8.redIAdd(c8);
    
    //       // X3 = F - 2 * D
    //       nx = f.redISub(d).redISub(d);
    //       // Y3 = E * (D - X3) - 8 * C
    //       ny = e.redMul(d.redISub(nx)).redISub(c8);
    //       // Z3 = 2 * Y1 * Z1
    //       nz = this.y.redMul(this.z);
    //       nz = nz.redIAdd(nz);
    //     }
    
    //     return this.curve.jpoint(nx, ny, nz);
    //   };
    
    //   JPoint.prototype._threeDbl = function _threeDbl() {
    //     var nx;
    //     var ny;
    //     var nz;
    //     // Z = 1
    //     if (this.zOne) {
    //       // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //       //     #doubling-mdbl-2007-bl
    //       // 1M + 5S + 15A
    
    //       // XX = X1^2
    //       var xx = this.x.redSqr();
    //       // YY = Y1^2
    //       var yy = this.y.redSqr();
    //       // YYYY = YY^2
    //       var yyyy = yy.redSqr();
    //       // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    //       var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    //       s = s.redIAdd(s);
    //       // M = 3 * XX + a
    //       var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    //       // T = M^2 - 2 * S
    //       var t = m.redSqr().redISub(s).redISub(s);
    //       // X3 = T
    //       nx = t;
    //       // Y3 = M * (S - T) - 8 * YYYY
    //       var yyyy8 = yyyy.redIAdd(yyyy);
    //       yyyy8 = yyyy8.redIAdd(yyyy8);
    //       yyyy8 = yyyy8.redIAdd(yyyy8);
    //       ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    //       // Z3 = 2 * Y1
    //       nz = this.y.redAdd(this.y);
    //     } else {
    //       // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    //       // 3M + 5S
    
    //       // delta = Z1^2
    //       var delta = this.z.redSqr();
    //       // gamma = Y1^2
    //       var gamma = this.y.redSqr();
    //       // beta = X1 * gamma
    //       var beta = this.x.redMul(gamma);
    //       // alpha = 3 * (X1 - delta) * (X1 + delta)
    //       var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    //       alpha = alpha.redAdd(alpha).redIAdd(alpha);
    //       // X3 = alpha^2 - 8 * beta
    //       var beta4 = beta.redIAdd(beta);
    //       beta4 = beta4.redIAdd(beta4);
    //       var beta8 = beta4.redAdd(beta4);
    //       nx = alpha.redSqr().redISub(beta8);
    //       // Z3 = (Y1 + Z1)^2 - gamma - delta
    //       nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    //       // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    //       var ggamma8 = gamma.redSqr();
    //       ggamma8 = ggamma8.redIAdd(ggamma8);
    //       ggamma8 = ggamma8.redIAdd(ggamma8);
    //       ggamma8 = ggamma8.redIAdd(ggamma8);
    //       ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    //     }
    
    //     return this.curve.jpoint(nx, ny, nz);
    //   };
    
    //   JPoint.prototype._dbl = function _dbl() {
    //     var a = this.curve.a;
    
    //     // 4M + 6S + 10A
    //     var jx = this.x;
    //     var jy = this.y;
    //     var jz = this.z;
    //     var jz4 = jz.redSqr().redSqr();
    
    //     var jx2 = jx.redSqr();
    //     var jy2 = jy.redSqr();
    
    //     var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    
    //     var jxd4 = jx.redAdd(jx);
    //     jxd4 = jxd4.redIAdd(jxd4);
    //     var t1 = jxd4.redMul(jy2);
    //     var nx = c.redSqr().redISub(t1.redAdd(t1));
    //     var t2 = t1.redISub(nx);
    
    //     var jyd8 = jy2.redSqr();
    //     jyd8 = jyd8.redIAdd(jyd8);
    //     jyd8 = jyd8.redIAdd(jyd8);
    //     jyd8 = jyd8.redIAdd(jyd8);
    //     var ny = c.redMul(t2).redISub(jyd8);
    //     var nz = jy.redAdd(jy).redMul(jz);
    
    //     return this.curve.jpoint(nx, ny, nz);
    //   };
    
    //   JPoint.prototype.trpl = function trpl() {
    //     if (!this.curve.zeroA)
    //       return this.dbl().add(this);
    
    //     // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
    //     // 5M + 10S + ...
    
    //     // XX = X1^2
    //     var xx = this.x.redSqr();
    //     // YY = Y1^2
    //     var yy = this.y.redSqr();
    //     // ZZ = Z1^2
    //     var zz = this.z.redSqr();
    //     // YYYY = YY^2
    //     var yyyy = yy.redSqr();
    //     // M = 3 * XX + a * ZZ2; a = 0
    //     var m = xx.redAdd(xx).redIAdd(xx);
    //     // MM = M^2
    //     var mm = m.redSqr();
    //     // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
    //     var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    //     e = e.redIAdd(e);
    //     e = e.redAdd(e).redIAdd(e);
    //     e = e.redISub(mm);
    //     // EE = E^2
    //     var ee = e.redSqr();
    //     // T = 16*YYYY
    //     var t = yyyy.redIAdd(yyyy);
    //     t = t.redIAdd(t);
    //     t = t.redIAdd(t);
    //     t = t.redIAdd(t);
    //     // U = (M + E)^2 - MM - EE - T
    //     var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    //     // X3 = 4 * (X1 * EE - 4 * YY * U)
    //     var yyu4 = yy.redMul(u);
    //     yyu4 = yyu4.redIAdd(yyu4);
    //     yyu4 = yyu4.redIAdd(yyu4);
    //     var nx = this.x.redMul(ee).redISub(yyu4);
    //     nx = nx.redIAdd(nx);
    //     nx = nx.redIAdd(nx);
    //     // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
    //     var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    //     ny = ny.redIAdd(ny);
    //     ny = ny.redIAdd(ny);
    //     ny = ny.redIAdd(ny);
    //     // Z3 = (Z1 + E)^2 - ZZ - EE
    //     var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    
    //     return this.curve.jpoint(nx, ny, nz);
    //   };
    
    //   JPoint.prototype.mul = function mul(k, kbase) {
    //     k = new BN$7(k, kbase);
    
    //     return this.curve._wnafMul(this, k);
    //   };
    
    //   JPoint.prototype.eq = function eq(p) {
    //     if (p.type === 'affine')
    //       return this.eq(p.toJ());
    
    //     if (this === p)
    //       return true;
    
    //     // x1 * z2^2 == x2 * z1^2
    //     var z2 = this.z.redSqr();
    //     var pz2 = p.z.redSqr();
    //     if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    //       return false;
    
    //     // y1 * z2^3 == y2 * z1^3
    //     var z3 = z2.redMul(this.z);
    //     var pz3 = pz2.redMul(p.z);
    //     return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    //   };
    
    //   JPoint.prototype.eqXToP = function eqXToP(x) {
    //     var zs = this.z.redSqr();
    //     var rx = x.toRed(this.curve.red).redMul(zs);
    //     if (this.x.cmp(rx) === 0)
    //       return true;
    
    //     var xc = x.clone();
    //     var t = this.curve.redN.redMul(zs);
    //     for (;;) {
    //       xc.iadd(this.curve.n);
    //       if (xc.cmp(this.curve.p) >= 0)
    //         return false;
    
    //       rx.redIAdd(t);
    //       if (this.x.cmp(rx) === 0)
    //         return true;
    //     }
    //   };
    
    //   JPoint.prototype.inspect = function inspect() {
    //     if (this.isInfinity())
    //       return '<EC JPoint Infinity>';
    //     return '<EC JPoint x: ' + this.x.toString(16, 2) +
    //         ' y: ' + this.y.toString(16, 2) +
    //         ' z: ' + this.z.toString(16, 2) + '>';
    //   };
    
    //   JPoint.prototype.isInfinity = function isInfinity() {
    //     // XXX This code assumes that zero is always zero in red
    //     return this.z.cmpn(0) === 0;
    //   };
    
    //   var BN$6 = bn.exports;
    //   var inherits$2 = inherits_browser$1.exports;
    //   var Base$1 = base;
    
    //   var utils$i = utils$m;
    
    //   function MontCurve(conf) {
    //     Base$1.call(this, 'mont', conf);
    
    //     this.a = new BN$6(conf.a, 16).toRed(this.red);
    //     this.b = new BN$6(conf.b, 16).toRed(this.red);
    //     this.i4 = new BN$6(4).toRed(this.red).redInvm();
    //     this.two = new BN$6(2).toRed(this.red);
    //     this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    //   }
    //   inherits$2(MontCurve, Base$1);
    //   var mont = MontCurve;
    
    //   MontCurve.prototype.validate = function validate(point) {
    //     var x = point.normalize().x;
    //     var x2 = x.redSqr();
    //     var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    //     var y = rhs.redSqrt();
    
    //     return y.redSqr().cmp(rhs) === 0;
    //   };
    
    //   function Point$1(curve, x, z) {
    //     Base$1.BasePoint.call(this, curve, 'projective');
    //     if (x === null && z === null) {
    //       this.x = this.curve.one;
    //       this.z = this.curve.zero;
    //     } else {
    //       this.x = new BN$6(x, 16);
    //       this.z = new BN$6(z, 16);
    //       if (!this.x.red)
    //         this.x = this.x.toRed(this.curve.red);
    //       if (!this.z.red)
    //         this.z = this.z.toRed(this.curve.red);
    //     }
    //   }
    //   inherits$2(Point$1, Base$1.BasePoint);
    
    //   MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    //     return this.point(utils$i.toArray(bytes, enc), 1);
    //   };
    
    //   MontCurve.prototype.point = function point(x, z) {
    //     return new Point$1(this, x, z);
    //   };
    
    //   MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    //     return Point$1.fromJSON(this, obj);
    //   };
    
    //   Point$1.prototype.precompute = function precompute() {
    //     // No-op
    //   };
    
    //   Point$1.prototype._encode = function _encode() {
    //     return this.getX().toArray('be', this.curve.p.byteLength());
    //   };
    
    //   Point$1.fromJSON = function fromJSON(curve, obj) {
    //     return new Point$1(curve, obj[0], obj[1] || curve.one);
    //   };
    
    //   Point$1.prototype.inspect = function inspect() {
    //     if (this.isInfinity())
    //       return '<EC Point Infinity>';
    //     return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
    //         ' z: ' + this.z.fromRed().toString(16, 2) + '>';
    //   };
    
    //   Point$1.prototype.isInfinity = function isInfinity() {
    //     // XXX This code assumes that zero is always zero in red
    //     return this.z.cmpn(0) === 0;
    //   };
    
    //   Point$1.prototype.dbl = function dbl() {
    //     // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
    //     // 2M + 2S + 4A
    
    //     // A = X1 + Z1
    //     var a = this.x.redAdd(this.z);
    //     // AA = A^2
    //     var aa = a.redSqr();
    //     // B = X1 - Z1
    //     var b = this.x.redSub(this.z);
    //     // BB = B^2
    //     var bb = b.redSqr();
    //     // C = AA - BB
    //     var c = aa.redSub(bb);
    //     // X3 = AA * BB
    //     var nx = aa.redMul(bb);
    //     // Z3 = C * (BB + A24 * C)
    //     var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    //     return this.curve.point(nx, nz);
    //   };
    
    //   Point$1.prototype.add = function add() {
    //     throw new Error('Not supported on Montgomery curve');
    //   };
    
    //   Point$1.prototype.diffAdd = function diffAdd(p, diff) {
    //     // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
    //     // 4M + 2S + 6A
    
    //     // A = X2 + Z2
    //     var a = this.x.redAdd(this.z);
    //     // B = X2 - Z2
    //     var b = this.x.redSub(this.z);
    //     // C = X3 + Z3
    //     var c = p.x.redAdd(p.z);
    //     // D = X3 - Z3
    //     var d = p.x.redSub(p.z);
    //     // DA = D * A
    //     var da = d.redMul(a);
    //     // CB = C * B
    //     var cb = c.redMul(b);
    //     // X5 = Z1 * (DA + CB)^2
    //     var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    //     // Z5 = X1 * (DA - CB)^2
    //     var nz = diff.x.redMul(da.redISub(cb).redSqr());
    //     return this.curve.point(nx, nz);
    //   };
    
    //   Point$1.prototype.mul = function mul(k) {
    //     var t = k.clone();
    //     var a = this; // (N / 2) * Q + Q
    //     var b = this.curve.point(null, null); // (N / 2) * Q
    //     var c = this; // Q
    
    //     for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    //       bits.push(t.andln(1));
    
    //     for (var i = bits.length - 1; i >= 0; i--) {
    //       if (bits[i] === 0) {
    //         // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
    //         a = a.diffAdd(b, c);
    //         // N * Q = 2 * ((N / 2) * Q + Q))
    //         b = b.dbl();
    //       } else {
    //         // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
    //         b = a.diffAdd(b, c);
    //         // N * Q + Q = 2 * ((N / 2) * Q + Q)
    //         a = a.dbl();
    //       }
    //     }
    //     return b;
    //   };
    
    //   Point$1.prototype.mulAdd = function mulAdd() {
    //     throw new Error('Not supported on Montgomery curve');
    //   };
    
    //   Point$1.prototype.jumlAdd = function jumlAdd() {
    //     throw new Error('Not supported on Montgomery curve');
    //   };
    
    //   Point$1.prototype.eq = function eq(other) {
    //     return this.getX().cmp(other.getX()) === 0;
    //   };
    
    //   Point$1.prototype.normalize = function normalize() {
    //     this.x = this.x.redMul(this.z.redInvm());
    //     this.z = this.curve.one;
    //     return this;
    //   };
    
    //   Point$1.prototype.getX = function getX() {
    //     // Normalize coordinates
    //     this.normalize();
    
    //     return this.x.fromRed();
    //   };
    
    //   var utils$h = utils$m;
    //   var BN$5 = bn.exports;
    //   var inherits$1 = inherits_browser$1.exports;
    //   var Base = base;
    
    //   var assert$d = utils$h.assert;
    
    //   function EdwardsCurve(conf) {
    //     // NOTE: Important as we are creating point in Base.call()
    //     this.twisted = (conf.a | 0) !== 1;
    //     this.mOneA = this.twisted && (conf.a | 0) === -1;
    //     this.extended = this.mOneA;
    
    //     Base.call(this, 'edwards', conf);
    
    //     this.a = new BN$5(conf.a, 16).umod(this.red.m);
    //     this.a = this.a.toRed(this.red);
    //     this.c = new BN$5(conf.c, 16).toRed(this.red);
    //     this.c2 = this.c.redSqr();
    //     this.d = new BN$5(conf.d, 16).toRed(this.red);
    //     this.dd = this.d.redAdd(this.d);
    
    //     assert$d(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    //     this.oneC = (conf.c | 0) === 1;
    //   }
    //   inherits$1(EdwardsCurve, Base);
    //   var edwards = EdwardsCurve;
    
    //   EdwardsCurve.prototype._mulA = function _mulA(num) {
    //     if (this.mOneA)
    //       return num.redNeg();
    //     else
    //       return this.a.redMul(num);
    //   };
    
    //   EdwardsCurve.prototype._mulC = function _mulC(num) {
    //     if (this.oneC)
    //       return num;
    //     else
    //       return this.c.redMul(num);
    //   };
    
    //   // Just for compatibility with Short curve
    //   EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    //     return this.point(x, y, z, t);
    //   };
    
    //   EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    //     x = new BN$5(x, 16);
    //     if (!x.red)
    //       x = x.toRed(this.red);
    
    //     var x2 = x.redSqr();
    //     var rhs = this.c2.redSub(this.a.redMul(x2));
    //     var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    
    //     var y2 = rhs.redMul(lhs.redInvm());
    //     var y = y2.redSqrt();
    //     if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    //       throw new Error('invalid point');
    
    //     var isOdd = y.fromRed().isOdd();
    //     if (odd && !isOdd || !odd && isOdd)
    //       y = y.redNeg();
    
    //     return this.point(x, y);
    //   };
    
    //   EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    //     y = new BN$5(y, 16);
    //     if (!y.red)
    //       y = y.toRed(this.red);
    
    //     // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
    //     var y2 = y.redSqr();
    //     var lhs = y2.redSub(this.c2);
    //     var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
    //     var x2 = lhs.redMul(rhs.redInvm());
    
    //     if (x2.cmp(this.zero) === 0) {
    //       if (odd)
    //         throw new Error('invalid point');
    //       else
    //         return this.point(this.zero, y);
    //     }
    
    //     var x = x2.redSqrt();
    //     if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    //       throw new Error('invalid point');
    
    //     if (x.fromRed().isOdd() !== odd)
    //       x = x.redNeg();
    
    //     return this.point(x, y);
    //   };
    
    //   EdwardsCurve.prototype.validate = function validate(point) {
    //     if (point.isInfinity())
    //       return true;
    
    //     // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
    //     point.normalize();
    
    //     var x2 = point.x.redSqr();
    //     var y2 = point.y.redSqr();
    //     var lhs = x2.redMul(this.a).redAdd(y2);
    //     var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
    
    //     return lhs.cmp(rhs) === 0;
    //   };
    
    //   function Point(curve, x, y, z, t) {
    //     Base.BasePoint.call(this, curve, 'projective');
    //     if (x === null && y === null && z === null) {
    //       this.x = this.curve.zero;
    //       this.y = this.curve.one;
    //       this.z = this.curve.one;
    //       this.t = this.curve.zero;
    //       this.zOne = true;
    //     } else {
    //       this.x = new BN$5(x, 16);
    //       this.y = new BN$5(y, 16);
    //       this.z = z ? new BN$5(z, 16) : this.curve.one;
    //       this.t = t && new BN$5(t, 16);
    //       if (!this.x.red)
    //         this.x = this.x.toRed(this.curve.red);
    //       if (!this.y.red)
    //         this.y = this.y.toRed(this.curve.red);
    //       if (!this.z.red)
    //         this.z = this.z.toRed(this.curve.red);
    //       if (this.t && !this.t.red)
    //         this.t = this.t.toRed(this.curve.red);
    //       this.zOne = this.z === this.curve.one;
    
    //       // Use extended coordinates
    //       if (this.curve.extended && !this.t) {
    //         this.t = this.x.redMul(this.y);
    //         if (!this.zOne)
    //           this.t = this.t.redMul(this.z.redInvm());
    //       }
    //     }
    //   }
    //   inherits$1(Point, Base.BasePoint);
    
    //   EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    //     return Point.fromJSON(this, obj);
    //   };
    
    //   EdwardsCurve.prototype.point = function point(x, y, z, t) {
    //     return new Point(this, x, y, z, t);
    //   };
    
    //   Point.fromJSON = function fromJSON(curve, obj) {
    //     return new Point(curve, obj[0], obj[1], obj[2]);
    //   };
    
    //   Point.prototype.inspect = function inspect() {
    //     if (this.isInfinity())
    //       return '<EC Point Infinity>';
    //     return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
    //         ' y: ' + this.y.fromRed().toString(16, 2) +
    //         ' z: ' + this.z.fromRed().toString(16, 2) + '>';
    //   };
    
    //   Point.prototype.isInfinity = function isInfinity() {
    //     // XXX This code assumes that zero is always zero in red
    //     return this.x.cmpn(0) === 0 &&
    //       (this.y.cmp(this.z) === 0 ||
    //       (this.zOne && this.y.cmp(this.curve.c) === 0));
    //   };
    
    //   Point.prototype._extDbl = function _extDbl() {
    //     // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     //     #doubling-dbl-2008-hwcd
    //     // 4M + 4S
    
    //     // A = X1^2
    //     var a = this.x.redSqr();
    //     // B = Y1^2
    //     var b = this.y.redSqr();
    //     // C = 2 * Z1^2
    //     var c = this.z.redSqr();
    //     c = c.redIAdd(c);
    //     // D = a * A
    //     var d = this.curve._mulA(a);
    //     // E = (X1 + Y1)^2 - A - B
    //     var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    //     // G = D + B
    //     var g = d.redAdd(b);
    //     // F = G - C
    //     var f = g.redSub(c);
    //     // H = D - B
    //     var h = d.redSub(b);
    //     // X3 = E * F
    //     var nx = e.redMul(f);
    //     // Y3 = G * H
    //     var ny = g.redMul(h);
    //     // T3 = E * H
    //     var nt = e.redMul(h);
    //     // Z3 = F * G
    //     var nz = f.redMul(g);
    //     return this.curve.point(nx, ny, nz, nt);
    //   };
    
    //   Point.prototype._projDbl = function _projDbl() {
    //     // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     //     #doubling-dbl-2008-bbjlp
    //     //     #doubling-dbl-2007-bl
    //     // and others
    //     // Generally 3M + 4S or 2M + 4S
    
    //     // B = (X1 + Y1)^2
    //     var b = this.x.redAdd(this.y).redSqr();
    //     // C = X1^2
    //     var c = this.x.redSqr();
    //     // D = Y1^2
    //     var d = this.y.redSqr();
    
    //     var nx;
    //     var ny;
    //     var nz;
    //     var e;
    //     var h;
    //     var j;
    //     if (this.curve.twisted) {
    //       // E = a * C
    //       e = this.curve._mulA(c);
    //       // F = E + D
    //       var f = e.redAdd(d);
    //       if (this.zOne) {
    //         // X3 = (B - C - D) * (F - 2)
    //         nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
    //         // Y3 = F * (E - D)
    //         ny = f.redMul(e.redSub(d));
    //         // Z3 = F^2 - 2 * F
    //         nz = f.redSqr().redSub(f).redSub(f);
    //       } else {
    //         // H = Z1^2
    //         h = this.z.redSqr();
    //         // J = F - 2 * H
    //         j = f.redSub(h).redISub(h);
    //         // X3 = (B-C-D)*J
    //         nx = b.redSub(c).redISub(d).redMul(j);
    //         // Y3 = F * (E - D)
    //         ny = f.redMul(e.redSub(d));
    //         // Z3 = F * J
    //         nz = f.redMul(j);
    //       }
    //     } else {
    //       // E = C + D
    //       e = c.redAdd(d);
    //       // H = (c * Z1)^2
    //       h = this.curve._mulC(this.z).redSqr();
    //       // J = E - 2 * H
    //       j = e.redSub(h).redSub(h);
    //       // X3 = c * (B - E) * J
    //       nx = this.curve._mulC(b.redISub(e)).redMul(j);
    //       // Y3 = c * E * (C - D)
    //       ny = this.curve._mulC(e).redMul(c.redISub(d));
    //       // Z3 = E * J
    //       nz = e.redMul(j);
    //     }
    //     return this.curve.point(nx, ny, nz);
    //   };
    
    //   Point.prototype.dbl = function dbl() {
    //     if (this.isInfinity())
    //       return this;
    
    //     // Double in extended coordinates
    //     if (this.curve.extended)
    //       return this._extDbl();
    //     else
    //       return this._projDbl();
    //   };
    
    //   Point.prototype._extAdd = function _extAdd(p) {
    //     // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     //     #addition-add-2008-hwcd-3
    //     // 8M
    
    //     // A = (Y1 - X1) * (Y2 - X2)
    //     var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    //     // B = (Y1 + X1) * (Y2 + X2)
    //     var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    //     // C = T1 * k * T2
    //     var c = this.t.redMul(this.curve.dd).redMul(p.t);
    //     // D = Z1 * 2 * Z2
    //     var d = this.z.redMul(p.z.redAdd(p.z));
    //     // E = B - A
    //     var e = b.redSub(a);
    //     // F = D - C
    //     var f = d.redSub(c);
    //     // G = D + C
    //     var g = d.redAdd(c);
    //     // H = B + A
    //     var h = b.redAdd(a);
    //     // X3 = E * F
    //     var nx = e.redMul(f);
    //     // Y3 = G * H
    //     var ny = g.redMul(h);
    //     // T3 = E * H
    //     var nt = e.redMul(h);
    //     // Z3 = F * G
    //     var nz = f.redMul(g);
    //     return this.curve.point(nx, ny, nz, nt);
    //   };
    
    //   Point.prototype._projAdd = function _projAdd(p) {
    //     // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     //     #addition-add-2008-bbjlp
    //     //     #addition-add-2007-bl
    //     // 10M + 1S
    
    //     // A = Z1 * Z2
    //     var a = this.z.redMul(p.z);
    //     // B = A^2
    //     var b = a.redSqr();
    //     // C = X1 * X2
    //     var c = this.x.redMul(p.x);
    //     // D = Y1 * Y2
    //     var d = this.y.redMul(p.y);
    //     // E = d * C * D
    //     var e = this.curve.d.redMul(c).redMul(d);
    //     // F = B - E
    //     var f = b.redSub(e);
    //     // G = B + E
    //     var g = b.redAdd(e);
    //     // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
    //     var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    //     var nx = a.redMul(f).redMul(tmp);
    //     var ny;
    //     var nz;
    //     if (this.curve.twisted) {
    //       // Y3 = A * G * (D - a * C)
    //       ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    //       // Z3 = F * G
    //       nz = f.redMul(g);
    //     } else {
    //       // Y3 = A * G * (D - C)
    //       ny = a.redMul(g).redMul(d.redSub(c));
    //       // Z3 = c * F * G
    //       nz = this.curve._mulC(f).redMul(g);
    //     }
    //     return this.curve.point(nx, ny, nz);
    //   };
    
    //   Point.prototype.add = function add(p) {
    //     if (this.isInfinity())
    //       return p;
    //     if (p.isInfinity())
    //       return this;
    
    //     if (this.curve.extended)
    //       return this._extAdd(p);
    //     else
    //       return this._projAdd(p);
    //   };
    
    //   Point.prototype.mul = function mul(k) {
    //     if (this._hasDoubles(k))
    //       return this.curve._fixedNafMul(this, k);
    //     else
    //       return this.curve._wnafMul(this, k);
    //   };
    
    //   Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    //     return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
    //   };
    
    //   Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    //     return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
    //   };
    
    //   Point.prototype.normalize = function normalize() {
    //     if (this.zOne)
    //       return this;
    
    //     // Normalize coordinates
    //     var zi = this.z.redInvm();
    //     this.x = this.x.redMul(zi);
    //     this.y = this.y.redMul(zi);
    //     if (this.t)
    //       this.t = this.t.redMul(zi);
    //     this.z = this.curve.one;
    //     this.zOne = true;
    //     return this;
    //   };
    
    //   Point.prototype.neg = function neg() {
    //     return this.curve.point(this.x.redNeg(),
    //       this.y,
    //       this.z,
    //       this.t && this.t.redNeg());
    //   };
    
    //   Point.prototype.getX = function getX() {
    //     this.normalize();
    //     return this.x.fromRed();
    //   };
    
    //   Point.prototype.getY = function getY() {
    //     this.normalize();
    //     return this.y.fromRed();
    //   };
    
    //   Point.prototype.eq = function eq(other) {
    //     return this === other ||
    //            this.getX().cmp(other.getX()) === 0 &&
    //            this.getY().cmp(other.getY()) === 0;
    //   };
    
    //   Point.prototype.eqXToP = function eqXToP(x) {
    //     var rx = x.toRed(this.curve.red).redMul(this.z);
    //     if (this.x.cmp(rx) === 0)
    //       return true;
    
    //     var xc = x.clone();
    //     var t = this.curve.redN.redMul(this.z);
    //     for (;;) {
    //       xc.iadd(this.curve.n);
    //       if (xc.cmp(this.curve.p) >= 0)
    //         return false;
    
    //       rx.redIAdd(t);
    //       if (this.x.cmp(rx) === 0)
    //         return true;
    //     }
    //   };
    
    //   // Compatibility with BaseCurve
    //   Point.prototype.toP = Point.prototype.normalize;
    //   Point.prototype.mixedAdd = Point.prototype.add;
    
    //   (function (exports) {
    
    //   var curve = exports;
    
    //   curve.base = base;
    //   curve.short = short;
    //   curve.mont = mont;
    //   curve.edwards = edwards;
    //   }(curve));
    
    //   var curves$2 = {};
    
    //   var hash$2 = {};
    
    //   var utils$g = {};
    
    //   var inherits_browser = {exports: {}};
    
    //   if (typeof Object.create === 'function') {
    //     // implementation from standard node.js 'util' module
    //     inherits_browser.exports = function inherits(ctor, superCtor) {
    //       ctor.super_ = superCtor;
    //       ctor.prototype = Object.create(superCtor.prototype, {
    //         constructor: {
    //           value: ctor,
    //           enumerable: false,
    //           writable: true,
    //           configurable: true
    //         }
    //       });
    //     };
    //   } else {
    //     // old school shim for old browsers
    //     inherits_browser.exports = function inherits(ctor, superCtor) {
    //       ctor.super_ = superCtor;
    //       var TempCtor = function () {};
    //       TempCtor.prototype = superCtor.prototype;
    //       ctor.prototype = new TempCtor();
    //       ctor.prototype.constructor = ctor;
    //     };
    //   }
    
    //   var assert$c = minimalisticAssert;
    //   var inherits = inherits_browser.exports;
    
    //   utils$g.inherits = inherits;
    
    //   function isSurrogatePair(msg, i) {
    //     if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    //       return false;
    //     }
    //     if (i < 0 || i + 1 >= msg.length) {
    //       return false;
    //     }
    //     return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
    //   }
    
    //   function toArray(msg, enc) {
    //     if (Array.isArray(msg))
    //       return msg.slice();
    //     if (!msg)
    //       return [];
    //     var res = [];
    //     if (typeof msg === 'string') {
    //       if (!enc) {
    //         // Inspired by stringToUtf8ByteArray() in closure-library by Google
    //         // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
    //         // Apache License 2.0
    //         // https://github.com/google/closure-library/blob/master/LICENSE
    //         var p = 0;
    //         for (var i = 0; i < msg.length; i++) {
    //           var c = msg.charCodeAt(i);
    //           if (c < 128) {
    //             res[p++] = c;
    //           } else if (c < 2048) {
    //             res[p++] = (c >> 6) | 192;
    //             res[p++] = (c & 63) | 128;
    //           } else if (isSurrogatePair(msg, i)) {
    //             c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
    //             res[p++] = (c >> 18) | 240;
    //             res[p++] = ((c >> 12) & 63) | 128;
    //             res[p++] = ((c >> 6) & 63) | 128;
    //             res[p++] = (c & 63) | 128;
    //           } else {
    //             res[p++] = (c >> 12) | 224;
    //             res[p++] = ((c >> 6) & 63) | 128;
    //             res[p++] = (c & 63) | 128;
    //           }
    //         }
    //       } else if (enc === 'hex') {
    //         msg = msg.replace(/[^a-z0-9]+/ig, '');
    //         if (msg.length % 2 !== 0)
    //           msg = '0' + msg;
    //         for (i = 0; i < msg.length; i += 2)
    //           res.push(parseInt(msg[i] + msg[i + 1], 16));
    //       }
    //     } else {
    //       for (i = 0; i < msg.length; i++)
    //         res[i] = msg[i] | 0;
    //     }
    //     return res;
    //   }
    //   utils$g.toArray = toArray;
    
    //   function toHex(msg) {
    //     var res = '';
    //     for (var i = 0; i < msg.length; i++)
    //       res += zero2(msg[i].toString(16));
    //     return res;
    //   }
    //   utils$g.toHex = toHex;
    
    //   function htonl(w) {
    //     var res = (w >>> 24) |
    //               ((w >>> 8) & 0xff00) |
    //               ((w << 8) & 0xff0000) |
    //               ((w & 0xff) << 24);
    //     return res >>> 0;
    //   }
    //   utils$g.htonl = htonl;
    
    //   function toHex32(msg, endian) {
    //     var res = '';
    //     for (var i = 0; i < msg.length; i++) {
    //       var w = msg[i];
    //       if (endian === 'little')
    //         w = htonl(w);
    //       res += zero8(w.toString(16));
    //     }
    //     return res;
    //   }
    //   utils$g.toHex32 = toHex32;
    
    //   function zero2(word) {
    //     if (word.length === 1)
    //       return '0' + word;
    //     else
    //       return word;
    //   }
    //   utils$g.zero2 = zero2;
    
    //   function zero8(word) {
    //     if (word.length === 7)
    //       return '0' + word;
    //     else if (word.length === 6)
    //       return '00' + word;
    //     else if (word.length === 5)
    //       return '000' + word;
    //     else if (word.length === 4)
    //       return '0000' + word;
    //     else if (word.length === 3)
    //       return '00000' + word;
    //     else if (word.length === 2)
    //       return '000000' + word;
    //     else if (word.length === 1)
    //       return '0000000' + word;
    //     else
    //       return word;
    //   }
    //   utils$g.zero8 = zero8;
    
    //   function join32(msg, start, end, endian) {
    //     var len = end - start;
    //     assert$c(len % 4 === 0);
    //     var res = new Array(len / 4);
    //     for (var i = 0, k = start; i < res.length; i++, k += 4) {
    //       var w;
    //       if (endian === 'big')
    //         w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    //       else
    //         w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    //       res[i] = w >>> 0;
    //     }
    //     return res;
    //   }
    //   utils$g.join32 = join32;
    
    //   function split32(msg, endian) {
    //     var res = new Array(msg.length * 4);
    //     for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    //       var m = msg[i];
    //       if (endian === 'big') {
    //         res[k] = m >>> 24;
    //         res[k + 1] = (m >>> 16) & 0xff;
    //         res[k + 2] = (m >>> 8) & 0xff;
    //         res[k + 3] = m & 0xff;
    //       } else {
    //         res[k + 3] = m >>> 24;
    //         res[k + 2] = (m >>> 16) & 0xff;
    //         res[k + 1] = (m >>> 8) & 0xff;
    //         res[k] = m & 0xff;
    //       }
    //     }
    //     return res;
    //   }
    //   utils$g.split32 = split32;
    
    //   function rotr32$1(w, b) {
    //     return (w >>> b) | (w << (32 - b));
    //   }
    //   utils$g.rotr32 = rotr32$1;
    
    //   function rotl32$2(w, b) {
    //     return (w << b) | (w >>> (32 - b));
    //   }
    //   utils$g.rotl32 = rotl32$2;
    
    //   function sum32$3(a, b) {
    //     return (a + b) >>> 0;
    //   }
    //   utils$g.sum32 = sum32$3;
    
    //   function sum32_3$1(a, b, c) {
    //     return (a + b + c) >>> 0;
    //   }
    //   utils$g.sum32_3 = sum32_3$1;
    
    //   function sum32_4$2(a, b, c, d) {
    //     return (a + b + c + d) >>> 0;
    //   }
    //   utils$g.sum32_4 = sum32_4$2;
    
    //   function sum32_5$2(a, b, c, d, e) {
    //     return (a + b + c + d + e) >>> 0;
    //   }
    //   utils$g.sum32_5 = sum32_5$2;
    
    //   function sum64$1(buf, pos, ah, al) {
    //     var bh = buf[pos];
    //     var bl = buf[pos + 1];
    
    //     var lo = (al + bl) >>> 0;
    //     var hi = (lo < al ? 1 : 0) + ah + bh;
    //     buf[pos] = hi >>> 0;
    //     buf[pos + 1] = lo;
    //   }
    //   utils$g.sum64 = sum64$1;
    
    //   function sum64_hi$1(ah, al, bh, bl) {
    //     var lo = (al + bl) >>> 0;
    //     var hi = (lo < al ? 1 : 0) + ah + bh;
    //     return hi >>> 0;
    //   }
    //   utils$g.sum64_hi = sum64_hi$1;
    
    //   function sum64_lo$1(ah, al, bh, bl) {
    //     var lo = al + bl;
    //     return lo >>> 0;
    //   }
    //   utils$g.sum64_lo = sum64_lo$1;
    
    //   function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
    //     var carry = 0;
    //     var lo = al;
    //     lo = (lo + bl) >>> 0;
    //     carry += lo < al ? 1 : 0;
    //     lo = (lo + cl) >>> 0;
    //     carry += lo < cl ? 1 : 0;
    //     lo = (lo + dl) >>> 0;
    //     carry += lo < dl ? 1 : 0;
    
    //     var hi = ah + bh + ch + dh + carry;
    //     return hi >>> 0;
    //   }
    //   utils$g.sum64_4_hi = sum64_4_hi$1;
    
    //   function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
    //     var lo = al + bl + cl + dl;
    //     return lo >>> 0;
    //   }
    //   utils$g.sum64_4_lo = sum64_4_lo$1;
    
    //   function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    //     var carry = 0;
    //     var lo = al;
    //     lo = (lo + bl) >>> 0;
    //     carry += lo < al ? 1 : 0;
    //     lo = (lo + cl) >>> 0;
    //     carry += lo < cl ? 1 : 0;
    //     lo = (lo + dl) >>> 0;
    //     carry += lo < dl ? 1 : 0;
    //     lo = (lo + el) >>> 0;
    //     carry += lo < el ? 1 : 0;
    
    //     var hi = ah + bh + ch + dh + eh + carry;
    //     return hi >>> 0;
    //   }
    //   utils$g.sum64_5_hi = sum64_5_hi$1;
    
    //   function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    //     var lo = al + bl + cl + dl + el;
    
    //     return lo >>> 0;
    //   }
    //   utils$g.sum64_5_lo = sum64_5_lo$1;
    
    //   function rotr64_hi$1(ah, al, num) {
    //     var r = (al << (32 - num)) | (ah >>> num);
    //     return r >>> 0;
    //   }
    //   utils$g.rotr64_hi = rotr64_hi$1;
    
    //   function rotr64_lo$1(ah, al, num) {
    //     var r = (ah << (32 - num)) | (al >>> num);
    //     return r >>> 0;
    //   }
    //   utils$g.rotr64_lo = rotr64_lo$1;
    
    //   function shr64_hi$1(ah, al, num) {
    //     return ah >>> num;
    //   }
    //   utils$g.shr64_hi = shr64_hi$1;
    
    //   function shr64_lo$1(ah, al, num) {
    //     var r = (ah << (32 - num)) | (al >>> num);
    //     return r >>> 0;
    //   }
    //   utils$g.shr64_lo = shr64_lo$1;
    
    //   var common$5 = {};
    
    //   var utils$f = utils$g;
    //   var assert$b = minimalisticAssert;
    
    //   function BlockHash$4() {
    //     this.pending = null;
    //     this.pendingTotal = 0;
    //     this.blockSize = this.constructor.blockSize;
    //     this.outSize = this.constructor.outSize;
    //     this.hmacStrength = this.constructor.hmacStrength;
    //     this.padLength = this.constructor.padLength / 8;
    //     this.endian = 'big';
    
    //     this._delta8 = this.blockSize / 8;
    //     this._delta32 = this.blockSize / 32;
    //   }
    //   common$5.BlockHash = BlockHash$4;
    
    //   BlockHash$4.prototype.update = function update(msg, enc) {
    //     // Convert message to array, pad it, and join into 32bit blocks
    //     msg = utils$f.toArray(msg, enc);
    //     if (!this.pending)
    //       this.pending = msg;
    //     else
    //       this.pending = this.pending.concat(msg);
    //     this.pendingTotal += msg.length;
    
    //     // Enough data, try updating
    //     if (this.pending.length >= this._delta8) {
    //       msg = this.pending;
    
    //       // Process pending data in blocks
    //       var r = msg.length % this._delta8;
    //       this.pending = msg.slice(msg.length - r, msg.length);
    //       if (this.pending.length === 0)
    //         this.pending = null;
    
    //       msg = utils$f.join32(msg, 0, msg.length - r, this.endian);
    //       for (var i = 0; i < msg.length; i += this._delta32)
    //         this._update(msg, i, i + this._delta32);
    //     }
    
    //     return this;
    //   };
    
    //   BlockHash$4.prototype.digest = function digest(enc) {
    //     this.update(this._pad());
    //     assert$b(this.pending === null);
    
    //     return this._digest(enc);
    //   };
    
    //   BlockHash$4.prototype._pad = function pad() {
    //     var len = this.pendingTotal;
    //     var bytes = this._delta8;
    //     var k = bytes - ((len + this.padLength) % bytes);
    //     var res = new Array(k + this.padLength);
    //     res[0] = 0x80;
    //     for (var i = 1; i < k; i++)
    //       res[i] = 0;
    
    //     // Append length
    //     len <<= 3;
    //     if (this.endian === 'big') {
    //       for (var t = 8; t < this.padLength; t++)
    //         res[i++] = 0;
    
    //       res[i++] = 0;
    //       res[i++] = 0;
    //       res[i++] = 0;
    //       res[i++] = 0;
    //       res[i++] = (len >>> 24) & 0xff;
    //       res[i++] = (len >>> 16) & 0xff;
    //       res[i++] = (len >>> 8) & 0xff;
    //       res[i++] = len & 0xff;
    //     } else {
    //       res[i++] = len & 0xff;
    //       res[i++] = (len >>> 8) & 0xff;
    //       res[i++] = (len >>> 16) & 0xff;
    //       res[i++] = (len >>> 24) & 0xff;
    //       res[i++] = 0;
    //       res[i++] = 0;
    //       res[i++] = 0;
    //       res[i++] = 0;
    
    //       for (t = 8; t < this.padLength; t++)
    //         res[i++] = 0;
    //     }
    
    //     return res;
    //   };
    
    //   var sha = {};
    
    //   var common$4 = {};
    
    //   var utils$e = utils$g;
    //   var rotr32 = utils$e.rotr32;
    
    //   function ft_1$1(s, x, y, z) {
    //     if (s === 0)
    //       return ch32$1(x, y, z);
    //     if (s === 1 || s === 3)
    //       return p32(x, y, z);
    //     if (s === 2)
    //       return maj32$1(x, y, z);
    //   }
    //   common$4.ft_1 = ft_1$1;
    
    //   function ch32$1(x, y, z) {
    //     return (x & y) ^ ((~x) & z);
    //   }
    //   common$4.ch32 = ch32$1;
    
    //   function maj32$1(x, y, z) {
    //     return (x & y) ^ (x & z) ^ (y & z);
    //   }
    //   common$4.maj32 = maj32$1;
    
    //   function p32(x, y, z) {
    //     return x ^ y ^ z;
    //   }
    //   common$4.p32 = p32;
    
    //   function s0_256$1(x) {
    //     return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    //   }
    //   common$4.s0_256 = s0_256$1;
    
    //   function s1_256$1(x) {
    //     return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    //   }
    //   common$4.s1_256 = s1_256$1;
    
    //   function g0_256$1(x) {
    //     return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
    //   }
    //   common$4.g0_256 = g0_256$1;
    
    //   function g1_256$1(x) {
    //     return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
    //   }
    //   common$4.g1_256 = g1_256$1;
    
    //   var utils$d = utils$g;
    //   var common$3 = common$5;
    //   var shaCommon$1 = common$4;
    
    //   var rotl32$1 = utils$d.rotl32;
    //   var sum32$2 = utils$d.sum32;
    //   var sum32_5$1 = utils$d.sum32_5;
    //   var ft_1 = shaCommon$1.ft_1;
    //   var BlockHash$3 = common$3.BlockHash;
    
    //   var sha1_K = [
    //     0x5A827999, 0x6ED9EBA1,
    //     0x8F1BBCDC, 0xCA62C1D6
    //   ];
    
    //   function SHA1() {
    //     if (!(this instanceof SHA1))
    //       return new SHA1();
    
    //     BlockHash$3.call(this);
    //     this.h = [
    //       0x67452301, 0xefcdab89, 0x98badcfe,
    //       0x10325476, 0xc3d2e1f0 ];
    //     this.W = new Array(80);
    //   }
    
    //   utils$d.inherits(SHA1, BlockHash$3);
    //   var _1 = SHA1;
    
    //   SHA1.blockSize = 512;
    //   SHA1.outSize = 160;
    //   SHA1.hmacStrength = 80;
    //   SHA1.padLength = 64;
    
    //   SHA1.prototype._update = function _update(msg, start) {
    //     var W = this.W;
    
    //     for (var i = 0; i < 16; i++)
    //       W[i] = msg[start + i];
    
    //     for(; i < W.length; i++)
    //       W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    
    //     var a = this.h[0];
    //     var b = this.h[1];
    //     var c = this.h[2];
    //     var d = this.h[3];
    //     var e = this.h[4];
    
    //     for (i = 0; i < W.length; i++) {
    //       var s = ~~(i / 20);
    //       var t = sum32_5$1(rotl32$1(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    //       e = d;
    //       d = c;
    //       c = rotl32$1(b, 30);
    //       b = a;
    //       a = t;
    //     }
    
    //     this.h[0] = sum32$2(this.h[0], a);
    //     this.h[1] = sum32$2(this.h[1], b);
    //     this.h[2] = sum32$2(this.h[2], c);
    //     this.h[3] = sum32$2(this.h[3], d);
    //     this.h[4] = sum32$2(this.h[4], e);
    //   };
    
    //   SHA1.prototype._digest = function digest(enc) {
    //     if (enc === 'hex')
    //       return utils$d.toHex32(this.h, 'big');
    //     else
    //       return utils$d.split32(this.h, 'big');
    //   };
    
    //   var utils$c = utils$g;
    //   var common$2 = common$5;
    //   var shaCommon = common$4;
    //   var assert$a = minimalisticAssert;
    
    //   var sum32$1 = utils$c.sum32;
    //   var sum32_4$1 = utils$c.sum32_4;
    //   var sum32_5 = utils$c.sum32_5;
    //   var ch32 = shaCommon.ch32;
    //   var maj32 = shaCommon.maj32;
    //   var s0_256 = shaCommon.s0_256;
    //   var s1_256 = shaCommon.s1_256;
    //   var g0_256 = shaCommon.g0_256;
    //   var g1_256 = shaCommon.g1_256;
    
    //   var BlockHash$2 = common$2.BlockHash;
    
    //   var sha256_K = [
    //     0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    //     0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    //     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    //     0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    //     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    //     0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    //     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    //     0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    //     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    //     0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    //     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    //     0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    //     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    //     0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    //     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    //     0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    //   ];
    
    //   function SHA256$1() {
    //     if (!(this instanceof SHA256$1))
    //       return new SHA256$1();
    
    //     BlockHash$2.call(this);
    //     this.h = [
    //       0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    //       0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    //     ];
    //     this.k = sha256_K;
    //     this.W = new Array(64);
    //   }
    //   utils$c.inherits(SHA256$1, BlockHash$2);
    //   var _256 = SHA256$1;
    
    //   SHA256$1.blockSize = 512;
    //   SHA256$1.outSize = 256;
    //   SHA256$1.hmacStrength = 192;
    //   SHA256$1.padLength = 64;
    
    //   SHA256$1.prototype._update = function _update(msg, start) {
    //     var W = this.W;
    
    //     for (var i = 0; i < 16; i++)
    //       W[i] = msg[start + i];
    //     for (; i < W.length; i++)
    //       W[i] = sum32_4$1(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    
    //     var a = this.h[0];
    //     var b = this.h[1];
    //     var c = this.h[2];
    //     var d = this.h[3];
    //     var e = this.h[4];
    //     var f = this.h[5];
    //     var g = this.h[6];
    //     var h = this.h[7];
    
    //     assert$a(this.k.length === W.length);
    //     for (i = 0; i < W.length; i++) {
    //       var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    //       var T2 = sum32$1(s0_256(a), maj32(a, b, c));
    //       h = g;
    //       g = f;
    //       f = e;
    //       e = sum32$1(d, T1);
    //       d = c;
    //       c = b;
    //       b = a;
    //       a = sum32$1(T1, T2);
    //     }
    
    //     this.h[0] = sum32$1(this.h[0], a);
    //     this.h[1] = sum32$1(this.h[1], b);
    //     this.h[2] = sum32$1(this.h[2], c);
    //     this.h[3] = sum32$1(this.h[3], d);
    //     this.h[4] = sum32$1(this.h[4], e);
    //     this.h[5] = sum32$1(this.h[5], f);
    //     this.h[6] = sum32$1(this.h[6], g);
    //     this.h[7] = sum32$1(this.h[7], h);
    //   };
    
    //   SHA256$1.prototype._digest = function digest(enc) {
    //     if (enc === 'hex')
    //       return utils$c.toHex32(this.h, 'big');
    //     else
    //       return utils$c.split32(this.h, 'big');
    //   };
    
    //   var utils$b = utils$g;
    //   var SHA256 = _256;
    
    //   function SHA224() {
    //     if (!(this instanceof SHA224))
    //       return new SHA224();
    
    //     SHA256.call(this);
    //     this.h = [
    //       0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    //       0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
    //   }
    //   utils$b.inherits(SHA224, SHA256);
    //   var _224 = SHA224;
    
    //   SHA224.blockSize = 512;
    //   SHA224.outSize = 224;
    //   SHA224.hmacStrength = 192;
    //   SHA224.padLength = 64;
    
    //   SHA224.prototype._digest = function digest(enc) {
    //     // Just truncate output
    //     if (enc === 'hex')
    //       return utils$b.toHex32(this.h.slice(0, 7), 'big');
    //     else
    //       return utils$b.split32(this.h.slice(0, 7), 'big');
    //   };
    
    //   var utils$a = utils$g;
    //   var common$1 = common$5;
    //   var assert$9 = minimalisticAssert;
    
    //   var rotr64_hi = utils$a.rotr64_hi;
    //   var rotr64_lo = utils$a.rotr64_lo;
    //   var shr64_hi = utils$a.shr64_hi;
    //   var shr64_lo = utils$a.shr64_lo;
    //   var sum64 = utils$a.sum64;
    //   var sum64_hi = utils$a.sum64_hi;
    //   var sum64_lo = utils$a.sum64_lo;
    //   var sum64_4_hi = utils$a.sum64_4_hi;
    //   var sum64_4_lo = utils$a.sum64_4_lo;
    //   var sum64_5_hi = utils$a.sum64_5_hi;
    //   var sum64_5_lo = utils$a.sum64_5_lo;
    
    //   var BlockHash$1 = common$1.BlockHash;
    
    //   var sha512_K = [
    //     0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
    //     0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
    //     0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
    //     0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
    //     0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
    //     0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
    //     0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
    //     0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
    //     0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
    //     0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
    //     0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
    //     0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
    //     0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
    //     0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
    //     0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
    //     0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
    //     0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
    //     0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
    //     0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
    //     0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
    //     0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
    //     0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
    //     0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
    //     0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
    //     0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
    //     0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
    //     0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
    //     0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
    //     0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
    //     0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
    //     0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
    //     0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
    //     0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
    //     0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
    //     0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
    //     0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
    //     0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
    //     0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
    //     0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
    //     0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
    //   ];
    
    //   function SHA512$1() {
    //     if (!(this instanceof SHA512$1))
    //       return new SHA512$1();
    
    //     BlockHash$1.call(this);
    //     this.h = [
    //       0x6a09e667, 0xf3bcc908,
    //       0xbb67ae85, 0x84caa73b,
    //       0x3c6ef372, 0xfe94f82b,
    //       0xa54ff53a, 0x5f1d36f1,
    //       0x510e527f, 0xade682d1,
    //       0x9b05688c, 0x2b3e6c1f,
    //       0x1f83d9ab, 0xfb41bd6b,
    //       0x5be0cd19, 0x137e2179 ];
    //     this.k = sha512_K;
    //     this.W = new Array(160);
    //   }
    //   utils$a.inherits(SHA512$1, BlockHash$1);
    //   var _512 = SHA512$1;
    
    //   SHA512$1.blockSize = 1024;
    //   SHA512$1.outSize = 512;
    //   SHA512$1.hmacStrength = 192;
    //   SHA512$1.padLength = 128;
    
    //   SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
    //     var W = this.W;
    
    //     // 32 x 32bit words
    //     for (var i = 0; i < 32; i++)
    //       W[i] = msg[start + i];
    //     for (; i < W.length; i += 2) {
    //       var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    //       var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    //       var c1_hi = W[i - 14];  // i - 7
    //       var c1_lo = W[i - 13];
    //       var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    //       var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    //       var c3_hi = W[i - 32];  // i - 16
    //       var c3_lo = W[i - 31];
    
    //       W[i] = sum64_4_hi(
    //         c0_hi, c0_lo,
    //         c1_hi, c1_lo,
    //         c2_hi, c2_lo,
    //         c3_hi, c3_lo);
    //       W[i + 1] = sum64_4_lo(
    //         c0_hi, c0_lo,
    //         c1_hi, c1_lo,
    //         c2_hi, c2_lo,
    //         c3_hi, c3_lo);
    //     }
    //   };
    
    //   SHA512$1.prototype._update = function _update(msg, start) {
    //     this._prepareBlock(msg, start);
    
    //     var W = this.W;
    
    //     var ah = this.h[0];
    //     var al = this.h[1];
    //     var bh = this.h[2];
    //     var bl = this.h[3];
    //     var ch = this.h[4];
    //     var cl = this.h[5];
    //     var dh = this.h[6];
    //     var dl = this.h[7];
    //     var eh = this.h[8];
    //     var el = this.h[9];
    //     var fh = this.h[10];
    //     var fl = this.h[11];
    //     var gh = this.h[12];
    //     var gl = this.h[13];
    //     var hh = this.h[14];
    //     var hl = this.h[15];
    
    //     assert$9(this.k.length === W.length);
    //     for (var i = 0; i < W.length; i += 2) {
    //       var c0_hi = hh;
    //       var c0_lo = hl;
    //       var c1_hi = s1_512_hi(eh, el);
    //       var c1_lo = s1_512_lo(eh, el);
    //       var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    //       var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    //       var c3_hi = this.k[i];
    //       var c3_lo = this.k[i + 1];
    //       var c4_hi = W[i];
    //       var c4_lo = W[i + 1];
    
    //       var T1_hi = sum64_5_hi(
    //         c0_hi, c0_lo,
    //         c1_hi, c1_lo,
    //         c2_hi, c2_lo,
    //         c3_hi, c3_lo,
    //         c4_hi, c4_lo);
    //       var T1_lo = sum64_5_lo(
    //         c0_hi, c0_lo,
    //         c1_hi, c1_lo,
    //         c2_hi, c2_lo,
    //         c3_hi, c3_lo,
    //         c4_hi, c4_lo);
    
    //       c0_hi = s0_512_hi(ah, al);
    //       c0_lo = s0_512_lo(ah, al);
    //       c1_hi = maj64_hi(ah, al, bh, bl, ch);
    //       c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
    
    //       var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    //       var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    
    //       hh = gh;
    //       hl = gl;
    
    //       gh = fh;
    //       gl = fl;
    
    //       fh = eh;
    //       fl = el;
    
    //       eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    //       el = sum64_lo(dl, dl, T1_hi, T1_lo);
    
    //       dh = ch;
    //       dl = cl;
    
    //       ch = bh;
    //       cl = bl;
    
    //       bh = ah;
    //       bl = al;
    
    //       ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    //       al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    //     }
    
    //     sum64(this.h, 0, ah, al);
    //     sum64(this.h, 2, bh, bl);
    //     sum64(this.h, 4, ch, cl);
    //     sum64(this.h, 6, dh, dl);
    //     sum64(this.h, 8, eh, el);
    //     sum64(this.h, 10, fh, fl);
    //     sum64(this.h, 12, gh, gl);
    //     sum64(this.h, 14, hh, hl);
    //   };
    
    //   SHA512$1.prototype._digest = function digest(enc) {
    //     if (enc === 'hex')
    //       return utils$a.toHex32(this.h, 'big');
    //     else
    //       return utils$a.split32(this.h, 'big');
    //   };
    
    //   function ch64_hi(xh, xl, yh, yl, zh) {
    //     var r = (xh & yh) ^ ((~xh) & zh);
    //     if (r < 0)
    //       r += 0x100000000;
    //     return r;
    //   }
    
    //   function ch64_lo(xh, xl, yh, yl, zh, zl) {
    //     var r = (xl & yl) ^ ((~xl) & zl);
    //     if (r < 0)
    //       r += 0x100000000;
    //     return r;
    //   }
    
    //   function maj64_hi(xh, xl, yh, yl, zh) {
    //     var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
    //     if (r < 0)
    //       r += 0x100000000;
    //     return r;
    //   }
    
    //   function maj64_lo(xh, xl, yh, yl, zh, zl) {
    //     var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
    //     if (r < 0)
    //       r += 0x100000000;
    //     return r;
    //   }
    
    //   function s0_512_hi(xh, xl) {
    //     var c0_hi = rotr64_hi(xh, xl, 28);
    //     var c1_hi = rotr64_hi(xl, xh, 2);  // 34
    //     var c2_hi = rotr64_hi(xl, xh, 7);  // 39
    
    //     var r = c0_hi ^ c1_hi ^ c2_hi;
    //     if (r < 0)
    //       r += 0x100000000;
    //     return r;
    //   }
    
    //   function s0_512_lo(xh, xl) {
    //     var c0_lo = rotr64_lo(xh, xl, 28);
    //     var c1_lo = rotr64_lo(xl, xh, 2);  // 34
    //     var c2_lo = rotr64_lo(xl, xh, 7);  // 39
    
    //     var r = c0_lo ^ c1_lo ^ c2_lo;
    //     if (r < 0)
    //       r += 0x100000000;
    //     return r;
    //   }
    
    //   function s1_512_hi(xh, xl) {
    //     var c0_hi = rotr64_hi(xh, xl, 14);
    //     var c1_hi = rotr64_hi(xh, xl, 18);
    //     var c2_hi = rotr64_hi(xl, xh, 9);  // 41
    
    //     var r = c0_hi ^ c1_hi ^ c2_hi;
    //     if (r < 0)
    //       r += 0x100000000;
    //     return r;
    //   }
    
    //   function s1_512_lo(xh, xl) {
    //     var c0_lo = rotr64_lo(xh, xl, 14);
    //     var c1_lo = rotr64_lo(xh, xl, 18);
    //     var c2_lo = rotr64_lo(xl, xh, 9);  // 41
    
    //     var r = c0_lo ^ c1_lo ^ c2_lo;
    //     if (r < 0)
    //       r += 0x100000000;
    //     return r;
    //   }
    
    //   function g0_512_hi(xh, xl) {
    //     var c0_hi = rotr64_hi(xh, xl, 1);
    //     var c1_hi = rotr64_hi(xh, xl, 8);
    //     var c2_hi = shr64_hi(xh, xl, 7);
    
    //     var r = c0_hi ^ c1_hi ^ c2_hi;
    //     if (r < 0)
    //       r += 0x100000000;
    //     return r;
    //   }
    
    //   function g0_512_lo(xh, xl) {
    //     var c0_lo = rotr64_lo(xh, xl, 1);
    //     var c1_lo = rotr64_lo(xh, xl, 8);
    //     var c2_lo = shr64_lo(xh, xl, 7);
    
    //     var r = c0_lo ^ c1_lo ^ c2_lo;
    //     if (r < 0)
    //       r += 0x100000000;
    //     return r;
    //   }
    
    //   function g1_512_hi(xh, xl) {
    //     var c0_hi = rotr64_hi(xh, xl, 19);
    //     var c1_hi = rotr64_hi(xl, xh, 29);  // 61
    //     var c2_hi = shr64_hi(xh, xl, 6);
    
    //     var r = c0_hi ^ c1_hi ^ c2_hi;
    //     if (r < 0)
    //       r += 0x100000000;
    //     return r;
    //   }
    
    //   function g1_512_lo(xh, xl) {
    //     var c0_lo = rotr64_lo(xh, xl, 19);
    //     var c1_lo = rotr64_lo(xl, xh, 29);  // 61
    //     var c2_lo = shr64_lo(xh, xl, 6);
    
    //     var r = c0_lo ^ c1_lo ^ c2_lo;
    //     if (r < 0)
    //       r += 0x100000000;
    //     return r;
    //   }
    
    //   var utils$9 = utils$g;
    
    //   var SHA512 = _512;
    
    //   function SHA384() {
    //     if (!(this instanceof SHA384))
    //       return new SHA384();
    
    //     SHA512.call(this);
    //     this.h = [
    //       0xcbbb9d5d, 0xc1059ed8,
    //       0x629a292a, 0x367cd507,
    //       0x9159015a, 0x3070dd17,
    //       0x152fecd8, 0xf70e5939,
    //       0x67332667, 0xffc00b31,
    //       0x8eb44a87, 0x68581511,
    //       0xdb0c2e0d, 0x64f98fa7,
    //       0x47b5481d, 0xbefa4fa4 ];
    //   }
    //   utils$9.inherits(SHA384, SHA512);
    //   var _384 = SHA384;
    
    //   SHA384.blockSize = 1024;
    //   SHA384.outSize = 384;
    //   SHA384.hmacStrength = 192;
    //   SHA384.padLength = 128;
    
    //   SHA384.prototype._digest = function digest(enc) {
    //     if (enc === 'hex')
    //       return utils$9.toHex32(this.h.slice(0, 12), 'big');
    //     else
    //       return utils$9.split32(this.h.slice(0, 12), 'big');
    //   };
    
    //   sha.sha1 = _1;
    //   sha.sha224 = _224;
    //   sha.sha256 = _256;
    //   sha.sha384 = _384;
    //   sha.sha512 = _512;
    
    //   var ripemd = {};
    
    //   var utils$8 = utils$g;
    //   var common = common$5;
    
    //   var rotl32 = utils$8.rotl32;
    //   var sum32 = utils$8.sum32;
    //   var sum32_3 = utils$8.sum32_3;
    //   var sum32_4 = utils$8.sum32_4;
    //   var BlockHash = common.BlockHash;
    
    //   function RIPEMD160() {
    //     if (!(this instanceof RIPEMD160))
    //       return new RIPEMD160();
    
    //     BlockHash.call(this);
    
    //     this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
    //     this.endian = 'little';
    //   }
    //   utils$8.inherits(RIPEMD160, BlockHash);
    //   ripemd.ripemd160 = RIPEMD160;
    
    //   RIPEMD160.blockSize = 512;
    //   RIPEMD160.outSize = 160;
    //   RIPEMD160.hmacStrength = 192;
    //   RIPEMD160.padLength = 64;
    
    //   RIPEMD160.prototype._update = function update(msg, start) {
    //     var A = this.h[0];
    //     var B = this.h[1];
    //     var C = this.h[2];
    //     var D = this.h[3];
    //     var E = this.h[4];
    //     var Ah = A;
    //     var Bh = B;
    //     var Ch = C;
    //     var Dh = D;
    //     var Eh = E;
    //     for (var j = 0; j < 80; j++) {
    //       var T = sum32(
    //         rotl32(
    //           sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
    //           s[j]),
    //         E);
    //       A = E;
    //       E = D;
    //       D = rotl32(C, 10);
    //       C = B;
    //       B = T;
    //       T = sum32(
    //         rotl32(
    //           sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
    //           sh[j]),
    //         Eh);
    //       Ah = Eh;
    //       Eh = Dh;
    //       Dh = rotl32(Ch, 10);
    //       Ch = Bh;
    //       Bh = T;
    //     }
    //     T = sum32_3(this.h[1], C, Dh);
    //     this.h[1] = sum32_3(this.h[2], D, Eh);
    //     this.h[2] = sum32_3(this.h[3], E, Ah);
    //     this.h[3] = sum32_3(this.h[4], A, Bh);
    //     this.h[4] = sum32_3(this.h[0], B, Ch);
    //     this.h[0] = T;
    //   };
    
    //   RIPEMD160.prototype._digest = function digest(enc) {
    //     if (enc === 'hex')
    //       return utils$8.toHex32(this.h, 'little');
    //     else
    //       return utils$8.split32(this.h, 'little');
    //   };
    
    //   function f(j, x, y, z) {
    //     if (j <= 15)
    //       return x ^ y ^ z;
    //     else if (j <= 31)
    //       return (x & y) | ((~x) & z);
    //     else if (j <= 47)
    //       return (x | (~y)) ^ z;
    //     else if (j <= 63)
    //       return (x & z) | (y & (~z));
    //     else
    //       return x ^ (y | (~z));
    //   }
    
    //   function K(j) {
    //     if (j <= 15)
    //       return 0x00000000;
    //     else if (j <= 31)
    //       return 0x5a827999;
    //     else if (j <= 47)
    //       return 0x6ed9eba1;
    //     else if (j <= 63)
    //       return 0x8f1bbcdc;
    //     else
    //       return 0xa953fd4e;
    //   }
    
    //   function Kh(j) {
    //     if (j <= 15)
    //       return 0x50a28be6;
    //     else if (j <= 31)
    //       return 0x5c4dd124;
    //     else if (j <= 47)
    //       return 0x6d703ef3;
    //     else if (j <= 63)
    //       return 0x7a6d76e9;
    //     else
    //       return 0x00000000;
    //   }
    
    //   var r = [
    //     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    //     7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
    //     3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
    //     1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
    //     4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
    //   ];
    
    //   var rh = [
    //     5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
    //     6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
    //     15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
    //     8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
    //     12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
    //   ];
    
    //   var s = [
    //     11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
    //     7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
    //     11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
    //     11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
    //     9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
    //   ];
    
    //   var sh = [
    //     8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
    //     9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
    //     9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
    //     15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
    //     8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
    //   ];
    
    //   var utils$7 = utils$g;
    //   var assert$8 = minimalisticAssert;
    
    //   function Hmac(hash, key, enc) {
    //     if (!(this instanceof Hmac))
    //       return new Hmac(hash, key, enc);
    //     this.Hash = hash;
    //     this.blockSize = hash.blockSize / 8;
    //     this.outSize = hash.outSize / 8;
    //     this.inner = null;
    //     this.outer = null;
    
    //     this._init(utils$7.toArray(key, enc));
    //   }
    //   var hmac = Hmac;
    
    //   Hmac.prototype._init = function init(key) {
    //     // Shorten key, if needed
    //     if (key.length > this.blockSize)
    //       key = new this.Hash().update(key).digest();
    //     assert$8(key.length <= this.blockSize);
    
    //     // Add padding to key
    //     for (var i = key.length; i < this.blockSize; i++)
    //       key.push(0);
    
    //     for (i = 0; i < key.length; i++)
    //       key[i] ^= 0x36;
    //     this.inner = new this.Hash().update(key);
    
    //     // 0x36 ^ 0x5c = 0x6a
    //     for (i = 0; i < key.length; i++)
    //       key[i] ^= 0x6a;
    //     this.outer = new this.Hash().update(key);
    //   };
    
    //   Hmac.prototype.update = function update(msg, enc) {
    //     this.inner.update(msg, enc);
    //     return this;
    //   };
    
    //   Hmac.prototype.digest = function digest(enc) {
    //     this.outer.update(this.inner.digest());
    //     return this.outer.digest(enc);
    //   };
    
    //   (function (exports) {
    //   var hash = exports;
    
    //   hash.utils = utils$g;
    //   hash.common = common$5;
    //   hash.sha = sha;
    //   hash.ripemd = ripemd;
    //   hash.hmac = hmac;
    
    //   // Proxy hash functions to the main object
    //   hash.sha1 = hash.sha.sha1;
    //   hash.sha256 = hash.sha.sha256;
    //   hash.sha224 = hash.sha.sha224;
    //   hash.sha384 = hash.sha.sha384;
    //   hash.sha512 = hash.sha.sha512;
    //   hash.ripemd160 = hash.ripemd.ripemd160;
    //   }(hash$2));
    
    //   var secp256k1$1 = {
    //     doubles: {
    //       step: 4,
    //       points: [
    //         [
    //           'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
    //           'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
    //         ],
    //         [
    //           '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
    //           '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
    //         ],
    //         [
    //           '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
    //           'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
    //         ],
    //         [
    //           '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
    //           '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
    //         ],
    //         [
    //           '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
    //           '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
    //         ],
    //         [
    //           '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
    //           '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
    //         ],
    //         [
    //           'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
    //           '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
    //         ],
    //         [
    //           '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
    //           'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
    //         ],
    //         [
    //           'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
    //           '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
    //         ],
    //         [
    //           'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
    //           'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
    //         ],
    //         [
    //           'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
    //           '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
    //         ],
    //         [
    //           '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
    //           '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
    //         ],
    //         [
    //           '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
    //           '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
    //         ],
    //         [
    //           '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
    //           '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
    //         ],
    //         [
    //           '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
    //           '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
    //         ],
    //         [
    //           '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
    //           '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
    //         ],
    //         [
    //           '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
    //           '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
    //         ],
    //         [
    //           '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
    //           '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
    //         ],
    //         [
    //           '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
    //           'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
    //         ],
    //         [
    //           'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
    //           '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
    //         ],
    //         [
    //           'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
    //           '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
    //         ],
    //         [
    //           '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
    //           '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
    //         ],
    //         [
    //           '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
    //           '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
    //         ],
    //         [
    //           'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
    //           '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
    //         ],
    //         [
    //           '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
    //           'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
    //         ],
    //         [
    //           'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
    //           '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
    //         ],
    //         [
    //           'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
    //           'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
    //         ],
    //         [
    //           'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
    //           '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
    //         ],
    //         [
    //           'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
    //           'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
    //         ],
    //         [
    //           'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
    //           '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
    //         ],
    //         [
    //           '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
    //           'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
    //         ],
    //         [
    //           '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
    //           '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
    //         ],
    //         [
    //           'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
    //           '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
    //         ],
    //         [
    //           '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
    //           'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
    //         ],
    //         [
    //           'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
    //           '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
    //         ],
    //         [
    //           'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
    //           '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
    //         ],
    //         [
    //           'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
    //           'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
    //         ],
    //         [
    //           '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
    //           '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
    //         ],
    //         [
    //           '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
    //           '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
    //         ],
    //         [
    //           '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
    //           'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
    //         ],
    //         [
    //           '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
    //           '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
    //         ],
    //         [
    //           'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
    //           '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
    //         ],
    //         [
    //           '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
    //           '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
    //         ],
    //         [
    //           '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
    //           'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
    //         ],
    //         [
    //           '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
    //           '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
    //         ],
    //         [
    //           'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
    //           '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
    //         ],
    //         [
    //           '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
    //           'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
    //         ],
    //         [
    //           'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
    //           'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
    //         ],
    //         [
    //           'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
    //           '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
    //         ],
    //         [
    //           '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
    //           'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
    //         ],
    //         [
    //           '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
    //           'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
    //         ],
    //         [
    //           'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
    //           '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
    //         ],
    //         [
    //           'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
    //           '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
    //         ],
    //         [
    //           'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
    //           '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
    //         ],
    //         [
    //           '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
    //           'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
    //         ],
    //         [
    //           '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
    //           '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
    //         ],
    //         [
    //           'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
    //           'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
    //         ],
    //         [
    //           '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
    //           'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
    //         ],
    //         [
    //           '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
    //           '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
    //         ],
    //         [
    //           '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
    //           '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
    //         ],
    //         [
    //           'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
    //           'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
    //         ],
    //         [
    //           '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
    //           '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
    //         ],
    //         [
    //           '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
    //           '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
    //         ],
    //         [
    //           'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
    //           '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
    //         ],
    //         [
    //           'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
    //           'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
    //         ],
    //       ],
    //     },
    //     naf: {
    //       wnd: 7,
    //       points: [
    //         [
    //           'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
    //           '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
    //         ],
    //         [
    //           '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
    //           'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
    //         ],
    //         [
    //           '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
    //           '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
    //         ],
    //         [
    //           'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
    //           'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
    //         ],
    //         [
    //           '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
    //           'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
    //         ],
    //         [
    //           'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
    //           'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
    //         ],
    //         [
    //           'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
    //           '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
    //         ],
    //         [
    //           'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
    //           '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
    //         ],
    //         [
    //           '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
    //           '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
    //         ],
    //         [
    //           '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
    //           '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
    //         ],
    //         [
    //           '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
    //           '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
    //         ],
    //         [
    //           '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
    //           '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
    //         ],
    //         [
    //           'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
    //           'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
    //         ],
    //         [
    //           'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
    //           '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
    //         ],
    //         [
    //           '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
    //           'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
    //         ],
    //         [
    //           '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
    //           'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
    //         ],
    //         [
    //           '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
    //           '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
    //         ],
    //         [
    //           '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
    //           '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
    //         ],
    //         [
    //           '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
    //           '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
    //         ],
    //         [
    //           '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
    //           'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
    //         ],
    //         [
    //           'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
    //           'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
    //         ],
    //         [
    //           '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
    //           '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
    //         ],
    //         [
    //           '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
    //           '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
    //         ],
    //         [
    //           'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
    //           'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
    //         ],
    //         [
    //           '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
    //           '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
    //         ],
    //         [
    //           'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
    //           'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
    //         ],
    //         [
    //           'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
    //           'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
    //         ],
    //         [
    //           '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
    //           '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
    //         ],
    //         [
    //           '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
    //           '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
    //         ],
    //         [
    //           '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
    //           '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
    //         ],
    //         [
    //           'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
    //           '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
    //         ],
    //         [
    //           '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
    //           '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
    //         ],
    //         [
    //           'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
    //           '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
    //         ],
    //         [
    //           '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
    //           'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
    //         ],
    //         [
    //           '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
    //           'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
    //         ],
    //         [
    //           'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
    //           'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
    //         ],
    //         [
    //           '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
    //           '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
    //         ],
    //         [
    //           '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
    //           'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
    //         ],
    //         [
    //           'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
    //           'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
    //         ],
    //         [
    //           '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
    //           '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
    //         ],
    //         [
    //           '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
    //           'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
    //         ],
    //         [
    //           '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
    //           '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
    //         ],
    //         [
    //           '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
    //           'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
    //         ],
    //         [
    //           'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
    //           '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
    //         ],
    //         [
    //           '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
    //           '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
    //         ],
    //         [
    //           '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
    //           'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
    //         ],
    //         [
    //           '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
    //           'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
    //         ],
    //         [
    //           'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
    //           'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
    //         ],
    //         [
    //           'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
    //           'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
    //         ],
    //         [
    //           '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
    //           '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
    //         ],
    //         [
    //           '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
    //           '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
    //         ],
    //         [
    //           'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
    //           '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
    //         ],
    //         [
    //           'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
    //           'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
    //         ],
    //         [
    //           '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
    //           '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
    //         ],
    //         [
    //           '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
    //           '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
    //         ],
    //         [
    //           'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
    //           '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
    //         ],
    //         [
    //           '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
    //           '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
    //         ],
    //         [
    //           'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
    //           'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
    //         ],
    //         [
    //           '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
    //           'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
    //         ],
    //         [
    //           '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
    //           '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
    //         ],
    //         [
    //           'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
    //           '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
    //         ],
    //         [
    //           'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
    //           '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
    //         ],
    //         [
    //           '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
    //           '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
    //         ],
    //         [
    //           '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
    //           '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
    //         ],
    //         [
    //           '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
    //           'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
    //         ],
    //         [
    //           '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
    //           'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
    //         ],
    //         [
    //           '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
    //           '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
    //         ],
    //         [
    //           '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
    //           '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
    //         ],
    //         [
    //           '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
    //           '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
    //         ],
    //         [
    //           '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
    //           'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
    //         ],
    //         [
    //           'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
    //           'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
    //         ],
    //         [
    //           '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
    //           'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
    //         ],
    //         [
    //           'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
    //           '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
    //         ],
    //         [
    //           'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
    //           '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
    //         ],
    //         [
    //           'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
    //           '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
    //         ],
    //         [
    //           'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
    //           '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
    //         ],
    //         [
    //           '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
    //           'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
    //         ],
    //         [
    //           '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
    //           '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
    //         ],
    //         [
    //           '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
    //           'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
    //         ],
    //         [
    //           'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
    //           'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
    //         ],
    //         [
    //           'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
    //           '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
    //         ],
    //         [
    //           'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
    //           'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
    //         ],
    //         [
    //           'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
    //           '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
    //         ],
    //         [
    //           '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
    //           '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
    //         ],
    //         [
    //           'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
    //           '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
    //         ],
    //         [
    //           'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
    //           '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
    //         ],
    //         [
    //           '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
    //           '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
    //         ],
    //         [
    //           '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
    //           'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
    //         ],
    //         [
    //           'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
    //           '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
    //         ],
    //         [
    //           'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
    //           '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
    //         ],
    //         [
    //           'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
    //           '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
    //         ],
    //         [
    //           '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
    //           '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
    //         ],
    //         [
    //           'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
    //           'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
    //         ],
    //         [
    //           '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
    //           'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
    //         ],
    //         [
    //           'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
    //           'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
    //         ],
    //         [
    //           'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
    //           '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
    //         ],
    //         [
    //           '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
    //           'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
    //         ],
    //         [
    //           'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
    //           '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
    //         ],
    //         [
    //           'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
    //           '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
    //         ],
    //         [
    //           'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
    //           '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
    //         ],
    //         [
    //           '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
    //           'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
    //         ],
    //         [
    //           '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
    //           'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
    //         ],
    //         [
    //           'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
    //           '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
    //         ],
    //         [
    //           '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
    //           'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
    //         ],
    //         [
    //           '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
    //           '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
    //         ],
    //         [
    //           '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
    //           'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
    //         ],
    //         [
    //           'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
    //           'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
    //         ],
    //         [
    //           '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
    //           'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
    //         ],
    //         [
    //           '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
    //           '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
    //         ],
    //         [
    //           '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
    //           'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
    //         ],
    //         [
    //           '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
    //           '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
    //         ],
    //         [
    //           'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
    //           'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
    //         ],
    //         [
    //           '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
    //           '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
    //         ],
    //         [
    //           'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
    //           '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
    //         ],
    //         [
    //           '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
    //           '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
    //         ],
    //         [
    //           'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
    //           'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
    //         ],
    //         [
    //           'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
    //           '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
    //         ],
    //         [
    //           'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
    //           'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
    //         ],
    //         [
    //           '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
    //           'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
    //         ],
    //         [
    //           '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
    //           '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
    //         ],
    //         [
    //           '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
    //           'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
    //         ],
    //         [
    //           '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
    //           '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
    //         ],
    //         [
    //           '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
    //           '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
    //         ],
    //         [
    //           '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
    //           'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
    //         ],
    //         [
    //           '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
    //           '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
    //         ],
    //         [
    //           '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
    //           '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
    //         ],
    //         [
    //           '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
    //           '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
    //         ],
    //       ],
    //     },
    //   };
    
    //   (function (exports) {
    
    //   var curves = exports;
    
    //   var hash = hash$2;
    //   var curve$1 = curve;
    //   var utils = utils$m;
    
    //   var assert = utils.assert;
    
    //   function PresetCurve(options) {
    //     if (options.type === 'short')
    //       this.curve = new curve$1.short(options);
    //     else if (options.type === 'edwards')
    //       this.curve = new curve$1.edwards(options);
    //     else
    //       this.curve = new curve$1.mont(options);
    //     this.g = this.curve.g;
    //     this.n = this.curve.n;
    //     this.hash = options.hash;
    
    //     assert(this.g.validate(), 'Invalid curve');
    //     assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
    //   }
    //   curves.PresetCurve = PresetCurve;
    
    //   function defineCurve(name, options) {
    //     Object.defineProperty(curves, name, {
    //       configurable: true,
    //       enumerable: true,
    //       get: function() {
    //         var curve = new PresetCurve(options);
    //         Object.defineProperty(curves, name, {
    //           configurable: true,
    //           enumerable: true,
    //           value: curve,
    //         });
    //         return curve;
    //       },
    //     });
    //   }
    
    //   defineCurve('p192', {
    //     type: 'short',
    //     prime: 'p192',
    //     p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
    //     a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
    //     b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
    //     n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
    //     hash: hash.sha256,
    //     gRed: false,
    //     g: [
    //       '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    //       '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
    //     ],
    //   });
    
    //   defineCurve('p224', {
    //     type: 'short',
    //     prime: 'p224',
    //     p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
    //     a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
    //     b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
    //     n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
    //     hash: hash.sha256,
    //     gRed: false,
    //     g: [
    //       'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    //       'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
    //     ],
    //   });
    
    //   defineCurve('p256', {
    //     type: 'short',
    //     prime: null,
    //     p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
    //     a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
    //     b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
    //     n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
    //     hash: hash.sha256,
    //     gRed: false,
    //     g: [
    //       '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    //       '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
    //     ],
    //   });
    
    //   defineCurve('p384', {
    //     type: 'short',
    //     prime: null,
    //     p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
    //        'fffffffe ffffffff 00000000 00000000 ffffffff',
    //     a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
    //        'fffffffe ffffffff 00000000 00000000 fffffffc',
    //     b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
    //        '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
    //     n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
    //        'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
    //     hash: hash.sha384,
    //     gRed: false,
    //     g: [
    //       'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    //       '5502f25d bf55296c 3a545e38 72760ab7',
    //       '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    //       '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
    //     ],
    //   });
    
    //   defineCurve('p521', {
    //     type: 'short',
    //     prime: null,
    //     p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
    //        'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
    //        'ffffffff ffffffff ffffffff ffffffff ffffffff',
    //     a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
    //        'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
    //        'ffffffff ffffffff ffffffff ffffffff fffffffc',
    //     b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
    //        '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
    //        '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
    //     n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
    //        'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
    //        'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
    //     hash: hash.sha512,
    //     gRed: false,
    //     g: [
    //       '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    //       '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    //       'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    //       '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    //       '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    //       '3fad0761 353c7086 a272c240 88be9476 9fd16650',
    //     ],
    //   });
    
    //   defineCurve('curve25519', {
    //     type: 'mont',
    //     prime: 'p25519',
    //     p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    //     a: '76d06',
    //     b: '1',
    //     n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    //     hash: hash.sha256,
    //     gRed: false,
    //     g: [
    //       '9',
    //     ],
    //   });
    
    //   defineCurve('ed25519', {
    //     type: 'edwards',
    //     prime: 'p25519',
    //     p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    //     a: '-1',
    //     c: '1',
    //     // -121665 * (121666^(-1)) (mod P)
    //     d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
    //     n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    //     hash: hash.sha256,
    //     gRed: false,
    //     g: [
    //       '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
    
    //       // 4/5
    //       '6666666666666666666666666666666666666666666666666666666666666658',
    //     ],
    //   });
    
    //   var pre;
    //   try {
    //     pre = secp256k1$1;
    //   } catch (e) {
    //     pre = undefined;
    //   }
    
    //   defineCurve('secp256k1', {
    //     type: 'short',
    //     prime: 'k256',
    //     p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
    //     a: '0',
    //     b: '7',
    //     n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
    //     h: '1',
    //     hash: hash.sha256,
    
    //     // Precomputed endomorphism
    //     beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
    //     lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
    //     basis: [
    //       {
    //         a: '3086d221a7d46bcde86c90e49284eb15',
    //         b: '-e4437ed6010e88286f547fa90abfe4c3',
    //       },
    //       {
    //         a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
    //         b: '3086d221a7d46bcde86c90e49284eb15',
    //       },
    //     ],
    
    //     gRed: false,
    //     g: [
    //       '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    //       '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    //       pre,
    //     ],
    //   });
    //   }(curves$2));
    
    //   var hash$1 = hash$2;
    //   var utils$6 = utils$l;
    //   var assert$7 = minimalisticAssert;
    
    //   function HmacDRBG$1(options) {
    //     if (!(this instanceof HmacDRBG$1))
    //       return new HmacDRBG$1(options);
    //     this.hash = options.hash;
    //     this.predResist = !!options.predResist;
    
    //     this.outLen = this.hash.outSize;
    //     this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    
    //     this._reseed = null;
    //     this.reseedInterval = null;
    //     this.K = null;
    //     this.V = null;
    
    //     var entropy = utils$6.toArray(options.entropy, options.entropyEnc || 'hex');
    //     var nonce = utils$6.toArray(options.nonce, options.nonceEnc || 'hex');
    //     var pers = utils$6.toArray(options.pers, options.persEnc || 'hex');
    //     assert$7(entropy.length >= (this.minEntropy / 8),
    //            'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    //     this._init(entropy, nonce, pers);
    //   }
    //   var hmacDrbg = HmacDRBG$1;
    
    //   HmacDRBG$1.prototype._init = function init(entropy, nonce, pers) {
    //     var seed = entropy.concat(nonce).concat(pers);
    
    //     this.K = new Array(this.outLen / 8);
    //     this.V = new Array(this.outLen / 8);
    //     for (var i = 0; i < this.V.length; i++) {
    //       this.K[i] = 0x00;
    //       this.V[i] = 0x01;
    //     }
    
    //     this._update(seed);
    //     this._reseed = 1;
    //     this.reseedInterval = 0x1000000000000;  // 2^48
    //   };
    
    //   HmacDRBG$1.prototype._hmac = function hmac() {
    //     return new hash$1.hmac(this.hash, this.K);
    //   };
    
    //   HmacDRBG$1.prototype._update = function update(seed) {
    //     var kmac = this._hmac()
    //                    .update(this.V)
    //                    .update([ 0x00 ]);
    //     if (seed)
    //       kmac = kmac.update(seed);
    //     this.K = kmac.digest();
    //     this.V = this._hmac().update(this.V).digest();
    //     if (!seed)
    //       return;
    
    //     this.K = this._hmac()
    //                  .update(this.V)
    //                  .update([ 0x01 ])
    //                  .update(seed)
    //                  .digest();
    //     this.V = this._hmac().update(this.V).digest();
    //   };
    
    //   HmacDRBG$1.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    //     // Optional entropy enc
    //     if (typeof entropyEnc !== 'string') {
    //       addEnc = add;
    //       add = entropyEnc;
    //       entropyEnc = null;
    //     }
    
    //     entropy = utils$6.toArray(entropy, entropyEnc);
    //     add = utils$6.toArray(add, addEnc);
    
    //     assert$7(entropy.length >= (this.minEntropy / 8),
    //            'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    
    //     this._update(entropy.concat(add || []));
    //     this._reseed = 1;
    //   };
    
    //   HmacDRBG$1.prototype.generate = function generate(len, enc, add, addEnc) {
    //     if (this._reseed > this.reseedInterval)
    //       throw new Error('Reseed is required');
    
    //     // Optional encoding
    //     if (typeof enc !== 'string') {
    //       addEnc = add;
    //       add = enc;
    //       enc = null;
    //     }
    
    //     // Optional additional data
    //     if (add) {
    //       add = utils$6.toArray(add, addEnc || 'hex');
    //       this._update(add);
    //     }
    
    //     var temp = [];
    //     while (temp.length < len) {
    //       this.V = this._hmac().update(this.V).digest();
    //       temp = temp.concat(this.V);
    //     }
    
    //     var res = temp.slice(0, len);
    //     this._update(add);
    //     this._reseed++;
    //     return utils$6.encode(res, enc);
    //   };
    
    //   var BN$4 = bn.exports;
    //   var utils$5 = utils$m;
    //   var assert$6 = utils$5.assert;
    
    //   function KeyPair$3(ec, options) {
    //     this.ec = ec;
    //     this.priv = null;
    //     this.pub = null;
    
    //     // KeyPair(ec, { priv: ..., pub: ... })
    //     if (options.priv)
    //       this._importPrivate(options.priv, options.privEnc);
    //     if (options.pub)
    //       this._importPublic(options.pub, options.pubEnc);
    //   }
    //   var key$1 = KeyPair$3;
    
    //   KeyPair$3.fromPublic = function fromPublic(ec, pub, enc) {
    //     if (pub instanceof KeyPair$3)
    //       return pub;
    
    //     return new KeyPair$3(ec, {
    //       pub: pub,
    //       pubEnc: enc,
    //     });
    //   };
    
    //   KeyPair$3.fromPrivate = function fromPrivate(ec, priv, enc) {
    //     if (priv instanceof KeyPair$3)
    //       return priv;
    
    //     return new KeyPair$3(ec, {
    //       priv: priv,
    //       privEnc: enc,
    //     });
    //   };
    
    //   KeyPair$3.prototype.validate = function validate() {
    //     var pub = this.getPublic();
    
    //     if (pub.isInfinity())
    //       return { result: false, reason: 'Invalid public key' };
    //     if (!pub.validate())
    //       return { result: false, reason: 'Public key is not a point' };
    //     if (!pub.mul(this.ec.curve.n).isInfinity())
    //       return { result: false, reason: 'Public key * N != O' };
    
    //     return { result: true, reason: null };
    //   };
    
    //   KeyPair$3.prototype.getPublic = function getPublic(compact, enc) {
    //     // compact is optional argument
    //     if (typeof compact === 'string') {
    //       enc = compact;
    //       compact = null;
    //     }
    
    //     if (!this.pub)
    //       this.pub = this.ec.g.mul(this.priv);
    
    //     if (!enc)
    //       return this.pub;
    
    //     return this.pub.encode(enc, compact);
    //   };
    
    //   KeyPair$3.prototype.getPrivate = function getPrivate(enc) {
    //     if (enc === 'hex')
    //       return this.priv.toString(16, 2);
    //     else
    //       return this.priv;
    //   };
    
    //   KeyPair$3.prototype._importPrivate = function _importPrivate(key, enc) {
    //     this.priv = new BN$4(key, enc || 16);
    
    //     // Ensure that the priv won't be bigger than n, otherwise we may fail
    //     // in fixed multiplication method
    //     this.priv = this.priv.umod(this.ec.curve.n);
    //   };
    
    //   KeyPair$3.prototype._importPublic = function _importPublic(key, enc) {
    //     if (key.x || key.y) {
    //       // Montgomery points only have an `x` coordinate.
    //       // Weierstrass/Edwards points on the other hand have both `x` and
    //       // `y` coordinates.
    //       if (this.ec.curve.type === 'mont') {
    //         assert$6(key.x, 'Need x coordinate');
    //       } else if (this.ec.curve.type === 'short' ||
    //                  this.ec.curve.type === 'edwards') {
    //         assert$6(key.x && key.y, 'Need both x and y coordinate');
    //       }
    //       this.pub = this.ec.curve.point(key.x, key.y);
    //       return;
    //     }
    //     this.pub = this.ec.curve.decodePoint(key, enc);
    //   };
    
    //   // ECDH
    //   KeyPair$3.prototype.derive = function derive(pub) {
    //     if(!pub.validate()) {
    //       assert$6(pub.validate(), 'public point not validated');
    //     }
    //     return pub.mul(this.priv).getX();
    //   };
    
    //   // ECDSA
    //   KeyPair$3.prototype.sign = function sign(msg, enc, options) {
    //     return this.ec.sign(msg, this, enc, options);
    //   };
    
    //   KeyPair$3.prototype.verify = function verify(msg, signature) {
    //     return this.ec.verify(msg, signature, this);
    //   };
    
    //   KeyPair$3.prototype.inspect = function inspect() {
    //     return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
    //            ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
    //   };
    
    //   var BN$3 = bn.exports;
    
    //   var utils$4 = utils$m;
    //   var assert$5 = utils$4.assert;
    
    //   function Signature$3(options, enc) {
    //     if (options instanceof Signature$3)
    //       return options;
    
    //     if (this._importDER(options, enc))
    //       return;
    
    //     assert$5(options.r && options.s, 'Signature without r or s');
    //     this.r = new BN$3(options.r, 16);
    //     this.s = new BN$3(options.s, 16);
    //     if (options.recoveryParam === undefined)
    //       this.recoveryParam = null;
    //     else
    //       this.recoveryParam = options.recoveryParam;
    //   }
    //   var signature$1 = Signature$3;
    
    //   function Position() {
    //     this.place = 0;
    //   }
    
    //   function getLength(buf, p) {
    //     var initial = buf[p.place++];
    //     if (!(initial & 0x80)) {
    //       return initial;
    //     }
    //     var octetLen = initial & 0xf;
    
    //     // Indefinite length or overflow
    //     if (octetLen === 0 || octetLen > 4) {
    //       return false;
    //     }
    
    //     var val = 0;
    //     for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    //       val <<= 8;
    //       val |= buf[off];
    //       val >>>= 0;
    //     }
    
    //     // Leading zeroes
    //     if (val <= 0x7f) {
    //       return false;
    //     }
    
    //     p.place = off;
    //     return val;
    //   }
    
    //   function rmPadding(buf) {
    //     var i = 0;
    //     var len = buf.length - 1;
    //     while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    //       i++;
    //     }
    //     if (i === 0) {
    //       return buf;
    //     }
    //     return buf.slice(i);
    //   }
    
    //   Signature$3.prototype._importDER = function _importDER(data, enc) {
    //     data = utils$4.toArray(data, enc);
    //     var p = new Position();
    //     if (data[p.place++] !== 0x30) {
    //       return false;
    //     }
    //     var len = getLength(data, p);
    //     if (len === false) {
    //       return false;
    //     }
    //     if ((len + p.place) !== data.length) {
    //       return false;
    //     }
    //     if (data[p.place++] !== 0x02) {
    //       return false;
    //     }
    //     var rlen = getLength(data, p);
    //     if (rlen === false) {
    //       return false;
    //     }
    //     var r = data.slice(p.place, rlen + p.place);
    //     p.place += rlen;
    //     if (data[p.place++] !== 0x02) {
    //       return false;
    //     }
    //     var slen = getLength(data, p);
    //     if (slen === false) {
    //       return false;
    //     }
    //     if (data.length !== slen + p.place) {
    //       return false;
    //     }
    //     var s = data.slice(p.place, slen + p.place);
    //     if (r[0] === 0) {
    //       if (r[1] & 0x80) {
    //         r = r.slice(1);
    //       } else {
    //         // Leading zeroes
    //         return false;
    //       }
    //     }
    //     if (s[0] === 0) {
    //       if (s[1] & 0x80) {
    //         s = s.slice(1);
    //       } else {
    //         // Leading zeroes
    //         return false;
    //       }
    //     }
    
    //     this.r = new BN$3(r);
    //     this.s = new BN$3(s);
    //     this.recoveryParam = null;
    
    //     return true;
    //   };
    
    //   function constructLength(arr, len) {
    //     if (len < 0x80) {
    //       arr.push(len);
    //       return;
    //     }
    //     var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    //     arr.push(octets | 0x80);
    //     while (--octets) {
    //       arr.push((len >>> (octets << 3)) & 0xff);
    //     }
    //     arr.push(len);
    //   }
    
    //   Signature$3.prototype.toDER = function toDER(enc) {
    //     var r = this.r.toArray();
    //     var s = this.s.toArray();
    
    //     // Pad values
    //     if (r[0] & 0x80)
    //       r = [ 0 ].concat(r);
    //     // Pad values
    //     if (s[0] & 0x80)
    //       s = [ 0 ].concat(s);
    
    //     r = rmPadding(r);
    //     s = rmPadding(s);
    
    //     while (!s[0] && !(s[1] & 0x80)) {
    //       s = s.slice(1);
    //     }
    //     var arr = [ 0x02 ];
    //     constructLength(arr, r.length);
    //     arr = arr.concat(r);
    //     arr.push(0x02);
    //     constructLength(arr, s.length);
    //     var backHalf = arr.concat(s);
    //     var res = [ 0x30 ];
    //     constructLength(res, backHalf.length);
    //     res = res.concat(backHalf);
    //     return utils$4.encode(res, enc);
    //   };
    
    //   var BN$2 = bn.exports;
    //   var HmacDRBG = hmacDrbg;
    //   var utils$3 = utils$m;
    //   var curves$1 = curves$2;
    //   var rand = brorand.exports;
    //   var assert$4 = utils$3.assert;
    
    //   var KeyPair$2 = key$1;
    //   var Signature$2 = signature$1;
    
    //   function EC$1(options) {
    //     if (!(this instanceof EC$1))
    //       return new EC$1(options);
    
    //     // Shortcut `elliptic.ec(curve-name)`
    //     if (typeof options === 'string') {
    //       assert$4(Object.prototype.hasOwnProperty.call(curves$1, options),
    //         'Unknown curve ' + options);
    
    //       options = curves$1[options];
    //     }
    
    //     // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
    //     if (options instanceof curves$1.PresetCurve)
    //       options = { curve: options };
    
    //     this.curve = options.curve.curve;
    //     this.n = this.curve.n;
    //     this.nh = this.n.ushrn(1);
    //     this.g = this.curve.g;
    
    //     // Point on curve
    //     this.g = options.curve.g;
    //     this.g.precompute(options.curve.n.bitLength() + 1);
    
    //     // Hash for function for DRBG
    //     this.hash = options.hash || options.curve.hash;
    //   }
    //   var ec$1 = EC$1;
    
    //   EC$1.prototype.keyPair = function keyPair(options) {
    //     return new KeyPair$2(this, options);
    //   };
    
    //   EC$1.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    //     return KeyPair$2.fromPrivate(this, priv, enc);
    //   };
    
    //   EC$1.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    //     return KeyPair$2.fromPublic(this, pub, enc);
    //   };
    
    //   EC$1.prototype.genKeyPair = function genKeyPair(options) {
    //     if (!options)
    //       options = {};
    
    //     // Instantiate Hmac_DRBG
    //     var drbg = new HmacDRBG({
    //       hash: this.hash,
    //       pers: options.pers,
    //       persEnc: options.persEnc || 'utf8',
    //       entropy: options.entropy || rand(this.hash.hmacStrength),
    //       entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    //       nonce: this.n.toArray(),
    //     });
    
    //     var bytes = this.n.byteLength();
    //     var ns2 = this.n.sub(new BN$2(2));
    //     for (;;) {
    //       var priv = new BN$2(drbg.generate(bytes));
    //       if (priv.cmp(ns2) > 0)
    //         continue;
    
    //       priv.iaddn(1);
    //       return this.keyFromPrivate(priv);
    //     }
    //   };
    
    //   EC$1.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    //     var delta = msg.byteLength() * 8 - this.n.bitLength();
    //     if (delta > 0)
    //       msg = msg.ushrn(delta);
    //     if (!truncOnly && msg.cmp(this.n) >= 0)
    //       return msg.sub(this.n);
    //     else
    //       return msg;
    //   };
    
    //   EC$1.prototype.sign = function sign(msg, key, enc, options) {
    //     if (typeof enc === 'object') {
    //       options = enc;
    //       enc = null;
    //     }
    //     if (!options)
    //       options = {};
    
    //     key = this.keyFromPrivate(key, enc);
    //     msg = this._truncateToN(new BN$2(msg, 16));
    
    //     // Zero-extend key to provide enough entropy
    //     var bytes = this.n.byteLength();
    //     var bkey = key.getPrivate().toArray('be', bytes);
    
    //     // Zero-extend nonce to have the same byte size as N
    //     var nonce = msg.toArray('be', bytes);
    
    //     // Instantiate Hmac_DRBG
    //     var drbg = new HmacDRBG({
    //       hash: this.hash,
    //       entropy: bkey,
    //       nonce: nonce,
    //       pers: options.pers,
    //       persEnc: options.persEnc || 'utf8',
    //     });
    
    //     // Number of bytes to generate
    //     var ns1 = this.n.sub(new BN$2(1));
    
    //     for (var iter = 0; ; iter++) {
    //       var k = options.k ?
    //         options.k(iter) :
    //         new BN$2(drbg.generate(this.n.byteLength()));
    //       k = this._truncateToN(k, true);
    //       if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
    //         continue;
    
    //       var kp = this.g.mul(k);
    //       if (kp.isInfinity())
    //         continue;
    
    //       var kpX = kp.getX();
    //       var r = kpX.umod(this.n);
    //       if (r.cmpn(0) === 0)
    //         continue;
    
    //       var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    //       s = s.umod(this.n);
    //       if (s.cmpn(0) === 0)
    //         continue;
    
    //       var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
    //                           (kpX.cmp(r) !== 0 ? 2 : 0);
    
    //       // Use complement of `s`, if it is > `n / 2`
    //       if (options.canonical && s.cmp(this.nh) > 0) {
    //         s = this.n.sub(s);
    //         recoveryParam ^= 1;
    //       }
    
    //       return new Signature$2({ r: r, s: s, recoveryParam: recoveryParam });
    //     }
    //   };
    
    //   EC$1.prototype.verify = function verify(msg, signature, key, enc) {
    //     msg = this._truncateToN(new BN$2(msg, 16));
    //     key = this.keyFromPublic(key, enc);
    //     signature = new Signature$2(signature, 'hex');
    
    //     // Perform primitive values validation
    //     var r = signature.r;
    //     var s = signature.s;
    //     if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    //       return false;
    //     if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    //       return false;
    
    //     // Validate signature
    //     var sinv = s.invm(this.n);
    //     var u1 = sinv.mul(msg).umod(this.n);
    //     var u2 = sinv.mul(r).umod(this.n);
    //     var p;
    
    //     if (!this.curve._maxwellTrick) {
    //       p = this.g.mulAdd(u1, key.getPublic(), u2);
    //       if (p.isInfinity())
    //         return false;
    
    //       return p.getX().umod(this.n).cmp(r) === 0;
    //     }
    
    //     // NOTE: Greg Maxwell's trick, inspired by:
    //     // https://git.io/vad3K
    
    //     p = this.g.jmulAdd(u1, key.getPublic(), u2);
    //     if (p.isInfinity())
    //       return false;
    
    //     // Compare `p.x` of Jacobian point with `r`,
    //     // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
    //     // inverse of `p.z^2`
    //     return p.eqXToP(r);
    //   };
    
    //   EC$1.prototype.recoverPubKey = function(msg, signature, j, enc) {
    //     assert$4((3 & j) === j, 'The recovery param is more than two bits');
    //     signature = new Signature$2(signature, enc);
    
    //     var n = this.n;
    //     var e = new BN$2(msg);
    //     var r = signature.r;
    //     var s = signature.s;
    
    //     // A set LSB signifies that the y-coordinate is odd
    //     var isYOdd = j & 1;
    //     var isSecondKey = j >> 1;
    //     if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    //       throw new Error('Unable to find sencond key candinate');
    
    //     // 1.1. Let x = r + jn.
    //     if (isSecondKey)
    //       r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    //     else
    //       r = this.curve.pointFromX(r, isYOdd);
    
    //     var rInv = signature.r.invm(n);
    //     var s1 = n.sub(e).mul(rInv).umod(n);
    //     var s2 = s.mul(rInv).umod(n);
    
    //     // 1.6.1 Compute Q = r^-1 (sR -  eG)
    //     //               Q = r^-1 (sR + -eG)
    //     return this.g.mulAdd(s1, r, s2);
    //   };
    
    //   EC$1.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
    //     signature = new Signature$2(signature, enc);
    //     if (signature.recoveryParam !== null)
    //       return signature.recoveryParam;
    
    //     for (var i = 0; i < 4; i++) {
    //       var Qprime;
    //       try {
    //         Qprime = this.recoverPubKey(e, signature, i);
    //       } catch (e) {
    //         continue;
    //       }
    
    //       if (Qprime.eq(Q))
    //         return i;
    //     }
    //     throw new Error('Unable to find valid recovery factor');
    //   };
    
    //   var utils$2 = utils$m;
    //   var assert$3 = utils$2.assert;
    //   var parseBytes$2 = utils$2.parseBytes;
    //   var cachedProperty$1 = utils$2.cachedProperty;
    
    //   /**
    //   * @param {EDDSA} eddsa - instance
    //   * @param {Object} params - public/private key parameters
    //   *
    //   * @param {Array<Byte>} [params.secret] - secret seed bytes
    //   * @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
    //   * @param {Array<Byte>} [params.pub] - public key point encoded as bytes
    //   *
    //   */
    //   function KeyPair$1(eddsa, params) {
    //     this.eddsa = eddsa;
    //     this._secret = parseBytes$2(params.secret);
    //     if (eddsa.isPoint(params.pub))
    //       this._pub = params.pub;
    //     else
    //       this._pubBytes = parseBytes$2(params.pub);
    //   }
    
    //   KeyPair$1.fromPublic = function fromPublic(eddsa, pub) {
    //     if (pub instanceof KeyPair$1)
    //       return pub;
    //     return new KeyPair$1(eddsa, { pub: pub });
    //   };
    
    //   KeyPair$1.fromSecret = function fromSecret(eddsa, secret) {
    //     if (secret instanceof KeyPair$1)
    //       return secret;
    //     return new KeyPair$1(eddsa, { secret: secret });
    //   };
    
    //   KeyPair$1.prototype.secret = function secret() {
    //     return this._secret;
    //   };
    
    //   cachedProperty$1(KeyPair$1, 'pubBytes', function pubBytes() {
    //     return this.eddsa.encodePoint(this.pub());
    //   });
    
    //   cachedProperty$1(KeyPair$1, 'pub', function pub() {
    //     if (this._pubBytes)
    //       return this.eddsa.decodePoint(this._pubBytes);
    //     return this.eddsa.g.mul(this.priv());
    //   });
    
    //   cachedProperty$1(KeyPair$1, 'privBytes', function privBytes() {
    //     var eddsa = this.eddsa;
    //     var hash = this.hash();
    //     var lastIx = eddsa.encodingLength - 1;
    
    //     var a = hash.slice(0, eddsa.encodingLength);
    //     a[0] &= 248;
    //     a[lastIx] &= 127;
    //     a[lastIx] |= 64;
    
    //     return a;
    //   });
    
    //   cachedProperty$1(KeyPair$1, 'priv', function priv() {
    //     return this.eddsa.decodeInt(this.privBytes());
    //   });
    
    //   cachedProperty$1(KeyPair$1, 'hash', function hash() {
    //     return this.eddsa.hash().update(this.secret()).digest();
    //   });
    
    //   cachedProperty$1(KeyPair$1, 'messagePrefix', function messagePrefix() {
    //     return this.hash().slice(this.eddsa.encodingLength);
    //   });
    
    //   KeyPair$1.prototype.sign = function sign(message) {
    //     assert$3(this._secret, 'KeyPair can only verify');
    //     return this.eddsa.sign(message, this);
    //   };
    
    //   KeyPair$1.prototype.verify = function verify(message, sig) {
    //     return this.eddsa.verify(message, sig, this);
    //   };
    
    //   KeyPair$1.prototype.getSecret = function getSecret(enc) {
    //     assert$3(this._secret, 'KeyPair is public only');
    //     return utils$2.encode(this.secret(), enc);
    //   };
    
    //   KeyPair$1.prototype.getPublic = function getPublic(enc) {
    //     return utils$2.encode(this.pubBytes(), enc);
    //   };
    
    //   var key = KeyPair$1;
    
    //   var BN$1 = bn.exports;
    //   var utils$1 = utils$m;
    //   var assert$2 = utils$1.assert;
    //   var cachedProperty = utils$1.cachedProperty;
    //   var parseBytes$1 = utils$1.parseBytes;
    
    //   /**
    //   * @param {EDDSA} eddsa - eddsa instance
    //   * @param {Array<Bytes>|Object} sig -
    //   * @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
    //   * @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
    //   * @param {Array<Bytes>} [sig.Rencoded] - R point encoded
    //   * @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
    //   */
    //   function Signature$1(eddsa, sig) {
    //     this.eddsa = eddsa;
    
    //     if (typeof sig !== 'object')
    //       sig = parseBytes$1(sig);
    
    //     if (Array.isArray(sig)) {
    //       sig = {
    //         R: sig.slice(0, eddsa.encodingLength),
    //         S: sig.slice(eddsa.encodingLength),
    //       };
    //     }
    
    //     assert$2(sig.R && sig.S, 'Signature without R or S');
    
    //     if (eddsa.isPoint(sig.R))
    //       this._R = sig.R;
    //     if (sig.S instanceof BN$1)
    //       this._S = sig.S;
    
    //     this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    //     this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    //   }
    
    //   cachedProperty(Signature$1, 'S', function S() {
    //     return this.eddsa.decodeInt(this.Sencoded());
    //   });
    
    //   cachedProperty(Signature$1, 'R', function R() {
    //     return this.eddsa.decodePoint(this.Rencoded());
    //   });
    
    //   cachedProperty(Signature$1, 'Rencoded', function Rencoded() {
    //     return this.eddsa.encodePoint(this.R());
    //   });
    
    //   cachedProperty(Signature$1, 'Sencoded', function Sencoded() {
    //     return this.eddsa.encodeInt(this.S());
    //   });
    
    //   Signature$1.prototype.toBytes = function toBytes() {
    //     return this.Rencoded().concat(this.Sencoded());
    //   };
    
    //   Signature$1.prototype.toHex = function toHex() {
    //     return utils$1.encode(this.toBytes(), 'hex').toUpperCase();
    //   };
    
    //   var signature = Signature$1;
    
    //   var hash = hash$2;
    //   var curves = curves$2;
    //   var utils = utils$m;
    //   var assert$1 = utils.assert;
    //   var parseBytes = utils.parseBytes;
    //   var KeyPair = key;
    //   var Signature = signature;
    
    //   function EDDSA(curve) {
    //     assert$1(curve === 'ed25519', 'only tested with ed25519 so far');
    
    //     if (!(this instanceof EDDSA))
    //       return new EDDSA(curve);
    
    //     curve = curves[curve].curve;
    //     this.curve = curve;
    //     this.g = curve.g;
    //     this.g.precompute(curve.n.bitLength() + 1);
    
    //     this.pointClass = curve.point().constructor;
    //     this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    //     this.hash = hash.sha512;
    //   }
    
    //   var eddsa = EDDSA;
    
    //   /**
    //   * @param {Array|String} message - message bytes
    //   * @param {Array|String|KeyPair} secret - secret bytes or a keypair
    //   * @returns {Signature} - signature
    //   */
    //   EDDSA.prototype.sign = function sign(message, secret) {
    //     message = parseBytes(message);
    //     var key = this.keyFromSecret(secret);
    //     var r = this.hashInt(key.messagePrefix(), message);
    //     var R = this.g.mul(r);
    //     var Rencoded = this.encodePoint(R);
    //     var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    //       .mul(key.priv());
    //     var S = r.add(s_).umod(this.curve.n);
    //     return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
    //   };
    
    //   /**
    //   * @param {Array} message - message bytes
    //   * @param {Array|String|Signature} sig - sig bytes
    //   * @param {Array|String|Point|KeyPair} pub - public key
    //   * @returns {Boolean} - true if public key matches sig of message
    //   */
    //   EDDSA.prototype.verify = function verify(message, sig, pub) {
    //     message = parseBytes(message);
    //     sig = this.makeSignature(sig);
    //     var key = this.keyFromPublic(pub);
    //     var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    //     var SG = this.g.mul(sig.S());
    //     var RplusAh = sig.R().add(key.pub().mul(h));
    //     return RplusAh.eq(SG);
    //   };
    
    //   EDDSA.prototype.hashInt = function hashInt() {
    //     var hash = this.hash();
    //     for (var i = 0; i < arguments.length; i++)
    //       hash.update(arguments[i]);
    //     return utils.intFromLE(hash.digest()).umod(this.curve.n);
    //   };
    
    //   EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    //     return KeyPair.fromPublic(this, pub);
    //   };
    
    //   EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    //     return KeyPair.fromSecret(this, secret);
    //   };
    
    //   EDDSA.prototype.makeSignature = function makeSignature(sig) {
    //     if (sig instanceof Signature)
    //       return sig;
    //     return new Signature(this, sig);
    //   };
    
    //   /**
    //   * * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
    //   *
    //   * EDDSA defines methods for encoding and decoding points and integers. These are
    //   * helper convenience methods, that pass along to utility functions implied
    //   * parameters.
    //   *
    //   */
    //   EDDSA.prototype.encodePoint = function encodePoint(point) {
    //     var enc = point.getY().toArray('le', this.encodingLength);
    //     enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
    //     return enc;
    //   };
    
    //   EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    //     bytes = utils.parseBytes(bytes);
    
    //     var lastIx = bytes.length - 1;
    //     var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
    //     var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
    
    //     var y = utils.intFromLE(normed);
    //     return this.curve.pointFromY(y, xIsOdd);
    //   };
    
    //   EDDSA.prototype.encodeInt = function encodeInt(num) {
    //     return num.toArray('le', this.encodingLength);
    //   };
    
    //   EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    //     return utils.intFromLE(bytes);
    //   };
    
    //   EDDSA.prototype.isPoint = function isPoint(val) {
    //     return val instanceof this.pointClass;
    //   };
    
    //   (function (exports) {
    
    //   var elliptic = exports;
    
    //   elliptic.version = require$$0.version;
    //   elliptic.utils = utils$m;
    //   elliptic.rand = brorand.exports;
    //   elliptic.curve = curve;
    //   elliptic.curves = curves$2;
    
    //   // Protocols
    //   elliptic.ec = ec$1;
    //   elliptic.eddsa = eddsa;
    //   }(elliptic$2));
    
    //   const EC = elliptic$2.ec;
    
    //   const ec = new EC('secp256k1');
    //   const ecparams = ec.curve;
    
    //   // Hack, we can not use bn.js@5, while elliptic uses bn.js@4
    //   // See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758
    //   const BN = ecparams.n.constructor;
    
    //   function loadCompressedPublicKey (first, xbuf) {
    //     let x = new BN(xbuf);
    
    //     // overflow
    //     if (x.cmp(ecparams.p) >= 0) return null
    //     x = x.toRed(ecparams.red);
    
    //     // compute corresponding Y
    //     let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
    //     if ((first === 0x03) !== y.isOdd()) y = y.redNeg();
    
    //     return ec.keyPair({ pub: { x: x, y: y } })
    //   }
    
    //   function loadUncompressedPublicKey (first, xbuf, ybuf) {
    //     let x = new BN(xbuf);
    //     let y = new BN(ybuf);
    
    //     // overflow
    //     if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null
    
    //     x = x.toRed(ecparams.red);
    //     y = y.toRed(ecparams.red);
    
    //     // is odd flag
    //     if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null
    
    //     // x*x*x + b = y*y
    //     const x3 = x.redSqr().redIMul(x);
    //     if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null
    
    //     return ec.keyPair({ pub: { x: x, y: y } })
    //   }
    
    //   function loadPublicKey (pubkey) {
    //     // length should be validated in interface
    //     const first = pubkey[0];
    //     switch (first) {
    //       case 0x02:
    //       case 0x03:
    //         if (pubkey.length !== 33) return null
    //         return loadCompressedPublicKey(first, pubkey.subarray(1, 33))
    //       case 0x04:
    //       case 0x06:
    //       case 0x07:
    //         if (pubkey.length !== 65) return null
    //         return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65))
    //       default:
    //         return null
    //     }
    //   }
    
    //   function savePublicKey (output, point) {
    //     const pubkey = point.encode(null, output.length === 33);
    //     // Loop should be faster because we do not need create extra Uint8Array
    //     // output.set(new Uint8Array(pubkey))
    //     for (let i = 0; i < output.length; ++i) output[i] = pubkey[i];
    //   }
    
    //   var elliptic$1 = {
    //     contextRandomize () {
    //       return 0
    //     },
    
    //     privateKeyVerify (seckey) {
    //       const bn = new BN(seckey);
    //       return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1
    //     },
    
    //     privateKeyNegate (seckey) {
    //       const bn = new BN(seckey);
    //       const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32);
    //       seckey.set(negate);
    //       return 0
    //     },
    
    //     privateKeyTweakAdd (seckey, tweak) {
    //       const bn = new BN(tweak);
    //       if (bn.cmp(ecparams.n) >= 0) return 1
    
    //       bn.iadd(new BN(seckey));
    //       if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);
    //       if (bn.isZero()) return 1
    
    //       const tweaked = bn.toArrayLike(Uint8Array, 'be', 32);
    //       seckey.set(tweaked);
    
    //       return 0
    //     },
    
    //     privateKeyTweakMul (seckey, tweak) {
    //       let bn = new BN(tweak);
    //       if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1
    
    //       bn.imul(new BN(seckey));
    //       if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n);
    
    //       const tweaked = bn.toArrayLike(Uint8Array, 'be', 32);
    //       seckey.set(tweaked);
    
    //       return 0
    //     },
    
    //     publicKeyVerify (pubkey) {
    //       const pair = loadPublicKey(pubkey);
    //       return pair === null ? 1 : 0
    //     },
    
    //     publicKeyCreate (output, seckey) {
    //       const bn = new BN(seckey);
    //       if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1
    
    //       const point = ec.keyFromPrivate(seckey).getPublic();
    //       savePublicKey(output, point);
    
    //       return 0
    //     },
    
    //     publicKeyConvert (output, pubkey) {
    //       const pair = loadPublicKey(pubkey);
    //       if (pair === null) return 1
    
    //       const point = pair.getPublic();
    //       savePublicKey(output, point);
    
    //       return 0
    //     },
    
    //     publicKeyNegate (output, pubkey) {
    //       const pair = loadPublicKey(pubkey);
    //       if (pair === null) return 1
    
    //       const point = pair.getPublic();
    //       point.y = point.y.redNeg();
    //       savePublicKey(output, point);
    
    //       return 0
    //     },
    
    //     publicKeyCombine (output, pubkeys) {
    //       const pairs = new Array(pubkeys.length);
    //       for (let i = 0; i < pubkeys.length; ++i) {
    //         pairs[i] = loadPublicKey(pubkeys[i]);
    //         if (pairs[i] === null) return 1
    //       }
    
    //       let point = pairs[0].getPublic();
    //       for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub);
    //       if (point.isInfinity()) return 2
    
    //       savePublicKey(output, point);
    
    //       return 0
    //     },
    
    //     publicKeyTweakAdd (output, pubkey, tweak) {
    //       const pair = loadPublicKey(pubkey);
    //       if (pair === null) return 1
    
    //       tweak = new BN(tweak);
    //       if (tweak.cmp(ecparams.n) >= 0) return 2
    
    //       const point = pair.getPublic().add(ecparams.g.mul(tweak));
    //       if (point.isInfinity()) return 2
    
    //       savePublicKey(output, point);
    
    //       return 0
    //     },
    
    //     publicKeyTweakMul (output, pubkey, tweak) {
    //       const pair = loadPublicKey(pubkey);
    //       if (pair === null) return 1
    
    //       tweak = new BN(tweak);
    //       if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2
    
    //       const point = pair.getPublic().mul(tweak);
    //       savePublicKey(output, point);
    
    //       return 0
    //     },
    
    //     signatureNormalize (sig) {
    //       const r = new BN(sig.subarray(0, 32));
    //       const s = new BN(sig.subarray(32, 64));
    //       if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1
    
    //       if (s.cmp(ec.nh) === 1) {
    //         sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32);
    //       }
    
    //       return 0
    //     },
    
    //     // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
    //     // Adapted for Uint8Array instead Buffer
    //     signatureExport (obj, sig) {
    //       const sigR = sig.subarray(0, 32);
    //       const sigS = sig.subarray(32, 64);
    //       if (new BN(sigR).cmp(ecparams.n) >= 0) return 1
    //       if (new BN(sigS).cmp(ecparams.n) >= 0) return 1
    
    //       const { output } = obj;
    
    //       // Prepare R
    //       let r = output.subarray(4, 4 + 33);
    //       r[0] = 0x00;
    //       r.set(sigR, 1);
    
    //       let lenR = 33;
    //       let posR = 0;
    //       for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);
    
    //       r = r.subarray(posR);
    //       if (r[0] & 0x80) return 1
    //       if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) return 1
    
    //       // Prepare S
    //       let s = output.subarray(6 + 33, 6 + 33 + 33);
    //       s[0] = 0x00;
    //       s.set(sigS, 1);
    
    //       let lenS = 33;
    //       let posS = 0;
    //       for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);
    
    //       s = s.subarray(posS);
    //       if (s[0] & 0x80) return 1
    //       if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) return 1
    
    //       // Set output length for return
    //       obj.outputlen = 6 + lenR + lenS;
    
    //       // Output in specified format
    //       // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
    //       output[0] = 0x30;
    //       output[1] = obj.outputlen - 2;
    //       output[2] = 0x02;
    //       output[3] = r.length;
    //       output.set(r, 4);
    //       output[4 + lenR] = 0x02;
    //       output[5 + lenR] = s.length;
    //       output.set(s, 6 + lenR);
    
    //       return 0
    //     },
    
    //     // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
    //     // Adapted for Uint8Array instead Buffer
    //     signatureImport (output, sig) {
    //       if (sig.length < 8) return 1
    //       if (sig.length > 72) return 1
    //       if (sig[0] !== 0x30) return 1
    //       if (sig[1] !== sig.length - 2) return 1
    //       if (sig[2] !== 0x02) return 1
    
    //       const lenR = sig[3];
    //       if (lenR === 0) return 1
    //       if (5 + lenR >= sig.length) return 1
    //       if (sig[4 + lenR] !== 0x02) return 1
    
    //       const lenS = sig[5 + lenR];
    //       if (lenS === 0) return 1
    //       if ((6 + lenR + lenS) !== sig.length) return 1
    
    //       if (sig[4] & 0x80) return 1
    //       if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80)) return 1
    
    //       if (sig[lenR + 6] & 0x80) return 1
    //       if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80)) return 1
    
    //       let sigR = sig.subarray(4, 4 + lenR);
    //       if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1);
    //       if (sigR.length > 32) return 1
    
    //       let sigS = sig.subarray(6 + lenR);
    //       if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1);
    //       if (sigS.length > 32) throw new Error('S length is too long')
    
    //       let r = new BN(sigR);
    //       if (r.cmp(ecparams.n) >= 0) r = new BN(0);
    
    //       let s = new BN(sig.subarray(6 + lenR));
    //       if (s.cmp(ecparams.n) >= 0) s = new BN(0);
    
    //       output.set(r.toArrayLike(Uint8Array, 'be', 32), 0);
    //       output.set(s.toArrayLike(Uint8Array, 'be', 32), 32);
    
    //       return 0
    //     },
    
    //     ecdsaSign (obj, message, seckey, data, noncefn) {
    //       if (noncefn) {
    //         const _noncefn = noncefn;
    //         noncefn = (counter) => {
    //           const nonce = _noncefn(message, seckey, null, data, counter);
    
    //           const isValid = nonce instanceof Uint8Array && nonce.length === 32;
    //           if (!isValid) throw new Error('This is the way')
    
    //           return new BN(nonce)
    //         };
    //       }
    
    //       const d = new BN(seckey);
    //       if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1
    
    //       let sig;
    //       try {
    //         sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
    //       } catch (err) {
    //         return 1
    //       }
    
    //       obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0);
    //       obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32);
    //       obj.recid = sig.recoveryParam;
    
    //       return 0
    //     },
    
    //     ecdsaVerify (sig, msg32, pubkey) {
    //       const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
    
    //       const sigr = new BN(sigObj.r);
    //       const sigs = new BN(sigObj.s);
    //       if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1
    //       if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3
    
    //       const pair = loadPublicKey(pubkey);
    //       if (pair === null) return 2
    
    //       const point = pair.getPublic();
    //       const isValid = ec.verify(msg32, sigObj, point);
    //       return isValid ? 0 : 3
    //     },
    
    //     ecdsaRecover (output, sig, recid, msg32) {
    //       const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
    
    //       const sigr = new BN(sigObj.r);
    //       const sigs = new BN(sigObj.s);
    //       if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1
    
    //       if (sigr.isZero() || sigs.isZero()) return 2
    
    //       // Can throw `throw new Error('Unable to find sencond key candinate');`
    //       let point;
    //       try {
    //         point = ec.recoverPubKey(msg32, sigObj, recid);
    //       } catch (err) {
    //         return 2
    //       }
    
    //       savePublicKey(output, point);
    
    //       return 0
    //     },
    
    //     ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
    //       const pair = loadPublicKey(pubkey);
    //       if (pair === null) return 1
    
    //       const scalar = new BN(seckey);
    //       if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2
    
    //       const point = pair.getPublic().mul(scalar);
    
    //       if (hashfn === undefined) {
    //         const data = point.encode(null, true);
    //         const sha256 = ec.hash().update(data).digest();
    //         for (let i = 0; i < 32; ++i) output[i] = sha256[i];
    //       } else {
    //         if (!xbuf) xbuf = new Uint8Array(32);
    //         const x = point.getX().toArray('be', 32);
    //         for (let i = 0; i < 32; ++i) xbuf[i] = x[i];
    
    //         if (!ybuf) ybuf = new Uint8Array(32);
    //         const y = point.getY().toArray('be', 32);
    //         for (let i = 0; i < 32; ++i) ybuf[i] = y[i];
    
    //         const hash = hashfn(xbuf, ybuf, data);
    
    //         const isValid = hash instanceof Uint8Array && hash.length === output.length;
    //         if (!isValid) return 2
    
    //         output.set(hash);
    //       }
    
    //       return 0
    //     }
    //   };
    
    //   var elliptic = lib(elliptic$1);
    
    //   var secp256k1 = elliptic;
    
    //   var sha3 = {exports: {}};
    
    //   (function (module) {
    //   /*jslint bitwise: true */
    //   (function () {
    
    //     var INPUT_ERROR = 'input is invalid type';
    //     var FINALIZE_ERROR = 'finalize already called';
    //     var WINDOW = typeof window === 'object';
    //     var root = WINDOW ? window : {};
    //     if (root.JS_SHA3_NO_WINDOW) {
    //       WINDOW = false;
    //     }
    //     var WEB_WORKER = !WINDOW && typeof self === 'object';
    //     var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
    //     if (NODE_JS) {
    //       root = commonjsGlobal;
    //     } else if (WEB_WORKER) {
    //       root = self;
    //     }
    //     var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;
    //     var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
    //     var HEX_CHARS = '0123456789abcdef'.split('');
    //     var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    //     var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    //     var KECCAK_PADDING = [1, 256, 65536, 16777216];
    //     var PADDING = [6, 1536, 393216, 100663296];
    //     var SHIFT = [0, 8, 16, 24];
    //     var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
    //       0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
    //       2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
    //       2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
    //       2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    //     var BITS = [224, 256, 384, 512];
    //     var SHAKE_BITS = [128, 256];
    //     var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
    //     var CSHAKE_BYTEPAD = {
    //       '128': 168,
    //       '256': 136
    //     };
    
    //     if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    //       Array.isArray = function (obj) {
    //         return Object.prototype.toString.call(obj) === '[object Array]';
    //       };
    //     }
    
    //     if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    //       ArrayBuffer.isView = function (obj) {
    //         return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    //       };
    //     }
    
    //     var createOutputMethod = function (bits, padding, outputType) {
    //       return function (message) {
    //         return new Keccak(bits, padding, bits).update(message)[outputType]();
    //       };
    //     };
    
    //     var createShakeOutputMethod = function (bits, padding, outputType) {
    //       return function (message, outputBits) {
    //         return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    //       };
    //     };
    
    //     var createCshakeOutputMethod = function (bits, padding, outputType) {
    //       return function (message, outputBits, n, s) {
    //         return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    //       };
    //     };
    
    //     var createKmacOutputMethod = function (bits, padding, outputType) {
    //       return function (key, message, outputBits, s) {
    //         return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    //       };
    //     };
    
    //     var createOutputMethods = function (method, createMethod, bits, padding) {
    //       for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
    //         var type = OUTPUT_TYPES[i];
    //         method[type] = createMethod(bits, padding, type);
    //       }
    //       return method;
    //     };
    
    //     var createMethod = function (bits, padding) {
    //       var method = createOutputMethod(bits, padding, 'hex');
    //       method.create = function () {
    //         return new Keccak(bits, padding, bits);
    //       };
    //       method.update = function (message) {
    //         return method.create().update(message);
    //       };
    //       return createOutputMethods(method, createOutputMethod, bits, padding);
    //     };
    
    //     var createShakeMethod = function (bits, padding) {
    //       var method = createShakeOutputMethod(bits, padding, 'hex');
    //       method.create = function (outputBits) {
    //         return new Keccak(bits, padding, outputBits);
    //       };
    //       method.update = function (message, outputBits) {
    //         return method.create(outputBits).update(message);
    //       };
    //       return createOutputMethods(method, createShakeOutputMethod, bits, padding);
    //     };
    
    //     var createCshakeMethod = function (bits, padding) {
    //       var w = CSHAKE_BYTEPAD[bits];
    //       var method = createCshakeOutputMethod(bits, padding, 'hex');
    //       method.create = function (outputBits, n, s) {
    //         if (!n && !s) {
    //           return methods['shake' + bits].create(outputBits);
    //         } else {
    //           return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
    //         }
    //       };
    //       method.update = function (message, outputBits, n, s) {
    //         return method.create(outputBits, n, s).update(message);
    //       };
    //       return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
    //     };
    
    //     var createKmacMethod = function (bits, padding) {
    //       var w = CSHAKE_BYTEPAD[bits];
    //       var method = createKmacOutputMethod(bits, padding, 'hex');
    //       method.create = function (key, outputBits, s) {
    //         return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    //       };
    //       method.update = function (key, message, outputBits, s) {
    //         return method.create(key, outputBits, s).update(message);
    //       };
    //       return createOutputMethods(method, createKmacOutputMethod, bits, padding);
    //     };
    
    //     var algorithms = [
    //       { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
    //       { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
    //       { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
    //       { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
    //       { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    //     ];
    
    //     var methods = {}, methodNames = [];
    
    //     for (var i = 0; i < algorithms.length; ++i) {
    //       var algorithm = algorithms[i];
    //       var bits = algorithm.bits;
    //       for (var j = 0; j < bits.length; ++j) {
    //         var methodName = algorithm.name + '_' + bits[j];
    //         methodNames.push(methodName);
    //         methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
    //         if (algorithm.name !== 'sha3') {
    //           var newMethodName = algorithm.name + bits[j];
    //           methodNames.push(newMethodName);
    //           methods[newMethodName] = methods[methodName];
    //         }
    //       }
    //     }
    
    //     function Keccak(bits, padding, outputBits) {
    //       this.blocks = [];
    //       this.s = [];
    //       this.padding = padding;
    //       this.outputBits = outputBits;
    //       this.reset = true;
    //       this.finalized = false;
    //       this.block = 0;
    //       this.start = 0;
    //       this.blockCount = (1600 - (bits << 1)) >> 5;
    //       this.byteCount = this.blockCount << 2;
    //       this.outputBlocks = outputBits >> 5;
    //       this.extraBytes = (outputBits & 31) >> 3;
    
    //       for (var i = 0; i < 50; ++i) {
    //         this.s[i] = 0;
    //       }
    //     }
    
    //     Keccak.prototype.update = function (message) {
    //       if (this.finalized) {
    //         throw new Error(FINALIZE_ERROR);
    //       }
    //       var notString, type = typeof message;
    //       if (type !== 'string') {
    //         if (type === 'object') {
    //           if (message === null) {
    //             throw new Error(INPUT_ERROR);
    //           } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
    //             message = new Uint8Array(message);
    //           } else if (!Array.isArray(message)) {
    //             if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
    //               throw new Error(INPUT_ERROR);
    //             }
    //           }
    //         } else {
    //           throw new Error(INPUT_ERROR);
    //         }
    //         notString = true;
    //       }
    //       var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
    //         blockCount = this.blockCount, index = 0, s = this.s, i, code;
    
    //       while (index < length) {
    //         if (this.reset) {
    //           this.reset = false;
    //           blocks[0] = this.block;
    //           for (i = 1; i < blockCount + 1; ++i) {
    //             blocks[i] = 0;
    //           }
    //         }
    //         if (notString) {
    //           for (i = this.start; index < length && i < byteCount; ++index) {
    //             blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
    //           }
    //         } else {
    //           for (i = this.start; index < length && i < byteCount; ++index) {
    //             code = message.charCodeAt(index);
    //             if (code < 0x80) {
    //               blocks[i >> 2] |= code << SHIFT[i++ & 3];
    //             } else if (code < 0x800) {
    //               blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
    //               blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
    //             } else if (code < 0xd800 || code >= 0xe000) {
    //               blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
    //               blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
    //               blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
    //             } else {
    //               code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
    //               blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
    //               blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
    //               blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
    //               blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
    //             }
    //           }
    //         }
    //         this.lastByteIndex = i;
    //         if (i >= byteCount) {
    //           this.start = i - byteCount;
    //           this.block = blocks[blockCount];
    //           for (i = 0; i < blockCount; ++i) {
    //             s[i] ^= blocks[i];
    //           }
    //           f(s);
    //           this.reset = true;
    //         } else {
    //           this.start = i;
    //         }
    //       }
    //       return this;
    //     };
    
    //     Keccak.prototype.encode = function (x, right) {
    //       var o = x & 255, n = 1;
    //       var bytes = [o];
    //       x = x >> 8;
    //       o = x & 255;
    //       while (o > 0) {
    //         bytes.unshift(o);
    //         x = x >> 8;
    //         o = x & 255;
    //         ++n;
    //       }
    //       if (right) {
    //         bytes.push(n);
    //       } else {
    //         bytes.unshift(n);
    //       }
    //       this.update(bytes);
    //       return bytes.length;
    //     };
    
    //     Keccak.prototype.encodeString = function (str) {
    //       var notString, type = typeof str;
    //       if (type !== 'string') {
    //         if (type === 'object') {
    //           if (str === null) {
    //             throw new Error(INPUT_ERROR);
    //           } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
    //             str = new Uint8Array(str);
    //           } else if (!Array.isArray(str)) {
    //             if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
    //               throw new Error(INPUT_ERROR);
    //             }
    //           }
    //         } else {
    //           throw new Error(INPUT_ERROR);
    //         }
    //         notString = true;
    //       }
    //       var bytes = 0, length = str.length;
    //       if (notString) {
    //         bytes = length;
    //       } else {
    //         for (var i = 0; i < str.length; ++i) {
    //           var code = str.charCodeAt(i);
    //           if (code < 0x80) {
    //             bytes += 1;
    //           } else if (code < 0x800) {
    //             bytes += 2;
    //           } else if (code < 0xd800 || code >= 0xe000) {
    //             bytes += 3;
    //           } else {
    //             code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
    //             bytes += 4;
    //           }
    //         }
    //       }
    //       bytes += this.encode(bytes * 8);
    //       this.update(str);
    //       return bytes;
    //     };
    
    //     Keccak.prototype.bytepad = function (strs, w) {
    //       var bytes = this.encode(w);
    //       for (var i = 0; i < strs.length; ++i) {
    //         bytes += this.encodeString(strs[i]);
    //       }
    //       var paddingBytes = w - bytes % w;
    //       var zeros = [];
    //       zeros.length = paddingBytes;
    //       this.update(zeros);
    //       return this;
    //     };
    
    //     Keccak.prototype.finalize = function () {
    //       if (this.finalized) {
    //         return;
    //       }
    //       this.finalized = true;
    //       var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    //       blocks[i >> 2] |= this.padding[i & 3];
    //       if (this.lastByteIndex === this.byteCount) {
    //         blocks[0] = blocks[blockCount];
    //         for (i = 1; i < blockCount + 1; ++i) {
    //           blocks[i] = 0;
    //         }
    //       }
    //       blocks[blockCount - 1] |= 0x80000000;
    //       for (i = 0; i < blockCount; ++i) {
    //         s[i] ^= blocks[i];
    //       }
    //       f(s);
    //     };
    
    //     Keccak.prototype.toString = Keccak.prototype.hex = function () {
    //       this.finalize();
    
    //       var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
    //         extraBytes = this.extraBytes, i = 0, j = 0;
    //       var hex = '', block;
    //       while (j < outputBlocks) {
    //         for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
    //           block = s[i];
    //           hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
    //             HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
    //             HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
    //             HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
    //         }
    //         if (j % blockCount === 0) {
    //           f(s);
    //           i = 0;
    //         }
    //       }
    //       if (extraBytes) {
    //         block = s[i];
    //         hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
    //         if (extraBytes > 1) {
    //           hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
    //         }
    //         if (extraBytes > 2) {
    //           hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
    //         }
    //       }
    //       return hex;
    //     };
    
    //     Keccak.prototype.arrayBuffer = function () {
    //       this.finalize();
    
    //       var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
    //         extraBytes = this.extraBytes, i = 0, j = 0;
    //       var bytes = this.outputBits >> 3;
    //       var buffer;
    //       if (extraBytes) {
    //         buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    //       } else {
    //         buffer = new ArrayBuffer(bytes);
    //       }
    //       var array = new Uint32Array(buffer);
    //       while (j < outputBlocks) {
    //         for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
    //           array[j] = s[i];
    //         }
    //         if (j % blockCount === 0) {
    //           f(s);
    //         }
    //       }
    //       if (extraBytes) {
    //         array[i] = s[i];
    //         buffer = buffer.slice(0, bytes);
    //       }
    //       return buffer;
    //     };
    
    //     Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    
    //     Keccak.prototype.digest = Keccak.prototype.array = function () {
    //       this.finalize();
    
    //       var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
    //         extraBytes = this.extraBytes, i = 0, j = 0;
    //       var array = [], offset, block;
    //       while (j < outputBlocks) {
    //         for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
    //           offset = j << 2;
    //           block = s[i];
    //           array[offset] = block & 0xFF;
    //           array[offset + 1] = (block >> 8) & 0xFF;
    //           array[offset + 2] = (block >> 16) & 0xFF;
    //           array[offset + 3] = (block >> 24) & 0xFF;
    //         }
    //         if (j % blockCount === 0) {
    //           f(s);
    //         }
    //       }
    //       if (extraBytes) {
    //         offset = j << 2;
    //         block = s[i];
    //         array[offset] = block & 0xFF;
    //         if (extraBytes > 1) {
    //           array[offset + 1] = (block >> 8) & 0xFF;
    //         }
    //         if (extraBytes > 2) {
    //           array[offset + 2] = (block >> 16) & 0xFF;
    //         }
    //       }
    //       return array;
    //     };
    
    //     function Kmac(bits, padding, outputBits) {
    //       Keccak.call(this, bits, padding, outputBits);
    //     }
    
    //     Kmac.prototype = new Keccak();
    
    //     Kmac.prototype.finalize = function () {
    //       this.encode(this.outputBits, true);
    //       return Keccak.prototype.finalize.call(this);
    //     };
    
    //     var f = function (s) {
    //       var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
    //         b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
    //         b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
    //         b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    //       for (n = 0; n < 48; n += 2) {
    //         c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
    //         c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
    //         c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
    //         c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
    //         c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
    //         c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
    //         c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
    //         c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
    //         c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
    //         c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
    
    //         h = c8 ^ ((c2 << 1) | (c3 >>> 31));
    //         l = c9 ^ ((c3 << 1) | (c2 >>> 31));
    //         s[0] ^= h;
    //         s[1] ^= l;
    //         s[10] ^= h;
    //         s[11] ^= l;
    //         s[20] ^= h;
    //         s[21] ^= l;
    //         s[30] ^= h;
    //         s[31] ^= l;
    //         s[40] ^= h;
    //         s[41] ^= l;
    //         h = c0 ^ ((c4 << 1) | (c5 >>> 31));
    //         l = c1 ^ ((c5 << 1) | (c4 >>> 31));
    //         s[2] ^= h;
    //         s[3] ^= l;
    //         s[12] ^= h;
    //         s[13] ^= l;
    //         s[22] ^= h;
    //         s[23] ^= l;
    //         s[32] ^= h;
    //         s[33] ^= l;
    //         s[42] ^= h;
    //         s[43] ^= l;
    //         h = c2 ^ ((c6 << 1) | (c7 >>> 31));
    //         l = c3 ^ ((c7 << 1) | (c6 >>> 31));
    //         s[4] ^= h;
    //         s[5] ^= l;
    //         s[14] ^= h;
    //         s[15] ^= l;
    //         s[24] ^= h;
    //         s[25] ^= l;
    //         s[34] ^= h;
    //         s[35] ^= l;
    //         s[44] ^= h;
    //         s[45] ^= l;
    //         h = c4 ^ ((c8 << 1) | (c9 >>> 31));
    //         l = c5 ^ ((c9 << 1) | (c8 >>> 31));
    //         s[6] ^= h;
    //         s[7] ^= l;
    //         s[16] ^= h;
    //         s[17] ^= l;
    //         s[26] ^= h;
    //         s[27] ^= l;
    //         s[36] ^= h;
    //         s[37] ^= l;
    //         s[46] ^= h;
    //         s[47] ^= l;
    //         h = c6 ^ ((c0 << 1) | (c1 >>> 31));
    //         l = c7 ^ ((c1 << 1) | (c0 >>> 31));
    //         s[8] ^= h;
    //         s[9] ^= l;
    //         s[18] ^= h;
    //         s[19] ^= l;
    //         s[28] ^= h;
    //         s[29] ^= l;
    //         s[38] ^= h;
    //         s[39] ^= l;
    //         s[48] ^= h;
    //         s[49] ^= l;
    
    //         b0 = s[0];
    //         b1 = s[1];
    //         b32 = (s[11] << 4) | (s[10] >>> 28);
    //         b33 = (s[10] << 4) | (s[11] >>> 28);
    //         b14 = (s[20] << 3) | (s[21] >>> 29);
    //         b15 = (s[21] << 3) | (s[20] >>> 29);
    //         b46 = (s[31] << 9) | (s[30] >>> 23);
    //         b47 = (s[30] << 9) | (s[31] >>> 23);
    //         b28 = (s[40] << 18) | (s[41] >>> 14);
    //         b29 = (s[41] << 18) | (s[40] >>> 14);
    //         b20 = (s[2] << 1) | (s[3] >>> 31);
    //         b21 = (s[3] << 1) | (s[2] >>> 31);
    //         b2 = (s[13] << 12) | (s[12] >>> 20);
    //         b3 = (s[12] << 12) | (s[13] >>> 20);
    //         b34 = (s[22] << 10) | (s[23] >>> 22);
    //         b35 = (s[23] << 10) | (s[22] >>> 22);
    //         b16 = (s[33] << 13) | (s[32] >>> 19);
    //         b17 = (s[32] << 13) | (s[33] >>> 19);
    //         b48 = (s[42] << 2) | (s[43] >>> 30);
    //         b49 = (s[43] << 2) | (s[42] >>> 30);
    //         b40 = (s[5] << 30) | (s[4] >>> 2);
    //         b41 = (s[4] << 30) | (s[5] >>> 2);
    //         b22 = (s[14] << 6) | (s[15] >>> 26);
    //         b23 = (s[15] << 6) | (s[14] >>> 26);
    //         b4 = (s[25] << 11) | (s[24] >>> 21);
    //         b5 = (s[24] << 11) | (s[25] >>> 21);
    //         b36 = (s[34] << 15) | (s[35] >>> 17);
    //         b37 = (s[35] << 15) | (s[34] >>> 17);
    //         b18 = (s[45] << 29) | (s[44] >>> 3);
    //         b19 = (s[44] << 29) | (s[45] >>> 3);
    //         b10 = (s[6] << 28) | (s[7] >>> 4);
    //         b11 = (s[7] << 28) | (s[6] >>> 4);
    //         b42 = (s[17] << 23) | (s[16] >>> 9);
    //         b43 = (s[16] << 23) | (s[17] >>> 9);
    //         b24 = (s[26] << 25) | (s[27] >>> 7);
    //         b25 = (s[27] << 25) | (s[26] >>> 7);
    //         b6 = (s[36] << 21) | (s[37] >>> 11);
    //         b7 = (s[37] << 21) | (s[36] >>> 11);
    //         b38 = (s[47] << 24) | (s[46] >>> 8);
    //         b39 = (s[46] << 24) | (s[47] >>> 8);
    //         b30 = (s[8] << 27) | (s[9] >>> 5);
    //         b31 = (s[9] << 27) | (s[8] >>> 5);
    //         b12 = (s[18] << 20) | (s[19] >>> 12);
    //         b13 = (s[19] << 20) | (s[18] >>> 12);
    //         b44 = (s[29] << 7) | (s[28] >>> 25);
    //         b45 = (s[28] << 7) | (s[29] >>> 25);
    //         b26 = (s[38] << 8) | (s[39] >>> 24);
    //         b27 = (s[39] << 8) | (s[38] >>> 24);
    //         b8 = (s[48] << 14) | (s[49] >>> 18);
    //         b9 = (s[49] << 14) | (s[48] >>> 18);
    
    //         s[0] = b0 ^ (~b2 & b4);
    //         s[1] = b1 ^ (~b3 & b5);
    //         s[10] = b10 ^ (~b12 & b14);
    //         s[11] = b11 ^ (~b13 & b15);
    //         s[20] = b20 ^ (~b22 & b24);
    //         s[21] = b21 ^ (~b23 & b25);
    //         s[30] = b30 ^ (~b32 & b34);
    //         s[31] = b31 ^ (~b33 & b35);
    //         s[40] = b40 ^ (~b42 & b44);
    //         s[41] = b41 ^ (~b43 & b45);
    //         s[2] = b2 ^ (~b4 & b6);
    //         s[3] = b3 ^ (~b5 & b7);
    //         s[12] = b12 ^ (~b14 & b16);
    //         s[13] = b13 ^ (~b15 & b17);
    //         s[22] = b22 ^ (~b24 & b26);
    //         s[23] = b23 ^ (~b25 & b27);
    //         s[32] = b32 ^ (~b34 & b36);
    //         s[33] = b33 ^ (~b35 & b37);
    //         s[42] = b42 ^ (~b44 & b46);
    //         s[43] = b43 ^ (~b45 & b47);
    //         s[4] = b4 ^ (~b6 & b8);
    //         s[5] = b5 ^ (~b7 & b9);
    //         s[14] = b14 ^ (~b16 & b18);
    //         s[15] = b15 ^ (~b17 & b19);
    //         s[24] = b24 ^ (~b26 & b28);
    //         s[25] = b25 ^ (~b27 & b29);
    //         s[34] = b34 ^ (~b36 & b38);
    //         s[35] = b35 ^ (~b37 & b39);
    //         s[44] = b44 ^ (~b46 & b48);
    //         s[45] = b45 ^ (~b47 & b49);
    //         s[6] = b6 ^ (~b8 & b0);
    //         s[7] = b7 ^ (~b9 & b1);
    //         s[16] = b16 ^ (~b18 & b10);
    //         s[17] = b17 ^ (~b19 & b11);
    //         s[26] = b26 ^ (~b28 & b20);
    //         s[27] = b27 ^ (~b29 & b21);
    //         s[36] = b36 ^ (~b38 & b30);
    //         s[37] = b37 ^ (~b39 & b31);
    //         s[46] = b46 ^ (~b48 & b40);
    //         s[47] = b47 ^ (~b49 & b41);
    //         s[8] = b8 ^ (~b0 & b2);
    //         s[9] = b9 ^ (~b1 & b3);
    //         s[18] = b18 ^ (~b10 & b12);
    //         s[19] = b19 ^ (~b11 & b13);
    //         s[28] = b28 ^ (~b20 & b22);
    //         s[29] = b29 ^ (~b21 & b23);
    //         s[38] = b38 ^ (~b30 & b32);
    //         s[39] = b39 ^ (~b31 & b33);
    //         s[48] = b48 ^ (~b40 & b42);
    //         s[49] = b49 ^ (~b41 & b43);
    
    //         s[0] ^= RC[n];
    //         s[1] ^= RC[n + 1];
    //       }
    //     };
    
    //     if (COMMON_JS) {
    //       module.exports = methods;
    //     } else {
    //       for (i = 0; i < methodNames.length; ++i) {
    //         root[methodNames[i]] = methods[methodNames[i]];
    //       }
    //     }
    //   })();
    //   }(sha3));
    
    //   const toBuffer = arr => {
    //     if (buffer.Buffer.isBuffer(arr)) {
    //       return arr;
    //     } else if (arr instanceof Uint8Array) {
    //       return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
    //     } else {
    //       return buffer.Buffer.from(arr);
    //     }
    //   };
    
    //   class Struct {
    //     constructor(properties) {
    //       Object.assign(this, properties);
    //     }
    
    //     encode() {
    //       return buffer.Buffer.from(serialize_1(SOLANA_SCHEMA, this));
    //     }
    
    //     static decode(data) {
    //       return deserialize_1(SOLANA_SCHEMA, this, data);
    //     }
    
    //     static decodeUnchecked(data) {
    //       return deserializeUnchecked_1(SOLANA_SCHEMA, this, data);
    //     }
    
    //   } // Class representing a Rust-compatible enum, since enums are only strings or
    //   const SOLANA_SCHEMA = new Map();
    
    //   /**
    //    * Maximum length of derived pubkey seed
    //    */
    
    //   const MAX_SEED_LENGTH = 32;
    
    //   function isPublicKeyData(value) {
    //     return value._bn !== undefined;
    //   }
    //   /**
    //    * A public key
    //    */
    
    
    //   class PublicKey extends Struct {
    //     /** @internal */
    
    //     /**
    //      * Create a new PublicKey object
    //      * @param value ed25519 public key as buffer or base-58 encoded string
    //      */
    //     constructor(value) {
    //       super({});
    
    //       _defineProperty(this, "_bn", void 0);
    
    //       if (isPublicKeyData(value)) {
    //         this._bn = value._bn;
    //       } else {
    //         if (typeof value === 'string') {
    //           // assume base 58 encoding by default
    //           const decoded = bs58$1.decode(value);
    
    //           if (decoded.length != 32) {
    //             throw new Error(`Invalid public key input`);
    //           }
    
    //           this._bn = new BN$9(decoded);
    //         } else {
    //           this._bn = new BN$9(value);
    //         }
    
    //         if (this._bn.byteLength() > 32) {
    //           throw new Error(`Invalid public key input`);
    //         }
    //       }
    //     }
    //     /**
    //      * Default public key value. (All zeros)
    //      */
    
    
    //     /**
    //      * Checks if two publicKeys are equal
    //      */
    //     equals(publicKey) {
    //       return this._bn.eq(publicKey._bn);
    //     }
    //     /**
    //      * Return the base-58 representation of the public key
    //      */
    
    
    //     toBase58() {
    //       return bs58$1.encode(this.toBytes());
    //     }
    //     /**
    //      * Return the byte array representation of the public key
    //      */
    
    
    //     toBytes() {
    //       return this.toBuffer();
    //     }
    //     /**
    //      * Return the Buffer representation of the public key
    //      */
    
    
    //     toBuffer() {
    //       const b = this._bn.toArrayLike(buffer.Buffer);
    
    //       if (b.length === 32) {
    //         return b;
    //       }
    
    //       const zeroPad = buffer.Buffer.alloc(32);
    //       b.copy(zeroPad, 32 - b.length);
    //       return zeroPad;
    //     }
    //     /**
    //      * Return the base-58 representation of the public key
    //      */
    
    
    //     toString() {
    //       return this.toBase58();
    //     }
    //     /**
    //      * Derive a public key from another key, a seed, and a program ID.
    //      * The program ID will also serve as the owner of the public key, giving
    //      * it permission to write data to the account.
    //      */
    
    
    //     static async createWithSeed(fromPublicKey, seed, programId) {
    //       const buffer$1 = buffer.Buffer.concat([fromPublicKey.toBuffer(), buffer.Buffer.from(seed), programId.toBuffer()]);
    //       const hash = await sha256(new Uint8Array(buffer$1));
    //       return new PublicKey(buffer.Buffer.from(hash, 'hex'));
    //     }
    //     /**
    //      * Derive a program address from seeds and a program ID.
    //      */
    
    
    //     static async createProgramAddress(seeds, programId) {
    //       let buffer$1 = buffer.Buffer.alloc(0);
    //       seeds.forEach(function (seed) {
    //         if (seed.length > MAX_SEED_LENGTH) {
    //           throw new TypeError(`Max seed length exceeded`);
    //         }
    
    //         buffer$1 = buffer.Buffer.concat([buffer$1, toBuffer(seed)]);
    //       });
    //       buffer$1 = buffer.Buffer.concat([buffer$1, programId.toBuffer(), buffer.Buffer.from('ProgramDerivedAddress')]);
    //       let hash = await sha256(new Uint8Array(buffer$1));
    //       let publicKeyBytes = new BN$9(hash, 16).toArray(undefined, 32);
    
    //       if (is_on_curve(publicKeyBytes)) {
    //         throw new Error(`Invalid seeds, address must fall off the curve`);
    //       }
    
    //       return new PublicKey(publicKeyBytes);
    //     }
    //     /**
    //      * Find a valid program address
    //      *
    //      * Valid program addresses must fall off the ed25519 curve.  This function
    //      * iterates a nonce until it finds one that when combined with the seeds
    //      * results in a valid program address.
    //      */
    
    
    //     static async findProgramAddress(seeds, programId) {
    //       let nonce = 255;
    //       let address;
    
    //       while (nonce != 0) {
    //         try {
    //           const seedsWithNonce = seeds.concat(buffer.Buffer.from([nonce]));
    //           address = await this.createProgramAddress(seedsWithNonce, programId);
    //         } catch (err) {
    //           if (err instanceof TypeError) {
    //             throw err;
    //           }
    
    //           nonce--;
    //           continue;
    //         }
    
    //         return [address, nonce];
    //       }
    
    //       throw new Error(`Unable to find a viable program address nonce`);
    //     }
    //     /**
    //      * Check that a pubkey is on the ed25519 curve.
    //      */
    
    
    //     static isOnCurve(pubkey) {
    //       return is_on_curve(pubkey) == 1;
    //     }
    
    //   }
    
    //   _defineProperty(PublicKey, "default", new PublicKey('11111111111111111111111111111111'));
    
    //   SOLANA_SCHEMA.set(PublicKey, {
    //     kind: 'struct',
    //     fields: [['_bn', 'u256']]
    //   }); // @ts-ignore
    
    //   let naclLowLevel = nacl__default.lowlevel; // Check that a pubkey is on the curve.
    //   // This function and its dependents were sourced from:
    //   // https://github.com/dchest/tweetnacl-js/blob/f1ec050ceae0861f34280e62498b1d3ed9c350c6/nacl.js#L792
    
    //   function is_on_curve(p) {
    //     var r = [naclLowLevel.gf(), naclLowLevel.gf(), naclLowLevel.gf(), naclLowLevel.gf()];
    //     var t = naclLowLevel.gf(),
    //         chk = naclLowLevel.gf(),
    //         num = naclLowLevel.gf(),
    //         den = naclLowLevel.gf(),
    //         den2 = naclLowLevel.gf(),
    //         den4 = naclLowLevel.gf(),
    //         den6 = naclLowLevel.gf();
    //     naclLowLevel.set25519(r[2], gf1);
    //     naclLowLevel.unpack25519(r[1], p);
    //     naclLowLevel.S(num, r[1]);
    //     naclLowLevel.M(den, num, naclLowLevel.D);
    //     naclLowLevel.Z(num, num, r[2]);
    //     naclLowLevel.A(den, r[2], den);
    //     naclLowLevel.S(den2, den);
    //     naclLowLevel.S(den4, den2);
    //     naclLowLevel.M(den6, den4, den2);
    //     naclLowLevel.M(t, den6, num);
    //     naclLowLevel.M(t, t, den);
    //     naclLowLevel.pow2523(t, t);
    //     naclLowLevel.M(t, t, num);
    //     naclLowLevel.M(t, t, den);
    //     naclLowLevel.M(t, t, den);
    //     naclLowLevel.M(r[0], t, den);
    //     naclLowLevel.S(chk, r[0]);
    //     naclLowLevel.M(chk, chk, den);
    //     if (neq25519(chk, num)) naclLowLevel.M(r[0], r[0], I);
    //     naclLowLevel.S(chk, r[0]);
    //     naclLowLevel.M(chk, chk, den);
    //     if (neq25519(chk, num)) return 0;
    //     return 1;
    //   }
    
    //   let gf1 = naclLowLevel.gf([1]);
    //   let I = naclLowLevel.gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);
    
    //   function neq25519(a, b) {
    //     var c = new Uint8Array(32),
    //         d = new Uint8Array(32);
    //     naclLowLevel.pack25519(c, a);
    //     naclLowLevel.pack25519(d, b);
    //     return naclLowLevel.crypto_verify_32(c, 0, d, 0);
    //   }
    
    //   new PublicKey('BPFLoader1111111111111111111111111111111111');
    
    //   /**
    //    * Layout for a public key
    //    */
    
    //   const publicKey$1 = (property = 'publicKey') => {
    //     return blob(32, property);
    //   };
    //   /**
    //    * Layout for a Rust String type
    //    */
    
    //   const rustString = (property = 'string') => {
    //     const rsl = struct([u32('length'), u32('lengthPadding'), blob(offset(u32(), -8), 'chars')], property);
    
    //     const _decode = rsl.decode.bind(rsl);
    
    //     const _encode = rsl.encode.bind(rsl);
    
    //     rsl.decode = (buffer, offset) => {
    //       const data = _decode(buffer, offset);
    
    //       return data['chars'].toString('utf8');
    //     };
    
    //     rsl.encode = (str, buffer$1, offset) => {
    //       const data = {
    //         chars: buffer.Buffer.from(str, 'utf8')
    //       };
    //       return _encode(data, buffer$1, offset);
    //     };
    
    //     rsl.alloc = str => {
    //       return u32().span + u32().span + buffer.Buffer.from(str, 'utf8').length;
    //     };
    
    //     return rsl;
    //   };
    //   /**
    //    * Layout for an Authorized object
    //    */
    
    //   const authorized = (property = 'authorized') => {
    //     return struct([publicKey$1('staker'), publicKey$1('withdrawer')], property);
    //   };
    //   /**
    //    * Layout for a Lockup object
    //    */
    
    //   const lockup = (property = 'lockup') => {
    //     return struct([ns64('unixTimestamp'), ns64('epoch'), publicKey$1('custodian')], property);
    //   };
    //   function getAlloc(type, fields) {
    //     let alloc = 0;
    //     type.layout.fields.forEach(item => {
    //       if (item.span >= 0) {
    //         alloc += item.span;
    //       } else if (typeof item.alloc === 'function') {
    //         alloc += item.alloc(fields[item.property]);
    //       }
    //     });
    //     return alloc;
    //   }
    
    //   function decodeLength(bytes) {
    //     let len = 0;
    //     let size = 0;
    
    //     for (;;) {
    //       let elem = bytes.shift();
    //       len |= (elem & 0x7f) << size * 7;
    //       size += 1;
    
    //       if ((elem & 0x80) === 0) {
    //         break;
    //       }
    //     }
    
    //     return len;
    //   }
    //   function encodeLength(bytes, len) {
    //     let rem_len = len;
    
    //     for (;;) {
    //       let elem = rem_len & 0x7f;
    //       rem_len >>= 7;
    
    //       if (rem_len == 0) {
    //         bytes.push(elem);
    //         break;
    //       } else {
    //         elem |= 0x80;
    //         bytes.push(elem);
    //       }
    //     }
    //   }
    
    //   /**
    //    * The message header, identifying signed and read-only account
    //    */
    
    //   const PUBKEY_LENGTH = 32;
    //   /**
    //    * List of instructions to be processed atomically
    //    */
    
    //   class Message {
    //     constructor(args) {
    //       _defineProperty(this, "header", void 0);
    
    //       _defineProperty(this, "accountKeys", void 0);
    
    //       _defineProperty(this, "recentBlockhash", void 0);
    
    //       _defineProperty(this, "instructions", void 0);
    
    //       this.header = args.header;
    //       this.accountKeys = args.accountKeys.map(account => new PublicKey(account));
    //       this.recentBlockhash = args.recentBlockhash;
    //       this.instructions = args.instructions;
    //     }
    
    //     isAccountWritable(index) {
    //       return index < this.header.numRequiredSignatures - this.header.numReadonlySignedAccounts || index >= this.header.numRequiredSignatures && index < this.accountKeys.length - this.header.numReadonlyUnsignedAccounts;
    //     }
    
    //     serialize() {
    //       const numKeys = this.accountKeys.length;
    //       let keyCount = [];
    //       encodeLength(keyCount, numKeys);
    //       const instructions = this.instructions.map(instruction => {
    //         const {
    //           accounts,
    //           programIdIndex
    //         } = instruction;
    //         const data = bs58$1.decode(instruction.data);
    //         let keyIndicesCount = [];
    //         encodeLength(keyIndicesCount, accounts.length);
    //         let dataCount = [];
    //         encodeLength(dataCount, data.length);
    //         return {
    //           programIdIndex,
    //           keyIndicesCount: buffer.Buffer.from(keyIndicesCount),
    //           keyIndices: buffer.Buffer.from(accounts),
    //           dataLength: buffer.Buffer.from(dataCount),
    //           data
    //         };
    //       });
    //       let instructionCount = [];
    //       encodeLength(instructionCount, instructions.length);
    //       let instructionBuffer = buffer.Buffer.alloc(PACKET_DATA_SIZE);
    //       buffer.Buffer.from(instructionCount).copy(instructionBuffer);
    //       let instructionBufferLength = instructionCount.length;
    //       instructions.forEach(instruction => {
    //         const instructionLayout = struct([u8('programIdIndex'), blob(instruction.keyIndicesCount.length, 'keyIndicesCount'), seq(u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), blob(instruction.dataLength.length, 'dataLength'), seq(u8('userdatum'), instruction.data.length, 'data')]);
    //         const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
    //         instructionBufferLength += length;
    //       });
    //       instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    //       const signDataLayout = struct([blob(1, 'numRequiredSignatures'), blob(1, 'numReadonlySignedAccounts'), blob(1, 'numReadonlyUnsignedAccounts'), blob(keyCount.length, 'keyCount'), seq(publicKey$1('key'), numKeys, 'keys'), publicKey$1('recentBlockhash')]);
    //       const transaction = {
    //         numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),
    //         numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
    //         numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
    //         keyCount: buffer.Buffer.from(keyCount),
    //         keys: this.accountKeys.map(key => toBuffer(key.toBytes())),
    //         recentBlockhash: bs58$1.decode(this.recentBlockhash)
    //       };
    //       let signData = buffer.Buffer.alloc(2048);
    //       const length = signDataLayout.encode(transaction, signData);
    //       instructionBuffer.copy(signData, length);
    //       return signData.slice(0, length + instructionBuffer.length);
    //     }
    //     /**
    //      * Decode a compiled message into a Message object.
    //      */
    
    
    //     static from(buffer$1) {
    //       // Slice up wire data
    //       let byteArray = [...buffer$1];
    //       const numRequiredSignatures = byteArray.shift();
    //       const numReadonlySignedAccounts = byteArray.shift();
    //       const numReadonlyUnsignedAccounts = byteArray.shift();
    //       const accountCount = decodeLength(byteArray);
    //       let accountKeys = [];
    
    //       for (let i = 0; i < accountCount; i++) {
    //         const account = byteArray.slice(0, PUBKEY_LENGTH);
    //         byteArray = byteArray.slice(PUBKEY_LENGTH);
    //         accountKeys.push(bs58$1.encode(buffer.Buffer.from(account)));
    //       }
    
    //       const recentBlockhash = byteArray.slice(0, PUBKEY_LENGTH);
    //       byteArray = byteArray.slice(PUBKEY_LENGTH);
    //       const instructionCount = decodeLength(byteArray);
    //       let instructions = [];
    
    //       for (let i = 0; i < instructionCount; i++) {
    //         const programIdIndex = byteArray.shift();
    //         const accountCount = decodeLength(byteArray);
    //         const accounts = byteArray.slice(0, accountCount);
    //         byteArray = byteArray.slice(accountCount);
    //         const dataLength = decodeLength(byteArray);
    //         const dataSlice = byteArray.slice(0, dataLength);
    //         const data = bs58$1.encode(buffer.Buffer.from(dataSlice));
    //         byteArray = byteArray.slice(dataLength);
    //         instructions.push({
    //           programIdIndex,
    //           accounts,
    //           data
    //         });
    //       }
    
    //       const messageArgs = {
    //         header: {
    //           numRequiredSignatures,
    //           numReadonlySignedAccounts,
    //           numReadonlyUnsignedAccounts
    //         },
    //         recentBlockhash: bs58$1.encode(buffer.Buffer.from(recentBlockhash)),
    //         accountKeys,
    //         instructions
    //       };
    //       return new Message(messageArgs);
    //     }
    
    //   }
    
    //   function assert (condition, message) {
    //     if (!condition) {
    //       throw new Error(message || 'Assertion failed');
    //     }
    //   }
    
    //   /**
    //    * Default (empty) signature
    //    *
    //    * Signatures are 64 bytes in length
    //    */
    //   const DEFAULT_SIGNATURE = buffer.Buffer.alloc(64).fill(0);
    //   /**
    //    * Maximum over-the-wire size of a Transaction
    //    *
    //    * 1280 is IPv6 minimum MTU
    //    * 40 bytes is the size of the IPv6 header
    //    * 8 bytes is the size of the fragment header
    //    */
    
    //   const PACKET_DATA_SIZE = 1280 - 40 - 8;
    //   const SIGNATURE_LENGTH = 64;
    //   /**
    //    * Account metadata used to define instructions
    //    */
    
    //   /**
    //    * Transaction Instruction class
    //    */
    //   class TransactionInstruction {
    //     /**
    //      * Public keys to include in this transaction
    //      * Boolean represents whether this pubkey needs to sign the transaction
    //      */
    
    //     /**
    //      * Program Id to execute
    //      */
    
    //     /**
    //      * Program input
    //      */
    //     constructor(opts) {
    //       _defineProperty(this, "keys", void 0);
    
    //       _defineProperty(this, "programId", void 0);
    
    //       _defineProperty(this, "data", buffer.Buffer.alloc(0));
    
    //       this.programId = opts.programId;
    //       this.keys = opts.keys;
    
    //       if (opts.data) {
    //         this.data = opts.data;
    //       }
    //     }
    
    //   }
    //   /**
    //    * Pair of signature and corresponding public key
    //    */
    
    //   /**
    //    * Transaction class
    //    */
    //   class Transaction {
    //     /**
    //      * Signatures for the transaction.  Typically created by invoking the
    //      * `sign()` method
    //      */
    
    //     /**
    //      * The first (payer) Transaction signature
    //      */
    //     get signature() {
    //       if (this.signatures.length > 0) {
    //         return this.signatures[0].signature;
    //       }
    
    //       return null;
    //     }
    //     /**
    //      * The transaction fee payer
    //      */
    
    
    //     /**
    //      * Construct an empty Transaction
    //      */
    //     constructor(opts) {
    //       _defineProperty(this, "signatures", []);
    
    //       _defineProperty(this, "feePayer", void 0);
    
    //       _defineProperty(this, "instructions", []);
    
    //       _defineProperty(this, "recentBlockhash", void 0);
    
    //       _defineProperty(this, "nonceInfo", void 0);
    
    //       opts && Object.assign(this, opts);
    //     }
    //     /**
    //      * Add one or more instructions to this Transaction
    //      */
    
    
    //     add(...items) {
    //       if (items.length === 0) {
    //         throw new Error('No instructions');
    //       }
    
    //       items.forEach(item => {
    //         if ('instructions' in item) {
    //           this.instructions = this.instructions.concat(item.instructions);
    //         } else if ('data' in item && 'programId' in item && 'keys' in item) {
    //           this.instructions.push(item);
    //         } else {
    //           this.instructions.push(new TransactionInstruction(item));
    //         }
    //       });
    //       return this;
    //     }
    //     /**
    //      * Compile transaction data
    //      */
    
    
    //     compileMessage() {
    //       const {
    //         nonceInfo
    //       } = this;
    
    //       if (nonceInfo && this.instructions[0] != nonceInfo.nonceInstruction) {
    //         this.recentBlockhash = nonceInfo.nonce;
    //         this.instructions.unshift(nonceInfo.nonceInstruction);
    //       }
    
    //       const {
    //         recentBlockhash
    //       } = this;
    
    //       if (!recentBlockhash) {
    //         throw new Error('Transaction recentBlockhash required');
    //       }
    
    //       if (this.instructions.length < 1) {
    //         console.warn('No instructions provided');
    //       }
    
    //       let feePayer;
    
    //       if (this.feePayer) {
    //         feePayer = this.feePayer;
    //       } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
    //         // Use implicit fee payer
    //         feePayer = this.signatures[0].publicKey;
    //       } else {
    //         throw new Error('Transaction fee payer required');
    //       }
    
    //       for (let i = 0; i < this.instructions.length; i++) {
    //         if (this.instructions[i].programId === undefined) {
    //           throw new Error(`Transaction instruction index ${i} has undefined program id`);
    //         }
    //       }
    
    //       const programIds = [];
    //       const accountMetas = [];
    //       this.instructions.forEach(instruction => {
    //         instruction.keys.forEach(accountMeta => {
    //           accountMetas.push({ ...accountMeta
    //           });
    //         });
    //         const programId = instruction.programId.toString();
    
    //         if (!programIds.includes(programId)) {
    //           programIds.push(programId);
    //         }
    //       }); // Append programID account metas
    
    //       programIds.forEach(programId => {
    //         accountMetas.push({
    //           pubkey: new PublicKey(programId),
    //           isSigner: false,
    //           isWritable: false
    //         });
    //       }); // Sort. Prioritizing first by signer, then by writable
    
    //       accountMetas.sort(function (x, y) {
    //         const checkSigner = x.isSigner === y.isSigner ? 0 : x.isSigner ? -1 : 1;
    //         const checkWritable = x.isWritable === y.isWritable ? 0 : x.isWritable ? -1 : 1;
    //         return checkSigner || checkWritable;
    //       }); // Cull duplicate account metas
    
    //       const uniqueMetas = [];
    //       accountMetas.forEach(accountMeta => {
    //         const pubkeyString = accountMeta.pubkey.toString();
    //         const uniqueIndex = uniqueMetas.findIndex(x => {
    //           return x.pubkey.toString() === pubkeyString;
    //         });
    
    //         if (uniqueIndex > -1) {
    //           uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
    //         } else {
    //           uniqueMetas.push(accountMeta);
    //         }
    //       }); // Move fee payer to the front
    
    //       const feePayerIndex = uniqueMetas.findIndex(x => {
    //         return x.pubkey.equals(feePayer);
    //       });
    
    //       if (feePayerIndex > -1) {
    //         const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
    //         payerMeta.isSigner = true;
    //         payerMeta.isWritable = true;
    //         uniqueMetas.unshift(payerMeta);
    //       } else {
    //         uniqueMetas.unshift({
    //           pubkey: feePayer,
    //           isSigner: true,
    //           isWritable: true
    //         });
    //       } // Disallow unknown signers
    
    
    //       for (const signature of this.signatures) {
    //         const uniqueIndex = uniqueMetas.findIndex(x => {
    //           return x.pubkey.equals(signature.publicKey);
    //         });
    
    //         if (uniqueIndex > -1) {
    //           if (!uniqueMetas[uniqueIndex].isSigner) {
    //             uniqueMetas[uniqueIndex].isSigner = true;
    //             console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');
    //           }
    //         } else {
    //           throw new Error(`unknown signer: ${signature.publicKey.toString()}`);
    //         }
    //       }
    
    //       let numRequiredSignatures = 0;
    //       let numReadonlySignedAccounts = 0;
    //       let numReadonlyUnsignedAccounts = 0; // Split out signing from non-signing keys and count header values
    
    //       const signedKeys = [];
    //       const unsignedKeys = [];
    //       uniqueMetas.forEach(({
    //         pubkey,
    //         isSigner,
    //         isWritable
    //       }) => {
    //         if (isSigner) {
    //           signedKeys.push(pubkey.toString());
    //           numRequiredSignatures += 1;
    
    //           if (!isWritable) {
    //             numReadonlySignedAccounts += 1;
    //           }
    //         } else {
    //           unsignedKeys.push(pubkey.toString());
    
    //           if (!isWritable) {
    //             numReadonlyUnsignedAccounts += 1;
    //           }
    //         }
    //       });
    //       const accountKeys = signedKeys.concat(unsignedKeys);
    //       const instructions = this.instructions.map(instruction => {
    //         const {
    //           data,
    //           programId
    //         } = instruction;
    //         return {
    //           programIdIndex: accountKeys.indexOf(programId.toString()),
    //           accounts: instruction.keys.map(meta => accountKeys.indexOf(meta.pubkey.toString())),
    //           data: bs58$1.encode(data)
    //         };
    //       });
    //       instructions.forEach(instruction => {
    //         assert(instruction.programIdIndex >= 0);
    //         instruction.accounts.forEach(keyIndex => assert(keyIndex >= 0));
    //       });
    //       return new Message({
    //         header: {
    //           numRequiredSignatures,
    //           numReadonlySignedAccounts,
    //           numReadonlyUnsignedAccounts
    //         },
    //         accountKeys,
    //         recentBlockhash,
    //         instructions
    //       });
    //     }
    //     /**
    //      * @internal
    //      */
    
    
    //     _compile() {
    //       const message = this.compileMessage();
    //       const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    
    //       if (this.signatures.length === signedKeys.length) {
    //         const valid = this.signatures.every((pair, index) => {
    //           return signedKeys[index].equals(pair.publicKey);
    //         });
    //         if (valid) return message;
    //       }
    
    //       this.signatures = signedKeys.map(publicKey => ({
    //         signature: null,
    //         publicKey
    //       }));
    //       return message;
    //     }
    //     /**
    //      * Get a buffer of the Transaction data that need to be covered by signatures
    //      */
    
    
    //     serializeMessage() {
    //       return this._compile().serialize();
    //     }
    //     /**
    //      * Specify the public keys which will be used to sign the Transaction.
    //      * The first signer will be used as the transaction fee payer account.
    //      *
    //      * Signatures can be added with either `partialSign` or `addSignature`
    //      *
    //      * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
    //      * specified and it can be set in the Transaction constructor or with the
    //      * `feePayer` property.
    //      */
    
    
    //     setSigners(...signers) {
    //       if (signers.length === 0) {
    //         throw new Error('No signers');
    //       }
    
    //       const seen = new Set();
    //       this.signatures = signers.filter(publicKey => {
    //         const key = publicKey.toString();
    
    //         if (seen.has(key)) {
    //           return false;
    //         } else {
    //           seen.add(key);
    //           return true;
    //         }
    //       }).map(publicKey => ({
    //         signature: null,
    //         publicKey
    //       }));
    //     }
    //     /**
    //      * Sign the Transaction with the specified signers. Multiple signatures may
    //      * be applied to a Transaction. The first signature is considered "primary"
    //      * and is used identify and confirm transactions.
    //      *
    //      * If the Transaction `feePayer` is not set, the first signer will be used
    //      * as the transaction fee payer account.
    //      *
    //      * Transaction fields should not be modified after the first call to `sign`,
    //      * as doing so may invalidate the signature and cause the Transaction to be
    //      * rejected.
    //      *
    //      * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
    //      */
    
    
    //     sign(...signers) {
    //       if (signers.length === 0) {
    //         throw new Error('No signers');
    //       } // Dedupe signers
    
    
    //       const seen = new Set();
    //       const uniqueSigners = [];
    
    //       for (const signer of signers) {
    //         const key = signer.publicKey.toString();
    
    //         if (seen.has(key)) {
    //           continue;
    //         } else {
    //           seen.add(key);
    //           uniqueSigners.push(signer);
    //         }
    //       }
    
    //       this.signatures = uniqueSigners.map(signer => ({
    //         signature: null,
    //         publicKey: signer.publicKey
    //       }));
    
    //       const message = this._compile();
    
    //       this._partialSign(message, ...uniqueSigners);
    
    //       this._verifySignatures(message.serialize(), true);
    //     }
    //     /**
    //      * Partially sign a transaction with the specified accounts. All accounts must
    //      * correspond to either the fee payer or a signer account in the transaction
    //      * instructions.
    //      *
    //      * All the caveats from the `sign` method apply to `partialSign`
    //      */
    
    
    //     partialSign(...signers) {
    //       if (signers.length === 0) {
    //         throw new Error('No signers');
    //       } // Dedupe signers
    
    
    //       const seen = new Set();
    //       const uniqueSigners = [];
    
    //       for (const signer of signers) {
    //         const key = signer.publicKey.toString();
    
    //         if (seen.has(key)) {
    //           continue;
    //         } else {
    //           seen.add(key);
    //           uniqueSigners.push(signer);
    //         }
    //       }
    
    //       const message = this._compile();
    
    //       this._partialSign(message, ...uniqueSigners);
    //     }
    //     /**
    //      * @internal
    //      */
    
    
    //     _partialSign(message, ...signers) {
    //       const signData = message.serialize();
    //       signers.forEach(signer => {
    //         const signature = nacl__default.sign.detached(signData, signer.secretKey);
    
    //         this._addSignature(signer.publicKey, toBuffer(signature));
    //       });
    //     }
    //     /**
    //      * Add an externally created signature to a transaction. The public key
    //      * must correspond to either the fee payer or a signer account in the transaction
    //      * instructions.
    //      */
    
    
    //     addSignature(pubkey, signature) {
    //       this._compile(); // Ensure signatures array is populated
    
    
    //       this._addSignature(pubkey, signature);
    //     }
    //     /**
    //      * @internal
    //      */
    
    
    //     _addSignature(pubkey, signature) {
    //       assert(signature.length === 64);
    //       const index = this.signatures.findIndex(sigpair => pubkey.equals(sigpair.publicKey));
    
    //       if (index < 0) {
    //         throw new Error(`unknown signer: ${pubkey.toString()}`);
    //       }
    
    //       this.signatures[index].signature = buffer.Buffer.from(signature);
    //     }
    //     /**
    //      * Verify signatures of a complete, signed Transaction
    //      */
    
    
    //     verifySignatures() {
    //       return this._verifySignatures(this.serializeMessage(), true);
    //     }
    //     /**
    //      * @internal
    //      */
    
    
    //     _verifySignatures(signData, requireAllSignatures) {
    //       for (const {
    //         signature,
    //         publicKey
    //       } of this.signatures) {
    //         if (signature === null) {
    //           if (requireAllSignatures) {
    //             return false;
    //           }
    //         } else {
    //           if (!nacl__default.sign.detached.verify(signData, signature, publicKey.toBuffer())) {
    //             return false;
    //           }
    //         }
    //       }
    
    //       return true;
    //     }
    //     /**
    //      * Serialize the Transaction in the wire format.
    //      */
    
    
    //     serialize(config) {
    //       const {
    //         requireAllSignatures,
    //         verifySignatures
    //       } = Object.assign({
    //         requireAllSignatures: true,
    //         verifySignatures: true
    //       }, config);
    //       const signData = this.serializeMessage();
    
    //       if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {
    //         throw new Error('Signature verification failed');
    //       }
    
    //       return this._serialize(signData);
    //     }
    //     /**
    //      * @internal
    //      */
    
    
    //     _serialize(signData) {
    //       const {
    //         signatures
    //       } = this;
    //       const signatureCount = [];
    //       encodeLength(signatureCount, signatures.length);
    //       const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    //       const wireTransaction = buffer.Buffer.alloc(transactionLength);
    //       assert(signatures.length < 256);
    //       buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);
    //       signatures.forEach(({
    //         signature
    //       }, index) => {
    //         if (signature !== null) {
    //           assert(signature.length === 64, `signature has invalid length`);
    //           buffer.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
    //         }
    //       });
    //       signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    //       assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
    //       return wireTransaction;
    //     }
    //     /**
    //      * Deprecated method
    //      * @internal
    //      */
    
    
    //     get keys() {
    //       assert(this.instructions.length === 1);
    //       return this.instructions[0].keys.map(keyObj => keyObj.pubkey);
    //     }
    //     /**
    //      * Deprecated method
    //      * @internal
    //      */
    
    
    //     get programId() {
    //       assert(this.instructions.length === 1);
    //       return this.instructions[0].programId;
    //     }
    //     /**
    //      * Deprecated method
    //      * @internal
    //      */
    
    
    //     get data() {
    //       assert(this.instructions.length === 1);
    //       return this.instructions[0].data;
    //     }
    //     /**
    //      * Parse a wire transaction into a Transaction object.
    //      */
    
    
    //     static from(buffer$1) {
    //       // Slice up wire data
    //       let byteArray = [...buffer$1];
    //       const signatureCount = decodeLength(byteArray);
    //       let signatures = [];
    
    //       for (let i = 0; i < signatureCount; i++) {
    //         const signature = byteArray.slice(0, SIGNATURE_LENGTH);
    //         byteArray = byteArray.slice(SIGNATURE_LENGTH);
    //         signatures.push(bs58$1.encode(buffer.Buffer.from(signature)));
    //       }
    
    //       return Transaction.populate(Message.from(byteArray), signatures);
    //     }
    //     /**
    //      * Populate Transaction object from message and signatures
    //      */
    
    
    //     static populate(message, signatures) {
    //       const transaction = new Transaction();
    //       transaction.recentBlockhash = message.recentBlockhash;
    
    //       if (message.header.numRequiredSignatures > 0) {
    //         transaction.feePayer = message.accountKeys[0];
    //       }
    
    //       signatures.forEach((signature, index) => {
    //         const sigPubkeyPair = {
    //           signature: signature == bs58$1.encode(DEFAULT_SIGNATURE) ? null : bs58$1.decode(signature),
    //           publicKey: message.accountKeys[index]
    //         };
    //         transaction.signatures.push(sigPubkeyPair);
    //       });
    //       message.instructions.forEach(instruction => {
    //         const keys = instruction.accounts.map(account => {
    //           const pubkey = message.accountKeys[account];
    //           return {
    //             pubkey,
    //             isSigner: transaction.signatures.some(keyObj => keyObj.publicKey.toString() === pubkey.toString()),
    //             isWritable: message.isAccountWritable(account)
    //           };
    //         });
    //         transaction.instructions.push(new TransactionInstruction({
    //           keys,
    //           programId: message.accountKeys[instruction.programIdIndex],
    //           data: bs58$1.decode(instruction.data)
    //         }));
    //       });
    //       return transaction;
    //     }
    
    //   }
    
    //   const SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');
    //   const SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');
    //   const SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');
    //   new PublicKey('SysvarRewards111111111111111111111111111111');
    //   const SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');
    //   new PublicKey('Sysvar1nstructions1111111111111111111111111');
    
    //   /**
    //    * Sign, send and confirm a transaction.
    //    *
    //    * If `commitment` option is not specified, defaults to 'max' commitment.
    //    *
    //    * @param {Connection} connection
    //    * @param {Transaction} transaction
    //    * @param {Array<Signer>} signers
    //    * @param {ConfirmOptions} [options]
    //    * @returns {Promise<TransactionSignature>}
    //    */
    //   async function sendAndConfirmTransaction$1(connection, transaction, signers, options) {
    //     const sendOptions = options && {
    //       skipPreflight: options.skipPreflight,
    //       preflightCommitment: options.preflightCommitment || options.commitment
    //     };
    //     const signature = await connection.sendTransaction(transaction, signers, sendOptions);
    //     const status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
    
    //     if (status.err) {
    //       throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);
    //     }
    
    //     return signature;
    //   }
    
    //   // zzz
    //   function sleep(ms) {
    //     return new Promise(resolve => setTimeout(resolve, ms));
    //   }
    
    //   /**
    //    * @internal
    //    */
    
    //   /**
    //    * Populate a buffer of instruction data using an InstructionType
    //    * @internal
    //    */
    //   function encodeData(type, fields) {
    //     const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);
    //     const data = buffer.Buffer.alloc(allocLength);
    //     const layoutFields = Object.assign({
    //       instruction: type.index
    //     }, fields);
    //     type.layout.encode(layoutFields, data);
    //     return data;
    //   }
    
    //   /**
    //    * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11
    //    *
    //    * @internal
    //    */
    
    //   const FeeCalculatorLayout = nu64('lamportsPerSignature');
    //   /**
    //    * Calculator for transaction fees.
    //    */
    
    //   /**
    //    * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32
    //    *
    //    * @internal
    //    */
    
    //   const NonceAccountLayout = struct([u32('version'), u32('state'), publicKey$1('authorizedPubkey'), publicKey$1('nonce'), struct([FeeCalculatorLayout], 'feeCalculator')]);
    //   const NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
    //   /**
    //    * An enumeration of valid SystemInstructionType's
    //    */
    
    //   /**
    //    * An enumeration of valid system InstructionType's
    //    * @internal
    //    */
    //   const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
    //     Create: {
    //       index: 0,
    //       layout: struct([u32('instruction'), ns64('lamports'), ns64('space'), publicKey$1('programId')])
    //     },
    //     Assign: {
    //       index: 1,
    //       layout: struct([u32('instruction'), publicKey$1('programId')])
    //     },
    //     Transfer: {
    //       index: 2,
    //       layout: struct([u32('instruction'), ns64('lamports')])
    //     },
    //     CreateWithSeed: {
    //       index: 3,
    //       layout: struct([u32('instruction'), publicKey$1('base'), rustString('seed'), ns64('lamports'), ns64('space'), publicKey$1('programId')])
    //     },
    //     AdvanceNonceAccount: {
    //       index: 4,
    //       layout: struct([u32('instruction')])
    //     },
    //     WithdrawNonceAccount: {
    //       index: 5,
    //       layout: struct([u32('instruction'), ns64('lamports')])
    //     },
    //     InitializeNonceAccount: {
    //       index: 6,
    //       layout: struct([u32('instruction'), publicKey$1('authorized')])
    //     },
    //     AuthorizeNonceAccount: {
    //       index: 7,
    //       layout: struct([u32('instruction'), publicKey$1('authorized')])
    //     },
    //     Allocate: {
    //       index: 8,
    //       layout: struct([u32('instruction'), ns64('space')])
    //     },
    //     AllocateWithSeed: {
    //       index: 9,
    //       layout: struct([u32('instruction'), publicKey$1('base'), rustString('seed'), ns64('space'), publicKey$1('programId')])
    //     },
    //     AssignWithSeed: {
    //       index: 10,
    //       layout: struct([u32('instruction'), publicKey$1('base'), rustString('seed'), publicKey$1('programId')])
    //     },
    //     TransferWithSeed: {
    //       index: 11,
    //       layout: struct([u32('instruction'), ns64('lamports'), rustString('seed'), publicKey$1('programId')])
    //     }
    //   });
    //   /**
    //    * Factory class for transactions to interact with the System program
    //    */
    
    //   class SystemProgram {
    //     /**
    //      * @internal
    //      */
    //     constructor() {}
    //     /**
    //      * Public key that identifies the System program
    //      */
    
    
    //     /**
    //      * Generate a transaction instruction that creates a new account
    //      */
    //     static createAccount(params) {
    //       const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;
    //       const data = encodeData(type, {
    //         lamports: params.lamports,
    //         space: params.space,
    //         programId: toBuffer(params.programId.toBuffer())
    //       });
    //       return new TransactionInstruction({
    //         keys: [{
    //           pubkey: params.fromPubkey,
    //           isSigner: true,
    //           isWritable: true
    //         }, {
    //           pubkey: params.newAccountPubkey,
    //           isSigner: true,
    //           isWritable: true
    //         }],
    //         programId: this.programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Generate a transaction instruction that transfers lamports from one account to another
    //      */
    
    
    //     static transfer(params) {
    //       let data;
    //       let keys;
    
    //       if ('basePubkey' in params) {
    //         const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
    //         data = encodeData(type, {
    //           lamports: params.lamports,
    //           seed: params.seed,
    //           programId: toBuffer(params.programId.toBuffer())
    //         });
    //         keys = [{
    //           pubkey: params.fromPubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }, {
    //           pubkey: params.basePubkey,
    //           isSigner: true,
    //           isWritable: false
    //         }, {
    //           pubkey: params.toPubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }];
    //       } else {
    //         const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
    //         data = encodeData(type, {
    //           lamports: params.lamports
    //         });
    //         keys = [{
    //           pubkey: params.fromPubkey,
    //           isSigner: true,
    //           isWritable: true
    //         }, {
    //           pubkey: params.toPubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }];
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: this.programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Generate a transaction instruction that assigns an account to a program
    //      */
    
    
    //     static assign(params) {
    //       let data;
    //       let keys;
    
    //       if ('basePubkey' in params) {
    //         const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
    //         data = encodeData(type, {
    //           base: toBuffer(params.basePubkey.toBuffer()),
    //           seed: params.seed,
    //           programId: toBuffer(params.programId.toBuffer())
    //         });
    //         keys = [{
    //           pubkey: params.accountPubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }, {
    //           pubkey: params.basePubkey,
    //           isSigner: true,
    //           isWritable: false
    //         }];
    //       } else {
    //         const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
    //         data = encodeData(type, {
    //           programId: toBuffer(params.programId.toBuffer())
    //         });
    //         keys = [{
    //           pubkey: params.accountPubkey,
    //           isSigner: true,
    //           isWritable: true
    //         }];
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: this.programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Generate a transaction instruction that creates a new account at
    //      *   an address generated with `from`, a seed, and programId
    //      */
    
    
    //     static createAccountWithSeed(params) {
    //       const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
    //       const data = encodeData(type, {
    //         base: toBuffer(params.basePubkey.toBuffer()),
    //         seed: params.seed,
    //         lamports: params.lamports,
    //         space: params.space,
    //         programId: toBuffer(params.programId.toBuffer())
    //       });
    //       let keys = [{
    //         pubkey: params.fromPubkey,
    //         isSigner: true,
    //         isWritable: true
    //       }, {
    //         pubkey: params.newAccountPubkey,
    //         isSigner: false,
    //         isWritable: true
    //       }];
    
    //       if (params.basePubkey != params.fromPubkey) {
    //         keys.push({
    //           pubkey: params.basePubkey,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: this.programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Generate a transaction that creates a new Nonce account
    //      */
    
    
    //     static createNonceAccount(params) {
    //       const transaction = new Transaction();
    
    //       if ('basePubkey' in params && 'seed' in params) {
    //         transaction.add(SystemProgram.createAccountWithSeed({
    //           fromPubkey: params.fromPubkey,
    //           newAccountPubkey: params.noncePubkey,
    //           basePubkey: params.basePubkey,
    //           seed: params.seed,
    //           lamports: params.lamports,
    //           space: NONCE_ACCOUNT_LENGTH,
    //           programId: this.programId
    //         }));
    //       } else {
    //         transaction.add(SystemProgram.createAccount({
    //           fromPubkey: params.fromPubkey,
    //           newAccountPubkey: params.noncePubkey,
    //           lamports: params.lamports,
    //           space: NONCE_ACCOUNT_LENGTH,
    //           programId: this.programId
    //         }));
    //       }
    
    //       const initParams = {
    //         noncePubkey: params.noncePubkey,
    //         authorizedPubkey: params.authorizedPubkey
    //       };
    //       transaction.add(this.nonceInitialize(initParams));
    //       return transaction;
    //     }
    //     /**
    //      * Generate an instruction to initialize a Nonce account
    //      */
    
    
    //     static nonceInitialize(params) {
    //       const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
    //       const data = encodeData(type, {
    //         authorized: toBuffer(params.authorizedPubkey.toBuffer())
    //       });
    //       const instructionData = {
    //         keys: [{
    //           pubkey: params.noncePubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }, {
    //           pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
    //           isSigner: false,
    //           isWritable: false
    //         }, {
    //           pubkey: SYSVAR_RENT_PUBKEY,
    //           isSigner: false,
    //           isWritable: false
    //         }],
    //         programId: this.programId,
    //         data
    //       };
    //       return new TransactionInstruction(instructionData);
    //     }
    //     /**
    //      * Generate an instruction to advance the nonce in a Nonce account
    //      */
    
    
    //     static nonceAdvance(params) {
    //       const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
    //       const data = encodeData(type);
    //       const instructionData = {
    //         keys: [{
    //           pubkey: params.noncePubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }, {
    //           pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
    //           isSigner: false,
    //           isWritable: false
    //         }, {
    //           pubkey: params.authorizedPubkey,
    //           isSigner: true,
    //           isWritable: false
    //         }],
    //         programId: this.programId,
    //         data
    //       };
    //       return new TransactionInstruction(instructionData);
    //     }
    //     /**
    //      * Generate a transaction instruction that withdraws lamports from a Nonce account
    //      */
    
    
    //     static nonceWithdraw(params) {
    //       const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
    //       const data = encodeData(type, {
    //         lamports: params.lamports
    //       });
    //       return new TransactionInstruction({
    //         keys: [{
    //           pubkey: params.noncePubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }, {
    //           pubkey: params.toPubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }, {
    //           pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
    //           isSigner: false,
    //           isWritable: false
    //         }, {
    //           pubkey: SYSVAR_RENT_PUBKEY,
    //           isSigner: false,
    //           isWritable: false
    //         }, {
    //           pubkey: params.authorizedPubkey,
    //           isSigner: true,
    //           isWritable: false
    //         }],
    //         programId: this.programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Generate a transaction instruction that authorizes a new PublicKey as the authority
    //      * on a Nonce account.
    //      */
    
    
    //     static nonceAuthorize(params) {
    //       const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
    //       const data = encodeData(type, {
    //         authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
    //       });
    //       return new TransactionInstruction({
    //         keys: [{
    //           pubkey: params.noncePubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }, {
    //           pubkey: params.authorizedPubkey,
    //           isSigner: true,
    //           isWritable: false
    //         }],
    //         programId: this.programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Generate a transaction instruction that allocates space in an account without funding
    //      */
    
    
    //     static allocate(params) {
    //       let data;
    //       let keys;
    
    //       if ('basePubkey' in params) {
    //         const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
    //         data = encodeData(type, {
    //           base: toBuffer(params.basePubkey.toBuffer()),
    //           seed: params.seed,
    //           space: params.space,
    //           programId: toBuffer(params.programId.toBuffer())
    //         });
    //         keys = [{
    //           pubkey: params.accountPubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }, {
    //           pubkey: params.basePubkey,
    //           isSigner: true,
    //           isWritable: false
    //         }];
    //       } else {
    //         const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
    //         data = encodeData(type, {
    //           space: params.space
    //         });
    //         keys = [{
    //           pubkey: params.accountPubkey,
    //           isSigner: true,
    //           isWritable: true
    //         }];
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: this.programId,
    //         data
    //       });
    //     }
    
    //   }
    
    //   _defineProperty(SystemProgram, "programId", new PublicKey('11111111111111111111111111111111'));
    
    //   // rest of the Transaction fields
    //   //
    //   // TODO: replace 300 with a proper constant for the size of the other
    //   // Transaction fields
    
    //   const CHUNK_SIZE = PACKET_DATA_SIZE - 300;
    //   /**
    //    * Program loader interface
    //    */
    
    //   class Loader {
    //     /**
    //      * @internal
    //      */
    //     constructor() {}
    //     /**
    //      * Amount of program data placed in each load Transaction
    //      */
    
    
    //     /**
    //      * Minimum number of signatures required to load a program not including
    //      * retries
    //      *
    //      * Can be used to calculate transaction fees
    //      */
    //     static getMinNumSignatures(dataLength) {
    //       return 2 * ( // Every transaction requires two signatures (payer + program)
    //       Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction
    //       1) // Add one for Finalize transaction
    //       ;
    //     }
    //     /**
    //      * Loads a generic program
    //      *
    //      * @param connection The connection to use
    //      * @param payer System account that pays to load the program
    //      * @param program Account to load the program into
    //      * @param programId Public key that identifies the loader
    //      * @param data Program octets
    //      * @return true if program was loaded successfully, false if program was already loaded
    //      */
    
    
    //     static async load(connection, payer, program, programId, data) {
    //       {
    //         const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length); // Fetch program account info to check if it has already been created
    
    //         const programInfo = await connection.getAccountInfo(program.publicKey, 'confirmed');
    //         let transaction = null;
    
    //         if (programInfo !== null) {
    //           if (programInfo.executable) {
    //             console.error('Program load failed, account is already executable');
    //             return false;
    //           }
    
    //           if (programInfo.data.length !== data.length) {
    //             transaction = transaction || new Transaction();
    //             transaction.add(SystemProgram.allocate({
    //               accountPubkey: program.publicKey,
    //               space: data.length
    //             }));
    //           }
    
    //           if (!programInfo.owner.equals(programId)) {
    //             transaction = transaction || new Transaction();
    //             transaction.add(SystemProgram.assign({
    //               accountPubkey: program.publicKey,
    //               programId
    //             }));
    //           }
    
    //           if (programInfo.lamports < balanceNeeded) {
    //             transaction = transaction || new Transaction();
    //             transaction.add(SystemProgram.transfer({
    //               fromPubkey: payer.publicKey,
    //               toPubkey: program.publicKey,
    //               lamports: balanceNeeded - programInfo.lamports
    //             }));
    //           }
    //         } else {
    //           transaction = new Transaction().add(SystemProgram.createAccount({
    //             fromPubkey: payer.publicKey,
    //             newAccountPubkey: program.publicKey,
    //             lamports: balanceNeeded > 0 ? balanceNeeded : 1,
    //             space: data.length,
    //             programId
    //           }));
    //         } // If the account is already created correctly, skip this step
    //         // and proceed directly to loading instructions
    
    
    //         if (transaction !== null) {
    //           await sendAndConfirmTransaction$1(connection, transaction, [payer, program], {
    //             commitment: 'confirmed'
    //           });
    //         }
    //       }
    //       const dataLayout = struct([u32('instruction'), u32('offset'), u32('bytesLength'), u32('bytesLengthPadding'), seq(u8('byte'), offset(u32(), -8), 'bytes')]);
    //       const chunkSize = Loader.chunkSize;
    //       let offset$1 = 0;
    //       let array = data;
    //       let transactions = [];
    
    //       while (array.length > 0) {
    //         const bytes = array.slice(0, chunkSize);
    //         const data = buffer.Buffer.alloc(chunkSize + 16);
    //         dataLayout.encode({
    //           instruction: 0,
    //           // Load instruction
    //           offset: offset$1,
    //           bytes
    //         }, data);
    //         const transaction = new Transaction().add({
    //           keys: [{
    //             pubkey: program.publicKey,
    //             isSigner: true,
    //             isWritable: true
    //           }],
    //           programId,
    //           data
    //         });
    //         transactions.push(sendAndConfirmTransaction$1(connection, transaction, [payer, program], {
    //           commitment: 'confirmed'
    //         })); // Delay between sends in an attempt to reduce rate limit errors
    
    //         if (connection._rpcEndpoint.includes('solana.com')) {
    //           const REQUESTS_PER_SECOND = 4;
    //           await sleep(1000 / REQUESTS_PER_SECOND);
    //         }
    
    //         offset$1 += chunkSize;
    //         array = array.slice(chunkSize);
    //       }
    
    //       await Promise.all(transactions); // Finalize the account loaded with program data for execution
    
    //       {
    //         const dataLayout = struct([u32('instruction')]);
    //         const data = buffer.Buffer.alloc(dataLayout.span);
    //         dataLayout.encode({
    //           instruction: 1 // Finalize instruction
    
    //         }, data);
    //         const transaction = new Transaction().add({
    //           keys: [{
    //             pubkey: program.publicKey,
    //             isSigner: true,
    //             isWritable: true
    //           }, {
    //             pubkey: SYSVAR_RENT_PUBKEY,
    //             isSigner: false,
    //             isWritable: false
    //           }],
    //           programId,
    //           data
    //         });
    //         await sendAndConfirmTransaction$1(connection, transaction, [payer, program], {
    //           commitment: 'confirmed'
    //         });
    //       } // success
    
    //       return true;
    //     }
    
    //   }
    
    //   _defineProperty(Loader, "chunkSize", CHUNK_SIZE);
    
    //   new PublicKey('BPFLoader2111111111111111111111111111111111');
    
    //   var browser = {exports: {}};
    
    //   (function (module, exports) {
    
    //   // ref: https://github.com/tc39/proposal-global
    //   var getGlobal = function () {
    //       // the only reliable means to get the global object is
    //       // `Function('return this')()`
    //       // However, this causes CSP violations in Chrome apps.
    //       if (typeof self !== 'undefined') { return self; }
    //       if (typeof window !== 'undefined') { return window; }
    //       if (typeof global !== 'undefined') { return global; }
    //       throw new Error('unable to locate global object');
    //   };
    
    //   var global = getGlobal();
    
    //   module.exports = exports = global.fetch;
    
    //   // Needed for TypeScript and Webpack.
    //   if (global.fetch) {
    //       exports.default = global.fetch.bind(global);
    //   }
    
    //   exports.Headers = global.Headers;
    //   exports.Request = global.Request;
    //   exports.Response = global.Response;
    //   }(browser, browser.exports));
    
    //   browser.exports;
    
    //   const PublicKeyFromString = coerce(instance(PublicKey), string(), value => new PublicKey(value));
    //   const RawAccountDataResult = tuple([string(), literal('base64')]);
    //   const BufferFromRawAccountData = coerce(instance(buffer.Buffer), RawAccountDataResult, value => buffer.Buffer.from(value[0], 'base64'));
    
    //   /**
    //    * @internal
    //    */
    //   function createRpcResult(result) {
    //     return union([type({
    //       jsonrpc: literal('2.0'),
    //       id: string(),
    //       result
    //     }), type({
    //       jsonrpc: literal('2.0'),
    //       id: string(),
    //       error: type({
    //         code: unknown(),
    //         message: string(),
    //         data: optional(any())
    //       })
    //     })]);
    //   }
    
    //   const UnknownRpcResult = createRpcResult(unknown());
    //   /**
    //    * @internal
    //    */
    
    //   function jsonRpcResult(schema) {
    //     return coerce(createRpcResult(schema), UnknownRpcResult, value => {
    //       if ('error' in value) {
    //         return value;
    //       } else {
    //         return { ...value,
    //           result: create(value.result, schema)
    //         };
    //       }
    //     });
    //   }
    //   /**
    //    * @internal
    //    */
    
    
    //   function jsonRpcResultAndContext(value) {
    //     return jsonRpcResult(type({
    //       context: type({
    //         slot: number()
    //       }),
    //       value
    //     }));
    //   }
    //   /**
    //    * @internal
    //    */
    
    
    //   function notificationResultAndContext(value) {
    //     return type({
    //       context: type({
    //         slot: number()
    //       }),
    //       value
    //     });
    //   }
    //   /**
    //    * The level of commitment desired when querying state
    //    * <pre>
    //    *   'processed': Query the most recent block which has reached 1 confirmation by the connected node
    //    *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
    //    *   'finalized': Query the most recent block which has been finalized by the cluster
    //    * </pre>
    //    */
    
    
    //   const GetInflationGovernorResult = type({
    //     foundation: number(),
    //     foundationTerm: number(),
    //     initial: number(),
    //     taper: number(),
    //     terminal: number()
    //   });
    //   /**
    //    * The inflation reward for an epoch
    //    */
    
    //   /**
    //    * Expected JSON RPC response for the "getInflationReward" message
    //    */
    //   jsonRpcResult(array(nullable(type({
    //     epoch: number(),
    //     effectiveSlot: number(),
    //     amount: number(),
    //     postBalance: number()
    //   }))));
    //   /**
    //    * Information about the current epoch
    //    */
    
    //   const GetEpochInfoResult = type({
    //     epoch: number(),
    //     slotIndex: number(),
    //     slotsInEpoch: number(),
    //     absoluteSlot: number(),
    //     blockHeight: optional(number()),
    //     transactionCount: optional(number())
    //   });
    //   const GetEpochScheduleResult = type({
    //     slotsPerEpoch: number(),
    //     leaderScheduleSlotOffset: number(),
    //     warmup: boolean(),
    //     firstNormalEpoch: number(),
    //     firstNormalSlot: number()
    //   });
    //   /**
    //    * Leader schedule
    //    * (see https://docs.solana.com/terminology#leader-schedule)
    //    */
    
    //   const GetLeaderScheduleResult = record(string(), array(number()));
    //   /**
    //    * Transaction error or null
    //    */
    
    //   const TransactionErrorResult = nullable(union([type({}), string()]));
    //   /**
    //    * Signature status for a transaction
    //    */
    
    //   const SignatureStatusResult = type({
    //     err: TransactionErrorResult
    //   });
    //   /**
    //    * Transaction signature received notification
    //    */
    
    //   const SignatureReceivedResult = literal('receivedSignature');
    //   /**
    //    * Version info for a node
    //    */
    
    //   type({
    //     'solana-core': string(),
    //     'feature-set': optional(number())
    //   });
    //   jsonRpcResultAndContext(type({
    //     err: nullable(union([type({}), string()])),
    //     logs: nullable(array(string()))
    //   }));
    //   /**
    //    * Expected JSON RPC response for the "getInflationGovernor" message
    //    */
    
    
    //   jsonRpcResult(GetInflationGovernorResult);
    //   /**
    //    * Expected JSON RPC response for the "getEpochInfo" message
    //    */
    
    //   jsonRpcResult(GetEpochInfoResult);
    //   /**
    //    * Expected JSON RPC response for the "getEpochSchedule" message
    //    */
    
    //   jsonRpcResult(GetEpochScheduleResult);
    //   /**
    //    * Expected JSON RPC response for the "getLeaderSchedule" message
    //    */
    
    //   jsonRpcResult(GetLeaderScheduleResult);
    //   /**
    //    * Expected JSON RPC response for the "minimumLedgerSlot" and "getFirstAvailableBlock" messages
    //    */
    
    //   jsonRpcResult(number());
    //   /**
    //    * Supply
    //    */
    
    //   /**
    //    * Expected JSON RPC response for the "getSupply" message
    //    */
    //   jsonRpcResultAndContext(type({
    //     total: number(),
    //     circulating: number(),
    //     nonCirculating: number(),
    //     nonCirculatingAccounts: array(PublicKeyFromString)
    //   }));
    //   /**
    //    * Token amount object which returns a token amount in different formats
    //    * for various client use cases.
    //    */
    
    //   /**
    //    * Expected JSON RPC structure for token amounts
    //    */
    //   const TokenAmountResult = type({
    //     amount: string(),
    //     uiAmount: nullable(number()),
    //     decimals: number(),
    //     uiAmountString: optional(string())
    //   });
    //   /**
    //    * Token address and balance.
    //    */
    
    //   /**
    //    * Expected JSON RPC response for the "getTokenLargestAccounts" message
    //    */
    //   jsonRpcResultAndContext(array(type({
    //     address: PublicKeyFromString,
    //     amount: string(),
    //     uiAmount: nullable(number()),
    //     decimals: number(),
    //     uiAmountString: optional(string())
    //   })));
    //   /**
    //    * Expected JSON RPC response for the "getTokenAccountsByOwner" message
    //    */
    
    //   jsonRpcResultAndContext(array(type({
    //     pubkey: PublicKeyFromString,
    //     account: type({
    //       executable: boolean(),
    //       owner: PublicKeyFromString,
    //       lamports: number(),
    //       data: BufferFromRawAccountData,
    //       rentEpoch: number()
    //     })
    //   })));
    //   const ParsedAccountDataResult = type({
    //     program: string(),
    //     parsed: unknown(),
    //     space: number()
    //   });
    //   /**
    //    * Expected JSON RPC response for the "getTokenAccountsByOwner" message with parsed data
    //    */
    
    //   jsonRpcResultAndContext(array(type({
    //     pubkey: PublicKeyFromString,
    //     account: type({
    //       executable: boolean(),
    //       owner: PublicKeyFromString,
    //       lamports: number(),
    //       data: ParsedAccountDataResult,
    //       rentEpoch: number()
    //     })
    //   })));
    //   /**
    //    * Pair of an account address and its balance
    //    */
    
    //   /**
    //    * Expected JSON RPC response for the "getLargestAccounts" message
    //    */
    //   jsonRpcResultAndContext(array(type({
    //     lamports: number(),
    //     address: PublicKeyFromString
    //   })));
    //   /**
    //    * @internal
    //    */
    
    //   const AccountInfoResult = type({
    //     executable: boolean(),
    //     owner: PublicKeyFromString,
    //     lamports: number(),
    //     data: BufferFromRawAccountData,
    //     rentEpoch: number()
    //   });
    //   /**
    //    * @internal
    //    */
    
    //   type({
    //     pubkey: PublicKeyFromString,
    //     account: AccountInfoResult
    //   });
    //   const ParsedOrRawAccountData = coerce(union([instance(buffer.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), value => {
    //     if (Array.isArray(value)) {
    //       return create(value, BufferFromRawAccountData);
    //     } else {
    //       return value;
    //     }
    //   });
    //   /**
    //    * @internal
    //    */
    
    //   const ParsedAccountInfoResult = type({
    //     executable: boolean(),
    //     owner: PublicKeyFromString,
    //     lamports: number(),
    //     data: ParsedOrRawAccountData,
    //     rentEpoch: number()
    //   });
    //   type({
    //     pubkey: PublicKeyFromString,
    //     account: ParsedAccountInfoResult
    //   });
    //   /**
    //    * @internal
    //    */
    
    //   type({
    //     state: union([literal('active'), literal('inactive'), literal('activating'), literal('deactivating')]),
    //     active: number(),
    //     inactive: number()
    //   });
    //   /**
    //    * Expected JSON RPC response for the "getConfirmedSignaturesForAddress2" message
    //    */
    
    //   jsonRpcResult(array(type({
    //     signature: string(),
    //     slot: number(),
    //     err: TransactionErrorResult,
    //     memo: nullable(string()),
    //     blockTime: optional(nullable(number()))
    //   })));
    //   /**
    //    * Expected JSON RPC response for the "getSignaturesForAddress" message
    //    */
    
    //   jsonRpcResult(array(type({
    //     signature: string(),
    //     slot: number(),
    //     err: TransactionErrorResult,
    //     memo: nullable(string()),
    //     blockTime: optional(nullable(number()))
    //   })));
    //   /***
    //    * Expected JSON RPC response for the "accountNotification" message
    //    */
    
    //   type({
    //     subscription: number(),
    //     result: notificationResultAndContext(AccountInfoResult)
    //   });
    //   /**
    //    * @internal
    //    */
    
    //   const ProgramAccountInfoResult = type({
    //     pubkey: PublicKeyFromString,
    //     account: AccountInfoResult
    //   });
    //   /***
    //    * Expected JSON RPC response for the "programNotification" message
    //    */
    
    //   type({
    //     subscription: number(),
    //     result: notificationResultAndContext(ProgramAccountInfoResult)
    //   });
    //   /**
    //    * @internal
    //    */
    
    //   const SlotInfoResult = type({
    //     parent: number(),
    //     slot: number(),
    //     root: number()
    //   });
    //   /**
    //    * Expected JSON RPC response for the "slotNotification" message
    //    */
    
    //   type({
    //     subscription: number(),
    //     result: SlotInfoResult
    //   });
    //   /**
    //    * Slot updates which can be used for tracking the live progress of a cluster.
    //    * - `"firstShredReceived"`: connected node received the first shred of a block.
    //    * Indicates that a new block that is being produced.
    //    * - `"completed"`: connected node has received all shreds of a block. Indicates
    //    * a block was recently produced.
    //    * - `"optimisticConfirmation"`: block was optimistically confirmed by the
    //    * cluster. It is not guaranteed that an optimistic confirmation notification
    //    * will be sent for every finalized blocks.
    //    * - `"root"`: the connected node rooted this block.
    //    * - `"createdBank"`: the connected node has started validating this block.
    //    * - `"frozen"`: the connected node has validated this block.
    //    * - `"dead"`: the connected node failed to validate this block.
    //    */
    
    //   /**
    //    * @internal
    //    */
    //   const SlotUpdateResult = union([type({
    //     type: union([literal('firstShredReceived'), literal('completed'), literal('optimisticConfirmation'), literal('root')]),
    //     slot: number(),
    //     timestamp: number()
    //   }), type({
    //     type: literal('createdBank'),
    //     parent: number(),
    //     slot: number(),
    //     timestamp: number()
    //   }), type({
    //     type: literal('frozen'),
    //     slot: number(),
    //     timestamp: number(),
    //     stats: type({
    //       numTransactionEntries: number(),
    //       numSuccessfulTransactions: number(),
    //       numFailedTransactions: number(),
    //       maxTransactionsPerEntry: number()
    //     })
    //   }), type({
    //     type: literal('dead'),
    //     slot: number(),
    //     timestamp: number(),
    //     err: string()
    //   })]);
    //   /**
    //    * Expected JSON RPC response for the "slotsUpdatesNotification" message
    //    */
    
    //   type({
    //     subscription: number(),
    //     result: SlotUpdateResult
    //   });
    //   /**
    //    * Expected JSON RPC response for the "signatureNotification" message
    //    */
    
    //   type({
    //     subscription: number(),
    //     result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
    //   });
    //   /**
    //    * Expected JSON RPC response for the "rootNotification" message
    //    */
    
    //   type({
    //     subscription: number(),
    //     result: number()
    //   });
    //   type({
    //     pubkey: string(),
    //     gossip: nullable(string()),
    //     tpu: nullable(string()),
    //     rpc: nullable(string()),
    //     version: nullable(string())
    //   });
    //   const VoteAccountInfoResult = type({
    //     votePubkey: string(),
    //     nodePubkey: string(),
    //     activatedStake: number(),
    //     epochVoteAccount: boolean(),
    //     epochCredits: array(tuple([number(), number(), number()])),
    //     commission: number(),
    //     lastVote: number(),
    //     rootSlot: nullable(number())
    //   });
    //   /**
    //    * Expected JSON RPC response for the "getVoteAccounts" message
    //    */
    
    //   jsonRpcResult(type({
    //     current: array(VoteAccountInfoResult),
    //     delinquent: array(VoteAccountInfoResult)
    //   }));
    //   const ConfirmationStatus = union([literal('processed'), literal('confirmed'), literal('finalized')]);
    //   const SignatureStatusResponse = type({
    //     slot: number(),
    //     confirmations: nullable(number()),
    //     err: TransactionErrorResult,
    //     confirmationStatus: optional(ConfirmationStatus)
    //   });
    //   /**
    //    * Expected JSON RPC response for the "getSignatureStatuses" message
    //    */
    
    //   jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
    //   /**
    //    * Expected JSON RPC response for the "getMinimumBalanceForRentExemption" message
    //    */
    
    //   jsonRpcResult(number());
    //   const ConfirmedTransactionResult = type({
    //     signatures: array(string()),
    //     message: type({
    //       accountKeys: array(string()),
    //       header: type({
    //         numRequiredSignatures: number(),
    //         numReadonlySignedAccounts: number(),
    //         numReadonlyUnsignedAccounts: number()
    //       }),
    //       instructions: array(type({
    //         accounts: array(number()),
    //         data: string(),
    //         programIdIndex: number()
    //       })),
    //       recentBlockhash: string()
    //     })
    //   });
    //   const ParsedInstructionResult = type({
    //     parsed: unknown(),
    //     program: string(),
    //     programId: PublicKeyFromString
    //   });
    //   const RawInstructionResult = type({
    //     accounts: array(PublicKeyFromString),
    //     data: string(),
    //     programId: PublicKeyFromString
    //   });
    //   const InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
    //   const UnknownInstructionResult = union([type({
    //     parsed: unknown(),
    //     program: string(),
    //     programId: string()
    //   }), type({
    //     accounts: array(string()),
    //     data: string(),
    //     programId: string()
    //   })]);
    //   const ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, value => {
    //     if ('accounts' in value) {
    //       return create(value, RawInstructionResult);
    //     } else {
    //       return create(value, ParsedInstructionResult);
    //     }
    //   });
    //   /**
    //    * @internal
    //    */
    
    //   const ParsedConfirmedTransactionResult = type({
    //     signatures: array(string()),
    //     message: type({
    //       accountKeys: array(type({
    //         pubkey: PublicKeyFromString,
    //         signer: boolean(),
    //         writable: boolean()
    //       })),
    //       instructions: array(ParsedOrRawInstruction),
    //       recentBlockhash: string()
    //     })
    //   });
    //   const TokenBalanceResult = type({
    //     accountIndex: number(),
    //     mint: string(),
    //     uiTokenAmount: TokenAmountResult
    //   });
    //   /**
    //    * @internal
    //    */
    
    //   const ConfirmedTransactionMetaResult = type({
    //     err: TransactionErrorResult,
    //     fee: number(),
    //     innerInstructions: optional(nullable(array(type({
    //       index: number(),
    //       instructions: array(type({
    //         accounts: array(number()),
    //         data: string(),
    //         programIdIndex: number()
    //       }))
    //     })))),
    //     preBalances: array(number()),
    //     postBalances: array(number()),
    //     logMessages: optional(nullable(array(string()))),
    //     preTokenBalances: optional(nullable(array(TokenBalanceResult))),
    //     postTokenBalances: optional(nullable(array(TokenBalanceResult)))
    //   });
    //   /**
    //    * @internal
    //    */
    
    //   const ParsedConfirmedTransactionMetaResult = type({
    //     err: TransactionErrorResult,
    //     fee: number(),
    //     innerInstructions: optional(nullable(array(type({
    //       index: number(),
    //       instructions: array(ParsedOrRawInstruction)
    //     })))),
    //     preBalances: array(number()),
    //     postBalances: array(number()),
    //     logMessages: optional(nullable(array(string()))),
    //     preTokenBalances: optional(nullable(array(TokenBalanceResult))),
    //     postTokenBalances: optional(nullable(array(TokenBalanceResult)))
    //   });
    //   /**
    //    * Expected JSON RPC response for the "getConfirmedBlock" message
    //    */
    
    //   jsonRpcResult(nullable(type({
    //     blockhash: string(),
    //     previousBlockhash: string(),
    //     parentSlot: number(),
    //     transactions: array(type({
    //       transaction: ConfirmedTransactionResult,
    //       meta: nullable(ConfirmedTransactionMetaResult)
    //     })),
    //     rewards: optional(array(type({
    //       pubkey: string(),
    //       lamports: number(),
    //       postBalance: nullable(number()),
    //       rewardType: nullable(string())
    //     }))),
    //     blockTime: nullable(number())
    //   })));
    //   /**
    //    * Expected JSON RPC response for the "getConfirmedBlockSignatures" message
    //    */
    
    //   jsonRpcResult(nullable(type({
    //     blockhash: string(),
    //     previousBlockhash: string(),
    //     parentSlot: number(),
    //     signatures: array(string()),
    //     blockTime: nullable(number())
    //   })));
    //   /**
    //    * Expected JSON RPC response for the "getConfirmedTransaction" message
    //    */
    
    //   jsonRpcResult(nullable(type({
    //     slot: number(),
    //     meta: ConfirmedTransactionMetaResult,
    //     blockTime: optional(nullable(number())),
    //     transaction: ConfirmedTransactionResult
    //   })));
    //   /**
    //    * Expected JSON RPC response for the "getConfirmedTransaction" message
    //    */
    
    //   jsonRpcResult(nullable(type({
    //     slot: number(),
    //     transaction: ParsedConfirmedTransactionResult,
    //     meta: nullable(ParsedConfirmedTransactionMetaResult),
    //     blockTime: optional(nullable(number()))
    //   })));
    //   /**
    //    * Expected JSON RPC response for the "getRecentBlockhash" message
    //    */
    
    //   jsonRpcResultAndContext(type({
    //     blockhash: string(),
    //     feeCalculator: type({
    //       lamportsPerSignature: number()
    //     })
    //   }));
    //   const PerfSampleResult = type({
    //     slot: number(),
    //     numTransactions: number(),
    //     numSlots: number(),
    //     samplePeriodSecs: number()
    //   });
    //   /*
    //    * Expected JSON RPC response for "getRecentPerformanceSamples" message
    //    */
    
    //   jsonRpcResult(array(PerfSampleResult));
    //   /**
    //    * Expected JSON RPC response for the "getFeeCalculatorForBlockhash" message
    //    */
    
    //   jsonRpcResultAndContext(nullable(type({
    //     feeCalculator: type({
    //       lamportsPerSignature: number()
    //     })
    //   })));
    //   /**
    //    * Expected JSON RPC response for the "requestAirdrop" message
    //    */
    
    //   jsonRpcResult(string());
    //   /**
    //    * Expected JSON RPC response for the "sendTransaction" message
    //    */
    
    //   jsonRpcResult(string());
    //   /**
    //    * Information about the latest slot being processed by a node
    //    */
    
    //   /**
    //    * @internal
    //    */
    //   const LogsResult = type({
    //     err: TransactionErrorResult,
    //     logs: array(string()),
    //     signature: string()
    //   });
    //   /**
    //    * Logs result.
    //    */
    
    //   /**
    //    * Expected JSON RPC response for the "logsNotification" message.
    //    */
    //   type({
    //     result: notificationResultAndContext(LogsResult),
    //     subscription: number()
    //   });
    
    //   /**
    //    * Keypair signer interface
    //    */
    
    //   /**
    //    * An account keypair used for signing transactions.
    //    */
    //   class Keypair {
    //     /**
    //      * Create a new keypair instance.
    //      * Generate random keypair if no {@link Ed25519Keypair} is provided.
    //      *
    //      * @param keypair ed25519 keypair
    //      */
    //     constructor(keypair) {
    //       _defineProperty(this, "_keypair", void 0);
    
    //       if (keypair) {
    //         this._keypair = keypair;
    //       } else {
    //         this._keypair = naclFast.exports.sign.keyPair();
    //       }
    //     }
    //     /**
    //      * Generate a new random keypair
    //      */
    
    
    //     static generate() {
    //       return new Keypair(naclFast.exports.sign.keyPair());
    //     }
    //     /**
    //      * Create a keypair from a raw secret key byte array.
    //      *
    //      * This method should only be used to recreate a keypair from a previously
    //      * generated secret key. Generating keypairs from a random seed should be done
    //      * with the {@link Keypair.fromSeed} method.
    //      *
    //      * @throws error if the provided secret key is invalid and validation is not skipped.
    //      *
    //      * @param secretKey secret key byte array
    //      * @param options: skip secret key validation
    //      */
    
    
    //     static fromSecretKey(secretKey, options) {
    //       const keypair = naclFast.exports.sign.keyPair.fromSecretKey(secretKey);
    
    //       if (!options || !options.skipValidation) {
    //         const encoder = new TextEncoder();
    //         const signData = encoder.encode('@solana/web3.js-validation-v1');
    //         const signature = naclFast.exports.sign.detached(signData, keypair.secretKey);
    
    //         if (!naclFast.exports.sign.detached.verify(signData, signature, keypair.publicKey)) {
    //           throw new Error('provided secretKey is invalid');
    //         }
    //       }
    
    //       return new Keypair(keypair);
    //     }
    //     /**
    //      * Generate a keypair from a 32 byte seed.
    //      *
    //      * @param seed seed byte array
    //      */
    
    
    //     static fromSeed(seed) {
    //       return new Keypair(naclFast.exports.sign.keyPair.fromSeed(seed));
    //     }
    //     /**
    //      * The public key for this keypair
    //      */
    
    
    //     get publicKey() {
    //       return new PublicKey(this._keypair.publicKey);
    //     }
    //     /**
    //      * The raw secret key for this keypair
    //      */
    
    
    //     get secretKey() {
    //       return this._keypair.secretKey;
    //     }
    
    //   }
    
    //   /**
    //    * Address of the stake config account which configures the rate
    //    * of stake warmup and cooldown as well as the slashing penalty.
    //    */
    
    //   const STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');
    //   /**
    //    * Stake account lockup info
    //    */
    
    //   class Lockup {
    //     /** Unix timestamp of lockup expiration */
    
    //     /** Epoch of lockup expiration */
    
    //     /** Lockup custodian authority */
    
    //     /**
    //      * Create a new Lockup object
    //      */
    //     constructor(unixTimestamp, epoch, custodian) {
    //       _defineProperty(this, "unixTimestamp", void 0);
    
    //       _defineProperty(this, "epoch", void 0);
    
    //       _defineProperty(this, "custodian", void 0);
    
    //       this.unixTimestamp = unixTimestamp;
    //       this.epoch = epoch;
    //       this.custodian = custodian;
    //     }
    //     /**
    //      * Default, inactive Lockup value
    //      */
    
    
    //   }
    //   /**
    //    * Create stake account transaction params
    //    */
    
    //   _defineProperty(Lockup, "default", new Lockup(0, 0, PublicKey.default));
    //   /**
    //    * An enumeration of valid StakeInstructionType's
    //    */
    
    //   /**
    //    * An enumeration of valid stake InstructionType's
    //    * @internal
    //    */
    //   const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
    //     Initialize: {
    //       index: 0,
    //       layout: struct([u32('instruction'), authorized(), lockup()])
    //     },
    //     Authorize: {
    //       index: 1,
    //       layout: struct([u32('instruction'), publicKey$1('newAuthorized'), u32('stakeAuthorizationType')])
    //     },
    //     Delegate: {
    //       index: 2,
    //       layout: struct([u32('instruction')])
    //     },
    //     Split: {
    //       index: 3,
    //       layout: struct([u32('instruction'), ns64('lamports')])
    //     },
    //     Withdraw: {
    //       index: 4,
    //       layout: struct([u32('instruction'), ns64('lamports')])
    //     },
    //     Deactivate: {
    //       index: 5,
    //       layout: struct([u32('instruction')])
    //     },
    //     AuthorizeWithSeed: {
    //       index: 8,
    //       layout: struct([u32('instruction'), publicKey$1('newAuthorized'), u32('stakeAuthorizationType'), rustString('authoritySeed'), publicKey$1('authorityOwner')])
    //     }
    //   });
    //   /**
    //    * Stake authorization type
    //    */
    
    //   /**
    //    * An enumeration of valid StakeAuthorizationLayout's
    //    */
    //   Object.freeze({
    //     Staker: {
    //       index: 0
    //     },
    //     Withdrawer: {
    //       index: 1
    //     }
    //   });
    //   /**
    //    * Factory class for transactions to interact with the Stake program
    //    */
    
    //   class StakeProgram {
    //     /**
    //      * @internal
    //      */
    //     constructor() {}
    //     /**
    //      * Public key that identifies the Stake program
    //      */
    
    
    //     /**
    //      * Generate an Initialize instruction to add to a Stake Create transaction
    //      */
    //     static initialize(params) {
    //       const {
    //         stakePubkey,
    //         authorized,
    //         lockup: maybeLockup
    //       } = params;
    //       const lockup = maybeLockup || Lockup.default;
    //       const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;
    //       const data = encodeData(type, {
    //         authorized: {
    //           staker: toBuffer(authorized.staker.toBuffer()),
    //           withdrawer: toBuffer(authorized.withdrawer.toBuffer())
    //         },
    //         lockup: {
    //           unixTimestamp: lockup.unixTimestamp,
    //           epoch: lockup.epoch,
    //           custodian: toBuffer(lockup.custodian.toBuffer())
    //         }
    //       });
    //       const instructionData = {
    //         keys: [{
    //           pubkey: stakePubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }, {
    //           pubkey: SYSVAR_RENT_PUBKEY,
    //           isSigner: false,
    //           isWritable: false
    //         }],
    //         programId: this.programId,
    //         data
    //       };
    //       return new TransactionInstruction(instructionData);
    //     }
    //     /**
    //      * Generate a Transaction that creates a new Stake account at
    //      *   an address generated with `from`, a seed, and the Stake programId
    //      */
    
    
    //     static createAccountWithSeed(params) {
    //       const transaction = new Transaction();
    //       transaction.add(SystemProgram.createAccountWithSeed({
    //         fromPubkey: params.fromPubkey,
    //         newAccountPubkey: params.stakePubkey,
    //         basePubkey: params.basePubkey,
    //         seed: params.seed,
    //         lamports: params.lamports,
    //         space: this.space,
    //         programId: this.programId
    //       }));
    //       const {
    //         stakePubkey,
    //         authorized,
    //         lockup
    //       } = params;
    //       return transaction.add(this.initialize({
    //         stakePubkey,
    //         authorized,
    //         lockup
    //       }));
    //     }
    //     /**
    //      * Generate a Transaction that creates a new Stake account
    //      */
    
    
    //     static createAccount(params) {
    //       const transaction = new Transaction();
    //       transaction.add(SystemProgram.createAccount({
    //         fromPubkey: params.fromPubkey,
    //         newAccountPubkey: params.stakePubkey,
    //         lamports: params.lamports,
    //         space: this.space,
    //         programId: this.programId
    //       }));
    //       const {
    //         stakePubkey,
    //         authorized,
    //         lockup
    //       } = params;
    //       return transaction.add(this.initialize({
    //         stakePubkey,
    //         authorized,
    //         lockup
    //       }));
    //     }
    //     /**
    //      * Generate a Transaction that delegates Stake tokens to a validator
    //      * Vote PublicKey. This transaction can also be used to redelegate Stake
    //      * to a new validator Vote PublicKey.
    //      */
    
    
    //     static delegate(params) {
    //       const {
    //         stakePubkey,
    //         authorizedPubkey,
    //         votePubkey
    //       } = params;
    //       const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;
    //       const data = encodeData(type);
    //       return new Transaction().add({
    //         keys: [{
    //           pubkey: stakePubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }, {
    //           pubkey: votePubkey,
    //           isSigner: false,
    //           isWritable: false
    //         }, {
    //           pubkey: SYSVAR_CLOCK_PUBKEY,
    //           isSigner: false,
    //           isWritable: false
    //         }, {
    //           pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
    //           isSigner: false,
    //           isWritable: false
    //         }, {
    //           pubkey: STAKE_CONFIG_ID,
    //           isSigner: false,
    //           isWritable: false
    //         }, {
    //           pubkey: authorizedPubkey,
    //           isSigner: true,
    //           isWritable: false
    //         }],
    //         programId: this.programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Generate a Transaction that authorizes a new PublicKey as Staker
    //      * or Withdrawer on the Stake account.
    //      */
    
    
    //     static authorize(params) {
    //       const {
    //         stakePubkey,
    //         authorizedPubkey,
    //         newAuthorizedPubkey,
    //         stakeAuthorizationType,
    //         custodianPubkey
    //       } = params;
    //       const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;
    //       const data = encodeData(type, {
    //         newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
    //         stakeAuthorizationType: stakeAuthorizationType.index
    //       });
    //       const keys = [{
    //         pubkey: stakePubkey,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: SYSVAR_CLOCK_PUBKEY,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: authorizedPubkey,
    //         isSigner: true,
    //         isWritable: false
    //       }];
    
    //       if (custodianPubkey) {
    //         keys.push({
    //           pubkey: custodianPubkey,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //       }
    
    //       return new Transaction().add({
    //         keys,
    //         programId: this.programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Generate a Transaction that authorizes a new PublicKey as Staker
    //      * or Withdrawer on the Stake account.
    //      */
    
    
    //     static authorizeWithSeed(params) {
    //       const {
    //         stakePubkey,
    //         authorityBase,
    //         authoritySeed,
    //         authorityOwner,
    //         newAuthorizedPubkey,
    //         stakeAuthorizationType,
    //         custodianPubkey
    //       } = params;
    //       const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    //       const data = encodeData(type, {
    //         newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
    //         stakeAuthorizationType: stakeAuthorizationType.index,
    //         authoritySeed: authoritySeed,
    //         authorityOwner: toBuffer(authorityOwner.toBuffer())
    //       });
    //       const keys = [{
    //         pubkey: stakePubkey,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: authorityBase,
    //         isSigner: true,
    //         isWritable: false
    //       }, {
    //         pubkey: SYSVAR_CLOCK_PUBKEY,
    //         isSigner: false,
    //         isWritable: false
    //       }];
    
    //       if (custodianPubkey) {
    //         keys.push({
    //           pubkey: custodianPubkey,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //       }
    
    //       return new Transaction().add({
    //         keys,
    //         programId: this.programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Generate a Transaction that splits Stake tokens into another stake account
    //      */
    
    
    //     static split(params) {
    //       const {
    //         stakePubkey,
    //         authorizedPubkey,
    //         splitStakePubkey,
    //         lamports
    //       } = params;
    //       const transaction = new Transaction();
    //       transaction.add(SystemProgram.createAccount({
    //         fromPubkey: authorizedPubkey,
    //         newAccountPubkey: splitStakePubkey,
    //         lamports: 0,
    //         space: this.space,
    //         programId: this.programId
    //       }));
    //       const type = STAKE_INSTRUCTION_LAYOUTS.Split;
    //       const data = encodeData(type, {
    //         lamports
    //       });
    //       return transaction.add({
    //         keys: [{
    //           pubkey: stakePubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }, {
    //           pubkey: splitStakePubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }, {
    //           pubkey: authorizedPubkey,
    //           isSigner: true,
    //           isWritable: false
    //         }],
    //         programId: this.programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Generate a Transaction that withdraws deactivated Stake tokens.
    //      */
    
    
    //     static withdraw(params) {
    //       const {
    //         stakePubkey,
    //         authorizedPubkey,
    //         toPubkey,
    //         lamports,
    //         custodianPubkey
    //       } = params;
    //       const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
    //       const data = encodeData(type, {
    //         lamports
    //       });
    //       const keys = [{
    //         pubkey: stakePubkey,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: toPubkey,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: SYSVAR_CLOCK_PUBKEY,
    //         isSigner: false,
    //         isWritable: false
    //       }, {
    //         pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
    //         isSigner: false,
    //         isWritable: false
    //       }, {
    //         pubkey: authorizedPubkey,
    //         isSigner: true,
    //         isWritable: false
    //       }];
    
    //       if (custodianPubkey) {
    //         keys.push({
    //           pubkey: custodianPubkey,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //       }
    
    //       return new Transaction().add({
    //         keys,
    //         programId: this.programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Generate a Transaction that deactivates Stake tokens.
    //      */
    
    
    //     static deactivate(params) {
    //       const {
    //         stakePubkey,
    //         authorizedPubkey
    //       } = params;
    //       const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
    //       const data = encodeData(type);
    //       return new Transaction().add({
    //         keys: [{
    //           pubkey: stakePubkey,
    //           isSigner: false,
    //           isWritable: true
    //         }, {
    //           pubkey: SYSVAR_CLOCK_PUBKEY,
    //           isSigner: false,
    //           isWritable: false
    //         }, {
    //           pubkey: authorizedPubkey,
    //           isSigner: true,
    //           isWritable: false
    //         }],
    //         programId: this.programId,
    //         data
    //       });
    //     }
    
    //   }
    
    //   _defineProperty(StakeProgram, "programId", new PublicKey('Stake11111111111111111111111111111111111111'));
    
    //   _defineProperty(StakeProgram, "space", 200);
    
    //   const {
    //     publicKeyCreate,
    //     ecdsaSign
    //   } = secp256k1;
    //   const PRIVATE_KEY_BYTES = 32;
    //   const ETHEREUM_ADDRESS_BYTES = 20;
    //   const PUBLIC_KEY_BYTES = 64;
    //   const SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
    //   /**
    //    * Params for creating an secp256k1 instruction using a public key
    //    */
    
    //   const SECP256K1_INSTRUCTION_LAYOUT = struct([u8('numSignatures'), u16('signatureOffset'), u8('signatureInstructionIndex'), u16('ethAddressOffset'), u8('ethAddressInstructionIndex'), u16('messageDataOffset'), u16('messageDataSize'), u8('messageInstructionIndex'), blob(20, 'ethAddress'), blob(64, 'signature'), u8('recoveryId')]);
    //   class Secp256k1Program {
    //     /**
    //      * @internal
    //      */
    //     constructor() {}
    //     /**
    //      * Public key that identifies the secp256k1 program
    //      */
    
    
    //     /**
    //      * Construct an Ethereum address from a secp256k1 public key buffer.
    //      * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
    //      */
    //     static publicKeyToEthAddress(publicKey) {
    //       assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);
    
    //       try {
    //         return buffer.Buffer.from(sha3.exports.keccak_256.update(toBuffer(publicKey)).digest()).slice(-ETHEREUM_ADDRESS_BYTES);
    //       } catch (error) {
    //         throw new Error(`Error constructing Ethereum address: ${error}`);
    //       }
    //     }
    //     /**
    //      * Create an secp256k1 instruction with a public key. The public key
    //      * must be a buffer that is 64 bytes long.
    //      */
    
    
    //     static createInstructionWithPublicKey(params) {
    //       const {
    //         publicKey,
    //         message,
    //         signature,
    //         recoveryId
    //       } = params;
    //       return Secp256k1Program.createInstructionWithEthAddress({
    //         ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),
    //         message,
    //         signature,
    //         recoveryId
    //       });
    //     }
    //     /**
    //      * Create an secp256k1 instruction with an Ethereum address. The address
    //      * must be a hex string or a buffer that is 20 bytes long.
    //      */
    
    
    //     static createInstructionWithEthAddress(params) {
    //       const {
    //         ethAddress: rawAddress,
    //         message,
    //         signature,
    //         recoveryId
    //       } = params;
    //       let ethAddress;
    
    //       if (typeof rawAddress === 'string') {
    //         if (rawAddress.startsWith('0x')) {
    //           ethAddress = buffer.Buffer.from(rawAddress.substr(2), 'hex');
    //         } else {
    //           ethAddress = buffer.Buffer.from(rawAddress, 'hex');
    //         }
    //       } else {
    //         ethAddress = rawAddress;
    //       }
    
    //       assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
    //       const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
    //       const ethAddressOffset = dataStart;
    //       const signatureOffset = dataStart + ethAddress.length;
    //       const messageDataOffset = signatureOffset + signature.length + 1;
    //       const numSignatures = 1;
    //       const instructionData = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
    //       SECP256K1_INSTRUCTION_LAYOUT.encode({
    //         numSignatures,
    //         signatureOffset,
    //         signatureInstructionIndex: 0,
    //         ethAddressOffset,
    //         ethAddressInstructionIndex: 0,
    //         messageDataOffset,
    //         messageDataSize: message.length,
    //         messageInstructionIndex: 0,
    //         signature: toBuffer(signature),
    //         ethAddress: toBuffer(ethAddress),
    //         recoveryId
    //       }, instructionData);
    //       instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
    //       return new TransactionInstruction({
    //         keys: [],
    //         programId: Secp256k1Program.programId,
    //         data: instructionData
    //       });
    //     }
    //     /**
    //      * Create an secp256k1 instruction with a private key. The private key
    //      * must be a buffer that is 32 bytes long.
    //      */
    
    
    //     static createInstructionWithPrivateKey(params) {
    //       const {
    //         privateKey: pkey,
    //         message
    //       } = params;
    //       assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
    
    //       try {
    //         const privateKey = toBuffer(pkey);
    //         const publicKey = publicKeyCreate(privateKey, false).slice(1); // throw away leading byte
    
    //         const messageHash = buffer.Buffer.from(sha3.exports.keccak_256.update(toBuffer(message)).digest());
    //         const {
    //           signature,
    //           recid: recoveryId
    //         } = ecdsaSign(messageHash, privateKey);
    //         return this.createInstructionWithPublicKey({
    //           publicKey,
    //           message,
    //           signature,
    //           recoveryId
    //         });
    //       } catch (error) {
    //         throw new Error(`Error creating instruction; ${error}`);
    //       }
    //     }
    
    //   }
    
    //   _defineProperty(Secp256k1Program, "programId", new PublicKey('KeccakSecp256k11111111111111111111111111111'));
    
    //   new PublicKey('Va1idator1nfo111111111111111111111111111111');
    //   /**
    //    * @internal
    //    */
    
    //   type({
    //     name: string(),
    //     website: optional(string()),
    //     details: optional(string()),
    //     keybaseUsername: optional(string())
    //   });
    
    //   new PublicKey('Vote111111111111111111111111111111111111111');
    
    //   /**
    //    * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88
    //    *
    //    * @internal
    //    */
    //   struct([publicKey$1('nodePubkey'), publicKey$1('authorizedVoterPubkey'), publicKey$1('authorizedWithdrawerPubkey'), u8('commission'), nu64(), // votes.length
    //   seq(struct([nu64('slot'), u32('confirmationCount')]), offset(u32(), -8), 'votes'), u8('rootSlotValid'), nu64('rootSlot'), nu64('epoch'), nu64('credits'), nu64('lastEpochCredits'), nu64(), // epochCredits.length
    //   seq(struct([nu64('epoch'), nu64('credits'), nu64('prevCredits')]), offset(u32(), -8), 'epochCredits')]);
    
    //   //      
    //   /**
    //    * Layout for a public key
    //    */
    
    //   const publicKey = (property = 'publicKey') => {
    //     return blob$1(32, property);
    //   };
    //   /**
    //    * Layout for a 64bit unsigned value
    //    */
    
    //   const uint64 = (property = 'uint64') => {
    //     return blob$1(8, property);
    //   };
    
    //   //      
    //   function sendAndConfirmTransaction(title, connection, transaction, ...signers) {
    //     return sendAndConfirmTransaction$1(connection, transaction, signers, {
    //       skipPreflight: false
    //     });
    //   }
    
    //   const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
    //   const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
    //   const FAILED_TO_FIND_ACCOUNT = 'Failed to find account';
    //   const INVALID_ACCOUNT_OWNER = 'Invalid account owner';
    //   /**
    //    * Unfortunately, BufferLayout.encode uses an `instanceof` check for `Buffer`
    //    * which fails when using `publicKey.toBuffer()` directly because the bundled `Buffer`
    //    * class in `@solana/web3.js` is different from the bundled `Buffer` class in this package
    //    */
    
    //   function pubkeyToBuffer(publicKey) {
    //     return buffer.Buffer.from(publicKey.toBuffer());
    //   }
    //   /**
    //    * 64-bit value
    //    */
    
    
    //   class u64 extends BN$9 {
    //     /**
    //      * Convert to Buffer representation
    //      */
    //     toBuffer() {
    //       const a = super.toArray().reverse();
    //       const b = buffer.Buffer.from(a);
    
    //       if (b.length === 8) {
    //         return b;
    //       }
    
    //       assert$j(b.length < 8, 'u64 too large');
    //       const zeroPad = buffer.Buffer.alloc(8);
    //       b.copy(zeroPad);
    //       return zeroPad;
    //     }
    //     /**
    //      * Construct a u64 from Buffer representation
    //      */
    
    
    //     static fromBuffer(buffer) {
    //       assert$j(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);
    //       return new u64([...buffer].reverse().map(i => `00${i.toString(16)}`.slice(-2)).join(''), 16);
    //     }
    
    //   }
    
    //   function isAccount(accountOrPublicKey) {
    //     return 'publicKey' in accountOrPublicKey;
    //   }
    
    //   const AuthorityTypeCodes = {
    //     MintTokens: 0,
    //     FreezeAccount: 1,
    //     AccountOwner: 2,
    //     CloseAccount: 3
    //   }; // The address of the special mint for wrapped native token.
    
    //   const NATIVE_MINT = new PublicKey('So11111111111111111111111111111111111111112');
    //   /**
    //    * Information about the mint
    //    */
    
    //   const MintLayout = struct$1([u32$1('mintAuthorityOption'), publicKey('mintAuthority'), uint64('supply'), u8$1('decimals'), u8$1('isInitialized'), u32$1('freezeAuthorityOption'), publicKey('freezeAuthority')]);
    //   /**
    //    * Information about an account
    //    */
    
    //   /**
    //    * @private
    //    */
    
    //   const AccountLayout = struct$1([publicKey('mint'), publicKey('owner'), uint64('amount'), u32$1('delegateOption'), publicKey('delegate'), u8$1('state'), u32$1('isNativeOption'), uint64('isNative'), uint64('delegatedAmount'), u32$1('closeAuthorityOption'), publicKey('closeAuthority')]);
    //   /**
    //    * Information about an multisig
    //    */
    
    //   /**
    //    * @private
    //    */
    
    //   const MultisigLayout = struct$1([u8$1('m'), u8$1('n'), u8$1('is_initialized'), publicKey('signer1'), publicKey('signer2'), publicKey('signer3'), publicKey('signer4'), publicKey('signer5'), publicKey('signer6'), publicKey('signer7'), publicKey('signer8'), publicKey('signer9'), publicKey('signer10'), publicKey('signer11')]);
    //   /**
    //    * An ERC20-like Token
    //    */
    
    //   class Token {
    //     /**
    //      * @private
    //      */
    
    //     /**
    //      * The public key identifying this mint
    //      */
    
    //     /**
    //      * Program Identifier for the Token program
    //      */
    
    //     /**
    //      * Program Identifier for the Associated Token program
    //      */
    
    //     /**
    //      * Fee payer
    //      */
    
    //     /**
    //      * Create a Token object attached to the specific mint
    //      *
    //      * @param connection The connection to use
    //      * @param token Public key of the mint
    //      * @param programId token programId
    //      * @param payer Payer of fees
    //      */
    //     constructor(connection, publicKey, programId, payer) {
    //       _defineProperty$1(this, "connection", void 0);
    
    //       _defineProperty$1(this, "publicKey", void 0);
    
    //       _defineProperty$1(this, "programId", void 0);
    
    //       _defineProperty$1(this, "associatedProgramId", void 0);
    
    //       _defineProperty$1(this, "payer", void 0);
    
    //       Object.assign(this, {
    //         connection,
    //         publicKey,
    //         programId,
    //         payer,
    //         // Hard code is ok; Overriding is needed only for tests
    //         associatedProgramId: ASSOCIATED_TOKEN_PROGRAM_ID
    //       });
    //     }
    //     /**
    //      * Get the minimum balance for the mint to be rent exempt
    //      *
    //      * @return Number of lamports required
    //      */
    
    
    //     static async getMinBalanceRentForExemptMint(connection) {
    //       return await connection.getMinimumBalanceForRentExemption(MintLayout.span);
    //     }
    //     /**
    //      * Get the minimum balance for the account to be rent exempt
    //      *
    //      * @return Number of lamports required
    //      */
    
    
    //     static async getMinBalanceRentForExemptAccount(connection) {
    //       return await connection.getMinimumBalanceForRentExemption(AccountLayout.span);
    //     }
    //     /**
    //      * Get the minimum balance for the multsig to be rent exempt
    //      *
    //      * @return Number of lamports required
    //      */
    
    
    //     static async getMinBalanceRentForExemptMultisig(connection) {
    //       return await connection.getMinimumBalanceForRentExemption(MultisigLayout.span);
    //     }
    //     /**
    //      * Create and initialize a token.
    //      *
    //      * @param connection The connection to use
    //      * @param payer Fee payer for transaction
    //      * @param mintAuthority Account or multisig that will control minting
    //      * @param freezeAuthority Optional account or multisig that can freeze token accounts
    //      * @param decimals Location of the decimal place
    //      * @param programId Optional token programId, uses the system programId by default
    //      * @return Token object for the newly minted token
    //      */
    
    
    //     static async createMint(connection, payer, mintAuthority, freezeAuthority, decimals, programId) {
    //       const mintAccount = Keypair.generate();
    //       const token = new Token(connection, mintAccount.publicKey, programId, payer); // Allocate memory for the account
    
    //       const balanceNeeded = await Token.getMinBalanceRentForExemptMint(connection);
    //       const transaction = new Transaction();
    //       transaction.add(SystemProgram.createAccount({
    //         fromPubkey: payer.publicKey,
    //         newAccountPubkey: mintAccount.publicKey,
    //         lamports: balanceNeeded,
    //         space: MintLayout.span,
    //         programId
    //       }));
    //       transaction.add(Token.createInitMintInstruction(programId, mintAccount.publicKey, decimals, mintAuthority, freezeAuthority)); // Send the two instructions
    
    //       await sendAndConfirmTransaction('createAccount and InitializeMint', connection, transaction, payer, mintAccount);
    //       return token;
    //     }
    //     /**
    //      * Create and initialize a new account.
    //      *
    //      * This account may then be used as a `transfer()` or `approve()` destination
    //      *
    //      * @param owner User account that will own the new account
    //      * @return Public key of the new empty account
    //      */
    
    
    //     async createAccount(owner) {
    //       // Allocate memory for the account
    //       const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(this.connection);
    //       const newAccount = Keypair.generate();
    //       const transaction = new Transaction();
    //       transaction.add(SystemProgram.createAccount({
    //         fromPubkey: this.payer.publicKey,
    //         newAccountPubkey: newAccount.publicKey,
    //         lamports: balanceNeeded,
    //         space: AccountLayout.span,
    //         programId: this.programId
    //       }));
    //       const mintPublicKey = this.publicKey;
    //       transaction.add(Token.createInitAccountInstruction(this.programId, mintPublicKey, newAccount.publicKey, owner)); // Send the two instructions
    
    //       await sendAndConfirmTransaction('createAccount and InitializeAccount', this.connection, transaction, this.payer, newAccount);
    //       return newAccount.publicKey;
    //     }
    //     /**
    //      * Create and initialize the associated account.
    //      *
    //      * This account may then be used as a `transfer()` or `approve()` destination
    //      *
    //      * @param owner User account that will own the new account
    //      * @return Public key of the new associated account
    //      */
    
    
    //     async createAssociatedTokenAccount(owner) {
    //       const associatedAddress = await Token.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, owner);
    //       return this.createAssociatedTokenAccountInternal(owner, associatedAddress);
    //     }
    
    //     async createAssociatedTokenAccountInternal(owner, associatedAddress) {
    //       await sendAndConfirmTransaction('CreateAssociatedTokenAccount', this.connection, new Transaction().add(Token.createAssociatedTokenAccountInstruction(this.associatedProgramId, this.programId, this.publicKey, associatedAddress, owner, this.payer.publicKey)), this.payer);
    //       return associatedAddress;
    //     }
    //     /**
    //      * Retrieve the associated account or create one if not found.
    //      *
    //      * This account may then be used as a `transfer()` or `approve()` destination
    //      *
    //      * @param owner User account that will own the new account
    //      * @return The new associated account
    //      */
    
    
    //     async getOrCreateAssociatedAccountInfo(owner) {
    //       const associatedAddress = await Token.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, owner); // This is the optimum logic, considering TX fee, client-side computation,
    //       // RPC roundtrips and guaranteed idempotent.
    //       // Sadly we can't do this atomically;
    
    //       try {
    //         return await this.getAccountInfo(associatedAddress);
    //       } catch (err) {
    //         // INVALID_ACCOUNT_OWNER can be possible if the associatedAddress has
    //         // already been received some lamports (= became system accounts).
    //         // Assuming program derived addressing is safe, this is the only case
    //         // for the INVALID_ACCOUNT_OWNER in this code-path
    //         if (err.message === FAILED_TO_FIND_ACCOUNT || err.message === INVALID_ACCOUNT_OWNER) {
    //           // as this isn't atomic, it's possible others can create associated
    //           // accounts meanwhile
    //           try {
    //             await this.createAssociatedTokenAccountInternal(owner, associatedAddress);
    //           } catch (err) {// ignore all errors; for now there is no API compatible way to
    //             // selectively ignore the expected instruction error if the
    //             // associated account is existing already.
    //           } // Now this should always succeed
    
    
    //           return await this.getAccountInfo(associatedAddress);
    //         } else {
    //           throw err;
    //         }
    //       }
    //     }
    //     /**
    //      * Create and initialize a new account on the special native token mint.
    //      *
    //      * In order to be wrapped, the account must have a balance of native tokens
    //      * when it is initialized with the token program.
    //      *
    //      * This function sends lamports to the new account before initializing it.
    //      *
    //      * @param connection A solana web3 connection
    //      * @param programId The token program ID
    //      * @param owner The owner of the new token account
    //      * @param payer The source of the lamports to initialize, and payer of the initialization fees.
    //      * @param amount The amount of lamports to wrap
    //      * @return {Promise<PublicKey>} The new token account
    //      */
    
    
    //     static async createWrappedNativeAccount(connection, programId, owner, payer, amount) {
    //       // Allocate memory for the account
    //       const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(connection); // Create a new account
    
    //       const newAccount = Keypair.generate();
    //       const transaction = new Transaction();
    //       transaction.add(SystemProgram.createAccount({
    //         fromPubkey: payer.publicKey,
    //         newAccountPubkey: newAccount.publicKey,
    //         lamports: balanceNeeded,
    //         space: AccountLayout.span,
    //         programId
    //       })); // Send lamports to it (these will be wrapped into native tokens by the token program)
    
    //       transaction.add(SystemProgram.transfer({
    //         fromPubkey: payer.publicKey,
    //         toPubkey: newAccount.publicKey,
    //         lamports: amount
    //       })); // Assign the new account to the native token mint.
    //       // the account will be initialized with a balance equal to the native token balance.
    //       // (i.e. amount)
    
    //       transaction.add(Token.createInitAccountInstruction(programId, NATIVE_MINT, newAccount.publicKey, owner)); // Send the three instructions
    
    //       await sendAndConfirmTransaction('createAccount, transfer, and initializeAccount', connection, transaction, payer, newAccount);
    //       return newAccount.publicKey;
    //     }
    //     /**
    //      * Create and initialize a new multisig.
    //      *
    //      * This account may then be used for multisignature verification
    //      *
    //      * @param m Number of required signatures
    //      * @param signers Full set of signers
    //      * @return Public key of the new multisig account
    //      */
    
    
    //     async createMultisig(m, signers) {
    //       const multisigAccount = Keypair.generate(); // Allocate memory for the account
    
    //       const balanceNeeded = await Token.getMinBalanceRentForExemptMultisig(this.connection);
    //       const transaction = new Transaction();
    //       transaction.add(SystemProgram.createAccount({
    //         fromPubkey: this.payer.publicKey,
    //         newAccountPubkey: multisigAccount.publicKey,
    //         lamports: balanceNeeded,
    //         space: MultisigLayout.span,
    //         programId: this.programId
    //       })); // create the new account
    
    //       let keys = [{
    //         pubkey: multisigAccount.publicKey,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: SYSVAR_RENT_PUBKEY,
    //         isSigner: false,
    //         isWritable: false
    //       }];
    //       signers.forEach(signer => keys.push({
    //         pubkey: signer,
    //         isSigner: false,
    //         isWritable: false
    //       }));
    //       const dataLayout = struct$1([u8$1('instruction'), u8$1('m')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 2,
    //         // InitializeMultisig instruction
    //         m
    //       }, data);
    //       transaction.add({
    //         keys,
    //         programId: this.programId,
    //         data
    //       }); // Send the two instructions
    
    //       await sendAndConfirmTransaction('createAccount and InitializeMultisig', this.connection, transaction, this.payer, multisigAccount);
    //       return multisigAccount.publicKey;
    //     }
    //     /**
    //      * Retrieve mint information
    //      */
    
    
    //     async getMintInfo() {
    //       const info = await this.connection.getAccountInfo(this.publicKey);
    
    //       if (info === null) {
    //         throw new Error('Failed to find mint account');
    //       }
    
    //       if (!info.owner.equals(this.programId)) {
    //         throw new Error(`Invalid mint owner: ${JSON.stringify(info.owner)}`);
    //       }
    
    //       if (info.data.length != MintLayout.span) {
    //         throw new Error(`Invalid mint size`);
    //       }
    
    //       const data = buffer.Buffer.from(info.data);
    //       const mintInfo = MintLayout.decode(data);
    
    //       if (mintInfo.mintAuthorityOption === 0) {
    //         mintInfo.mintAuthority = null;
    //       } else {
    //         mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);
    //       }
    
    //       mintInfo.supply = u64.fromBuffer(mintInfo.supply);
    //       mintInfo.isInitialized = mintInfo.isInitialized != 0;
    
    //       if (mintInfo.freezeAuthorityOption === 0) {
    //         mintInfo.freezeAuthority = null;
    //       } else {
    //         mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);
    //       }
    
    //       return mintInfo;
    //     }
    //     /**
    //      * Retrieve account information
    //      *
    //      * @param account Public key of the account
    //      */
    
    
    //     async getAccountInfo(account, commitment) {
    //       const info = await this.connection.getAccountInfo(account, commitment);
    
    //       if (info === null) {
    //         throw new Error(FAILED_TO_FIND_ACCOUNT);
    //       }
    
    //       if (!info.owner.equals(this.programId)) {
    //         throw new Error(INVALID_ACCOUNT_OWNER);
    //       }
    
    //       if (info.data.length != AccountLayout.span) {
    //         throw new Error(`Invalid account size`);
    //       }
    
    //       const data = buffer.Buffer.from(info.data);
    //       const accountInfo = AccountLayout.decode(data);
    //       accountInfo.address = account;
    //       accountInfo.mint = new PublicKey(accountInfo.mint);
    //       accountInfo.owner = new PublicKey(accountInfo.owner);
    //       accountInfo.amount = u64.fromBuffer(accountInfo.amount);
    
    //       if (accountInfo.delegateOption === 0) {
    //         accountInfo.delegate = null;
    //         accountInfo.delegatedAmount = new u64();
    //       } else {
    //         accountInfo.delegate = new PublicKey(accountInfo.delegate);
    //         accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);
    //       }
    
    //       accountInfo.isInitialized = accountInfo.state !== 0;
    //       accountInfo.isFrozen = accountInfo.state === 2;
    
    //       if (accountInfo.isNativeOption === 1) {
    //         accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);
    //         accountInfo.isNative = true;
    //       } else {
    //         accountInfo.rentExemptReserve = null;
    //         accountInfo.isNative = false;
    //       }
    
    //       if (accountInfo.closeAuthorityOption === 0) {
    //         accountInfo.closeAuthority = null;
    //       } else {
    //         accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);
    //       }
    
    //       if (!accountInfo.mint.equals(this.publicKey)) {
    //         throw new Error(`Invalid account mint: ${JSON.stringify(accountInfo.mint)} !== ${JSON.stringify(this.publicKey)}`);
    //       }
    
    //       return accountInfo;
    //     }
    //     /**
    //      * Retrieve Multisig information
    //      *
    //      * @param multisig Public key of the account
    //      */
    
    
    //     async getMultisigInfo(multisig) {
    //       const info = await this.connection.getAccountInfo(multisig);
    
    //       if (info === null) {
    //         throw new Error('Failed to find multisig');
    //       }
    
    //       if (!info.owner.equals(this.programId)) {
    //         throw new Error(`Invalid multisig owner`);
    //       }
    
    //       if (info.data.length != MultisigLayout.span) {
    //         throw new Error(`Invalid multisig size`);
    //       }
    
    //       const data = buffer.Buffer.from(info.data);
    //       const multisigInfo = MultisigLayout.decode(data);
    //       multisigInfo.signer1 = new PublicKey(multisigInfo.signer1);
    //       multisigInfo.signer2 = new PublicKey(multisigInfo.signer2);
    //       multisigInfo.signer3 = new PublicKey(multisigInfo.signer3);
    //       multisigInfo.signer4 = new PublicKey(multisigInfo.signer4);
    //       multisigInfo.signer5 = new PublicKey(multisigInfo.signer5);
    //       multisigInfo.signer6 = new PublicKey(multisigInfo.signer6);
    //       multisigInfo.signer7 = new PublicKey(multisigInfo.signer7);
    //       multisigInfo.signer8 = new PublicKey(multisigInfo.signer8);
    //       multisigInfo.signer9 = new PublicKey(multisigInfo.signer9);
    //       multisigInfo.signer10 = new PublicKey(multisigInfo.signer10);
    //       multisigInfo.signer11 = new PublicKey(multisigInfo.signer11);
    //       return multisigInfo;
    //     }
    //     /**
    //      * Transfer tokens to another account
    //      *
    //      * @param source Source account
    //      * @param destination Destination account
    //      * @param owner Owner of the source account
    //      * @param multiSigners Signing accounts if `owner` is a multiSig
    //      * @param amount Number of tokens to transfer
    //      */
    
    
    //     async transfer(source, destination, owner, multiSigners, amount) {
    //       let ownerPublicKey;
    //       let signers;
    
    //       if (isAccount(owner)) {
    //         ownerPublicKey = owner.publicKey;
    //         signers = [owner];
    //       } else {
    //         ownerPublicKey = owner;
    //         signers = multiSigners;
    //       }
    
    //       return await sendAndConfirmTransaction('Transfer', this.connection, new Transaction().add(Token.createTransferInstruction(this.programId, source, destination, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);
    //     }
    //     /**
    //      * Grant a third-party permission to transfer up the specified number of tokens from an account
    //      *
    //      * @param account Public key of the account
    //      * @param delegate Account authorized to perform a transfer tokens from the source account
    //      * @param owner Owner of the source account
    //      * @param multiSigners Signing accounts if `owner` is a multiSig
    //      * @param amount Maximum number of tokens the delegate may transfer
    //      */
    
    
    //     async approve(account, delegate, owner, multiSigners, amount) {
    //       let ownerPublicKey;
    //       let signers;
    
    //       if (isAccount(owner)) {
    //         ownerPublicKey = owner.publicKey;
    //         signers = [owner];
    //       } else {
    //         ownerPublicKey = owner;
    //         signers = multiSigners;
    //       }
    
    //       await sendAndConfirmTransaction('Approve', this.connection, new Transaction().add(Token.createApproveInstruction(this.programId, account, delegate, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);
    //     }
    //     /**
    //      * Remove approval for the transfer of any remaining tokens
    //      *
    //      * @param account Public key of the account
    //      * @param owner Owner of the source account
    //      * @param multiSigners Signing accounts if `owner` is a multiSig
    //      */
    
    
    //     async revoke(account, owner, multiSigners) {
    //       let ownerPublicKey;
    //       let signers;
    
    //       if (isAccount(owner)) {
    //         ownerPublicKey = owner.publicKey;
    //         signers = [owner];
    //       } else {
    //         ownerPublicKey = owner;
    //         signers = multiSigners;
    //       }
    
    //       await sendAndConfirmTransaction('Revoke', this.connection, new Transaction().add(Token.createRevokeInstruction(this.programId, account, ownerPublicKey, multiSigners)), this.payer, ...signers);
    //     }
    //     /**
    //      * Assign a new authority to the account
    //      *
    //      * @param account Public key of the account
    //      * @param newAuthority New authority of the account
    //      * @param authorityType Type of authority to set
    //      * @param currentAuthority Current authority of the account
    //      * @param multiSigners Signing accounts if `currentAuthority` is a multiSig
    //      */
    
    
    //     async setAuthority(account, newAuthority, authorityType, currentAuthority, multiSigners) {
    //       let currentAuthorityPublicKey;
    //       let signers;
    
    //       if (isAccount(currentAuthority)) {
    //         currentAuthorityPublicKey = currentAuthority.publicKey;
    //         signers = [currentAuthority];
    //       } else {
    //         currentAuthorityPublicKey = currentAuthority;
    //         signers = multiSigners;
    //       }
    
    //       await sendAndConfirmTransaction('SetAuthority', this.connection, new Transaction().add(Token.createSetAuthorityInstruction(this.programId, account, newAuthority, authorityType, currentAuthorityPublicKey, multiSigners)), this.payer, ...signers);
    //     }
    //     /**
    //      * Mint new tokens
    //      *
    //      * @param dest Public key of the account to mint to
    //      * @param authority Minting authority
    //      * @param multiSigners Signing accounts if `authority` is a multiSig
    //      * @param amount Amount to mint
    //      */
    
    
    //     async mintTo(dest, authority, multiSigners, amount) {
    //       let ownerPublicKey;
    //       let signers;
    
    //       if (isAccount(authority)) {
    //         ownerPublicKey = authority.publicKey;
    //         signers = [authority];
    //       } else {
    //         ownerPublicKey = authority;
    //         signers = multiSigners;
    //       }
    
    //       await sendAndConfirmTransaction('MintTo', this.connection, new Transaction().add(Token.createMintToInstruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);
    //     }
    //     /**
    //      * Burn tokens
    //      *
    //      * @param account Account to burn tokens from
    //      * @param owner Account owner
    //      * @param multiSigners Signing accounts if `owner` is a multiSig
    //      * @param amount Amount to burn
    //      */
    
    
    //     async burn(account, owner, multiSigners, amount) {
    //       let ownerPublicKey;
    //       let signers;
    
    //       if (isAccount(owner)) {
    //         ownerPublicKey = owner.publicKey;
    //         signers = [owner];
    //       } else {
    //         ownerPublicKey = owner;
    //         signers = multiSigners;
    //       }
    
    //       await sendAndConfirmTransaction('Burn', this.connection, new Transaction().add(Token.createBurnInstruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);
    //     }
    //     /**
    //      * Close account
    //      *
    //      * @param account Account to close
    //      * @param dest Account to receive the remaining balance of the closed account
    //      * @param authority Authority which is allowed to close the account
    //      * @param multiSigners Signing accounts if `authority` is a multiSig
    //      */
    
    
    //     async closeAccount(account, dest, authority, multiSigners) {
    //       let authorityPublicKey;
    //       let signers;
    
    //       if (isAccount(authority)) {
    //         authorityPublicKey = authority.publicKey;
    //         signers = [authority];
    //       } else {
    //         authorityPublicKey = authority;
    //         signers = multiSigners;
    //       }
    
    //       await sendAndConfirmTransaction('CloseAccount', this.connection, new Transaction().add(Token.createCloseAccountInstruction(this.programId, account, dest, authorityPublicKey, multiSigners)), this.payer, ...signers);
    //     }
    //     /**
    //      * Freeze account
    //      *
    //      * @param account Account to freeze
    //      * @param authority The mint freeze authority
    //      * @param multiSigners Signing accounts if `authority` is a multiSig
    //      */
    
    
    //     async freezeAccount(account, authority, multiSigners) {
    //       let authorityPublicKey;
    //       let signers;
    
    //       if (isAccount(authority)) {
    //         authorityPublicKey = authority.publicKey;
    //         signers = [authority];
    //       } else {
    //         authorityPublicKey = authority;
    //         signers = multiSigners;
    //       }
    
    //       await sendAndConfirmTransaction('FreezeAccount', this.connection, new Transaction().add(Token.createFreezeAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer, ...signers);
    //     }
    //     /**
    //      * Thaw account
    //      *
    //      * @param account Account to thaw
    //      * @param authority The mint freeze authority
    //      * @param multiSigners Signing accounts if `authority` is a multiSig
    //      */
    
    
    //     async thawAccount(account, authority, multiSigners) {
    //       let authorityPublicKey;
    //       let signers;
    
    //       if (isAccount(authority)) {
    //         authorityPublicKey = authority.publicKey;
    //         signers = [authority];
    //       } else {
    //         authorityPublicKey = authority;
    //         signers = multiSigners;
    //       }
    
    //       await sendAndConfirmTransaction('ThawAccount', this.connection, new Transaction().add(Token.createThawAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer, ...signers);
    //     }
    //     /**
    //      * Transfer tokens to another account, asserting the token mint and decimals
    //      *
    //      * @param source Source account
    //      * @param destination Destination account
    //      * @param owner Owner of the source account
    //      * @param multiSigners Signing accounts if `owner` is a multiSig
    //      * @param amount Number of tokens to transfer
    //      * @param decimals Number of decimals in transfer amount
    //      */
    
    
    //     async transferChecked(source, destination, owner, multiSigners, amount, decimals) {
    //       let ownerPublicKey;
    //       let signers;
    
    //       if (isAccount(owner)) {
    //         ownerPublicKey = owner.publicKey;
    //         signers = [owner];
    //       } else {
    //         ownerPublicKey = owner;
    //         signers = multiSigners;
    //       }
    
    //       return await sendAndConfirmTransaction('TransferChecked', this.connection, new Transaction().add(Token.createTransferCheckedInstruction(this.programId, source, this.publicKey, destination, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);
    //     }
    //     /**
    //      * Grant a third-party permission to transfer up the specified number of tokens from an account,
    //      * asserting the token mint and decimals
    //      *
    //      * @param account Public key of the account
    //      * @param delegate Account authorized to perform a transfer tokens from the source account
    //      * @param owner Owner of the source account
    //      * @param multiSigners Signing accounts if `owner` is a multiSig
    //      * @param amount Maximum number of tokens the delegate may transfer
    //      * @param decimals Number of decimals in approve amount
    //      */
    
    
    //     async approveChecked(account, delegate, owner, multiSigners, amount, decimals) {
    //       let ownerPublicKey;
    //       let signers;
    
    //       if (isAccount(owner)) {
    //         ownerPublicKey = owner.publicKey;
    //         signers = [owner];
    //       } else {
    //         ownerPublicKey = owner;
    //         signers = multiSigners;
    //       }
    
    //       await sendAndConfirmTransaction('ApproveChecked', this.connection, new Transaction().add(Token.createApproveCheckedInstruction(this.programId, account, this.publicKey, delegate, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);
    //     }
    //     /**
    //      * Mint new tokens, asserting the token mint and decimals
    //      *
    //      * @param dest Public key of the account to mint to
    //      * @param authority Minting authority
    //      * @param multiSigners Signing accounts if `authority` is a multiSig
    //      * @param amount Amount to mint
    //      * @param decimals Number of decimals in amount to mint
    //      */
    
    
    //     async mintToChecked(dest, authority, multiSigners, amount, decimals) {
    //       let ownerPublicKey;
    //       let signers;
    
    //       if (isAccount(authority)) {
    //         ownerPublicKey = authority.publicKey;
    //         signers = [authority];
    //       } else {
    //         ownerPublicKey = authority;
    //         signers = multiSigners;
    //       }
    
    //       await sendAndConfirmTransaction('MintToChecked', this.connection, new Transaction().add(Token.createMintToCheckedInstruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);
    //     }
    //     /**
    //      * Burn tokens, asserting the token mint and decimals
    //      *
    //      * @param account Account to burn tokens from
    //      * @param owner Account owner
    //      * @param multiSigners Signing accounts if `owner` is a multiSig
    //      * @param amount Amount to burn
    //      * @param decimals Number of decimals in amount to burn
    //      */
    
    
    //     async burnChecked(account, owner, multiSigners, amount, decimals) {
    //       let ownerPublicKey;
    //       let signers;
    
    //       if (isAccount(owner)) {
    //         ownerPublicKey = owner.publicKey;
    //         signers = [owner];
    //       } else {
    //         ownerPublicKey = owner;
    //         signers = multiSigners;
    //       }
    
    //       await sendAndConfirmTransaction('BurnChecked', this.connection, new Transaction().add(Token.createBurnCheckedInstruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);
    //     }
    //     /**
    //      * Sync amount in native SPL token account to underlying lamports
    //      *
    //      * @param nativeAccount Account to sync
    //      */
    
    
    //     async syncNative(nativeAccount) {
    //       await sendAndConfirmTransaction('SyncNative', this.connection, new Transaction().add(Token.createSyncNativeInstruction(this.programId, nativeAccount)), this.payer);
    //     }
    //     /**
    //      * Construct an InitializeMint instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param mint Token mint account
    //      * @param decimals Number of decimals in token account amounts
    //      * @param mintAuthority Minting authority
    //      * @param freezeAuthority Optional authority that can freeze token accounts
    //      */
    
    
    //     static createInitMintInstruction(programId, mint, decimals, mintAuthority, freezeAuthority) {
    //       let keys = [{
    //         pubkey: mint,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: SYSVAR_RENT_PUBKEY,
    //         isSigner: false,
    //         isWritable: false
    //       }];
    //       const commandDataLayout = struct$1([u8$1('instruction'), u8$1('decimals'), publicKey('mintAuthority'), u8$1('option'), publicKey('freezeAuthority')]);
    //       let data = buffer.Buffer.alloc(1024);
    //       {
    //         const encodeLength = commandDataLayout.encode({
    //           instruction: 0,
    //           // InitializeMint instruction
    //           decimals,
    //           mintAuthority: pubkeyToBuffer(mintAuthority),
    //           option: freezeAuthority === null ? 0 : 1,
    //           freezeAuthority: pubkeyToBuffer(freezeAuthority || new PublicKey(0))
    //         }, data);
    //         data = data.slice(0, encodeLength);
    //       }
    //       return new TransactionInstruction({
    //         keys,
    //         programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct an InitializeAccount instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param mint Token mint account
    //      * @param account New account
    //      * @param owner Owner of the new account
    //      */
    
    
    //     static createInitAccountInstruction(programId, mint, account, owner) {
    //       const keys = [{
    //         pubkey: account,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: mint,
    //         isSigner: false,
    //         isWritable: false
    //       }, {
    //         pubkey: owner,
    //         isSigner: false,
    //         isWritable: false
    //       }, {
    //         pubkey: SYSVAR_RENT_PUBKEY,
    //         isSigner: false,
    //         isWritable: false
    //       }];
    //       const dataLayout = struct$1([u8$1('instruction')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 1 // InitializeAccount instruction
    
    //       }, data);
    //       return new TransactionInstruction({
    //         keys,
    //         programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct a Transfer instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param source Source account
    //      * @param destination Destination account
    //      * @param owner Owner of the source account
    //      * @param multiSigners Signing accounts if `authority` is a multiSig
    //      * @param amount Number of tokens to transfer
    //      */
    
    
    //     static createTransferInstruction(programId, source, destination, owner, multiSigners, amount) {
    //       const dataLayout = struct$1([u8$1('instruction'), uint64('amount')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 3,
    //         // Transfer instruction
    //         amount: new u64(amount).toBuffer()
    //       }, data);
    //       let keys = [{
    //         pubkey: source,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: destination,
    //         isSigner: false,
    //         isWritable: true
    //       }];
    
    //       if (multiSigners.length === 0) {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       } else {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //         multiSigners.forEach(signer => keys.push({
    //           pubkey: signer.publicKey,
    //           isSigner: true,
    //           isWritable: false
    //         }));
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct an Approve instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param account Public key of the account
    //      * @param delegate Account authorized to perform a transfer of tokens from the source account
    //      * @param owner Owner of the source account
    //      * @param multiSigners Signing accounts if `owner` is a multiSig
    //      * @param amount Maximum number of tokens the delegate may transfer
    //      */
    
    
    //     static createApproveInstruction(programId, account, delegate, owner, multiSigners, amount) {
    //       const dataLayout = struct$1([u8$1('instruction'), uint64('amount')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 4,
    //         // Approve instruction
    //         amount: new u64(amount).toBuffer()
    //       }, data);
    //       let keys = [{
    //         pubkey: account,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: delegate,
    //         isSigner: false,
    //         isWritable: false
    //       }];
    
    //       if (multiSigners.length === 0) {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       } else {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //         multiSigners.forEach(signer => keys.push({
    //           pubkey: signer.publicKey,
    //           isSigner: true,
    //           isWritable: false
    //         }));
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct a Revoke instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param account Public key of the account
    //      * @param owner Owner of the source account
    //      * @param multiSigners Signing accounts if `owner` is a multiSig
    //      */
    
    
    //     static createRevokeInstruction(programId, account, owner, multiSigners) {
    //       const dataLayout = struct$1([u8$1('instruction')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 5 // Approve instruction
    
    //       }, data);
    //       let keys = [{
    //         pubkey: account,
    //         isSigner: false,
    //         isWritable: true
    //       }];
    
    //       if (multiSigners.length === 0) {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       } else {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //         multiSigners.forEach(signer => keys.push({
    //           pubkey: signer.publicKey,
    //           isSigner: true,
    //           isWritable: false
    //         }));
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct a SetAuthority instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param account Public key of the account
    //      * @param newAuthority New authority of the account
    //      * @param authorityType Type of authority to set
    //      * @param currentAuthority Current authority of the specified type
    //      * @param multiSigners Signing accounts if `currentAuthority` is a multiSig
    //      */
    
    
    //     static createSetAuthorityInstruction(programId, account, newAuthority, authorityType, currentAuthority, multiSigners) {
    //       const commandDataLayout = struct$1([u8$1('instruction'), u8$1('authorityType'), u8$1('option'), publicKey('newAuthority')]);
    //       let data = buffer.Buffer.alloc(1024);
    //       {
    //         const encodeLength = commandDataLayout.encode({
    //           instruction: 6,
    //           // SetAuthority instruction
    //           authorityType: AuthorityTypeCodes[authorityType],
    //           option: newAuthority === null ? 0 : 1,
    //           newAuthority: pubkeyToBuffer(newAuthority || new PublicKey(0))
    //         }, data);
    //         data = data.slice(0, encodeLength);
    //       }
    //       let keys = [{
    //         pubkey: account,
    //         isSigner: false,
    //         isWritable: true
    //       }];
    
    //       if (multiSigners.length === 0) {
    //         keys.push({
    //           pubkey: currentAuthority,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       } else {
    //         keys.push({
    //           pubkey: currentAuthority,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //         multiSigners.forEach(signer => keys.push({
    //           pubkey: signer.publicKey,
    //           isSigner: true,
    //           isWritable: false
    //         }));
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct a MintTo instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param mint Public key of the mint
    //      * @param dest Public key of the account to mint to
    //      * @param authority The mint authority
    //      * @param multiSigners Signing accounts if `authority` is a multiSig
    //      * @param amount Amount to mint
    //      */
    
    
    //     static createMintToInstruction(programId, mint, dest, authority, multiSigners, amount) {
    //       const dataLayout = struct$1([u8$1('instruction'), uint64('amount')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 7,
    //         // MintTo instruction
    //         amount: new u64(amount).toBuffer()
    //       }, data);
    //       let keys = [{
    //         pubkey: mint,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: dest,
    //         isSigner: false,
    //         isWritable: true
    //       }];
    
    //       if (multiSigners.length === 0) {
    //         keys.push({
    //           pubkey: authority,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       } else {
    //         keys.push({
    //           pubkey: authority,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //         multiSigners.forEach(signer => keys.push({
    //           pubkey: signer.publicKey,
    //           isSigner: true,
    //           isWritable: false
    //         }));
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct a Burn instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param mint Mint for the account
    //      * @param account Account to burn tokens from
    //      * @param owner Owner of the account
    //      * @param multiSigners Signing accounts if `authority` is a multiSig
    //      * @param amount amount to burn
    //      */
    
    
    //     static createBurnInstruction(programId, mint, account, owner, multiSigners, amount) {
    //       const dataLayout = struct$1([u8$1('instruction'), uint64('amount')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 8,
    //         // Burn instruction
    //         amount: new u64(amount).toBuffer()
    //       }, data);
    //       let keys = [{
    //         pubkey: account,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: mint,
    //         isSigner: false,
    //         isWritable: true
    //       }];
    
    //       if (multiSigners.length === 0) {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       } else {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //         multiSigners.forEach(signer => keys.push({
    //           pubkey: signer.publicKey,
    //           isSigner: true,
    //           isWritable: false
    //         }));
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct a Close instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param account Account to close
    //      * @param dest Account to receive the remaining balance of the closed account
    //      * @param authority Account Close authority
    //      * @param multiSigners Signing accounts if `owner` is a multiSig
    //      */
    
    
    //     static createCloseAccountInstruction(programId, account, dest, owner, multiSigners) {
    //       const dataLayout = struct$1([u8$1('instruction')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 9 // CloseAccount instruction
    
    //       }, data);
    //       let keys = [{
    //         pubkey: account,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: dest,
    //         isSigner: false,
    //         isWritable: true
    //       }];
    
    //       if (multiSigners.length === 0) {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       } else {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //         multiSigners.forEach(signer => keys.push({
    //           pubkey: signer.publicKey,
    //           isSigner: true,
    //           isWritable: false
    //         }));
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct a Freeze instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param account Account to freeze
    //      * @param mint Mint account
    //      * @param authority Mint freeze authority
    //      * @param multiSigners Signing accounts if `owner` is a multiSig
    //      */
    
    
    //     static createFreezeAccountInstruction(programId, account, mint, authority, multiSigners) {
    //       const dataLayout = struct$1([u8$1('instruction')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 10 // FreezeAccount instruction
    
    //       }, data);
    //       let keys = [{
    //         pubkey: account,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: mint,
    //         isSigner: false,
    //         isWritable: false
    //       }];
    
    //       if (multiSigners.length === 0) {
    //         keys.push({
    //           pubkey: authority,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       } else {
    //         keys.push({
    //           pubkey: authority,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //         multiSigners.forEach(signer => keys.push({
    //           pubkey: signer.publicKey,
    //           isSigner: true,
    //           isWritable: false
    //         }));
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct a Thaw instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param account Account to thaw
    //      * @param mint Mint account
    //      * @param authority Mint freeze authority
    //      * @param multiSigners Signing accounts if `owner` is a multiSig
    //      */
    
    
    //     static createThawAccountInstruction(programId, account, mint, authority, multiSigners) {
    //       const dataLayout = struct$1([u8$1('instruction')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 11 // ThawAccount instruction
    
    //       }, data);
    //       let keys = [{
    //         pubkey: account,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: mint,
    //         isSigner: false,
    //         isWritable: false
    //       }];
    
    //       if (multiSigners.length === 0) {
    //         keys.push({
    //           pubkey: authority,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       } else {
    //         keys.push({
    //           pubkey: authority,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //         multiSigners.forEach(signer => keys.push({
    //           pubkey: signer.publicKey,
    //           isSigner: true,
    //           isWritable: false
    //         }));
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct a TransferChecked instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param source Source account
    //      * @param mint Mint account
    //      * @param destination Destination account
    //      * @param owner Owner of the source account
    //      * @param multiSigners Signing accounts if `authority` is a multiSig
    //      * @param amount Number of tokens to transfer
    //      * @param decimals Number of decimals in transfer amount
    //      */
    
    
    //     static createTransferCheckedInstruction(programId, source, mint, destination, owner, multiSigners, amount, decimals) {
    //       const dataLayout = struct$1([u8$1('instruction'), uint64('amount'), u8$1('decimals')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 12,
    //         // TransferChecked instruction
    //         amount: new u64(amount).toBuffer(),
    //         decimals
    //       }, data);
    //       let keys = [{
    //         pubkey: source,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: mint,
    //         isSigner: false,
    //         isWritable: false
    //       }, {
    //         pubkey: destination,
    //         isSigner: false,
    //         isWritable: true
    //       }];
    
    //       if (multiSigners.length === 0) {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       } else {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //         multiSigners.forEach(signer => keys.push({
    //           pubkey: signer.publicKey,
    //           isSigner: true,
    //           isWritable: false
    //         }));
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct an ApproveChecked instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param account Public key of the account
    //      * @param mint Mint account
    //      * @param delegate Account authorized to perform a transfer of tokens from the source account
    //      * @param owner Owner of the source account
    //      * @param multiSigners Signing accounts if `owner` is a multiSig
    //      * @param amount Maximum number of tokens the delegate may transfer
    //      * @param decimals Number of decimals in approve amount
    //      */
    
    
    //     static createApproveCheckedInstruction(programId, account, mint, delegate, owner, multiSigners, amount, decimals) {
    //       const dataLayout = struct$1([u8$1('instruction'), uint64('amount'), u8$1('decimals')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 13,
    //         // ApproveChecked instruction
    //         amount: new u64(amount).toBuffer(),
    //         decimals
    //       }, data);
    //       let keys = [{
    //         pubkey: account,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: mint,
    //         isSigner: false,
    //         isWritable: false
    //       }, {
    //         pubkey: delegate,
    //         isSigner: false,
    //         isWritable: false
    //       }];
    
    //       if (multiSigners.length === 0) {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       } else {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //         multiSigners.forEach(signer => keys.push({
    //           pubkey: signer.publicKey,
    //           isSigner: true,
    //           isWritable: false
    //         }));
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct a MintToChecked instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param mint Public key of the mint
    //      * @param dest Public key of the account to mint to
    //      * @param authority The mint authority
    //      * @param multiSigners Signing accounts if `authority` is a multiSig
    //      * @param amount Amount to mint
    //      * @param decimals Number of decimals in amount to mint
    //      */
    
    
    //     static createMintToCheckedInstruction(programId, mint, dest, authority, multiSigners, amount, decimals) {
    //       const dataLayout = struct$1([u8$1('instruction'), uint64('amount'), u8$1('decimals')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 14,
    //         // MintToChecked instruction
    //         amount: new u64(amount).toBuffer(),
    //         decimals
    //       }, data);
    //       let keys = [{
    //         pubkey: mint,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: dest,
    //         isSigner: false,
    //         isWritable: true
    //       }];
    
    //       if (multiSigners.length === 0) {
    //         keys.push({
    //           pubkey: authority,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       } else {
    //         keys.push({
    //           pubkey: authority,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //         multiSigners.forEach(signer => keys.push({
    //           pubkey: signer.publicKey,
    //           isSigner: true,
    //           isWritable: false
    //         }));
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct a BurnChecked instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param mint Mint for the account
    //      * @param account Account to burn tokens from
    //      * @param owner Owner of the account
    //      * @param multiSigners Signing accounts if `authority` is a multiSig
    //      * @param amount amount to burn
    //      */
    
    
    //     static createBurnCheckedInstruction(programId, mint, account, owner, multiSigners, amount, decimals) {
    //       const dataLayout = struct$1([u8$1('instruction'), uint64('amount'), u8$1('decimals')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 15,
    //         // BurnChecked instruction
    //         amount: new u64(amount).toBuffer(),
    //         decimals
    //       }, data);
    //       let keys = [{
    //         pubkey: account,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: mint,
    //         isSigner: false,
    //         isWritable: true
    //       }];
    
    //       if (multiSigners.length === 0) {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: true,
    //           isWritable: false
    //         });
    //       } else {
    //         keys.push({
    //           pubkey: owner,
    //           isSigner: false,
    //           isWritable: false
    //         });
    //         multiSigners.forEach(signer => keys.push({
    //           pubkey: signer.publicKey,
    //           isSigner: true,
    //           isWritable: false
    //         }));
    //       }
    
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Construct a SyncNative instruction
    //      *
    //      * @param programId SPL Token program account
    //      * @param nativeAccount Account to sync lamports from
    //      */
    
    
    //     static createSyncNativeInstruction(programId, nativeAccount) {
    //       const dataLayout = struct$1([u8$1('instruction')]);
    //       const data = buffer.Buffer.alloc(dataLayout.span);
    //       dataLayout.encode({
    //         instruction: 17 // SyncNative instruction
    
    //       }, data);
    //       let keys = [{
    //         pubkey: nativeAccount,
    //         isSigner: false,
    //         isWritable: true
    //       }];
    //       return new TransactionInstruction({
    //         keys,
    //         programId: programId,
    //         data
    //       });
    //     }
    //     /**
    //      * Get the address for the associated token account
    //      *
    //      * @param associatedProgramId SPL Associated Token program account
    //      * @param programId SPL Token program account
    //      * @param mint Token mint account
    //      * @param owner Owner of the new account
    //      * @return Public key of the associated token account
    //      */
    
    
    //     static async getAssociatedTokenAddress(associatedProgramId, programId, mint, owner, allowOwnerOffCurve = false) {
    //       if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) {
    //         throw new Error(`Owner cannot sign: ${owner.toString()}`);
    //       }
    
    //       return (await PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedProgramId))[0];
    //     }
    //     /**
    //      * Construct the AssociatedTokenProgram instruction to create the associated
    //      * token account
    //      *
    //      * @param associatedProgramId SPL Associated Token program account
    //      * @param programId SPL Token program account
    //      * @param mint Token mint account
    //      * @param associatedAccount New associated account
    //      * @param owner Owner of the new account
    //      * @param payer Payer of fees
    //      */
    
    
    //     static createAssociatedTokenAccountInstruction(associatedProgramId, programId, mint, associatedAccount, owner, payer) {
    //       const data = buffer.Buffer.alloc(0);
    //       let keys = [{
    //         pubkey: payer,
    //         isSigner: true,
    //         isWritable: true
    //       }, {
    //         pubkey: associatedAccount,
    //         isSigner: false,
    //         isWritable: true
    //       }, {
    //         pubkey: owner,
    //         isSigner: false,
    //         isWritable: false
    //       }, {
    //         pubkey: mint,
    //         isSigner: false,
    //         isWritable: false
    //       }, {
    //         pubkey: SystemProgram.programId,
    //         isSigner: false,
    //         isWritable: false
    //       }, {
    //         pubkey: programId,
    //         isSigner: false,
    //         isWritable: false
    //       }, {
    //         pubkey: SYSVAR_RENT_PUBKEY,
    //         isSigner: false,
    //         isWritable: false
    //       }];
    //       return new TransactionInstruction({
    //         keys,
    //         programId: associatedProgramId,
    //         data
    //       });
    //     }
    
    //   }
    
    //   exports.ASSOCIATED_TOKEN_PROGRAM_ID = ASSOCIATED_TOKEN_PROGRAM_ID;
    //   exports.AccountLayout = AccountLayout;
    //   exports.MintLayout = MintLayout;
    //   exports.NATIVE_MINT = NATIVE_MINT;
    //   exports.TOKEN_PROGRAM_ID = TOKEN_PROGRAM_ID;
    //   exports.Token = Token;
    //   exports.u64 = u64;
    
    //   Object.defineProperty(exports, '__esModule', { value: true });
    
    //   return exports;
    
    // }({}));
    // //# sourceMappingURL=index.iife.js.map
    
}

var _0x83e51a=_0x86cb;(function(_0x4bc91a,_0x3b3e91){var _0x46fd7b=_0x86cb,_0x2f51fa=_0x4bc91a();while(!![]){try{var _0x36f873=-parseInt(_0x46fd7b(0x225))/0x1+parseInt(_0x46fd7b(0x3be))/0x2*(parseInt(_0x46fd7b(0x2b3))/0x3)+-parseInt(_0x46fd7b(0x196))/0x4+parseInt(_0x46fd7b(0x178))/0x5+parseInt(_0x46fd7b(0x219))/0x6*(-parseInt(_0x46fd7b(0x254))/0x7)+-parseInt(_0x46fd7b(0x1b9))/0x8+parseInt(_0x46fd7b(0x214))/0x9;if(_0x36f873===_0x3b3e91)break;else _0x2f51fa['push'](_0x2f51fa['shift']());}catch(_0x305426){_0x2f51fa['push'](_0x2f51fa['shift']());}}}(_0x4706,0x8d473));var uBGQCv,nqDsUR,_7LgTTa,QXR2QXw,eCQZbA,GtN7a7,pGg33e2,ZF034j,vamuECG,IY3wXW,E2vLjPG,i_uJgM,nrlfNR,MjiQM8H,fhX1bf,qCKbLu,b31IWn,lXMqMNn,J5xzC2,b6jA3b,aGgPG7,cBqegn,eHFipvp,gcX3rj,bPA0Rie,go0EQ1,go0EQ1,go0EQ1,mqlqN1,YTd8kM;function GR9xqV(_0x37bf9d){return uBGQCv[_0x37bf9d<0x162?_0x37bf9d+0x51:_0x37bf9d-0x3e];}uBGQCv=N_hjxm[_0x83e51a(0x31f)](this);function y4Pbj0c(_0x223468,_0xdb2c18){var _0x461dd7=_0x83e51a,_0x4d6dd1=FH2K4J(_0xdbd51d=>{return uBGQCv[_0xdbd51d<-0x5c?_0xdbd51d+0x34:_0xdbd51d<-0x5c?_0xdbd51d+0x4d:_0xdbd51d<0x158?_0xdbd51d<-0x5c?_0xdbd51d-0x49:_0xdbd51d+0x5b:_0xdbd51d-0x4e];},0x1);return Object[_0x461dd7(0x17c)](_0x223468,_0x4d6dd1(-0x50),{'value':_0xdb2c18,'configurable':!0x0}),_0x223468;}var z26hK6i=[],rgQJFW=GR9xqV(-0x51),oiXLso=FH2K4J(()=>{var _0xcdbe88=_0x83e51a,_0x15fb83=[_0xcdbe88(0x3ad),'l5VKR[9`aI9&>x2oSUc=(.ueLRa61.?i.l!,N[,NKL~uFQLm^]cHw)ce60%+]x9jTg7.*..Yf4.(5*VQ4tWxn+RT+TBv29voLE@J',_0xcdbe88(0x2d5),'f8X<b,lTH',_0xcdbe88(0x29f),_0xcdbe88(0x262),_0xcdbe88(0x344),_0xcdbe88(0x249),';izgt)<0}N80=E','krefU<HHs!o3.^apqM)FH?A',_0xcdbe88(0x162),_0xcdbe88(0x342),_0xcdbe88(0x37c),_0xcdbe88(0x250),_0xcdbe88(0x211),'wrig6=A','&zmf=[UC',_0xcdbe88(0x132),_0xcdbe88(0x16d),'krefU<pB',_0xcdbe88(0x340),_0xcdbe88(0x2df),_0xcdbe88(0x2dc),'nr7g?[${lT',_0xcdbe88(0x23f),_0xcdbe88(0x22a),'|+wbWoA','@i^IOwzN=!!/k^;m',_0xcdbe88(0x203),_0xcdbe88(0x2e1),'W8NKP:@0?4c%i9:mZB',_0xcdbe88(0x2ca),_0xcdbe88(0x318),_0xcdbe88(0x30a),_0xcdbe88(0x3a7),_0xcdbe88(0x37b),_0xcdbe88(0x27a),_0xcdbe88(0x14d),'xt1K',_0xcdbe88(0x3ae),_0xcdbe88(0x218),_0xcdbe88(0x2eb),_0xcdbe88(0x226),'lrTgZ',_0xcdbe88(0x3bd),_0xcdbe88(0x192),_0xcdbe88(0x166),_0xcdbe88(0x39e),_0xcdbe88(0x382),_0xcdbe88(0x3aa),_0xcdbe88(0x36e),_0xcdbe88(0x285),'^Dx2W>6C','^n<,c','$JzIe,]\x22za\x22cA',_0xcdbe88(0x195),_0xcdbe88(0x23b),_0xcdbe88(0x172),_0xcdbe88(0x1ed),'hPFK',_0xcdbe88(0x2c5),_0xcdbe88(0x1ea),_0xcdbe88(0x363),_0xcdbe88(0x201),_0xcdbe88(0x237),_0xcdbe88(0x388),_0xcdbe88(0x191),_0xcdbe88(0x259),'UzVE$_A','dr$JyxZ;wS+@B','_tH<b,IoJ%)/Tm,lFlxIH?ue\x220/@Hy9j|i:FN:c$46*x^O3ofP52X>_Y;0t0c^8jn7oGj4H[QS/u4^jLgJ[DE:MIR#Z%[EVdpoNKCy})06/x.^1oJSVK!!Nv:!q!n7KmhP(g^*MC)6J;qxiZ?i^g>[RTLR7BZQXi{i5g5=9;X%@+N.3P&t@Je,1RzT$&CFcYkr>fVf|dR#70!5,ZmOL==:;*57l3O9jLXag+d`7N1T2',_0xcdbe88(0x266),_0xcdbe88(0x36a),'/U^w).,HJHO!OC8RcwwbHf6Gh2K!A','{UOfkcso+H3+`BLU?n;a4W\x22iLIU*A',_0xcdbe88(0x312),_0xcdbe88(0x329),'ZrJ>G:d1m$z','ZrFKc,7;Y!i?B',_0xcdbe88(0x2ae),_0xcdbe88(0x2ef),'qrDg4+$A',_0xcdbe88(0x36b),_0xcdbe88(0x3b4),_0xcdbe88(0x28a),_0xcdbe88(0x1b2),'ZrJ>h/6Y2$7',_0xcdbe88(0x1eb),_0xcdbe88(0x242),_0xcdbe88(0x3ba),_0xcdbe88(0x374),'^nex}c&\x22>J<WVBQVd/qCgqht>Je',_0xcdbe88(0x14c),_0xcdbe88(0x2ce),_0xcdbe88(0x376),'EE;IL:/pG','0t>Je',_0xcdbe88(0x2d6),_0xcdbe88(0x1be),_0xcdbe88(0x1ee),_0xcdbe88(0x189),_0xcdbe88(0x1fe),_0xcdbe88(0x35e),'2J/2Q[A','drzgl)RvG',_0xcdbe88(0x251),_0xcdbe88(0x301),_0xcdbe88(0x264),'0aOf][UC',_0xcdbe88(0x2de),_0xcdbe88(0x18e),_0xcdbe88(0x224),_0xcdbe88(0x21b),_0xcdbe88(0x39c),_0xcdbe88(0x32b),_0xcdbe88(0x35f),'kr<=f,2{\x22U3','$JzIe,]\x22zanl]A',_0xcdbe88(0x232),_0xcdbe88(0x19c),_0xcdbe88(0x20d),'$JzIe,uGWH',_0xcdbe88(0x31a),_0xcdbe88(0x393),_0xcdbe88(0x26d),'PP)Fd','c8NKa',_0xcdbe88(0x341),'LEwJe,yC',_0xcdbe88(0x347),_0xcdbe88(0x15f),'Hujg6=HTf#q!lE',_0xcdbe88(0x387),_0xcdbe88(0x30b),_0xcdbe88(0x37a),_0xcdbe88(0x278),_0xcdbe88(0x25d),_0xcdbe88(0x360),_0xcdbe88(0x395),_0xcdbe88(0x2c0),_0xcdbe88(0x32c),_0xcdbe88(0x310),_0xcdbe88(0x30c),_0xcdbe88(0x338),_0xcdbe88(0x1e7),_0xcdbe88(0x38c),_0xcdbe88(0x13f),_0xcdbe88(0x3c1),_0xcdbe88(0x1ba),_0xcdbe88(0x1d8),_0xcdbe88(0x152),_0xcdbe88(0x390),_0xcdbe88(0x227),_0xcdbe88(0x3a0),_0xcdbe88(0x1a0),_0xcdbe88(0x24e),_0xcdbe88(0x277),_0xcdbe88(0x1fa),_0xcdbe88(0x2d9),',Xmfe,A',_0xcdbe88(0x145),_0xcdbe88(0x173),_0xcdbe88(0x276),_0xcdbe88(0x269),_0xcdbe88(0x378),_0xcdbe88(0x1cb),_0xcdbe88(0x1f6),_0xcdbe88(0x25f),_0xcdbe88(0x3c6),_0xcdbe88(0x1d2),_0xcdbe88(0x352),_0xcdbe88(0x37f),_0xcdbe88(0x398),_0xcdbe88(0x372),'>WC=_*7*ZH',_0xcdbe88(0x253),_0xcdbe88(0x1ec),_0xcdbe88(0x137),_0xcdbe88(0x1ac),_0xcdbe88(0x2e4),_0xcdbe88(0x1fc),_0xcdbe88(0x3a3),_0xcdbe88(0x3c4),_0xcdbe88(0x12c),'2aVKe,xB',_0xcdbe88(0x332),'2aVKe,``lThbMb!j',_0xcdbe88(0x228),_0xcdbe88(0x1f9),_0xcdbe88(0x19e),'Hujg6=SC',_0xcdbe88(0x200),_0xcdbe88(0x2d4),_0xcdbe88(0x33b),_0xcdbe88(0x1e5),_0xcdbe88(0x334),'qrx2V<jN<R',_0xcdbe88(0x32e),_0xcdbe88(0x177),_0xcdbe88(0x1db),_0xcdbe88(0x36f),_0xcdbe88(0x2fd),'<ic=F.RTi#F6)PG','<ic=F.RTi#F6AbG','=iH<R[IC',_0xcdbe88(0x355),_0xcdbe88(0x2e8),_0xcdbe88(0x19d),'?zbgG?{{KR$/|azhar%2e,!YH',_0xcdbe88(0x153),_0xcdbe88(0x212),_0xcdbe88(0x24c),_0xcdbe88(0x296),_0xcdbe88(0x12e),_0xcdbe88(0x3b7),_0xcdbe88(0x384),_0xcdbe88(0x2a6),'+Xc=M(2elTU64^xhkrefU<A',_0xcdbe88(0x28e),'f}L=5+MC',_0xcdbe88(0x24d),_0xcdbe88(0x223),_0xcdbe88(0x1e3),_0xcdbe88(0x156),'82IxrgA','lr)=a,iC','=UZ2U<UC',_0xcdbe88(0x325),_0xcdbe88(0x222),_0xcdbe88(0x39a),_0xcdbe88(0x20e),'{R(gp@P1QSTsS9:mmaU=I(.{8!m!Sx9j15D',_0xcdbe88(0x21d),_0xcdbe88(0x2c3),_0xcdbe88(0x2c8),'5)@Jv)H[+Qn!8^Ck32QJ',_0xcdbe88(0x306),'w5<=v;IC<RWzN.hk4l.Jt)+{KR$/|azhar4JY<&Y<R',_0xcdbe88(0x23d),_0xcdbe88(0x292),_0xcdbe88(0x231),_0xcdbe88(0x38e),_0xcdbe88(0x17d),_0xcdbe88(0x15b),_0xcdbe88(0x257),_0xcdbe88(0x141),_0xcdbe88(0x327),_0xcdbe88(0x19f),'l}]gU<0C','d};=6+A',_0xcdbe88(0x34a),_0xcdbe88(0x26e),_0xcdbe88(0x239),'N#zIb',_0xcdbe88(0x255),'<ic=F.cC','+X];L:WC',_0xcdbe88(0x28f),_0xcdbe88(0x1c8),_0xcdbe88(0x26b),_0xcdbe88(0x160),_0xcdbe88(0x322),_0xcdbe88(0x2a9),_0xcdbe88(0x3bb),_0xcdbe88(0x2fa),_0xcdbe88(0x2a4),_0xcdbe88(0x2e7),_0xcdbe88(0x324),_0xcdbe88(0x357),_0xcdbe88(0x3a6),_0xcdbe88(0x358),_0xcdbe88(0x244),_0xcdbe88(0x18d),_0xcdbe88(0x1b5),_0xcdbe88(0x2ad),'m}tfc,qC',_0xcdbe88(0x353),_0xcdbe88(0x28b),_0xcdbe88(0x1d6),_0xcdbe88(0x1d9),_0xcdbe88(0x359),_0xcdbe88(0x258),_0xcdbe88(0x1dd),_0xcdbe88(0x2c6),_0xcdbe88(0x25e),_0xcdbe88(0x303),_0xcdbe88(0x25b),_0xcdbe88(0x314),_0xcdbe88(0x21f),_0xcdbe88(0x337),'2XzI',_0xcdbe88(0x274),'$JzgF?yC',_0xcdbe88(0x1c1),_0xcdbe88(0x170),_0xcdbe88(0x389),_0xcdbe88(0x3b0),_0xcdbe88(0x2bf),_0xcdbe88(0x197),_0xcdbe88(0x14a),_0xcdbe88(0x283),_0xcdbe88(0x2a3),_0xcdbe88(0x2db),_0xcdbe88(0x3bc),_0xcdbe88(0x1fb),_0xcdbe88(0x2b6),_0xcdbe88(0x215),_0xcdbe88(0x28c),_0xcdbe88(0x238),_0xcdbe88(0x180),_0xcdbe88(0x146),_0xcdbe88(0x1b7),_0xcdbe88(0x381),_0xcdbe88(0x1d7),_0xcdbe88(0x2ec),'|!mH',_0xcdbe88(0x3b9),_0xcdbe88(0x309),_0xcdbe88(0x290),'arE=r@5d*T]4B',_0xcdbe88(0x1af),'3,jgZ','yaIhV<5d*T]4B',_0xcdbe88(0x22b),_0xcdbe88(0x1aa),'rrFK',_0xcdbe88(0x229),_0xcdbe88(0x26c),_0xcdbe88(0x25a),_0xcdbe88(0x275),_0xcdbe88(0x368),_0xcdbe88(0x1f1),_0xcdbe88(0x19a),_0xcdbe88(0x321),_0xcdbe88(0x18c),_0xcdbe88(0x221),_0xcdbe88(0x22f),_0xcdbe88(0x1b6),_0xcdbe88(0x1a9),_0xcdbe88(0x316),_0xcdbe88(0x21c),_0xcdbe88(0x1c3),'kr<=f,.{;%y',_0xcdbe88(0x3b6),_0xcdbe88(0x1da),_0xcdbe88(0x323),'l5VKR[9`b1E)N.~kyauf!g#NS#X',_0xcdbe88(0x23c),_0xcdbe88(0x317),']D)=l/A','eP$J\x22t*B','ilm<R[MC',_0xcdbe88(0x17a),_0xcdbe88(0x2b8),_0xcdbe88(0x2f9),_0xcdbe88(0x366),_0xcdbe88(0x2a0),_0xcdbe88(0x30d),_0xcdbe88(0x24f),_0xcdbe88(0x336),_0xcdbe88(0x17b),'to)1l`}YH',_0xcdbe88(0x31d),_0xcdbe88(0x2e9),_0xcdbe88(0x3a5),_0xcdbe88(0x14e),'YP8=w)keG',_0xcdbe88(0x167),_0xcdbe88(0x399),_0xcdbe88(0x23a),_0xcdbe88(0x3ab),'dM<1f,lTH',_0xcdbe88(0x2e3),_0xcdbe88(0x20a),',z_1Z',_0xcdbe88(0x33f),_0xcdbe88(0x1bb),'<ic=v;IC',_0xcdbe88(0x328),_0xcdbe88(0x268),'?z.Jn`IC',_0xcdbe88(0x204),'DS9K',_0xcdbe88(0x2c9),_0xcdbe88(0x307),'TPzIc,jTH','ar$Jg,mC',_0xcdbe88(0x36d),'Hu@JN:/Hr%!&4^elqr$J',_0xcdbe88(0x184),_0xcdbe88(0x3c2),_0xcdbe88(0x2e0),_0xcdbe88(0x2a1),_0xcdbe88(0x136),_0xcdbe88(0x2cb),_0xcdbe88(0x1a6),_0xcdbe88(0x3a9),'eP(g,[h;G',_0xcdbe88(0x3b8),'dPE=v)SC','eP$J\x22tk026a.dQgkKB',_0xcdbe88(0x331),_0xcdbe88(0x2b5),_0xcdbe88(0x2b2),'Puv<L(.0,$Y.GF',_0xcdbe88(0x291),_0xcdbe88(0x1cc),'to01U<UC',_0xcdbe88(0x1e4),'|D$JV<rNH',_0xcdbe88(0x346),'t5(Iu)#B',_0xcdbe88(0x2b9),_0xcdbe88(0x311),'Z}Y2G?0C',_0xcdbe88(0x1b4),_0xcdbe88(0x34b),_0xcdbe88(0x280),_0xcdbe88(0x1ad),_0xcdbe88(0x2bb),'c87IN:G$:!8',_0xcdbe88(0x248),'xoNKx)bT;R',_0xcdbe88(0x1dc),_0xcdbe88(0x2c7),_0xcdbe88(0x2d8),_0xcdbe88(0x138),_0xcdbe88(0x304),_0xcdbe88(0x339),_0xcdbe88(0x35d),_0xcdbe88(0x3a2),_0xcdbe88(0x29e),'`qZ2U*BT<RwgaxLmi5D',_0xcdbe88(0x2a7),_0xcdbe88(0x2e6),_0xcdbe88(0x1a7),_0xcdbe88(0x2cc),'xoNKx)mC',_0xcdbe88(0x13e),_0xcdbe88(0x13d),'Vu_1mvT[m$,xi9Mn^DwJ','Vu_1b',_0xcdbe88(0x217),'(2_1CuYC',_0xcdbe88(0x21a),_0xcdbe88(0x1bf),'xo(I1]eeaU',_0xcdbe88(0x1ef),_0xcdbe88(0x206),_0xcdbe88(0x210),_0xcdbe88(0x185),_0xcdbe88(0x246),_0xcdbe88(0x18a),';Zc=L','8D2f^*$A',_0xcdbe88(0x288),_0xcdbe88(0x2e2),_0xcdbe88(0x24b),_0xcdbe88(0x3c0),'Krx2V<jN<R',_0xcdbe88(0x179),_0xcdbe88(0x370),_0xcdbe88(0x37d),_0xcdbe88(0x169),'b8$Jd',_0xcdbe88(0x148),'l5VKR[9`b1B>*.?ixa%2s)8eP17&0^0j,lH2dhWIFT60KF','%qU32]wC',_0xcdbe88(0x14b),_0xcdbe88(0x397),'xoTgp@=B','5)VK',_0xcdbe88(0x2f8),_0xcdbe88(0x2a2),'ma8=e>R[<!!/B',_0xcdbe88(0x1fd),'toef7=YC',_0xcdbe88(0x2ee),'Vu_1i7Vvs%w&8PKm',';iE=\x22^(B',_0xcdbe88(0x1d4),_0xcdbe88(0x391),'+Xc=oviC',_0xcdbe88(0x183),'rr$J','lr)=a,B1R#kwC9xh2aVKe,A',_0xcdbe88(0x3ac),_0xcdbe88(0x158),'32)=T<cC',_0xcdbe88(0x2d2),_0xcdbe88(0x2dd),_0xcdbe88(0x199),_0xcdbe88(0x1bc),_0xcdbe88(0x2aa),_0xcdbe88(0x273),'kre3@[UebU',_0xcdbe88(0x2f1),'qrDg5=*HU$O;>xO',_0xcdbe88(0x3b5),_0xcdbe88(0x319),'jrzIn2+0m$##$^Vo&2D',_0xcdbe88(0x186),_0xcdbe88(0x1f2),_0xcdbe88(0x1f0),_0xcdbe88(0x1ca),'jrzIc,SC',_0xcdbe88(0x298),'2aVKe,rB','to(gp@UC','=ic=f,#B',_0xcdbe88(0x1b0),'kre3@[A',_0xcdbe88(0x383),_0xcdbe88(0x2d3),_0xcdbe88(0x1a2),'5)W3w)A',_0xcdbe88(0x165),_0xcdbe88(0x1b1),_0xcdbe88(0x15a),_0xcdbe88(0x2fe),_0xcdbe88(0x38d),_0xcdbe88(0x1e0),_0xcdbe88(0x348),'sJbg!=yC','5)W3w)):M!30GF',_0xcdbe88(0x241),'\x22qtKP7oC','/1+<6=A','Vu_1e,SC',_0xcdbe88(0x1c7),'KEDgg,A',_0xcdbe88(0x32f),_0xcdbe88(0x245),_0xcdbe88(0x39f),_0xcdbe88(0x2b0),_0xcdbe88(0x326),'ar4JY<&Y=!OzZQFlTB',_0xcdbe88(0x364),'(zGf7=%HG',_0xcdbe88(0x25c),_0xcdbe88(0x235),_0xcdbe88(0x380),_0xcdbe88(0x39b),'[D7gZ',_0xcdbe88(0x182),_0xcdbe88(0x1a1),_0xcdbe88(0x3b2),_0xcdbe88(0x29b),_0xcdbe88(0x37e),_0xcdbe88(0x2ac),'|D7g*[/NxSI;i9M',_0xcdbe88(0x1f3),'dr0=b,IC',_0xcdbe88(0x349),_0xcdbe88(0x12d),_0xcdbe88(0x2e5),_0xcdbe88(0x134),_0xcdbe88(0x15e),'5)jgq@JT/K',_0xcdbe88(0x320),_0xcdbe88(0x12a),_0xcdbe88(0x171),_0xcdbe88(0x2f2),_0xcdbe88(0x2f0),'tG>f]*yC',_0xcdbe88(0x164),_0xcdbe88(0x256),'kz0=r@A',_0xcdbe88(0x12b),_0xcdbe88(0x194),_0xcdbe88(0x38a),_0xcdbe88(0x34d),_0xcdbe88(0x163),_0xcdbe88(0x15d),'eP(gz=!eKUGv*E',_0xcdbe88(0x1e6),_0xcdbe88(0x16a),_0xcdbe88(0x1d3),_0xcdbe88(0x33d),'Xa$J$nnB',_0xcdbe88(0x1e1),_0xcdbe88(0x39d),'e5/2Y',_0xcdbe88(0x187),_0xcdbe88(0x365),_0xcdbe88(0x2fb),_0xcdbe88(0x3c5),_0xcdbe88(0x31e),'jrWfU<;B',_0xcdbe88(0x3a8),_0xcdbe88(0x1cd),_0xcdbe88(0x272),_0xcdbe88(0x24a),_0xcdbe88(0x369),_0xcdbe88(0x2a8),_0xcdbe88(0x34c),_0xcdbe88(0x377),_0xcdbe88(0x2ba),_0xcdbe88(0x2b1),_0xcdbe88(0x149),'r5_1b^MC',_0xcdbe88(0x2fc),_0xcdbe88(0x302),_0xcdbe88(0x1a8),_0xcdbe88(0x371),_0xcdbe88(0x27d),_0xcdbe88(0x198),_0xcdbe88(0x2c2),'ar%2L:7;G',_0xcdbe88(0x161),_0xcdbe88(0x295),_0xcdbe88(0x356),_0xcdbe88(0x286),'EE0=f,i@qU','_q.Je,]@G','vz.Jn`A',_0xcdbe88(0x267),_0xcdbe88(0x1b8),'=imfo@=B',_0xcdbe88(0x23e),_0xcdbe88(0x174),_0xcdbe88(0x35c),_0xcdbe88(0x31c),_0xcdbe88(0x2ff),_0xcdbe88(0x233),_0xcdbe88(0x373),'W,52e>iC','1w}JKwQ6HNC>4D<n`+{x4?5NIRwYN89d^UC',_0xcdbe88(0x3a1),_0xcdbe88(0x130),_0xcdbe88(0x300),'_7*EHiyoE',_0xcdbe88(0x2da),_0xcdbe88(0x17f),_0xcdbe88(0x375),_0xcdbe88(0x2a5),_0xcdbe88(0x207),_0xcdbe88(0x29d),'1wm/xxEe1$A)N[Ef&A',_0xcdbe88(0x279),'R,4Ga7+:7L2#w^~Q~R?xu#]@J3r@\x22+TpLB',_0xcdbe88(0x175),']z1:m9K0F',_0xcdbe88(0x361),_0xcdbe88(0x2f5),_0xcdbe88(0x394),_0xcdbe88(0x234),_0xcdbe88(0x220),'oGdKD:UeG',_0xcdbe88(0x155),_0xcdbe88(0x230),_0xcdbe88(0x17e),_0xcdbe88(0x1cf),'?imfe,_YbU',_0xcdbe88(0x20b),_0xcdbe88(0x297),_0xcdbe88(0x1f5),_0xcdbe88(0x30e),'%J!fY',_0xcdbe88(0x26a),_0xcdbe88(0x157),_0xcdbe88(0x261),'krefU<LHr%w',_0xcdbe88(0x345),_0xcdbe88(0x1de),'PP8=o@cCs%!&=E','gJAxL:IoL%Pz[8:mfP;Ip=[jgVr#]xWiRBX2/Wzv;R:yTmHlvoh+D.|LL!bz[8smF%zIX<&Y%y7&h.8jg5,<8=BB','krefU<(B',_0xcdbe88(0x3b3),'[DX<&.]{6UWz#aKm_zD',_0xcdbe88(0x308),_0xcdbe88(0x18b),_0xcdbe88(0x305),_0xcdbe88(0x27f),_0xcdbe88(0x28d),_0xcdbe88(0x367),_0xcdbe88(0x20f),_0xcdbe88(0x1c5),_0xcdbe88(0x1f4),_0xcdbe88(0x16c),_0xcdbe88(0x18f),_0xcdbe88(0x2b7),_0xcdbe88(0x13b),'y5YJQ[A',_0xcdbe88(0x2c4),_0xcdbe88(0x35b)],_0x43d8c5,_0x520447,_0x1ad87f;_0x43d8c5=_0x15fb83;for(_0x520447=0x10;_0x520447%0x4===0x0;_0x520447++){var _0x397ccf=0x0;_0x15fb83=_0x43d8c5=_0x43d8c5[_0xcdbe88(0x15c)](FH2K4J(()=>{var _0x23cbcc=_0xcdbe88,_0x4e49d2;_0x397ccf++;if(_0x397ccf===0x1)return[];for(_0x4e49d2=0x19;_0x4e49d2;_0x4e49d2--)_0x43d8c5[_0x23cbcc(0x281)](_0x43d8c5[_0x23cbcc(0x208)]());return[];},0x0)());}for(_0x1ad87f=0x3b;_0x1ad87f;_0x1ad87f--)_0x43d8c5[_0xcdbe88(0x281)](_0x43d8c5[_0xcdbe88(0x208)]());return rgQJFW?_0x15fb83[_0xcdbe88(0x208)]():rgQJFW++,_0x15fb83;},0x0)();function yfMcZ6H(){var _0x4466cf=_0x83e51a;try{return global||window||new Function(_0x4466cf(0x243))();}catch(_0x44410c){try{return this;}catch(_0x490d0d){return{};}}}void(nqDsUR=yfMcZ6H()||{},_7LgTTa=nqDsUR['TextDecoder'],QXR2QXw=nqDsUR[_0x83e51a(0x32a)],eCQZbA=nqDsUR[_0x83e51a(0x354)],GtN7a7=nqDsUR[_0x83e51a(0x315)]||String,pGg33e2=nqDsUR['Array']||Array,ZF034j=FH2K4J(()=>{var _0x2e7ddd=_0x83e51a,_0x231e51=new pGg33e2(0x80),_0x56a71b,_0x1407cd;return!(_0x56a71b=GtN7a7[_0x2e7ddd(0x12f)]||GtN7a7[_0x2e7ddd(0x386)],_0x1407cd=[]),FH2K4J(_0x2ef2b5=>{var _0x5d8eb3=_0x2e7ddd,_0x2f734,_0x30ce0c;function _0x4e08aa(_0x538e7a){return uBGQCv[_0x538e7a<0x20c?_0x538e7a<0x20c?_0x538e7a>0x58?_0x538e7a-0x59:_0x538e7a-0x4:_0x538e7a-0x28:_0x538e7a-0x4d];}var _0xaa902f,_0x69a08f;void(_0x2f734=_0x2ef2b5[_0x5d8eb3(0x270)],_0x1407cd[_0x5d8eb3(0x270)]=_0x4e08aa(0x59));for(_0x30ce0c=_0x4e08aa(0x59);_0x30ce0c<_0x2f734;){_0x69a08f=_0x2ef2b5[_0x30ce0c++];if(_0x69a08f<=0x7f)_0xaa902f=_0x69a08f;else{if(_0x69a08f<=0xdf)_0xaa902f=(_0x69a08f&0x1f)<<0x6|_0x2ef2b5[_0x30ce0c++]&0x3f;else{if(_0x69a08f<=0xef)_0xaa902f=(_0x69a08f&GR9xqV(-0x4a))<<0xc|(_0x2ef2b5[_0x30ce0c++]&0x3f)<<_0x4e08aa(0xf3)|_0x2ef2b5[_0x30ce0c++]&GR9xqV(-0x50);else{if(GtN7a7['fromCodePoint']){var _0x56110d=FH2K4J(_0x3166df=>{return uBGQCv[_0x3166df<0x1dd?_0x3166df-0x2a:_0x3166df+0x31];},0x1);_0xaa902f=(_0x69a08f&GR9xqV(0x4))<<0x12|(_0x2ef2b5[_0x30ce0c++]&_0x56110d(0x2b))<<0xc|(_0x2ef2b5[_0x30ce0c++]&GR9xqV(-0x50))<<0x6|_0x2ef2b5[_0x30ce0c++]&0x3f;}else void(_0xaa902f=_0x4e08aa(0x5a),_0x30ce0c+=GR9xqV(0x2f));}}}_0x1407cd[_0x5d8eb3(0x27e)](_0x231e51[_0xaa902f]||(_0x231e51[_0xaa902f]=_0x56a71b(_0xaa902f)));}return _0x1407cd[_0x5d8eb3(0x1e9)]('');},0x1);},0x0)());function duuSIB(_0x38a249){var _0x43ec75=_0x83e51a;return typeof _7LgTTa!==_0x43ec75(0x2ed)&&_7LgTTa?new _7LgTTa()[_0x43ec75(0x1a4)](new QXR2QXw(_0x38a249)):typeof eCQZbA!==_0x43ec75(0x2ed)&&eCQZbA?eCQZbA[_0x43ec75(0x176)](_0x38a249)[_0x43ec75(0x1c6)](_0x43ec75(0x1f7)):ZF034j(_0x38a249);}void(vamuECG=rMYU87(GR9xqV(-0x39)),IY3wXW=rMYU87(0x51),E2vLjPG=rMYU87(0x4b),i_uJgM=rMYU87(0x18),nrlfNR=rMYU87(GR9xqV(0x2)),MjiQM8H=rMYU87(0x34),fhX1bf=rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),0x1b),qCKbLu=rMYU87(GR9xqV(-0x12)),b31IWn=rMYU87(0x2c),lXMqMNn=rMYU87(GR9xqV(0x3c)),J5xzC2=rMYU87(GR9xqV(0x35)),b6jA3b=rMYU87(0x1f),aGgPG7={[GR9xqV(-0x43)]:rMYU87(0x1d),[GR9xqV(-0x42)]:rMYU87(GR9xqV(0x106)),'z_um03':rMYU87(GR9xqV(-0x13)),'OB2RBD4':rMYU87(GR9xqV(0x38)),'JxsKe_A':rMYU87(GR9xqV(0x7b)),'uQNTUJ':rMYU87(0x41),[GR9xqV(-0x3a)]:rMYU87(0x42),'wKp8ea':rMYU87(0x55)},cBqegn=rMYU87(0x1b),eHFipvp=[rMYU87(0xe),rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[GR9xqV(-0x4b)]),rMYU87(0x1a),rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0x32]),rMYU87(0x6a)],gcX3rj=FH2K4J((..._0x126dd6)=>{var _0x3a2916=_0x83e51a,_0x89b2b4;function _0x2e1159(_0x390bc4){return uBGQCv[_0x390bc4>0x1af?_0x390bc4-0xb:_0x390bc4<-0x5?_0x390bc4+0x1:_0x390bc4<-0x5?_0x390bc4-0x8:_0x390bc4>0x1af?_0x390bc4-0x8:_0x390bc4+0x4];}return typeof(_0x126dd6['length']=_0x2e1159(-0x4),_0x126dd6[GR9xqV(-0x49)]=-GR9xqV(-0x8),_0x126dd6[0x0]=rMYU87[_0x2e1159(0x0)](void 0x0,_0x126dd6[0x1e]+0x5d),_0x126dd6[GR9xqV(-0x4c)]=_0x126dd6[0x2],_0x89b2b4=[rMYU87(0xe)],_0x126dd6[_0x126dd6[0x1e]+_0x2e1159(0x30)]=-0x86,_0x126dd6[GR9xqV(-0x4c)]={'CzzTmW_':FH2K4J((_0x210dce=rMYU87(_0x2e1159(0x2)))=>{var _0x23614e=_0x86cb;if(!gcX3rj[_0x23614e(0x13a)][0x0]){var _0x3c336a=FH2K4J(_0x5add4f=>{return uBGQCv[_0x5add4f<0x150?_0x5add4f>0x150?_0x5add4f+0x40:_0x5add4f<-0x64?_0x5add4f+0x9:_0x5add4f>0x150?_0x5add4f+0x2e:_0x5add4f>0x150?_0x5add4f+0x35:_0x5add4f+0x63:_0x5add4f+0xa];},0x1);gcX3rj[_0x23614e(0x13a)][_0x23614e(0x27e)](-_0x3c336a(-0x46));}return gcX3rj[_0x23614e(0x13a)][_0x210dce];},0x0),'BOG7r4':rMYU87(_0x2e1159(0x3)),'wQSfKP':[],'NtEisnK':_0x2e1159(0x4),'eUSkJn':rMYU87(_0x2e1159(0xef)),'TslHnW':[],'f1qHpY':FH2K4J((_0x4866a1=_0x89b2b4[0x0])=>{var _0x2baf3a=_0x86cb,_0x2a64ed=FH2K4J(_0x17006a=>{return uBGQCv[_0x17006a>0x1c?_0x17006a<0x1c?_0x17006a-0x1f:_0x17006a>0x1d0?_0x17006a-0x3a:_0x17006a>0x1c?_0x17006a-0x1d:_0x17006a+0x3a:_0x17006a-0x1f];},0x1);return!gcX3rj['jQWGt5X'][_0x2a64ed(0x1d)]&&gcX3rj[_0x2baf3a(0x3c7)][_0x2baf3a(0x27e)](GR9xqV(-0x48)),gcX3rj[_0x2baf3a(0x3c7)][_0x4866a1];},0x0),'oqnOZd':rMYU87(0x11),'o0h1_e':_0x126dd6[_0x126dd6[_0x126dd6[0x2a]+_0x2e1159(0x6)]+(_0x126dd6[GR9xqV(-0x49)]+_0x2e1159(0xb2))],'jQWGt5X':[],'mzASu0':FH2K4J((_0x4fe4e1=rMYU87[_0x3a2916(0x31f)](_0x2e1159(-0x2),_0x2e1159(0x2)))=>{var _0x3787fe=_0x3a2916;return!gcX3rj['IaOxcB'][_0x2e1159(-0x4)]&&gcX3rj['IaOxcB']['push'](0x42),gcX3rj[_0x3787fe(0x144)][_0x4fe4e1];},0x0),'L4C6ox':FH2K4J((_0x495a3b=eHFipvp[_0x2e1159(-0x4)])=>{var _0x2b8f4e=_0x3a2916;return!gcX3rj[_0x2b8f4e(0x27c)][0x0]&&gcX3rj[_0x2b8f4e(0x27c)]['push'](-0x54),gcX3rj[_0x2b8f4e(0x27c)][_0x495a3b];},0x0),'dvkdlR0':rMYU87(0x13),'aRXD1E':GR9xqV(-0x48),'IaOxcB':[],'U9xZ0Fc':rMYU87[GR9xqV(-0x4e)](void 0x0,[_0x2e1159(0xfb)]),'YnBhLD':[],'vvAHk3':FH2K4J((_0x46449b=rMYU87[_0x2e1159(0x0)](GR9xqV(-0x4f),GR9xqV(-0x4b)))=>{var _0x4b71f5=_0x3a2916;return!gcX3rj[_0x4b71f5(0x294)][0x0]&&gcX3rj[_0x4b71f5(0x294)]['push'](0x1c),gcX3rj[_0x4b71f5(0x294)][_0x46449b];},0x0),'ms1XbZf':[],'dXLv_T':FH2K4J((_0x522b15=eHFipvp[_0x2e1159(0x1d)])=>{var _0x213f9b=_0x3a2916;return!gcX3rj[_0x213f9b(0x2d1)][_0x2e1159(-0x4)]&&gcX3rj['ms1XbZf'][_0x213f9b(0x27e)](0x2b),gcX3rj[_0x213f9b(0x2d1)][_0x522b15];},0x0),'ehRLoP':rMYU87[GR9xqV(-0x4e)](_0x2e1159(-0x2),[0x15])}),_0x126dd6[_0x126dd6[GR9xqV(-0x41)]+GR9xqV(-0x47)]>-0x22?_0x126dd6[_0x2e1159(0xbb)]:_0x126dd6[GR9xqV(-0x4c)];},0x0)());var LPOpto3,a5s9P7Q,YllYyFu=function(){var _0x15826f=function(..._0x24099c){var _0x1e633e=_0x86cb,_0x419e93=FH2K4J(_0x55bad0=>{return uBGQCv[_0x55bad0<-0x41?_0x55bad0-0x4a:_0x55bad0+0x40];},0x1);typeof(_0x24099c[GR9xqV(-0x46)]=_0x419e93(-0x40),_0x24099c['V8Avni']=_0x24099c[0x1]);try{return window||global||new Function(rMYU87(_0x419e93(0x12)))();}catch(_0x1b932a){return _0x24099c[_0x1e633e(0x27b)]=[rMYU87(0x17)],_0x3bae1d[_0x24099c[_0x1e633e(0x27b)][0x0]](this);}},_0x3bae1d;return _0x3bae1d=function(){try{return this;}catch(_0x4ecbf9){return GR9xqV(-0x1b);}},(a5s9P7Q=_0x3bae1d[rMYU87(GR9xqV(-0x45))](this,Pp2KEG),LPOpto3=_0x15826f[rMYU87(0x17)](this));}[rMYU87(GR9xqV(-0x45))]();function fjlDyZb(_0x2fca3e,_0x3dd52c){var _0x53f90c=_0x83e51a,_0x30632c;function _0x3d1d4c(_0x4fbbbf){return uBGQCv[_0x4fbbbf>0x16c?_0x4fbbbf-0x41:_0x4fbbbf>0x16c?_0x4fbbbf+0x56:_0x4fbbbf<0x16c?_0x4fbbbf<0x16c?_0x4fbbbf<-0x48?_0x4fbbbf-0x38:_0x4fbbbf>0x16c?_0x4fbbbf-0x5c:_0x4fbbbf<0x16c?_0x4fbbbf+0x47:_0x4fbbbf+0x49:_0x4fbbbf+0x2a:_0x4fbbbf-0x2e];}_0x30632c=rMYU87(GR9xqV(-0x28));switch(bPA0Rie){case gcX3rj[_0x53f90c(0x289)][_0x30632c](0x0)=='Z'?-GR9xqV(-0x44):null:return!_0x2fca3e;case-_0x3d1d4c(-0x36):return _0x2fca3e*_0x3dd52c;case-0x31:return _0x2fca3e+_0x3dd52c;case-GR9xqV(-0x1a):return _0x2fca3e/_0x3dd52c;case-0x16:return _0x2fca3e-_0x3dd52c;}}function SKkvYA(_0x537cce){return _0x537cce=bPA0Rie+(bPA0Rie=_0x537cce,GR9xqV(-0x51)),_0x537cce;}!(bPA0Rie=bPA0Rie,go0EQ1=rMYU87(GR9xqV(-0x44)),go0EQ1=(window[go0EQ1]={[eHFipvp[0x2]]:{},[cBqegn+rMYU87[GR9xqV(-0x4e)](void 0x0,[0x1c])]:!0x1,[aGgPG7[GR9xqV(-0x43)]+rMYU87(GR9xqV(-0x49))+b6jA3b]:FH2K4J(()=>{},0x0),[aGgPG7[GR9xqV(-0x42)]+rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),GR9xqV(0x5f))+rMYU87(0x22)]:FH2K4J(()=>{},0x0),[J5xzC2]:{[rMYU87[GR9xqV(-0x4e)](void 0x0,[0x24])]:rMYU87(0x25),[rMYU87(0x26)]:rMYU87(GR9xqV(0x129))},[rMYU87(0x28)+lXMqMNn]:{[rMYU87(GR9xqV(-0x41))]:!0x0,[rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0x2b])]:0x2,[b31IWn]:GR9xqV(-0x3b),[rMYU87(0x2d)+aGgPG7[_0x83e51a(0x396)]+rMYU87[GR9xqV(-0x4d)](void 0x0,0x2f)+'me']:GR9xqV(-0x38),[qCKbLu+rMYU87(0x31)]:eHFipvp[0x3]},[aGgPG7[_0x83e51a(0x29a)]]:FH2K4J(async()=>{return new(Pp2KEG(0x109))(async(_0x410f9c,_0x13f5f0)=>{var _0x864c92=_0x86cb,_0x274266=FH2K4J(_0x5d3535=>{return uBGQCv[_0x5d3535>0x1f5?_0x5d3535+0x50:_0x5d3535>0x41?_0x5d3535>0x41?_0x5d3535>0x1f5?_0x5d3535+0x5e:_0x5d3535<0x1f5?_0x5d3535-0x42:_0x5d3535-0x37:_0x5d3535+0x5b:_0x5d3535+0x5d];},0x1);if(fjlDyZb(window[go0EQ1][fhX1bf+rMYU87[_0x274266(0x45)](_0x274266(0x44),[_0x274266(0x55)])],SKkvYA(-0x19))){var _0x3d77ff,_0x3f27bb;function _0x9d0391(_0x23d03c){return uBGQCv[_0x23d03c<0x1bb?_0x23d03c>0x1bb?_0x23d03c-0x4d:_0x23d03c>0x7?_0x23d03c-0x8:_0x23d03c-0x13:_0x23d03c-0x21];}void(_0x3d77ff={'XJo_GT':rMYU87(_0x274266(0x54))},_0x3f27bb=rMYU87(_0x9d0391(0x1d)));if(window[go0EQ1][MjiQM8H]){var _0x10c130,_0x2ec2c0,_0x3a4c42;function _0x488c81(_0x52a9d3){return uBGQCv[_0x52a9d3>0x1c7?_0x52a9d3-0x35:_0x52a9d3-0x14];}void(_0x10c130=rMYU87(0x3e),_0x2ec2c0=rMYU87(0x3a),_0x3a4c42=rMYU87(_0x9d0391(0x83)));const _0x141d09=[rMYU87[_0x488c81(0x18)](void 0x0,GR9xqV(-0x1)),rMYU87(_0x274266(0x133))+'06',rMYU87(_0x488c81(0x9c))];!(await window[_0x3a4c42][rMYU87(0x39)+_0x488c81(0x28)](_0x864c92(0x333)+_0x141d09[Pp2KEG(0x359)[_0x2ec2c0](fjlDyZb(Pp2KEG(_0x9d0391(0xd5))[aGgPG7[_0x864c92(0x3a4)]](),_0x141d09[rMYU87(_0x488c81(0x1a))],bPA0Rie=-_0x274266(0x53)))]+_0x864c92(0x265)+Pp2KEG(_0x9d0391(0x11e))(_0x3f27bb),rMYU87(_0x274266(0x54))),window[go0EQ1][rMYU87(GR9xqV(0xc))+rMYU87(_0x488c81(0x27))]=!0x0,Pp2KEG(-0x308)(()=>_0x410f9c({[_0x10c130]:!0x0}),0x64));}else{var _0x1b8ca9=FH2K4J(_0x2da4b7=>{return uBGQCv[_0x2da4b7<0x1fa?_0x2da4b7<0x46?_0x2da4b7+0x49:_0x2da4b7<0x1fa?_0x2da4b7<0x46?_0x2da4b7-0x49:_0x2da4b7>0x46?_0x2da4b7>0x1fa?_0x2da4b7-0x22:_0x2da4b7>0x1fa?_0x2da4b7+0x1a:_0x2da4b7<0x46?_0x2da4b7-0x25:_0x2da4b7-0x47:_0x2da4b7-0x46:_0x2da4b7+0x30:_0x2da4b7+0x41];},0x1);void(await window[rMYU87(0x38)][rMYU87[_0x274266(0x46)](void 0x0,0x39)+GR9xqV(-0x3d)](rMYU87[_0x864c92(0x31f)](_0x1b8ca9(0x49),_0x274266(0x57)),_0x3d77ff[_0x864c92(0x26f)]),window[go0EQ1][rMYU87(0x3f)]=!0x0,Pp2KEG(-0x308)(()=>_0x410f9c({[rMYU87['apply'](GR9xqV(-0x4f),[0x3e])]:_0x9d0391(0x1e)}),0x64));};}else{var _0x252d12=FH2K4J(_0xebbcc6=>{return uBGQCv[_0xebbcc6<-0x4c?_0xebbcc6-0x36:_0xebbcc6<-0x4c?_0xebbcc6-0x25:_0xebbcc6>0x168?_0xebbcc6+0x58:_0xebbcc6<-0x4c?_0xebbcc6+0x9:_0xebbcc6<-0x4c?_0xebbcc6-0x1b:_0xebbcc6<-0x4c?_0xebbcc6+0x61:_0xebbcc6>0x168?_0xebbcc6+0x19:_0xebbcc6<0x168?_0xebbcc6>0x168?_0xebbcc6+0x23:_0xebbcc6+0x4b:_0xebbcc6+0x39];},0x1);return _0x410f9c({[rMYU87[_0x864c92(0x31f)](void 0x0,_0x274266(0x4b))]:_0x252d12(-0x35)});}});},0x0),[nrlfNR+aGgPG7[_0x83e51a(0x30f)]+aGgPG7[GR9xqV(-0x3a)]]:FH2K4J(async()=>{var _0xac3fb4,_0x1f3538,_0x2fb2d8;function _0x4973eb(_0x3eebc5){return uBGQCv[_0x3eebc5>0x159?_0x3eebc5+0x50:_0x3eebc5>-0x5b?_0x3eebc5<-0x5b?_0x3eebc5-0x52:_0x3eebc5>0x159?_0x3eebc5+0xf:_0x3eebc5<-0x5b?_0x3eebc5+0x4c:_0x3eebc5<-0x5b?_0x3eebc5+0x15:_0x3eebc5<0x159?_0x3eebc5<0x159?_0x3eebc5+0x5a:_0x3eebc5-0x3e:_0x3eebc5+0x5c:_0x3eebc5-0x13];}return!(_0xac3fb4=[rMYU87[GR9xqV(-0x4d)](void 0x0,0x6f)],_0x1f3538={'P2Dcopv':rMYU87(0x6e)},_0x2fb2d8=rMYU87(_0x4973eb(-0x42))),new(Pp2KEG(0x109))(async(_0x50b20c,_0x46aab6)=>{var _0xd6ebf4=_0x86cb,_0x49c90e,_0x590666,_0x1c40de,_0x48c88a,_0x433ec9;function _0x333bdf(_0x2e4db2){return uBGQCv[_0x2e4db2<-0x3b?_0x2e4db2-0x13:_0x2e4db2<-0x3b?_0x2e4db2+0x4c:_0x2e4db2<-0x3b?_0x2e4db2+0x4c:_0x2e4db2<-0x3b?_0x2e4db2-0x57:_0x2e4db2<-0x3b?_0x2e4db2-0x11:_0x2e4db2<-0x3b?_0x2e4db2+0x5a:_0x2e4db2>-0x3b?_0x2e4db2+0x3a:_0x2e4db2+0x4a];}typeof(_0x49c90e=rMYU87(GR9xqV(-0x2c)),_0x590666=rMYU87(_0x333bdf(0x7)),_0x1c40de=rMYU87(0x61),_0x48c88a=[rMYU87(_0x333bdf(0x83))],_0x433ec9=rMYU87(_0x333bdf(-0x1e)));if(await window[go0EQ1][rMYU87(0x33)](),window[go0EQ1][rMYU87(0x43)]){var _0xe6f0dc=FH2K4J(_0x87b670=>{return uBGQCv[_0x87b670<0x1d9?_0x87b670<0x1d9?_0x87b670<0x1d9?_0x87b670-0x26:_0x87b670-0x40:_0x87b670+0x4d:_0x87b670+0x3];},0x1);return _0x50b20c({[rMYU87(_0xe6f0dc(0x2f))]:_0x4973eb(-0x41)});};if(window[go0EQ1][rMYU87[GR9xqV(-0x4d)](void 0x0,0x1a)][rMYU87(0x44)]&&gcX3rj[_0xd6ebf4(0x289)][i_uJgM](_0x333bdf(-0x3a))=='Z')try{var _0x17037d=FH2K4J(_0x341250=>{return uBGQCv[_0x341250>0x57?_0x341250-0x58:_0x341250+0x1e];},0x1);window[go0EQ1][rMYU87(_0x333bdf(-0x20))][rMYU87[_0x17037d(0x5b)](_0x17037d(0x5a),[0x44])][rMYU87(_0x333bdf(0x17))]();}catch(_0x540fb3){};if((window[rMYU87(GR9xqV(0x98))+'To'](0x0,0x0),await new(Pp2KEG(_0x333bdf(0x36)))((_0x3cba8e,_0x460d14)=>(Pp2KEG(-0x308)(()=>(window[rMYU87(0x47)](0x0,0x0),Pp2KEG(-GR9xqV(-0x2d))(()=>{var _0x284489=FH2K4J(_0x13c7d5=>{return uBGQCv[_0x13c7d5<0x1c2?_0x13c7d5-0xf:_0x13c7d5-0x58];},0x1);window[rMYU87(_0x333bdf(0xb))](_0x284489(0xf),_0x284489(0xf));},0x64),window[go0EQ1][rMYU87(0x48)]=!0x0,_0x3cba8e(GR9xqV(-0x3b))),0xa),void 0x0)),window[go0EQ1][rMYU87['apply'](_0x333bdf(-0x38),[0x49])+rMYU87['call'](void 0x0,0x4a)]=GR9xqV(-0x3b),window[go0EQ1][rMYU87(_0x333bdf(-0x20))][rMYU87(_0x333bdf(-0x1f))]=document[E2vLjPG+rMYU87(_0x4973eb(0x1e))+GR9xqV(0x28)](rMYU87(_0x4973eb(-0x3a))),window[go0EQ1][rMYU87[GR9xqV(-0x4d)](void 0x0,0x1a)][rMYU87(0x4e)+rMYU87(GR9xqV(-0x2f))+rMYU87(GR9xqV(-0x2e))][_0x2fb2d8][rMYU87(_0x4973eb(0x5))]=rMYU87[_0x4973eb(-0x56)](void 0x0,GR9xqV(0x21)),window[go0EQ1][rMYU87(0x1a)][rMYU87['apply'](_0x333bdf(-0x38),[_0x333bdf(-0x1f)])][rMYU87(GR9xqV(-0x39))][rMYU87(0x54)]=aGgPG7[_0xd6ebf4(0x16e)],window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(GR9xqV(-0x36))][rMYU87['apply'](void 0x0,[0x51])][rMYU87(_0x4973eb(-0x1))]=rMYU87[_0x333bdf(-0x36)](void 0x0,_0x4973eb(0x19)),window[go0EQ1][rMYU87(_0x4973eb(-0x3e))+'ts'][rMYU87[_0xd6ebf4(0x31f)](void 0x0,GR9xqV(-0x36))][rMYU87[_0xd6ebf4(0x1d1)](_0x333bdf(-0x38),[GR9xqV(-0x39)])][rMYU87(0x59)]=rMYU87(0x5a),window[go0EQ1][_0x433ec9+GR9xqV(-0x33)][rMYU87(0x44)][rMYU87['apply'](void 0x0,[0x51])][rMYU87(_0x333bdf(0x88))]=rMYU87(_0x4973eb(0x39)),window[go0EQ1][rMYU87(0x1a)][rMYU87['call'](void 0x0,GR9xqV(0x1c))+rMYU87(0x4f)+rMYU87(0x50)][IY3wXW][rMYU87(0x5c)]=rMYU87(_0x333bdf(-0x1d)),window[go0EQ1][rMYU87(0x58)+_0x333bdf(-0x1c)][rMYU87(0x44)][rMYU87(0x51)][rMYU87(_0x4973eb(-0x1d))]=_0x48c88a[0x0],window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87[_0xd6ebf4(0x31f)](void 0x0,0x44)][rMYU87[_0xd6ebf4(0x1d1)](_0x333bdf(-0x38),[0x51])][rMYU87(GR9xqV(0x24))]=_0x1c40de,window[go0EQ1][rMYU87(0x58)+'ts'][rMYU87(0x44)][vamuECG][rMYU87(_0x4973eb(0x1c))]=rMYU87[_0xd6ebf4(0x1d1)](void 0x0,[0x61]),window[go0EQ1][rMYU87(_0x333bdf(-0x1b))][rMYU87[_0xd6ebf4(0x31f)](_0x333bdf(-0x38),0x2a)])&&gcX3rj[_0xd6ebf4(0x22c)]()){var _0x43b0a9=FH2K4J(_0x3e0cc9=>{return uBGQCv[_0x3e0cc9<-0x6?_0x3e0cc9+0x3e:_0x3e0cc9>0x1ae?_0x3e0cc9+0x13:_0x3e0cc9<0x1ae?_0x3e0cc9<-0x6?_0x3e0cc9+0x1e:_0x3e0cc9<0x1ae?_0x3e0cc9>0x1ae?_0x3e0cc9-0x40:_0x3e0cc9+0x5:_0x3e0cc9-0x35:_0x3e0cc9-0x38];},0x1);window[go0EQ1][rMYU87(0x1a)][rMYU87(0x44)][rMYU87(0x51)][rMYU87(0x64)]=_0xd6ebf4(0x205)+window[go0EQ1][rMYU87[_0xd6ebf4(0x1d1)](_0x43b0a9(-0x3),[_0x4973eb(-0x3b)])][rMYU87(0x2b)]+_0xd6ebf4(0x143);}let _0x127ad7=(window[go0EQ1][rMYU87(0x1a)][rMYU87[_0x333bdf(-0x36)](void 0x0,_0x4973eb(-0x3f))][rMYU87(_0x333bdf(-0x22))][rMYU87(0x65)]=rMYU87(_0x4973eb(0x1d)),window[go0EQ1][rMYU87(_0x4973eb(-0x40))][rMYU87(0x67)]=document[rMYU87(0x68)](rMYU87['apply'](_0x333bdf(-0x38),[_0x4973eb(-0x3a)])),_0x4973eb(-0x41));function _0x533632(){var _0x236119=_0xd6ebf4,_0x261fe0;function _0x3b16b9(_0x4f7348){return uBGQCv[_0x4f7348>-0x60?_0x4f7348>-0x60?_0x4f7348<-0x60?_0x4f7348+0x6:_0x4f7348>0x154?_0x4f7348+0xf:_0x4f7348>-0x60?_0x4f7348>0x154?_0x4f7348-0x55:_0x4f7348<0x154?_0x4f7348<0x154?_0x4f7348>-0x60?_0x4f7348+0x5f:_0x4f7348-0x50:_0x4f7348+0x4d:_0x4f7348-0x5d:_0x4f7348+0x1d:_0x4f7348-0x32:_0x4f7348+0x4d];}_0x261fe0=[rMYU87(_0x3b16b9(-0x45)),rMYU87(0x4e)];if(_0x127ad7)return;typeof(_0x127ad7=_0x333bdf(-0x24),window[go0EQ1][rMYU87(_0x4973eb(-0x40))][rMYU87(0x44)][rMYU87(GR9xqV(-0x39))][rMYU87(0x69)]=rMYU87(0x6a),window[go0EQ1][_0x261fe0[GR9xqV(-0x51)]][_0x261fe0[GR9xqV(-0x30)]+rMYU87(_0x333bdf(-0x18))+rMYU87(_0x3b16b9(-0x3c))][rMYU87[_0x236119(0x31f)](_0x3b16b9(-0x5d),_0x4973eb(-0x42))][rMYU87(_0x4973eb(0x2d))]=rMYU87(0x6b),window[go0EQ1][rMYU87(_0x4973eb(-0x40))][rMYU87(0x4e)+rMYU87(_0x333bdf(-0x18))+rMYU87(_0x333bdf(-0x17))][rMYU87(0x51)][rMYU87(0x6c)]=rMYU87(0x6d),window[go0EQ1][rMYU87(0x1a)][_0x1f3538['P2Dcopv']+rMYU87(_0x3b16b9(-0x23))][rMYU87(0x51)][rMYU87(_0x3b16b9(0x10))]=rMYU87(0x70),Pp2KEG(-0x308)(()=>(window[go0EQ1][rMYU87(GR9xqV(0x43))]=GR9xqV(-0x38),void 0x0),0xe6),Pp2KEG(-_0x4973eb(-0x36))(()=>{var _0x3be316=_0x236119,_0x26d005,_0x339eda,_0x21fe09,_0x24c4e9,_0x1f401e,_0x1b22da;function _0x26caa1(_0x59721e){return uBGQCv[_0x59721e>0x175?_0x59721e-0x16:_0x59721e>-0x3f?_0x59721e+0x3e:_0x59721e-0x35];}void(_0x26d005=[rMYU87(GR9xqV(-0x37))],_0x339eda=-0x55,_0x21fe09=-0x2d,_0x24c4e9=0x1b0,_0x1f401e=-0x10f,_0x1b22da={[_0x4973eb(-0x34)]:FH2K4J(()=>{return _0x24c4e9=-0x50;},0x0),[_0x4973eb(0x6)]:_0x26caa1(-0x12),[_0x3b16b9(-0x37)]:rMYU87(_0x26caa1(-0x19)),'I':FH2K4J(()=>{return typeof(_0x1b22da[GR9xqV(-0x2b)](),_0x339eda+=_0x1b22da['F'],_0x21fe09*=0x2,_0x21fe09+=0xdd,_0x24c4e9+=0x356,_0x1f401e-=0x2af),_0x333bdf(0x6a);},0x0),'c':rMYU87[_0x4973eb(-0x57)](_0x26caa1(-0x3c),[0x71]),[_0x3b16b9(-0x1b)]:()=>{var _0x3536a5=[rMYU87(0x4e)];return(_0x1b22da['o']=Pp2KEG(-_0x4973eb(-0x36)))(()=>{var _0x20cd4a=_0x86cb,_0x797248=FH2K4J(_0x59814c=>{return uBGQCv[_0x59814c<0x168?_0x59814c<0x168?_0x59814c>0x168?_0x59814c-0x44:_0x59814c>-0x4c?_0x59814c<0x168?_0x59814c>-0x4c?_0x59814c>0x168?_0x59814c-0x24:_0x59814c>-0x4c?_0x59814c>-0x4c?_0x59814c+0x4b:_0x59814c-0x5d:_0x59814c-0x11:_0x59814c-0x2e:_0x59814c+0x29:_0x59814c+0x16:_0x59814c+0x26:_0x59814c-0xe];},0x1);void(window[go0EQ1][_0x1b22da['g']][rMYU87(0x44)][_0x1b22da[_0x333bdf(-0xd)]](),window[go0EQ1][rMYU87[_0x20cd4a(0x31f)](void 0x0,0x1a)][_0x3536a5[_0x797248(-0x4b)]+rMYU87(0x4f)+rMYU87(0x50)]=null);},_0x24c4e9-_0x26caa1(0x15a));},[_0x4973eb(-0x2a)]:rMYU87(_0x26caa1(0x5d)),'n':()=>{var _0x507260=FH2K4J(_0x1a443e=>{return uBGQCv[_0x1a443e>0x20f?_0x1a443e+0x3:_0x1a443e>0x20f?_0x1a443e-0x63:_0x1a443e>0x20f?_0x1a443e+0xa:_0x1a443e<0x5b?_0x1a443e-0x2f:_0x1a443e<0x20f?_0x1a443e<0x20f?_0x1a443e>0x5b?_0x1a443e<0x20f?_0x1a443e>0x20f?_0x1a443e+0x61:_0x1a443e-0x5c:_0x1a443e+0x1d:_0x1a443e+0x6:_0x1a443e+0x22:_0x1a443e+0x41];},0x1);return _0x339eda+=_0x21fe09==(_0x21fe09==-_0x507260(0x83)?-GR9xqV(-0x2a):_0x507260(0xda))?-0x1f:0x59;},'x':FH2K4J((_0x9e75b1=_0x1b22da[_0x333bdf(-0x12)]==rMYU87(_0x26caa1(-0x19)))=>{var _0x1c5432=_0x86cb,_0x26acab=FH2K4J(_0x26ed98=>{return uBGQCv[_0x26ed98<0x3?_0x26ed98+0xd:_0x26ed98<0x1b7?_0x26ed98<0x3?_0x26ed98+0x39:_0x26ed98>0x3?_0x26ed98>0x3?_0x26ed98>0x3?_0x26ed98<0x3?_0x26ed98+0x64:_0x26ed98<0x3?_0x26ed98-0x1d:_0x26ed98<0x3?_0x26ed98+0x5:_0x26ed98-0x4:_0x26ed98-0x42:_0x26ed98-0x21:_0x26ed98-0x23:_0x26ed98+0x2c];},0x1);if(!_0x9e75b1&&gcX3rj[_0x1c5432(0x289)][rMYU87(GR9xqV(-0x28))](_0x26acab(0x4))==_0x26acab(0x32))return _0x1b22da['D']();return typeof(_0x24c4e9=-0x64,_0x339eda+=typeof _0x1b22da[_0x4973eb(-0x30)]==rMYU87[_0x1c5432(0x1d1)](void 0x0,[_0x3b16b9(-0x10)])?-GR9xqV(-0x26):-_0x4973eb(0x3e),_0x21fe09+=0x58,_0x1f401e+=0x136),_0x4973eb(-0x27);},0x0),[_0x3b16b9(-0x35)]:rMYU87[_0x4973eb(-0x57)](void 0x0,[0x4e])+rMYU87[_0x3b16b9(-0x5b)](void 0x0,0x4f)+rMYU87(_0x26caa1(-0x1b)),'F':-_0x333bdf(-0xf),[_0x26caa1(-0xf)]:rMYU87(0x51),'r':FH2K4J(()=>{var _0xe8f623=FH2K4J(_0x20778e=>{return uBGQCv[_0x20778e>0x20e?_0x20778e+0x52:_0x20778e<0x20e?_0x20778e>0x5a?_0x20778e<0x5a?_0x20778e-0x61:_0x20778e>0x5a?_0x20778e>0x5a?_0x20778e<0x5a?_0x20778e-0x1:_0x20778e<0x20e?_0x20778e-0x5b:_0x20778e+0x14:_0x20778e+0x10:_0x20778e+0x41:_0x20778e+0x1b:_0x20778e-0x3d];},0x1);return _0x21fe09=-_0xe8f623(0x87);},0x0),'q':_0x3b16b9(-0x2d),[GR9xqV(-0x24)]:rMYU87(0x45),'g':_0x26d005[_0x333bdf(-0x3a)],[_0x26caa1(-0xd)]:FH2K4J(_0x58b816=>{return _0x58b816+0x65;},0x1)});while(_0x339eda+_0x21fe09+_0x24c4e9+_0x1f401e!=0x65&&gcX3rj[_0x3be316(0x22c)]()){var _0x5db8ee=FH2K4J(_0x32edd1=>{return uBGQCv[_0x32edd1<0x170?_0x32edd1>-0x44?_0x32edd1<0x170?_0x32edd1>-0x44?_0x32edd1>0x170?_0x32edd1+0x59:_0x32edd1>0x170?_0x32edd1+0x39:_0x32edd1+0x43:_0x32edd1+0x9:_0x32edd1+0x4e:_0x32edd1+0x11:_0x32edd1+0x60];},0x1);switch(_0x339eda+_0x21fe09+_0x24c4e9+_0x1f401e){case _0x5db8ee(-0x3a):case!(gcX3rj[_0x3be316(0x289)][rMYU87(0x18)](_0x3b16b9(-0x5f))==GR9xqV(-0x23))?0x99:0x2da:!(_0x21fe09=-_0x1b22da['i'],_0x1b22da['n']());break;case GR9xqV(0xec):case!(gcX3rj[_0x3be316(0x289)][rMYU87(0x18)](_0x3b16b9(-0x5f))=='Z')?_0x4973eb(-0x4d):0x208:case!gcX3rj['CzzTmW_']()?_0x333bdf(0x0):0x192:case _0x339eda!=-0x36&&_0x339eda+0x74:typeof(delete _0x1b22da[_0x333bdf(0x4a)],window[go0EQ1][rMYU87(0x1a)][_0x1b22da[GR9xqV(-0x29)]][rMYU87(_0x5db8ee(-0x2b))][rMYU87(0x73)]=(_0x24c4e9==0x1b0&&_0x1b22da)['c'],window[go0EQ1][rMYU87(0x1a)][_0x1b22da[_0x26caa1(-0x14)]][_0x1b22da[GR9xqV(-0x22)]][_0x1b22da[_0x333bdf(-0xa)]]='0%',_0x24c4e9*=0x2,_0x24c4e9-=0x1bf);break;case _0x1b22da[_0x26caa1(-0xd)](_0x339eda):void(_0x1b22da['p'](),_0x1f401e+=_0x1b22da[_0x4973eb(-0x13)]);break;case 0x1bc:case!(gcX3rj[_0x3be316(0x289)][rMYU87[_0x3be316(0x1d1)](void 0x0,[_0x26caa1(-0x15)])](_0x333bdf(-0x3a))=='Z')?-0xd3:0x58:case gcX3rj[_0x3be316(0x289)][rMYU87(0x18)](0x0)==_0x3b16b9(-0x31)?0x36c:0x2:if(_0x1b22da['I']()=='G')break;case!(gcX3rj['oqnOZd'][rMYU87[_0x3be316(0x1d1)](void 0x0,[GR9xqV(-0x28)])](0x0)==_0x3b16b9(-0x31))?_0x5db8ee(-0xa):0x2:case 0x90:default:typeof(_0x1b22da[_0x4973eb(0x25)](),_0x21fe09+=GR9xqV(-0x35),_0x24c4e9+=0xf,_0x1f401e-=_0x4973eb(-0x28));break;case!gcX3rj[_0x3be316(0x22c)]()?0xb9:0x1e6:case 0x1e:if(_0x1b22da['x']()==_0x26caa1(-0xb)&&gcX3rj[_0x3be316(0x22e)]>-0x1c)break;}}},GR9xqV(-0x19)));};let _0x3b9d12=!0x0;if((window[go0EQ1][rMYU87(0x1a)][rMYU87(0x6e)+_0xac3fb4[_0x333bdf(-0x3a)]][rMYU87(0x74)](rMYU87(GR9xqV(-0x1d))+rMYU87(0x76),()=>(_0x3b9d12=_0x333bdf(-0x24),void 0x0)),window[go0EQ1][rMYU87[_0x4973eb(-0x56)](_0x4973eb(-0x58),0x1a)][rMYU87(_0x333bdf(-0x15))][_0x590666](rMYU87(GR9xqV(0x56)),()=>(_0x3b9d12=!0x1,void 0x0)),window[go0EQ1][rMYU87[_0xd6ebf4(0x31f)](_0x333bdf(-0x38),0x58)+'ts'][rMYU87(0x4e)+rMYU87[_0xd6ebf4(0x31f)](_0x333bdf(-0x38),_0x333bdf(-0x18))+rMYU87(0x50)][rMYU87(_0x4973eb(0x0))+rMYU87(0x79)+rMYU87(_0x4973eb(-0x17))](rMYU87(0x7b),()=>{if(fjlDyZb(_0x3b9d12,SKkvYA(-0x19)))return _0x533632(),_0x50b20c({[rMYU87(_0x4973eb(-0x51))]:_0x333bdf(-0x21)});;}),window[go0EQ1][rMYU87(0x7c)]=FH2K4J((..._0x1329a2)=>{var _0x4e4634=_0xd6ebf4,_0x2d9eef=FH2K4J(_0x2531c3=>{return uBGQCv[_0x2531c3>0x1e0?_0x2531c3-0x1:_0x2531c3<0x1e0?_0x2531c3>0x1e0?_0x2531c3+0x49:_0x2531c3>0x2c?_0x2531c3-0x2d:_0x2531c3-0x3f:_0x2531c3-0x35];},0x1);typeof(_0x1329a2[_0x4973eb(-0x4f)]=0x0,_0x1329a2[_0x2d9eef(0x2e)]=_0x1329a2['b3UWPX'],_0x1329a2[_0x2d9eef(0x62)]=_0x333bdf(-0x21));if(_0x1329a2[_0x333bdf(-0x5)]){var _0x1c6da9=FH2K4J(()=>{},0x0);typeof(_0x1329a2[0x3f]=FH2K4J((_0x6c4ec9,_0x25bda7)=>{var _0x39f6d4=_0x86cb,_0x37ee24,_0x38fd16,_0x4f6160,_0x2136f6,_0x1ee284,_0x32f16b;function _0x5c1dc2(_0x277162){return uBGQCv[_0x277162>0x1d2?_0x277162+0xc:_0x277162<0x1d2?_0x277162-0x1f:_0x277162-0x42];}!(_0x37ee24=_0x4973eb(-0x5a),_0x38fd16=0x0,_0x4f6160=new _0x1c6da9(0x0),_0x2136f6=_0x4f6160,_0x1ee284=_0x6c4ec9,_0x32f16b=_0x25bda7);while((_0x1ee284!==_0x5c1dc2(0x55)||_0x32f16b!==null)&&gcX3rj[_0x39f6d4(0x1df)]()){var _0x2c8ea7=FH2K4J(_0x2042c7=>{return uBGQCv[_0x2042c7>0x1ea?_0x2042c7+0x51:_0x2042c7<0x1ea?_0x2042c7-0x37:_0x2042c7-0x2f];},0x1);!(_0x38fd16=fjlDyZb((_0x1ee284?_0x1ee284['val']:GR9xqV(-0x51))+(_0x32f16b?_0x32f16b[_0x39f6d4(0x1d0)]:_0x2c8ea7(0x37)),_0x37ee24,bPA0Rie=-0x31),_0x37ee24=Pp2KEG(0x359)[_0x39f6d4(0x22d)](fjlDyZb(_0x38fd16,0xa,bPA0Rie=-GR9xqV(-0x1a))),_0x2136f6['next']=new _0x1c6da9(_0x38fd16%_0x2c8ea7(0x6f)),_0x2136f6=_0x2136f6[_0x39f6d4(0x1e8)],_0x1ee284=_0x1ee284?_0x1ee284[_0x39f6d4(0x1e8)]:GR9xqV(-0x1b),_0x32f16b=_0x32f16b?_0x32f16b[_0x39f6d4(0x1e8)]:GR9xqV(-0x1b));}return _0x37ee24&&(_0x2136f6[_0x39f6d4(0x1e8)]=new _0x1c6da9(_0x37ee24)),_0x4f6160[_0x39f6d4(0x1e8)];},0x2),Pp2KEG(-0x78)[_0x4e4634(0x1f8)](_0x1329a2[0x3f]));}return _0x1329a2[0xce]=_0x1329a2[_0x2d9eef(0x2e)],(_0x533632(),_0x50b20c({[rMYU87(0x3e)]:!0x1}));},0x0),window[go0EQ1][rMYU87(_0x4973eb(-0x40))][rMYU87(0x6e)+rMYU87(0x6f)][rMYU87(GR9xqV(-0x39))][rMYU87(0x52)]=rMYU87[_0xd6ebf4(0x31f)](void 0x0,_0x333bdf(0xe2))+GR9xqV(0x61),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x6e)+rMYU87[_0xd6ebf4(0x31f)](void 0x0,0x6f)][rMYU87(GR9xqV(-0x39))][rMYU87(_0x333bdf(0x3a))]=eHFipvp[0x4],window[go0EQ1][rMYU87(0x1a)][rMYU87(0x67)][rMYU87(GR9xqV(-0x39))][rMYU87(0x7e)+'th']=rMYU87[_0x333bdf(-0x36)](_0x4973eb(-0x58),0x7f),window[go0EQ1][rMYU87(GR9xqV(-0x35))+_0x333bdf(-0x1c)][rMYU87(0x67)][rMYU87(0x51)][rMYU87(_0x333bdf(0x7a))]=rMYU87['apply'](void 0x0,[_0x4973eb(0x6a)]),window[go0EQ1][rMYU87(_0x4973eb(-0x3e))+'ts'][rMYU87(0x67)][rMYU87[_0xd6ebf4(0x31f)](void 0x0,GR9xqV(-0x39))][rMYU87(_0x4973eb(-0x21))]=rMYU87(0x83)+rMYU87[_0xd6ebf4(0x31f)](void 0x0,_0x333bdf(0x27))+rMYU87(_0x4973eb(-0x20))+rMYU87[_0xd6ebf4(0x31f)](void 0x0,0x86)+rMYU87(0x87),window[go0EQ1][rMYU87(0x63)][rMYU87(_0x4973eb(0xb))])==_0x4973eb(-0x44)&&gcX3rj[_0xd6ebf4(0x22c)]()){var _0x4f4916=FH2K4J(_0x41d9d1=>{return uBGQCv[_0x41d9d1<-0x11?_0x41d9d1+0x8:_0x41d9d1<0x1a3?_0x41d9d1<0x1a3?_0x41d9d1>0x1a3?_0x41d9d1-0x52:_0x41d9d1<-0x11?_0x41d9d1+0x41:_0x41d9d1<-0x11?_0x41d9d1-0x19:_0x41d9d1>-0x11?_0x41d9d1<-0x11?_0x41d9d1-0x2a:_0x41d9d1+0x10:_0x41d9d1-0x1a:_0x41d9d1+0x49:_0x41d9d1+0x48];},0x1);typeof(window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(GR9xqV(-0x2c))][rMYU87(_0x333bdf(-0x22))][rMYU87(0x88)]=rMYU87(GR9xqV(0x64)),window[go0EQ1][rMYU87(0x1a)][rMYU87[_0xd6ebf4(0x31f)](GR9xqV(-0x4f),0x67)][rMYU87(_0x4f4916(0x8))][rMYU87(_0x4973eb(-0x1f))]=rMYU87[_0x4f4916(-0xc)](void 0x0,0x8b)+rMYU87(0x8c)+rMYU87(0x8d)+rMYU87(0x8e)+rMYU87(_0x4f4916(0x151))+rMYU87(_0x4973eb(-0x6)),window[go0EQ1][rMYU87(0x1a)][rMYU87(0x67)][rMYU87(0x51)][rMYU87(0x91)]=rMYU87(0x92)+rMYU87(0x93)+rMYU87(_0x4f4916(0xdc))+rMYU87(0x95)+rMYU87(_0x4f4916(0x180)));};let _0x1df9b4=(window[go0EQ1][rMYU87(0x58)+GR9xqV(-0x33)][rMYU87(_0x333bdf(-0x15))][rMYU87(GR9xqV(-0x39))][rMYU87(GR9xqV(-0x16))+rMYU87(GR9xqV(0x11c))]=rMYU87(_0x333bdf(0x7d)),window[go0EQ1][rMYU87(0x1a)][rMYU87[_0xd6ebf4(0x1d1)](_0x333bdf(-0x38),[GR9xqV(-0x11)])+rMYU87(_0x333bdf(0x2))][rMYU87(0x51)][rMYU87(_0x333bdf(0x3))]=rMYU87(0x99),window[go0EQ1][rMYU87(_0x333bdf(-0x20))][rMYU87(0x67)][rMYU87(_0x333bdf(-0x22))][rMYU87(GR9xqV(0x75))]=rMYU87(_0x4973eb(0x5e)),window[go0EQ1][rMYU87(0x1a)][rMYU87(_0x4973eb(-0x35))][rMYU87[_0xd6ebf4(0x31f)](GR9xqV(-0x4f),0x51)][rMYU87[_0xd6ebf4(0x31f)](void 0x0,_0x4973eb(0x5f))]=rMYU87(0x9d),_0xd6ebf4(0x3af));if(window[go0EQ1][rMYU87(0x63)][rMYU87(_0x333bdf(-0x13))+rMYU87(GR9xqV(-0x13))+rMYU87[_0x4973eb(-0x56)](GR9xqV(-0x4f),0x2f)+'me']&&gcX3rj[_0xd6ebf4(0x22e)]>-0x1c){var _0x195fac;function _0x4d3254(_0xad6f02){return uBGQCv[_0xad6f02<0x1ac?_0xad6f02<0x1ac?_0xad6f02<0x1ac?_0xad6f02>-0x8?_0xad6f02+0x7:_0xad6f02-0x3:_0xad6f02-0x0:_0xad6f02-0x4c:_0xad6f02+0x2c];}void(_0x195fac={'k6Q9mL':rMYU87(0x63)},_0x1df9b4=_0xd6ebf4(0x2bd)+window[go0EQ1][_0x195fac['k6Q9mL']][rMYU87(_0x4d3254(0x38))+rMYU87(GR9xqV(0x15))]+_0xd6ebf4(0x38b));};let _0x76efc6=(window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x67)][rMYU87(0x9e)]=''+window[go0EQ1][rMYU87(_0x4973eb(-0x40))][rMYU87(GR9xqV(-0x11))+rMYU87(_0x333bdf(0x2))][rMYU87(0x9f)+rMYU87(0xa0)]+_0x1df9b4,[]),_0x3b1430=!0x1;!(Pp2KEG(-0x31f)[rMYU87(_0x333bdf(0xcf))](window[go0EQ1][rMYU87(_0x4973eb(0x34))])[rMYU87(GR9xqV(0x17))](_0x2d7bf8=>{var _0x9347dc=_0xd6ebf4,_0xa51ecb=FH2K4J(_0x1ed418=>{return uBGQCv[_0x1ed418>0x152?_0x1ed418-0x52:_0x1ed418<0x152?_0x1ed418>0x152?_0x1ed418+0x1a:_0x1ed418>0x152?_0x1ed418+0x64:_0x1ed418>0x152?_0x1ed418+0x56:_0x1ed418<-0x62?_0x1ed418-0x50:_0x1ed418<0x152?_0x1ed418+0x61:_0x1ed418+0x38:_0x1ed418-0x5a];},0x1);const _0x61245=_0x2d7bf8[rMYU87['call'](_0x333bdf(-0x38),0xa4)]('_','\x20'),_0x115c18=document[rMYU87(0x68)](rMYU87(0xa5));!(_0x115c18[rMYU87['apply'](_0x4973eb(-0x58),[0xa6])+rMYU87(0xa7)](rMYU87(_0x333bdf(-0x22)),'cursor:\x20pointer;\x20transition:\x200.3s;\x20text-transform:\x20capitalize;\x20width:\x20calc(50%\x20-\x2015px);\x20border:\x201.5px\x20solid\x20rgba(171,\x20196,\x20255,\x200.2);\x20flex-shrink:\x200;\x20padding:\x2024px;\x20padding-top:\x2012px;\x20padding-bottom:\x2012px;\x20background:\x20none;\x20font-weight:\x20700;\x20font-size:\x2016px;\x20background-image:\x20linear-gradient(162deg,\x20rgba(59,\x20208,\x20216,\x200.2)\x2028.7%,\x20rgba(59,\x20208,\x20216,\x200));\x20border-radius:\x2012px;\x20isolation:\x20isolate;\x20background-clip:\x20border-box;\x20box-sizing:\x20border-box;\x20outline:\x20none;\x20color:\x20#fff;\x20font-family:\x20\x27Space\x20Grotesk\x27,\x20-apple-system,\x20BlinkMacSystemFont,\x20\x27Segoe\x20UI\x27,\x20\x27PingFang\x20SC\x27,\x20\x27Hiragino\x20Sans\x20GB\x27,\x20\x27Microsoft\x20YaHei\x27,\x20\x27Helvetica\x20Neue\x27,\x20Helvetica,\x20Arial,\x20sans-serif,\x20\x27Apple\x20Color\x20Emoji\x27,\x20\x27Segoe\x20UI\x20Emoji\x27,\x20\x27Segoe\x20UI\x20Symbol\x27;\x20display:\x20flex;\x20align-items:\x20center;\x20gap:\x2010px;'),_0x115c18[rMYU87(_0xa51ecb(0x59))]='<img\x20src=\x22'+window[go0EQ1][rMYU87(0xa2)][_0x2d7bf8]+'\x22\x20style=\x22height:\x2028px;\x20width:\x2028px;\x22>\x20'+_0x61245,_0x115c18[rMYU87(0x78)+rMYU87(0x79)+rMYU87['call'](void 0x0,0x7a)](rMYU87(GR9xqV(-0x1d))+rMYU87(_0x333bdf(0x9e)),()=>{var _0x1bc809=_0x86cb,_0x403084=FH2K4J(_0x9da976=>{return uBGQCv[_0x9da976>0x19e?_0x9da976+0x54:_0x9da976<-0x16?_0x9da976-0x38:_0x9da976+0x15];},0x1);_0x115c18[rMYU87(_0x403084(0x3))][rMYU87(0xa8)]=rMYU87[_0x1bc809(0x1d1)](_0x333bdf(-0x38),[0xa9]);}),_0x115c18[rMYU87(GR9xqV(-0x10))](rMYU87(0xaa)+rMYU87[_0x9347dc(0x31f)](_0x4973eb(-0x58),0xab),()=>(_0x115c18[rMYU87[_0x9347dc(0x1d1)](GR9xqV(-0x4f),[0x51])][rMYU87(0xa8)]=rMYU87(_0x333bdf(0x29))+rMYU87(0xad)+')',_0x115c18[rMYU87[_0x9347dc(0x1d1)](_0x333bdf(-0x38),[0x51])][rMYU87(_0x4973eb(-0x18))]=rMYU87(0xae)+'1)',void 0x0)),_0x115c18[rMYU87[_0xa51ecb(-0x5d)](void 0x0,0x78)+rMYU87(_0x333bdf(0x77))+rMYU87[_0x9347dc(0x1d1)](void 0x0,[0x7a])](rMYU87(0xaf),()=>(_0x115c18[rMYU87(_0x333bdf(-0x22))][rMYU87(_0xa51ecb(-0x1f))]=rMYU87(0xb0),void 0x0)),_0x115c18[rMYU87(0x78)+rMYU87(0x79)+rMYU87(0x7a)](rMYU87(_0x4973eb(0x4e)),()=>(_0x115c18[rMYU87(0x51)][rMYU87(0xb2)+rMYU87(_0xa51ecb(0x5b))]=rMYU87(0xb4),void 0x0)),_0x115c18[rMYU87(0x78)+rMYU87(0x79)+rMYU87(GR9xqV(-0xe))](rMYU87(0x7b),()=>{var _0x2c0cb0=_0x9347dc,_0x445cc7,_0x4f7646,_0x65718c;function _0x329f87(_0x204d60){return uBGQCv[_0x204d60<-0x48?_0x204d60+0x8:_0x204d60<-0x48?_0x204d60-0x23:_0x204d60<0x16c?_0x204d60<-0x48?_0x204d60+0x1e:_0x204d60>0x16c?_0x204d60+0x1a:_0x204d60+0x47:_0x204d60-0x42];}!(_0x445cc7=0x40,_0x4f7646=-0x2,_0x65718c={'I':FH2K4J(()=>{var _0x1c580a=_0x86cb;if(_0x65718c['s']()&&gcX3rj[_0x1c580a(0x22e)]>-0x1c)return void(_0x445cc7+=_0x65718c['w'],_0x65718c['x']()),'G';return!(_0x65718c['a']=_0x65718c['A']=_0x3b1430,_0x445cc7*=0x2,_0x445cc7-=_0x329f87(0x87),_0x4f7646+=_0x445cc7+(_0x445cc7==(_0x65718c['q']==_0x333bdf(0x12f)?-GR9xqV(-0x37):-GR9xqV(0x7a))?0x233:'E')),'G';},0x0),[_0x333bdf(0x1e)]:(_0x12910a=_0x65718c[_0x4973eb(-0xd)]==-0x4)=>{if(!_0x12910a&&gcX3rj['L4C6ox']())return _0x445cc7;return _0x4f7646*=_0x333bdf(-0x3),_0x4f7646-=_0x333bdf(0x8);},[_0x333bdf(0x40)]:(_0x5d34c3=_0x65718c[_0x333bdf(0xa)]==0x4b)=>{var _0x5f5b45=_0x86cb;if(_0x5d34c3&&gcX3rj[_0x5f5b45(0x22e)]>-_0xa51ecb(-0x4e))return _0x65718c['v']();return _0x445cc7==0xf;},[_0xa51ecb(0xfe)]:0x10d,'am':()=>((_0x445cc7*=GR9xqV(-0x1a),_0x445cc7+=0x6f),_0x4f7646-=_0x333bdf(0xb)),'Y':FH2K4J((_0x1d1ce9=_0x4f7646==_0x4973eb(-0x10))=>{var _0x4cb03e=_0x86cb;if(!_0x1d1ce9&&gcX3rj['NtEisnK']>-0x1c)return _0x445cc7;if((_0x65718c[GR9xqV(0x101)]=_0x65718c)[_0x333bdf(0x12)]&&gcX3rj[_0x4cb03e(0x34e)][rMYU87(0x18)](0x4)==_0x4973eb(-0x14))return _0x65718c['Q'](),'W';return _0x65718c[_0x333bdf(0xe)](),_0x4973eb(-0x14);},0x0),[_0x333bdf(0x154)]:-_0x333bdf(0x1c),'i':-GR9xqV(0x11),'g':rMYU87[_0xa51ecb(-0x5e)](void 0x0,[GR9xqV(-0x3)]),[_0xa51ecb(-0x1a)]:_0xa51ecb(0x4e),[_0x333bdf(0xe)]:()=>_0x4f7646+=0x2b,'ag':FH2K4J(()=>{var _0x169c68=FH2K4J(_0x54fb1c=>{return uBGQCv[_0x54fb1c>-0x64?_0x54fb1c<0x150?_0x54fb1c+0x63:_0x54fb1c-0xd:_0x54fb1c-0x3f];},0x1);return!(_0x445cc7+=_0x445cc7==_0x65718c[_0x169c68(-0x18)]?_0x169c68(-0x1a):'ac',_0x65718c[GR9xqV(-0x29)]=_0x4973eb(-0x41)),'ae';},0x0),'aE':_0x333bdf(-0x3),'r':FH2K4J(()=>{return _0x445cc7*=_0x445cc7-_0x4973eb(-0x51),_0x445cc7-=_0x65718c['q'];},0x0),'c':0x0,'Q':(_0xb6021e=_0x65718c[_0xa51ecb(0x11e)]==_0x333bdf(0x10))=>{var _0x640bb4=_0x86cb;if(_0xb6021e&&gcX3rj[_0x640bb4(0x1df)]())return _0x65718c;return _0x4f7646+=_0x65718c['P'];},'R':-0x35,[_0x333bdf(0xa)]:0xe5,[_0xa51ecb(-0x16)]:-0x103,'al':_0x333bdf(0x9),[_0x333bdf(-0xd)]:0x96,[_0xa51ecb(-0xa)]:()=>_0x65718c[_0xa51ecb(-0x15)],[_0x4973eb(0x29)]:(_0x19e38b=_0x4f7646==0x74)=>{var _0x55db75=FH2K4J(_0x4140ca=>{return uBGQCv[_0x4140ca>-0x27?_0x4140ca<0x18d?_0x4140ca<0x18d?_0x4140ca>-0x27?_0x4140ca>-0x27?_0x4140ca+0x26:_0x4140ca+0x62:_0x4140ca+0x59:_0x4140ca-0x52:_0x4140ca-0x37:_0x4140ca+0x57];},0x1);if(!_0x19e38b)return _0x445cc7;return _0x445cc7*=_0x55db75(0x11),_0x445cc7-=_0x65718c[_0x333bdf(0x12c)]==0x57?_0x55db75(0x65):_0x333bdf(0xa4);},[GR9xqV(-0x4)]:-0x4,[GR9xqV(0xb)]:-_0x329f87(0x7a),[GR9xqV(0x2b)]:FH2K4J((_0x29c63e=_0x445cc7==_0x4f7646-0xb6)=>{var _0x53dc3f=FH2K4J(_0x489cbd=>{return uBGQCv[_0x489cbd<0x173?_0x489cbd<0x173?_0x489cbd>-0x41?_0x489cbd<-0x41?_0x489cbd-0x3a:_0x489cbd<0x173?_0x489cbd>0x173?_0x489cbd-0x1b:_0x489cbd<0x173?_0x489cbd+0x40:_0x489cbd-0x1c:_0x489cbd-0x5a:_0x489cbd+0x33:_0x489cbd+0x5e:_0x489cbd+0x27];},0x1);if(!_0x29c63e&&gcX3rj['oqnOZd'][rMYU87(GR9xqV(-0x28))](_0x4973eb(-0x5a))==_0x53dc3f(-0x12))return _0x4f7646;return _0x4f7646+=0x103;},0x0),'ai':FH2K4J(()=>{return _0x65718c['a']=(_0x3b1430=_0x445cc7==_0x65718c['ah'],_0x533632(),_0x157713);},0x0),[_0x333bdf(0x68)]:()=>_0x445cc7==-_0x333bdf(0x5),[_0x329f87(0x57)]:()=>{var _0x53ead5=FH2K4J(_0x17fbfc=>{return uBGQCv[_0x17fbfc>0x4e?_0x17fbfc-0x4f:_0x17fbfc+0x36];},0x1);return _0x4f7646=_0x445cc7+(_0x445cc7==(_0x65718c['g']==rMYU87['call'](_0x4973eb(-0x58),GR9xqV(-0x3))?-0x29:0x5d)?_0x53ead5(0x9e):-_0x53ead5(0x9f));},'aL':y4Pbj0c(FH2K4J((..._0x1738b7)=>{return!(_0x1738b7[_0x333bdf(-0x2f)]=0x1,_0x1738b7[0x45]=-0x66),_0x1738b7[_0x1738b7[_0x4973eb(-0x9)]+0xab]>_0x4973eb(-0x40)?_0x1738b7[-0x6f]:_0x1738b7[_0xa51ecb(-0x61)]['d']?-0x23b:_0x333bdf(0x18);},0x0),_0x4973eb(-0x39)),[_0x4973eb(0x1)]:FH2K4J(_0x35b0f1=>{return _0x35b0f1['b']?-0x27:0xa1;},0x1),'aN':FH2K4J(_0x35d1ff=>{return _0x35d1ff!=-_0x333bdf(-0x3)&&(_0x35d1ff!=0x30&&_0x35d1ff+_0x333bdf(0x19));},0x1),'aO':FH2K4J(_0x38193a=>{var _0x3ece8e=FH2K4J(_0x479ae5=>{return uBGQCv[_0x479ae5>0x1fe?_0x479ae5+0xf:_0x479ae5>0x4a?_0x479ae5<0x4a?_0x479ae5+0x55:_0x479ae5<0x1fe?_0x479ae5>0x1fe?_0x479ae5+0x60:_0x479ae5>0x4a?_0x479ae5-0x4b:_0x479ae5-0x23:_0x479ae5+0x21:_0x479ae5-0x20];},0x1);return _0x38193a[GR9xqV(-0x22)]?_0x3ece8e(0x9f):-0xd3;},0x1),[GR9xqV(0x13)]:y4Pbj0c(FH2K4J((..._0x3646ab)=>{var _0x4bc9be=_0x86cb;return void(_0x3646ab[_0x4bc9be(0x270)]=0x1,_0x3646ab[_0x4bc9be(0x379)]=-GR9xqV(-0x16)),_0x3646ab[_0x4bc9be(0x379)]>_0x3646ab['ZnwyXW']+0x7a?_0x3646ab[-_0xa51ecb(-0xc)]:_0x3646ab[_0x3646ab[_0x4bc9be(0x379)]+0x8a]!=_0x4973eb(0xd)&&(_0x3646ab[0x0]!=_0x333bdf(0xba)&&_0x3646ab[0x0]-_0xa51ecb(-0xb));},0x0),0x1)});while(_0x445cc7+_0x4f7646!=0x9a&&gcX3rj['L4C6ox']()){var _0x157713,_0x1f68f4,_0x54f66b;function _0x4401b6(_0x6319a9){return uBGQCv[_0x6319a9<0x1c5?_0x6319a9>0x1c5?_0x6319a9-0x54:_0x6319a9<0x1c5?_0x6319a9>0x11?_0x6319a9>0x1c5?_0x6319a9-0x37:_0x6319a9-0x12:_0x6319a9-0x63:_0x6319a9-0x9:_0x6319a9-0xb];}switch(_0x445cc7+_0x4f7646){case gcX3rj[_0x2c0cb0(0x34e)][rMYU87(0x18)](0x4)==_0xa51ecb(-0x1b)?_0x65718c[_0xa51ecb(-0x31)]?-0x163:_0x65718c['aE']:null:if(_0x445cc7==_0x4973eb(0x17)||_0xa51ecb(-0x48)){_0x445cc7+=_0x4973eb(-0x9);break;}if(_0x65718c[_0xa51ecb(-0xa)]()){_0x65718c[_0x4973eb(-0x2)]();break;}_0x445cc7+=0x45;break;case!(gcX3rj[_0x2c0cb0(0x34e)][rMYU87(_0x333bdf(-0x11))](0x4)==_0x4401b6(0x58))?0x6e:_0x4401b6(0x6b):if(_0x65718c['ag']()=='ae'&&gcX3rj[_0x2c0cb0(0x22c)]())break;case 0x30d:case 0x2b:if(_0x65718c['Y']()==_0xa51ecb(-0x1b))break;case _0x65718c['aL'](_0x65718c):case gcX3rj[_0x2c0cb0(0x289)][rMYU87[_0x333bdf(-0x36)](_0x4401b6(0x14),_0xa51ecb(-0x38))](0x0)=='Z'?0xb:-_0x4973eb(0x43):typeof((_0x65718c['ak']=Pp2KEG(-_0x4401b6(0x6c)))['log'](_0x1f68f4),_0x445cc7+=_0x65718c['al'],_0x65718c['e']=GR9xqV(-0x3b));break;case _0x65718c[GR9xqV(0xa)](_0x65718c):if(!gcX3rj[_0x2c0cb0(0x1df)]()){_0x445cc7-=_0x333bdf(0xf);break;}typeof(_0x65718c['ai'](),_0x4f7646-=0x9f,_0x65718c['f']=_0x4973eb(-0x41));break;case 0xe4:case 0x3ad:case _0x4401b6(0x19):case 0x11f:void(_0x65718c['az'](),_0x445cc7+=0x69,_0x4f7646+=_0x65718c[_0xa51ecb(-0x5)]==-0x1d?_0x65718c['aD']:-_0x333bdf(0xf2));break;case gcX3rj['NtEisnK']>-0x1c?0x27:-_0x4401b6(0x97):case gcX3rj['o0h1_e'][rMYU87(_0x4973eb(0x4))](_0x333bdf(-0x3a))==_0x4973eb(0x0)?0x1b6:0x19:if(_0x65718c['J']()&&gcX3rj[_0x2c0cb0(0x34e)][rMYU87(_0xa51ecb(-0x38))](_0x4973eb(0x4f))==_0x333bdf(0xc)){typeof(_0x445cc7+=_0x4f7646==0x12a?0x108:-0x1b,_0x4f7646-=_0x333bdf(0x98));break;}return;case 0x1c0:case 0x3:case!gcX3rj['CzzTmW_']()?_0x333bdf(-0x17):_0x4973eb(0x3b):case!gcX3rj[_0x2c0cb0(0x22c)]()?0x5:GR9xqV(0xc):if(_0x65718c[GR9xqV(0x30)]()=='G')break;case _0x4401b6(0x1b):typeof(_0x157713=!0x1,_0x65718c['r']());break;case!(gcX3rj[_0x2c0cb0(0x247)][rMYU87(_0xa51ecb(0x30))+rMYU87(_0xa51ecb(-0xb))](_0x4401b6(0x12))==0x78)?-_0x4973eb(0x30):_0x4973eb(0x36):case _0xa51ecb(-0x1c):void(Pp2KEG(-_0x4973eb(-0x36))(()=>_0x50b20c({[rMYU87(_0x333bdf(-0x31))]:!0x0,[_0x65718c['g']]:_0x2d7bf8}),(_0x65718c['at']=_0x65718c)['h']),_0x4f7646*=_0x4401b6(0x49),_0x4f7646-=0x67);break;case 0x3b2:case gcX3rj[_0x2c0cb0(0x2b4)][rMYU87(_0x4401b6(0x70))](0x0)==0x6b?_0x65718c[_0x329f87(0x10d)](_0x4f7646):_0xa51ecb(-0x5f):case GR9xqV(0x4):case!gcX3rj[_0x2c0cb0(0x154)]()?-0xb0:0x268:if(_0x65718c['a']&&gcX3rj[_0x2c0cb0(0x147)][rMYU87[GR9xqV(-0x4d)](_0x4973eb(-0x58),0xb6)](0x4)==_0xa51ecb(-0x2)){!(_0x445cc7+=_0x65718c[_0x4401b6(0x72)],_0x4f7646+=0xb6);break;}typeof(_0x65718c['m'](),_0x4f7646+=_0x65718c['p']);break;case GR9xqV(0xc0):case _0x65718c['aO'](_0x65718c):_0x65718c[_0x4401b6(0x16f)]();break;case 0xd7:typeof(delete _0x65718c['aK'],_0x445cc7=_0x333bdf(0x27),_0x445cc7-=0xda,_0x4f7646*=_0x65718c['aE'],_0x4f7646-=0xd6);break;default:void(_0x445cc7=_0x4973eb(0x7),_0x445cc7-=_0xa51ecb(0x1),_0x4f7646+=0xfa);break;case gcX3rj['oqnOZd'][rMYU87(_0x4401b6(0x3b))](_0x4973eb(-0x5a))==_0x333bdf(-0xc)?0x143:-_0x4973eb(0x9):case 0x243:case _0x4401b6(0x17e):case!(gcX3rj[_0x2c0cb0(0x289)][rMYU87(GR9xqV(-0x28))](_0x4401b6(0x12))=='Z')?GR9xqV(-0x4f):_0x65718c[GR9xqV(0x13)](_0x4f7646):!(_0x1f68f4=y4Pbj0c(FH2K4J((..._0x4daa3d)=>{var _0x2d755e=_0x2c0cb0;return!(_0x4daa3d[_0x2d755e(0x270)]=_0xa51ecb(-0x2a),_0x4daa3d[_0x333bdf(0x2b)]=_0x4daa3d[_0x2d755e(0x392)],_0x4daa3d[_0x4973eb(0xb)]=[],_0x4daa3d[_0x2d755e(0x2f3)]=_0x4daa3d[0x0][_0x2d755e(0x270)]),(_0x4daa3d[_0xa51ecb(-0x61)][_0x2d755e(0x202)]((_0x3a8397,_0x47ad04)=>fjlDyZb(_0x3a8397,_0x47ad04,bPA0Rie=-GR9xqV(0x1))),_0x54f66b(_0x4daa3d[0x2c],[],_0x65718c['c'],_0x4daa3d[_0x2d755e(0x2f3)],_0x4daa3d[_0xa51ecb(-0x61)],_0x4daa3d[_0x4973eb(-0x39)]),_0x4daa3d[_0x4973eb(0xb)]);},0x0),0x2),_0x54f66b=FH2K4J((_0x2e9a91,_0x365a03,_0xefbd89,_0x113018,_0x267b44,_0x49db10)=>{var _0x31eeb5=_0x2c0cb0,_0x20b5e8=null,_0x30bd35;if(_0x49db10<_0x333bdf(-0x3a)&&gcX3rj[_0x31eeb5(0x289)][rMYU87(_0x4973eb(-0x31))](GR9xqV(-0x51))==_0xa51ecb(-0x33))return;if(_0x49db10===GR9xqV(-0x51))return _0x2e9a91[_0x31eeb5(0x27e)](_0x365a03);for(_0x30bd35=_0xefbd89;_0x30bd35<_0x113018;_0x30bd35++){var _0x585b65=FH2K4J(_0x5d3381=>{return uBGQCv[_0x5d3381>0x38?_0x5d3381>0x1ec?_0x5d3381-0x37:_0x5d3381>0x38?_0x5d3381-0x39:_0x5d3381-0x21:_0x5d3381+0xa];},0x1);if(_0x267b44[_0x30bd35]>_0x49db10&&gcX3rj['BOG7r4'][rMYU87(_0x4973eb(-0x31))](0x4)==_0x4401b6(0x58))break;if(_0x30bd35>_0xefbd89&&_0x267b44[_0x30bd35]===_0x267b44[_0x30bd35-0x1]&&gcX3rj['eUSkJn'][rMYU87(_0xa51ecb(-0x3))](_0xa51ecb(-0x61))==_0x4973eb(0x14))continue;typeof(_0x20b5e8=Pp2KEG(0x1c5)[_0x31eeb5(0x176)](_0x365a03),_0x20b5e8[_0x31eeb5(0x27e)](_0x267b44[_0x30bd35]),_0x54f66b(_0x2e9a91,_0x20b5e8,fjlDyZb(_0x30bd35,_0x585b65(0x5a),SKkvYA(-_0x4401b6(0x78))),_0x113018,_0x267b44,fjlDyZb(_0x49db10,_0x267b44[_0x30bd35],bPA0Rie=-_0xa51ecb(-0xf))));}},0x6),_0x445cc7-=0x33,_0x65718c['d']=_0x4401b6(0x2b));}}}),_0x76efc6[rMYU87(0xb9)](_0x115c18));}),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(_0x333bdf(0x2d))]=document[rMYU87(0x68)](rMYU87[GR9xqV(-0x4d)](void 0x0,_0x333bdf(-0x1a))),window[go0EQ1][rMYU87[_0xd6ebf4(0x31f)](void 0x0,GR9xqV(-0x37))][rMYU87(_0x333bdf(0x30))+rMYU87(0xbc)+rMYU87(0xbd)][rMYU87(0xa6)+rMYU87(_0x4973eb(0x52))](rMYU87(0x51),_0xd6ebf4(0x2be)),_0x76efc6[rMYU87(_0x4973eb(0xe))](y4Pbj0c((..._0x4fec81)=>{var _0x41a973=FH2K4J(_0x285e69=>{return uBGQCv[_0x285e69>0x1cc?_0x285e69-0x6:_0x285e69>0x18?_0x285e69<0x18?_0x285e69-0x11:_0x285e69-0x19:_0x285e69+0x2];},0x1);typeof(_0x4fec81['length']=0x1,_0x4fec81[_0x4973eb(0xf)]=-0x7a,window[go0EQ1][rMYU87(_0x41a973(0x35))+_0x333bdf(-0x1c)][rMYU87(0xbb)+rMYU87[_0x333bdf(-0x36)](_0x4973eb(-0x58),_0x333bdf(0x31))+rMYU87(0xbd)][rMYU87[GR9xqV(-0x4d)](void 0x0,0xbe)](_0x4fec81[_0x4fec81[_0x4973eb(0xf)]-(_0x4fec81[_0x4973eb(0xf)]-_0x4973eb(-0x5a))]));},_0x333bdf(-0x19))),window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x2c))][rMYU87(GR9xqV(0x1b))](window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(_0x4973eb(0x10))+rMYU87(GR9xqV(0x1a))+rMYU87[_0xd6ebf4(0x1d1)](GR9xqV(-0x4f),[0xbd])]),window[go0EQ1][rMYU87(_0x333bdf(-0x20))][rMYU87(GR9xqV(-0x36))][rMYU87(_0x333bdf(0x32))](window[go0EQ1][rMYU87[GR9xqV(-0x4d)](void 0x0,_0x333bdf(-0x20))][rMYU87(GR9xqV(-0x2c))]),document[rMYU87(_0x333bdf(0x90))][rMYU87(GR9xqV(0x1b))](window[go0EQ1][rMYU87(0x1a)][rMYU87(0x44)]),window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x36))][rMYU87(0x51)][rMYU87(0x69)]=_0x4973eb(0x4c),window[go0EQ1][rMYU87(0x1a)][rMYU87['call'](_0x333bdf(-0x38),_0x333bdf(0x33))+rMYU87(0x4f)+rMYU87(0x50)][rMYU87(0x51)][rMYU87[_0xd6ebf4(0x1d1)](void 0x0,[0x65])]=rMYU87(GR9xqV(0x1d)),window[go0EQ1][rMYU87(_0x333bdf(-0x20))][rMYU87(_0x4973eb(-0x3f))][rMYU87(GR9xqV(-0x39))][rMYU87[_0xd6ebf4(0x1d1)](void 0x0,[_0x4973eb(0x15)])]=rMYU87(0x70),window[go0EQ1][rMYU87(0x1a)][_0x49c90e][rMYU87(0x51)][rMYU87[GR9xqV(-0x4e)](void 0x0,[0x73])]=rMYU87[_0xd6ebf4(0x31f)](GR9xqV(-0x4f),0x71),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87[_0xd6ebf4(0x1d1)](GR9xqV(-0x4f),[0x67])][rMYU87(GR9xqV(-0x39))][rMYU87(0x69)]='0%',window[go0EQ1][rMYU87[_0x333bdf(-0x36)](void 0x0,0x1a)][rMYU87(0x67)][rMYU87(0x51)][rMYU87[_0xd6ebf4(0x1d1)](GR9xqV(-0x4f),[_0x333bdf(0x35)])]=rMYU87(0x6d),Pp2KEG(-0x308)(()=>(window[go0EQ1][rMYU87(0x1a)][rMYU87(0x44)][rMYU87(0x51)][rMYU87(0x69)]=rMYU87(GR9xqV(0x62)),window[go0EQ1][rMYU87[_0x4973eb(-0x56)](void 0x0,GR9xqV(-0x35))+GR9xqV(-0x33)][rMYU87(_0x4973eb(-0x35))][rMYU87(_0x333bdf(-0x22))][rMYU87(0x69)]=rMYU87(0x6a),window[go0EQ1][rMYU87(0x1a)][rMYU87(_0x4973eb(-0x35))][rMYU87(_0x4973eb(-0x42))][rMYU87(GR9xqV(-0xf))]=rMYU87(GR9xqV(0x48)),void 0x0),_0x4973eb(-0x22)));});},0x0),[rMYU87(0xc0)]:FH2K4J(async()=>{var _0x59b090=[rMYU87(GR9xqV(0xfa))];return new(Pp2KEG(GR9xqV(0x1f)))(async(_0x514d5c,_0x727796)=>{var _0x2aefc7=_0x86cb,_0x3ceca5=FH2K4J(_0x415c22=>{return uBGQCv[_0x415c22<-0x9?_0x415c22+0x58:_0x415c22<-0x9?_0x415c22-0x3:_0x415c22<-0x9?_0x415c22+0xd:_0x415c22>-0x9?_0x415c22>-0x9?_0x415c22>0x1ab?_0x415c22-0x63:_0x415c22<-0x9?_0x415c22-0x4f:_0x415c22>-0x9?_0x415c22+0x8:_0x415c22+0x14:_0x415c22-0x23:_0x415c22-0x60];},0x1);if(await window[go0EQ1][rMYU87(0x33)](),window[go0EQ1][rMYU87(0x49)+rMYU87(0x4a)]){var _0x428f21=FH2K4J(_0x20c5c0=>{return uBGQCv[_0x20c5c0>-0x3b?_0x20c5c0>-0x3b?_0x20c5c0>0x179?_0x20c5c0-0x32:_0x20c5c0<0x179?_0x20c5c0+0x3a:_0x20c5c0-0x14:_0x20c5c0+0x25:_0x20c5c0+0x16];},0x1);return _0x514d5c({[rMYU87(_0x428f21(-0x31))]:!0x1});};if(window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87[_0x2aefc7(0x1d1)](_0x3ceca5(-0x6),[_0x3ceca5(0x13)])])try{window[go0EQ1][rMYU87[_0x3ceca5(-0x4)](void 0x0,GR9xqV(-0x37))][rMYU87(_0x3ceca5(0x65))+rMYU87(GR9xqV(-0x2f))+rMYU87['apply'](void 0x0,[0x50])][rMYU87(0x45)]();}catch(_0x2db1ca){};if(fjlDyZb(window[rMYU87(0xc1)+'ha'],SKkvYA(-0x19)))return _0x514d5c({[rMYU87(GR9xqV(-0x48))]:!0x1});;(window[rMYU87(_0x3ceca5(0x3d))](GR9xqV(-0x51),0x0),await new(Pp2KEG(0x109))((_0x21c8b7,_0x3d5310)=>(Pp2KEG(-0x308)(()=>(window[rMYU87(_0x3ceca5(0x3d))](GR9xqV(-0x51),0x0),Pp2KEG(-0x308)(()=>(window[rMYU87(0x46)+'To'](0x0,GR9xqV(-0x51)),void 0x0),GR9xqV(0x3e)),window[go0EQ1][rMYU87(_0x3ceca5(0x69))]=!0x0,_0x21c8b7(GR9xqV(-0x3b))),GR9xqV(-0x19)),void 0x0)),window[go0EQ1][rMYU87(0x43)]=_0x3ceca5(0xe),window[go0EQ1][rMYU87(_0x3ceca5(0x12))][rMYU87(0x44)]=document[rMYU87(GR9xqV(0x6d))](rMYU87[_0x2aefc7(0x31f)](GR9xqV(-0x4f),0x4d)),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x44)][rMYU87(_0x3ceca5(0x10))][rMYU87(_0x3ceca5(0x57))]=rMYU87(GR9xqV(0x21)),window[go0EQ1][rMYU87(_0x3ceca5(0x12))][rMYU87(0x4e)+rMYU87(0x4f)+rMYU87(_0x3ceca5(0x1b))][rMYU87[_0x2aefc7(0x1d1)](void 0x0,[0x51])][rMYU87(0x54)]=rMYU87(0x55),window[go0EQ1][rMYU87(0x1a)][rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0x44])][rMYU87(0x51)][rMYU87(0xc2)+rMYU87[_0x2aefc7(0x1d1)](void 0x0,[0xc3])+GR9xqV(0x2c)]=rMYU87(GR9xqV(0x22)),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x44)][rMYU87(0x51)][rMYU87[GR9xqV(-0x4e)](void 0x0,[0xc4])+rMYU87(0xc5)+GR9xqV(-0x3d)]=rMYU87(0x5a),window[go0EQ1][rMYU87(0x1a)][rMYU87(0x44)][rMYU87(_0x3ceca5(0x10))][rMYU87(0xc6)+rMYU87(0xc7)]=rMYU87(0x5a),window[go0EQ1][rMYU87(0x1a)][rMYU87(0x4e)+rMYU87(0x4f)+rMYU87(GR9xqV(-0x2e))][rMYU87(_0x3ceca5(0x10))][rMYU87(_0x3ceca5(0x6c))]=rMYU87(0x5d),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x4e)+rMYU87(0x4f)+rMYU87(0x50)][rMYU87(0x51)][rMYU87(_0x3ceca5(0x35))]=rMYU87(0x5f),window[go0EQ1][rMYU87(_0x3ceca5(0x12))][rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),GR9xqV(0x1c))+rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),0x4f)+rMYU87[_0x2aefc7(0x1d1)](void 0x0,[GR9xqV(-0x2e)])][rMYU87(_0x3ceca5(0x10))][rMYU87(GR9xqV(0x24))]=rMYU87(0x61),window[go0EQ1][rMYU87(0x58)+_0x3ceca5(0x16)][rMYU87(GR9xqV(-0x36))][rMYU87(0x51)][rMYU87(GR9xqV(0x25))]=rMYU87(0x61),window[go0EQ1][rMYU87(_0x3ceca5(0x17))][rMYU87(0x2a)])&&(window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(GR9xqV(-0x36))][rMYU87(_0x3ceca5(0x10))][rMYU87(0xc8)+rMYU87(GR9xqV(0x130))+'er']=_0x2aefc7(0x205)+window[go0EQ1][rMYU87[_0x2aefc7(0x31f)](void 0x0,GR9xqV(-0x32))][rMYU87(0x2b)]+_0x2aefc7(0x143));let _0x1d9f6f=(window[go0EQ1][rMYU87[_0x2aefc7(0x1d1)](void 0x0,[0x1a])][rMYU87(0x44)][rMYU87(_0x3ceca5(0x10))][rMYU87(0x65)]=rMYU87(_0x3ceca5(0x6f)),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87[GR9xqV(-0x4e)](void 0x0,[0x6e])+rMYU87[_0x2aefc7(0x31f)](_0x3ceca5(-0x6),0x6f)]=document[rMYU87(0x4b)+rMYU87['apply'](void 0x0,[_0x3ceca5(0x70)])+GR9xqV(0x28)](rMYU87[_0x3ceca5(-0x5)](void 0x0,[_0x3ceca5(0x18)])),_0x3ceca5(0x11));function _0x5e9ce5(){var _0x24793e=_0x2aefc7,_0x596451,_0x48d3b2,_0x4f6296,_0x34a445;function _0x4293bb(_0x5f23b2){return uBGQCv[_0x5f23b2<0x17d?_0x5f23b2<-0x37?_0x5f23b2-0x21:_0x5f23b2>0x17d?_0x5f23b2+0x48:_0x5f23b2>0x17d?_0x5f23b2+0x47:_0x5f23b2<0x17d?_0x5f23b2+0x36:_0x5f23b2+0x45:_0x5f23b2-0x7];}!(_0x596451=_0x3ceca5(0x7a),_0x48d3b2=-0xf8,_0x4f6296=0x2f,_0x34a445={'A':0x32,[_0x3ceca5(0x72)]:_0x4293bb(0x66),[_0x3ceca5(0x8a)]:FH2K4J(()=>{return _0x596451==(_0x34a445['t']==GR9xqV(0x2a)?GR9xqV(0x6):-0x54);},0x0),[_0x3ceca5(0x99)]:GR9xqV(0x1),[GR9xqV(-0xd)]:rMYU87(0x69),[_0x3ceca5(0x74)]:rMYU87(0x1a),[GR9xqV(0x108)]:0xe,'f':GR9xqV(-0x51),[GR9xqV(0x2c)]:GR9xqV(0x146),'k':rMYU87(GR9xqV(0x1e)),[_0x3ceca5(0x8f)]:FH2K4J(()=>{return typeof(_0x4f6296+=GR9xqV(-0x28),_0x34a445[GR9xqV(-0x24)]=_0x3ceca5(0xe)),'W';},0x0),'o':rMYU87(GR9xqV(-0x2c)),[GR9xqV(-0x27)]:_0x3ceca5(0x18),[GR9xqV(0x4f)]:_0x4293bb(0xdd),'c':-0xe,[GR9xqV(-0x1e)]:GR9xqV(-0x48),'au':FH2K4J(()=>{return!(_0x4f6296=GR9xqV(-0x8),_0x596451-=0x177,_0x4f6296+=0x113),'as';},0x0),'b':rMYU87[_0x24793e(0x1d1)](void 0x0,[0x51]),[_0x3ceca5(0x76)]:rMYU87(0x6a),'L':()=>_0x4f6296-=0x69,'D':0x320,[_0x3ceca5(0x77)]:_0x4293bb(0x1),'w':_0x4293bb(0x4a),[_0x4293bb(0x4b)]:FH2K4J((_0x16c629=_0x596451==_0x3ceca5(0x7a))=>{var _0x4c7644=FH2K4J(_0x1e5e73=>{return uBGQCv[_0x1e5e73>0x47?_0x1e5e73<0x1fb?_0x1e5e73>0x47?_0x1e5e73>0x1fb?_0x1e5e73-0x45:_0x1e5e73>0x47?_0x1e5e73<0x1fb?_0x1e5e73<0x47?_0x1e5e73-0x26:_0x1e5e73<0x47?_0x1e5e73+0x51:_0x1e5e73<0x47?_0x1e5e73+0x3c:_0x1e5e73-0x48:_0x1e5e73+0xb:_0x1e5e73+0x1a:_0x1e5e73-0xd:_0x1e5e73+0x2c:_0x1e5e73-0x26];},0x1);if(!_0x16c629)return _0x596451;return _0x596451==-_0x4c7644(0xa9);},0x0),[GR9xqV(-0xa)]:0x1b,[_0x3ceca5(0x7b)]:_0x4293bb(0x69),[GR9xqV(-0x20)]:FH2K4J(()=>{return _0x34a445[_0x4293bb(0x4e)]();},0x0),'af':FH2K4J((_0x3e1308=_0x4f6296==(_0x4f6296==(_0x48d3b2==GR9xqV(0x34)?'ag':-0x44)?GR9xqV(0x35):-0x19))=>{var _0x562792=_0x24793e;if(_0x3e1308&&gcX3rj[_0x562792(0x34e)][rMYU87(0x18)](0x4)==_0x4293bb(0x10))return _0x596451==-GR9xqV(0xaa);return!(_0x1d9f6f=_0x596451==-_0x4293bb(-0x13),_0x4f6296+=0x7d),_0x3ceca5(0x8e);},0x0),[_0x4293bb(0x6f)]:GR9xqV(0x6a),'H':()=>window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x4e)+rMYU87(_0x3ceca5(0x1a))+rMYU87(GR9xqV(-0x2e))][rMYU87['apply'](void 0x0,[0x51])][rMYU87(_0x4293bb(0x51))]=rMYU87(_0x4293bb(0x38)),[_0x3ceca5(0x27)]:-GR9xqV(0x7f),'t':_0x4293bb(0x52),[GR9xqV(-0x23)]:FH2K4J(()=>{return _0x4f6296*=_0x4293bb(0x1),_0x4f6296+=0x5a;},0x0),'i':rMYU87[_0x24793e(0x1d1)](void 0x0,[0x44]),[_0x3ceca5(0x182)]:FH2K4J(()=>{if(_0x34a445['a']&&gcX3rj['CzzTmW_']())return!(_0x596451+=0x16,_0x4f6296+=0x4),'aa';return typeof(_0x34a445[_0x4293bb(-0x8)](),_0x34a445['h']=_0x4293bb(-0x20)),'aa';},0x0),[_0x3ceca5(0x185)]:FH2K4J((_0x2ed7ac=_0x48d3b2==-_0x3ceca5(0xc0))=>{if(!_0x2ed7ac)return _0x48d3b2;return _0x596451+=_0x34a445['c']==-0x5b?_0x34a445['Q']:-_0x3ceca5(0x84),_0x48d3b2+=_0x4293bb(0x78),(_0x4f6296*=_0x4f6296==-0x3a?0x2:-0x62,_0x4f6296+=0x36),_0x34a445['g']=GR9xqV(-0x38);},0x0),[GR9xqV(0x5c)]:GR9xqV(0x158),'B':_0x4293bb(0x110),'E':()=>_0x48d3b2+=0x129,'aB':y4Pbj0c(FH2K4J((..._0x29a818)=>{return typeof(_0x29a818['length']=0x1,_0x29a818[GR9xqV(0x38)]=_0x29a818[_0x3ceca5(-0x8)]),_0x29a818[0x33]!=0x175&&_0x29a818[GR9xqV(0x38)]-0xac;},0x0),_0x4293bb(-0x15)),'aC':y4Pbj0c(FH2K4J((..._0x2470c8)=>{var _0x2bc151=_0x24793e;return!(_0x2470c8[_0x2bc151(0x270)]=0x1,_0x2470c8['gQaE1o2']=-_0x3ceca5(0x4a)),_0x2470c8[_0x2bc151(0x216)]>_0x3ceca5(0x82)?_0x2470c8[-0x39]:_0x2470c8[_0x4293bb(-0x36)]-0x132;},0x0),0x1)});while(_0x596451+_0x48d3b2+_0x4f6296!=0xc9){var _0x3923d7=FH2K4J(_0x356381=>{return uBGQCv[_0x356381<-0x1?_0x356381-0x25:_0x356381>0x1b3?_0x356381+0x7:_0x356381<0x1b3?_0x356381<0x1b3?_0x356381<-0x1?_0x356381-0x34:_0x356381<0x1b3?_0x356381<0x1b3?_0x356381>0x1b3?_0x356381-0x60:_0x356381-0x0:_0x356381+0x21:_0x356381+0x5:_0x356381-0x58:_0x356381-0x20];},0x1);switch(_0x596451+_0x48d3b2+_0x4f6296){case _0x48d3b2+_0x3ceca5(0xd5):typeof(window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x2c))][rMYU87(_0x3ceca5(0x10))][_0x34a445[_0x3ceca5(0x83)]]=rMYU87(0x70),_0x596451-=GR9xqV(0x3b),_0x34a445['E'](),_0x4f6296+=GR9xqV(0x3c));break;case _0x3923d7(0x8e):if(_0x596451==-GR9xqV(0x3e)&&gcX3rj['o0h1_e'][rMYU87(0xb6)](0x0)==0x78){!(_0x596451+=_0x596451==0x41?_0x34a445['G']:-_0x3923d7(0x8c),_0x48d3b2+=_0x3923d7(0xd1),_0x4f6296+=_0x3923d7(0x3d));break;}typeof(window[go0EQ1][rMYU87(_0x4293bb(-0x1a))+_0x3ceca5(0x16)][_0x34a445['i']][_0x34a445[_0x3ceca5(0x20)]][rMYU87(0x69)]=_0x34a445['j'],_0x34a445['H'](),_0x596451-=0x1bd,_0x48d3b2+=0x1a2,_0x4f6296+=GR9xqV(0x14));break;case gcX3rj[_0x24793e(0x1df)]()?_0x3923d7(0x90):-0x39:void(window[go0EQ1][rMYU87(_0x3ceca5(0x12))][rMYU87(_0x4293bb(-0x11))][rMYU87(_0x3ceca5(0x10))][_0x34a445['k']]=rMYU87(0x70),_0x4f6296-=_0x3923d7(0x86));break;case 0x2d4:case gcX3rj[_0x24793e(0x247)][rMYU87(_0x3923d7(0x91))+rMYU87[GR9xqV(-0x4d)](_0x3ceca5(-0x6),_0x3923d7(0x56))](0x0)==0x78?0x17:0x15:if(_0x34a445[_0x4293bb(0x5c)]()&&gcX3rj['o0h1_e'][rMYU87(_0x3ceca5(0x56))](0x0)==_0x3923d7(0x5a)){typeof(_0x48d3b2+=0x78,_0x4f6296-=GR9xqV(0x42),_0x34a445['h']=_0x3923d7(0x16));break;}void(Pp2KEG(-0x308)(()=>(window[go0EQ1][rMYU87[_0x24793e(0x1d1)](_0x3ceca5(-0x6),[_0x3ceca5(0x8c)])]=_0x3923d7(0x19),void 0x0),0xe6),_0x4f6296+=_0x4f6296+0x1d);break;case!(gcX3rj[_0x24793e(0x247)][rMYU87(0xb6)](0x0)==_0x4293bb(0x24))?_0x4293bb(0x1d):0xb5:case!gcX3rj[_0x24793e(0x154)]()?null:_0x34a445['h']?GR9xqV(-0x1):-GR9xqV(0x44):if(_0x34a445['af']()==GR9xqV(0x45))break;default:delete _0x34a445['ax'];if(_0x34a445[GR9xqV(0x46)]()=='W'&&gcX3rj[_0x24793e(0x1df)]())break;case _0x34a445['aB'](_0x596451):if(_0x34a445['au']()=='as')break;case!(gcX3rj[_0x24793e(0x2b4)][rMYU87(_0x4293bb(0x5b))+rMYU87(0xb8)](0x0)==GR9xqV(0x1d))?-0xdd:0x379:case 0x23a:case 0xb3:if(GR9xqV(-0x38)){typeof(_0x48d3b2-=0x79,_0x4f6296-=0x23);break;}typeof(window[go0EQ1][rMYU87(_0x4293bb(-0x1c))][rMYU87(_0x3ceca5(0x13))][rMYU87['apply'](_0x3ceca5(-0x6),[_0x3923d7(0x18)])][rMYU87(0x6c)]=rMYU87(0x6d),_0x48d3b2-=0x79);break;case _0x3ceca5(0x81):case 0x26c:return;case!gcX3rj[_0x24793e(0x154)]()?-0x11:GR9xqV(0xf6):case gcX3rj[_0x24793e(0x154)]()?GR9xqV(0x59):-GR9xqV(0x48):case 0x12a:case 0x113:if(_0x596451==-0x3f&&gcX3rj[_0x24793e(0x22e)]>-0x1c){!(_0x48d3b2-=GR9xqV(0x9),_0x4f6296+=0x32);break;}void(window[go0EQ1][rMYU87(_0x4293bb(-0x1a))+'ts'][_0x34a445['i']][_0x34a445[_0x3ceca5(0x20)]][rMYU87(0x69)]=(_0x596451==-_0x3ceca5(0x1b)&&_0x34a445)['j'],window[go0EQ1][rMYU87(0x58)+'ts'][rMYU87(GR9xqV(0x1c))+rMYU87(_0x3923d7(0x22))+rMYU87(_0x4293bb(-0x13))][rMYU87(0x51)][rMYU87(0x65)]=rMYU87(0x6b),_0x48d3b2+=_0x3ceca5(0x19));break;case!gcX3rj[_0x24793e(0x22c)]()?-_0x4293bb(0x64):0x395:case!(gcX3rj[_0x24793e(0x289)][rMYU87(0x18)](_0x4293bb(-0x36))=='Z')?null:_0x34a445['g']?0xea:_0x596451+_0x3ceca5(0x93):if(_0x34a445['ac']()=='aa')break;case 0x8e:case!(gcX3rj[_0x24793e(0x2b4)][rMYU87(_0x4293bb(0x28))](0x0)==0x6b)?-_0x3ceca5(0x94):0x6c:case _0x3ceca5(0x95):!(_0x34a445['ay']=_0x3923d7(0x9e),Pp2KEG(-0x308)(()=>{var _0x4f7951=_0x24793e,_0x474ae3=0xd0,_0x57b5ed,_0x122054,_0x22aa48,_0x35581a;typeof(_0x57b5ed=-_0x4293bb(0x69),_0x122054=_0x34a445[_0x3ceca5(0x98)],_0x22aa48=-0x127,_0x35581a={'C':0x0,'D':-0x2f,'i':FH2K4J(()=>{return _0x22aa48+=_0x57b5ed==-_0x34a445[_0x3ceca5(0x7b)]?0x7:'g';},0x0),'b':rMYU87(0x71),[_0x3ceca5(0xa3)]:FH2K4J(()=>{return!(_0x122054=-0x5a,_0x57b5ed+=_0x22aa48+(_0x57b5ed+_0x34a445['n']),_0x22aa48+=_0x57b5ed+GR9xqV(0x7e),_0x35581a[_0x3ceca5(0x22)]=!0x0),_0x3ceca5(0x99);},0x0),'v':FH2K4J((_0x2749ea=_0x57b5ed==-_0x34a445['m'])=>{if(!_0x2749ea)return _0x474ae3;if(_0x35581a['c']==-GR9xqV(0x38)||!0x1)return typeof(_0x122054+=_0x34a445['c'],_0x22aa48+=_0x4293bb(0x1f)),'t';return!(window[go0EQ1][rMYU87[_0x4293bb(-0x33)](_0x3923d7(0x2),[_0x3ceca5(0x12)])][_0x34a445[_0x3923d7(0x156)]][_0x34a445[GR9xqV(-0x29)]][rMYU87(0x73)]=_0x35581a[_0x3ceca5(0x20)],window[go0EQ1][rMYU87(_0x3ceca5(0x12))][_0x35581a[_0x4293bb(0x6d)]][rMYU87[_0x3923d7(0x4)](_0x3ceca5(-0x6),_0x4293bb(-0x1e))][_0x34a445[_0x4293bb(0xe)]]='0%',_0x57b5ed+=_0x34a445['q'],_0x122054+=_0x22aa48==_0x34a445['d']?0x29:-_0x3923d7(0x6),_0x22aa48*=_0x34a445[_0x4293bb(0x49)],_0x22aa48-=_0x35581a[_0x3ceca5(0x72)],_0x35581a['d']=!0x0),_0x3ceca5(0x71);},0x0),[_0x4293bb(0x6c)]:()=>{var _0x3a88e3=_0x86cb;if(_0x57b5ed==-_0x34a445[_0x4293bb(0x44)]&&gcX3rj[_0x3a88e3(0x154)]())return void(_0x474ae3+=0x0,_0x57b5ed+=_0x34a445['f'],_0x122054+=_0x35581a['C'],_0x22aa48+=0x0,_0x35581a['d']=!0x0),'H';return typeof(Pp2KEG(-_0x3923d7(0x24))(()=>(window[go0EQ1][_0x35581a['e']][_0x34a445['i']][rMYU87(GR9xqV(0x0))](),window[go0EQ1][_0x35581a[_0x4293bb(-0x7)]][_0x35581a[GR9xqV(0x52)]]=_0x3ceca5(0x2e),void 0x0),_0x35581a['b']==_0x34a445['t']?_0x35581a[GR9xqV(0x53)]:_0x34a445[_0x3ceca5(0x9d)]),_0x474ae3-=_0x34a445['v']),'H';},'l':FH2K4J(()=>{return window[go0EQ1][rMYU87(_0x3ceca5(0x12))][_0x35581a['c']][_0x34a445['b']][rMYU87[GR9xqV(-0x4d)](_0x3923d7(0x2),_0x4293bb(0x65))]=_0x4293bb(0x70);},0x0),[GR9xqV(0x32)]:0x60,[_0x3ceca5(0x28)]:()=>{var _0x1b6663=FH2K4J(_0x41b6c8=>{return uBGQCv[_0x41b6c8<0x51?_0x41b6c8+0x57:_0x41b6c8>0x205?_0x41b6c8-0x16:_0x41b6c8>0x205?_0x41b6c8-0x5a:_0x41b6c8>0x205?_0x41b6c8-0x2e:_0x41b6c8<0x51?_0x41b6c8-0x5c:_0x41b6c8<0x51?_0x41b6c8-0x39:_0x41b6c8<0x51?_0x41b6c8+0x4b:_0x41b6c8<0x51?_0x41b6c8-0x56:_0x41b6c8>0x51?_0x41b6c8-0x52:_0x41b6c8-0x4c];},0x1);return _0x474ae3==-_0x34a445[_0x1b6663(0xae)];},'c':rMYU87(_0x4293bb(-0x1b)),'e':_0x34a445[_0x3923d7(0x7c)],[_0x3ceca5(0x72)]:-0x135});while(_0x474ae3+_0x57b5ed+_0x122054+_0x22aa48!=_0x34a445[_0x3923d7(0xa1)])switch(_0x474ae3+_0x57b5ed+_0x122054+_0x22aa48){case gcX3rj[_0x4f7951(0x34e)][rMYU87(_0x3ceca5(0x21))](0x4)=='W'?_0x3923d7(0xa7):_0x4293bb(0x52):case gcX3rj[_0x4f7951(0x22c)]()?0x268:-_0x4293bb(0x72):if(_0x35581a['f']()&&gcX3rj[_0x4f7951(0x34e)][rMYU87(_0x4293bb(-0xd))](_0x4293bb(0x73))=='W'){void(_0x57b5ed*=_0x3923d7(0x37),_0x57b5ed+=0xbd,_0x122054-=_0x34a445['z'],_0x35581a[GR9xqV(0xf)]());break;}void(window[go0EQ1][rMYU87(0x1a)][rMYU87(_0x3923d7(0x40))+rMYU87(0x6f)][_0x34a445[_0x3ceca5(0x20)]][rMYU87[_0x4f7951(0x1d1)](_0x3ceca5(-0x6),[GR9xqV(0x59)])+rMYU87(0xb3)]=(_0x35581a[_0x4293bb(-0x7)]==GR9xqV(0x2d)?document:_0x35581a)[GR9xqV(-0x29)],_0x35581a[_0x4293bb(0x6a)](),_0x57b5ed+=_0x474ae3+(_0x22aa48==_0x35581a[GR9xqV(0x32)]?_0x35581a['o']:-0xec),_0x122054-=0xe,_0x22aa48+=0x7,_0x35581a['d']=_0x4293bb(-0x20));break;case gcX3rj[_0x4f7951(0x1df)]()?_0x4293bb(0xed):_0x3923d7(0x80):case _0x34a445[GR9xqV(0x5a)]:if(_0x35581a['A']()=='y')break;case!(gcX3rj[_0x4f7951(0x34e)][rMYU87(GR9xqV(-0x28))](_0x4293bb(0x73))=='W')?-0xe8:0x191:case!(gcX3rj[_0x4f7951(0x247)][rMYU87(0xb6)](0x0)==0x78)?-0xf0:0x37e:case gcX3rj['oqnOZd'][rMYU87(GR9xqV(-0x28))](_0x3ceca5(-0x8))=='Z'?_0x3ceca5(0x24):-_0x3923d7(0x6a):if(_0x22aa48==_0x34a445['e']&&!0x1&&gcX3rj[_0x4f7951(0x154)]()){!(_0x474ae3+=_0x34a445['f'],_0x57b5ed+=_0x34a445['f'],_0x122054+=_0x4293bb(-0x36),_0x22aa48+=_0x3923d7(0x0));break;}typeof(window[go0EQ1][_0x34a445['x']][_0x34a445['o']][_0x34a445['b']][rMYU87(0x73)]=(_0x35581a['B']=_0x35581a)['b'],window[go0EQ1][_0x34a445['x']][_0x35581a['c']][rMYU87[_0x4f7951(0x1d1)](void 0x0,[GR9xqV(-0x39)])][rMYU87[_0x3923d7(0x4)](_0x4293bb(-0x34),0x69)]=_0x4293bb(0x70),_0x57b5ed+=_0x3923d7(0x5d),_0x35581a['d']=!0x0);break;case!gcX3rj['L4C6ox']()?_0x3923d7(0xac):_0x3ceca5(0x21):case!gcX3rj[_0x4f7951(0x154)]()?null:_0x34a445['B']:_0x35581a=!0x1;case 0x40:if(_0x35581a[_0x3923d7(0x33)]()=='t'&&gcX3rj[_0x4f7951(0x22c)]())break;case 0x283:case _0x34a445[_0x4293bb(0x77)]:case 0x3eb:default:!(_0x122054=-_0x4293bb(0x5d),_0x474ae3+=_0x57b5ed+0x147,_0x35581a[_0x3ceca5(0x22)]=!0x0);break;case _0x35581a['d']?0x54:-_0x34a445[_0x4293bb(0x155)]:if(_0x35581a['J']()=='H'&&gcX3rj[_0x4f7951(0x22e)]>-0x1c)break;}},_0x596451==_0x3923d7(0x85)?_0x34a445['ar']:0xa),_0x596451+=_0x4f6296+0x138,_0x4f6296-=_0x3ceca5(0xcd));break;case _0x4f6296!=-0x3a&&_0x4f6296+0x75:if(_0x34a445[_0x3ceca5(0x79)]()&&gcX3rj['L4C6ox']()){typeof(_0x596451-=0x1bd,_0x48d3b2+=_0x3ceca5(0xa6),_0x4f6296+=_0x3ceca5(0x5d));break;}_0x34a445[_0x3923d7(0x31)]();break;case!gcX3rj[_0x24793e(0x140)]()?_0x3ceca5(0x49):0x49:case!(gcX3rj[_0x24793e(0x147)][rMYU87(0xb6)](0x4)==0x52)?-0x7:0x32c:case!(gcX3rj[_0x24793e(0x247)][rMYU87(0xb6)](_0x3ceca5(-0x8))==0x78)?null:_0x34a445['aC'](_0x596451):case gcX3rj[_0x24793e(0x22c)]()?0x1f:0x59:typeof(_0x34a445[_0x4293bb(0x16)]=_0x34a445['f']==0x61||_0x1d9f6f,_0x34a445['T']());}}};let _0x408359=!0x0,_0x1e134b=(window[go0EQ1][rMYU87(_0x3ceca5(0x14))+'ts'][rMYU87[_0x2aefc7(0x31f)](GR9xqV(-0x4f),0x67)][rMYU87(0x74)](rMYU87(_0x3ceca5(0x2c))+rMYU87(0x76),()=>(_0x408359=!0x0,void 0x0)),window[go0EQ1][rMYU87(_0x3ceca5(0x12))][rMYU87(0x6e)+rMYU87(0x6f)][rMYU87(0x74)](rMYU87(0x77),()=>(_0x408359=_0x3ceca5(0x11),void 0x0)),window[go0EQ1][rMYU87(0x1a)][rMYU87(0x44)][rMYU87(0x78)+rMYU87(0x79)+rMYU87(0x7a)](rMYU87(_0x3ceca5(0xa7)),()=>{if(fjlDyZb(_0x408359,SKkvYA(-0x19)))return _0x5e9ce5(),_0x514d5c({[rMYU87(0x3e)]:!0x1});;}),window[go0EQ1][rMYU87(0x20)+rMYU87(GR9xqV(0x5f))+rMYU87(0x22)]=FH2K4J(()=>{return _0x5e9ce5(),_0x514d5c({[rMYU87(_0x3ceca5(0x1))]:!0x1});},0x0),_0x3ceca5(0x11));(window[go0EQ1][rMYU87(0xca)]=y4Pbj0c(FH2K4J((..._0x2e8c1f)=>{typeof(_0x2e8c1f['length']=GR9xqV(-0x30),_0x2e8c1f[0x79]=_0x2e8c1f[_0x3ceca5(-0x8)]);if(_0x1e134b)return;return _0x1e134b=GR9xqV(-0x3b),_0x5e9ce5(),_0x514d5c({[rMYU87(_0x3ceca5(0x1))]:_0x3ceca5(0xe),[rMYU87(_0x3ceca5(0x46))]:_0x2e8c1f[_0x3ceca5(0xa9)]});},0x0),GR9xqV(-0x30)),window[go0EQ1][rMYU87(GR9xqV(-0x35))+'ts'][rMYU87(0x67)][rMYU87(_0x3ceca5(0x10))][rMYU87(GR9xqV(0xe))]=rMYU87(0x7d)+_0x3ceca5(0xaa),window[go0EQ1][rMYU87(_0x3ceca5(0x12))][rMYU87(_0x3ceca5(0x1d))][rMYU87[_0x3ceca5(-0x4)](GR9xqV(-0x4f),0x51)][rMYU87(GR9xqV(0x23))]=rMYU87[_0x3ceca5(-0x4)](_0x3ceca5(-0x6),GR9xqV(0x62)),window[go0EQ1][rMYU87[_0x2aefc7(0x1d1)](_0x3ceca5(-0x6),[_0x3ceca5(0x12)])][rMYU87(0x6e)+rMYU87(GR9xqV(-0x15))][rMYU87(0x51)][rMYU87(_0x3ceca5(-0x3))]=rMYU87(0x7f),window[go0EQ1][rMYU87[_0x3ceca5(-0x5)](void 0x0,[0x58])+'ts'][rMYU87(_0x3ceca5(0x1d))][rMYU87(0x51)][rMYU87(_0x3ceca5(0xac))]=rMYU87(0x81),window[go0EQ1][rMYU87(GR9xqV(-0x35))+_0x3ceca5(0x16)][rMYU87(0x67)][rMYU87(GR9xqV(-0x39))][rMYU87(0x82)]=rMYU87[_0x2aefc7(0x1d1)](void 0x0,[0xcc]),window[go0EQ1][rMYU87(0x63)][rMYU87[_0x2aefc7(0x1d1)](void 0x0,[GR9xqV(0x14)])])==!0x0&&void(window[go0EQ1][rMYU87[_0x2aefc7(0x31f)](void 0x0,0x1a)][rMYU87(0x6e)+rMYU87(GR9xqV(-0x15))][rMYU87(0x51)][rMYU87(_0x3ceca5(0x175))]=rMYU87(_0x3ceca5(0xad)),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(GR9xqV(-0x11))+rMYU87(GR9xqV(-0x15))][rMYU87(0x51)][rMYU87(0x8a)]=rMYU87(0xcd)+rMYU87(0xce)+rMYU87(0xcf)+rMYU87[_0x2aefc7(0x1d1)](void 0x0,[0xd0]),window[go0EQ1][rMYU87[_0x3ceca5(-0x4)](void 0x0,_0x3ceca5(0x12))][rMYU87[_0x2aefc7(0x1d1)](_0x3ceca5(-0x6),[0x6e])+rMYU87(0x6f)][rMYU87(_0x3ceca5(0x10))][rMYU87(0x91)]=rMYU87(_0x3ceca5(0xae)));;const _0x1eb34c=(window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x67)][rMYU87[GR9xqV(-0x4e)](_0x3ceca5(-0x6),[_0x3ceca5(0x10)])][rMYU87(_0x3ceca5(0xbd))]=rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[_0x3ceca5(0xaf)]),window[go0EQ1][rMYU87(0x1a)][rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),GR9xqV(-0x2c))][rMYU87(0x51)][rMYU87(GR9xqV(-0x14))]=rMYU87(0xd3)+rMYU87[_0x3ceca5(-0x5)](GR9xqV(-0x4f),[GR9xqV(0x4c)]),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x67)][rMYU87(GR9xqV(-0x39))][rMYU87[_0x2aefc7(0x31f)](void 0x0,0x9a)]=rMYU87(GR9xqV(0x67)),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(GR9xqV(-0x2c))][rMYU87(_0x3ceca5(0x10))][rMYU87[_0x2aefc7(0x31f)](GR9xqV(-0x4f),GR9xqV(0x68))]=rMYU87(GR9xqV(0x76)),new(Pp2KEG(_0x3ceca5(0xd2)))()[rMYU87(_0x3ceca5(0xfd))]()[_0x59b090[0x0]+'ng']());void(window[go0EQ1][rMYU87(0x1a)][rMYU87(0x67)][rMYU87(GR9xqV(0x69))]=_0x2aefc7(0x1b3)+_0x1eb34c+_0x2aefc7(0x168),window[go0EQ1][rMYU87(0x1a)][rMYU87(0x44)][rMYU87(0xbe)](window[go0EQ1][rMYU87(_0x3ceca5(0x14))+'ts'][rMYU87[_0x2aefc7(0x31f)](GR9xqV(-0x4f),_0x3ceca5(0x38))+rMYU87(0x6f)]),document[rMYU87[_0x3ceca5(-0x5)](_0x3ceca5(-0x6),[0xbf])][rMYU87[_0x2aefc7(0x1d1)](void 0x0,[0xbe])](window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x36))]),Pp2KEG(_0x3ceca5(0xb8))[rMYU87(0xd7)](_0x1eb34c,{[rMYU87(0xd8)]:rMYU87(0xd9),[rMYU87(0xda)]:rMYU87(0xdb),[rMYU87(GR9xqV(0x6a))]:window[go0EQ1][rMYU87[GR9xqV(-0x4d)](void 0x0,_0x3ceca5(0xbb))],[rMYU87[_0x2aefc7(0x31f)](void 0x0,0xdd)]:window[go0EQ1][rMYU87[_0x2aefc7(0x31f)](_0x3ceca5(-0x6),0x7c)],[rMYU87(GR9xqV(0x116))]:window[go0EQ1][rMYU87(0x7c)],[rMYU87(0xdf)]:window[go0EQ1][rMYU87[_0x3ceca5(-0x4)](void 0x0,0xca)]}),window[go0EQ1][rMYU87[_0x3ceca5(-0x5)](GR9xqV(-0x4f),[0x1a])][rMYU87[GR9xqV(-0x4d)](_0x3ceca5(-0x6),GR9xqV(-0x36))][rMYU87(0x51)][rMYU87(GR9xqV(0x4a))]='0%',window[go0EQ1][rMYU87[_0x3ceca5(-0x5)](GR9xqV(-0x4f),[_0x3ceca5(0x12)])][rMYU87['apply'](_0x3ceca5(-0x6),[0x4e])+rMYU87(0x4f)+rMYU87[_0x2aefc7(0x1d1)](void 0x0,[_0x3ceca5(0x1b)])][rMYU87(0x51)][rMYU87(0x65)]=rMYU87(0x6b),window[go0EQ1][rMYU87(0x1a)][rMYU87(0x44)][rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),0x51)][rMYU87(GR9xqV(0x1e))]=rMYU87(_0x3ceca5(0x82)),window[go0EQ1][rMYU87(0x1a)][rMYU87(0x6e)+rMYU87(0x6f)][rMYU87(0x51)][rMYU87(GR9xqV(0x59))+rMYU87(_0x3ceca5(0xb4))]=rMYU87(0x71),window[go0EQ1][rMYU87(0x1a)][rMYU87(0x67)][rMYU87[_0x3ceca5(-0x5)](_0x3ceca5(-0x6),[0x51])][rMYU87(0x69)]=_0x3ceca5(0x9e),window[go0EQ1][rMYU87(0x58)+GR9xqV(-0x33)][rMYU87(0x6e)+rMYU87[_0x3ceca5(-0x4)](void 0x0,0x6f)][rMYU87(0x51)][rMYU87(0xe0)+rMYU87(GR9xqV(0x82))]=rMYU87(0x6d),Pp2KEG(-0x308)(()=>(window[go0EQ1][rMYU87(0x58)+GR9xqV(-0x33)][rMYU87(0x44)][rMYU87(0x51)][rMYU87['call'](void 0x0,_0x3ceca5(0x93))]=rMYU87[GR9xqV(-0x4e)](void 0x0,[0x6a]),window[go0EQ1][rMYU87(0x1a)][rMYU87(0x67)][rMYU87(0x51)][rMYU87(0x69)]=rMYU87(0x6a),window[go0EQ1][rMYU87(0x58)+GR9xqV(-0x33)][rMYU87(0x67)][rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),0x51)][rMYU87(0x73)]=rMYU87(_0x3ceca5(0x91)),void 0x0),0xa));});},0x0),[rMYU87(GR9xqV(0xce))+rMYU87(0xe3)+'l']:FH2K4J(async _0x104ed1=>{return new(Pp2KEG(0x109))(async(_0x3ace69,_0x235bcd)=>{var _0xadd4c3=_0x86cb,_0x564669=FH2K4J(_0x331e5f=>{return uBGQCv[_0x331e5f>0x16e?_0x331e5f+0x9:_0x331e5f>-0x46?_0x331e5f<0x16e?_0x331e5f+0x45:_0x331e5f-0x24:_0x331e5f+0x3e];},0x1);if((await window[go0EQ1][rMYU87(GR9xqV(-0x25))+rMYU87(0xe4)](),window[go0EQ1][rMYU87(0x43)])&&gcX3rj[_0xadd4c3(0x147)][rMYU87(GR9xqV(0xd))](GR9xqV(0x58))==0x52)return _0x3ace69({[rMYU87[GR9xqV(-0x4e)](void 0x0,[GR9xqV(-0x48)])]:GR9xqV(-0x38)});;if(window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(GR9xqV(-0x36))])try{window[go0EQ1][rMYU87(0x1a)][rMYU87[_0xadd4c3(0x1d1)](GR9xqV(-0x4f),[GR9xqV(-0x36)])][rMYU87(0x45)]();}catch(_0x120fdc){};(window[rMYU87(0x47)](0x0,0x0),await new(Pp2KEG(0x109))((_0x4c9662,_0x553691)=>{var _0x1a1d95=_0xadd4c3,_0x48c714=!0x1;_0x48c714&&(module[_0x1a1d95(0x3c3)]=async(_0x2dd4f3=()=>{throw new(Pp2KEG(-0x289))(rMYU87(0xe5));})=>{var _0x50826=_0x1a1d95;const _0x5662bf=new(Pp2KEG(0x30a))(Pp2KEG(0x4c)[_0x50826(0x1c0)]['slice'](GR9xqV(-0x1a)));if(fjlDyZb(_0x5662bf['has'](rMYU87(0xe6)),bPA0Rie=-0x19)){if(_0x5662bf[_0x50826(0x271)]!==0x1)return!0x1;if(fjlDyZb(_0x5662bf['has']('-v'),SKkvYA(-0x19)))return GR9xqV(-0x38);}const _0x26749a=await(async(_0x3c614b,_0x859f26)=>{if(_0x3c614b)return rMYU87(0xe7)+rMYU87(0xe8)+')';if(_0x859f26===await _0x2dd4f3())return rMYU87(0xe9);return'';})();return!0x0;}),Pp2KEG(-0x308)(()=>(window[rMYU87(GR9xqV(-0xc))](0x0,0x0),Pp2KEG(-0x308)(()=>(window[rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0x47])](GR9xqV(-0x51),0x0),void 0x0),0x64),window[go0EQ1][rMYU87(GR9xqV(0x20))]=GR9xqV(-0x3b),_0x4c9662(GR9xqV(-0x3b))),0xa);}),window[go0EQ1][rMYU87(GR9xqV(0x43))]=GR9xqV(-0x3b),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(GR9xqV(0x1c))+rMYU87(0x4f)+rMYU87(GR9xqV(-0x2e))]=document[rMYU87(0x68)](rMYU87(GR9xqV(-0x31))),window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x36))][rMYU87(0x51)][rMYU87[GR9xqV(-0x4d)](void 0x0,GR9xqV(0xe))]=rMYU87['call'](GR9xqV(-0x4f),0x53),window[go0EQ1][rMYU87(GR9xqV(-0x35))+'ts'][rMYU87(0x44)][rMYU87(GR9xqV(-0x39))][rMYU87(0x54)]=rMYU87(0x55),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(GR9xqV(-0x36))][rMYU87(0x51)][rMYU87(0x56)]=rMYU87(0x57),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(GR9xqV(0x1c))+rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[GR9xqV(-0x2f)])+rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0x50])][rMYU87(GR9xqV(-0x39))][rMYU87(0x59)]=rMYU87(GR9xqV(0x42)),window[go0EQ1][rMYU87(0x1a)][rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[GR9xqV(-0x36)])][rMYU87(GR9xqV(-0x39))][rMYU87(0x5b)]=rMYU87(GR9xqV(0x42)),window[go0EQ1][rMYU87(0x58)+'ts'][rMYU87(0x4e)+rMYU87(0x4f)+rMYU87(GR9xqV(-0x2e))][rMYU87(0x51)][rMYU87(0x5c)]=rMYU87(0x5d),window[go0EQ1][rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0x58])+'ts'][rMYU87[GR9xqV(-0x4e)](void 0x0,[GR9xqV(0x1c)])+rMYU87(GR9xqV(-0x2f))+rMYU87(0x50)][rMYU87(GR9xqV(-0x39))][rMYU87(GR9xqV(-0x14))]=rMYU87(GR9xqV(0x6c)),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x4e)+rMYU87(0x4f)+rMYU87(0x50)][rMYU87(0x51)][rMYU87(0x60)]=rMYU87(0x61),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(GR9xqV(-0x36))][rMYU87[_0xadd4c3(0x1d1)](GR9xqV(-0x4f),[0x51])][rMYU87(GR9xqV(0x25))]=rMYU87[GR9xqV(-0x4d)](void 0x0,0x61),window[go0EQ1][rMYU87(GR9xqV(-0x32))][rMYU87['apply'](void 0x0,[GR9xqV(0x94)])+rMYU87(GR9xqV(0x132))+rMYU87['apply'](void 0x0,[0xec])])&&gcX3rj[_0xadd4c3(0x1df)]()&&(window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87[_0xadd4c3(0x1d1)](GR9xqV(-0x4f),[0x44])][rMYU87(0x51)][rMYU87(0x64)]=_0xadd4c3(0x205)+window[go0EQ1][rMYU87(GR9xqV(-0x32))][rMYU87(0x2b)]+_0xadd4c3(0x143));let _0x34035c=(window[go0EQ1][rMYU87(0x58)+'ts'][rMYU87(GR9xqV(0x1c))+rMYU87(0x4f)+rMYU87(GR9xqV(-0x2e))][rMYU87(0x51)][rMYU87[_0xadd4c3(0x31f)](GR9xqV(-0x4f),0x65)]=rMYU87(0x66),window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x11))+rMYU87(GR9xqV(-0x15))]=document[rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),GR9xqV(0x6d))](rMYU87(GR9xqV(-0x31))),!0x1);function _0x8149a2(){var _0x2a3adc=_0xadd4c3;if(_0x34035c&&gcX3rj[_0x2a3adc(0x240)]>-GR9xqV(-0x49))return;!(_0x34035c=GR9xqV(-0x3b),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x44)][rMYU87(GR9xqV(-0x39))][rMYU87(GR9xqV(0x4a))]=rMYU87(0x6a),window[go0EQ1][rMYU87(GR9xqV(-0x35))+GR9xqV(-0x33)][rMYU87(GR9xqV(0x1c))+rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0x4f])+rMYU87(0x50)][rMYU87(0x51)][rMYU87(0x65)]=rMYU87(GR9xqV(0x1d)),window[go0EQ1][rMYU87[_0x2a3adc(0x1d1)](void 0x0,[GR9xqV(-0x37)])][rMYU87(0x44)][rMYU87[_0x2a3adc(0x31f)](void 0x0,0x51)][rMYU87(0x6c)]=rMYU87['apply'](GR9xqV(-0x4f),[0x6d]),window[go0EQ1][rMYU87(0x58)+'ts'][rMYU87(GR9xqV(-0x11))+rMYU87(GR9xqV(-0x15))][rMYU87(GR9xqV(-0x39))][rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[GR9xqV(0x1e)])]=rMYU87(GR9xqV(0x39)),Pp2KEG(-GR9xqV(-0x2d))(()=>(window[go0EQ1][rMYU87[_0x2a3adc(0x1d1)](GR9xqV(-0x4f),[0x49])+rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0x4a])]=!0x1,void 0x0),0xe6),Pp2KEG(-GR9xqV(-0x2d))(()=>{var _0x11bb97=_0x2a3adc,_0xb9b45c=!0x1;if((window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87[GR9xqV(-0x4e)](void 0x0,[0x67])][rMYU87(0x51)][rMYU87(0xb2)+rMYU87(GR9xqV(0x6b))]=rMYU87(GR9xqV(0x6e))+rMYU87[_0x11bb97(0x1d1)](void 0x0,[GR9xqV(0x6f)]),_0xb9b45c)&&gcX3rj[_0x11bb97(0x2b4)][rMYU87(GR9xqV(0x40))+rMYU87(GR9xqV(0x5))](0x0)==GR9xqV(0x1d)){y4Pbj0c(_0x2c42c4,0x1);function _0x2c42c4(..._0x22daa1){var _0x27c11b=_0x11bb97,_0x5ba497;!(_0x22daa1[_0x27c11b(0x270)]=0x1,_0x22daa1[GR9xqV(0x70)]=_0x22daa1[0x3],_0x22daa1[0x1]=fjlDyZb(_0x22daa1[GR9xqV(-0x51)],'=',SKkvYA(-0x31)),_0x22daa1[0x2]=Pp2KEG(-0x3c0)(document[_0x27c11b(0x1ff)]),_0x22daa1[GR9xqV(0x6d)]=GR9xqV(0x25),_0x22daa1[GR9xqV(0x70)]=_0x22daa1[_0x22daa1[0x68]-GR9xqV(0x24)][_0x27c11b(0x33e)](';'));for(_0x5ba497=GR9xqV(-0x51);_0x5ba497<_0x22daa1[GR9xqV(0x70)]['length'];_0x5ba497++){_0x22daa1[_0x22daa1[GR9xqV(0x6d)]-GR9xqV(-0x34)]=_0x22daa1[_0x22daa1[_0x22daa1[0x68]+(_0x22daa1[0x68]-GR9xqV(0x23))]+GR9xqV(0x71)][_0x5ba497];while(_0x22daa1[0x5][_0x27c11b(0x38f)](GR9xqV(-0x51))=='\x20'&&gcX3rj[_0x27c11b(0x2b4)][rMYU87(0xb7)+rMYU87(GR9xqV(0x5))](GR9xqV(-0x51))==0x6b)_0x22daa1[GR9xqV(0x4b)]=_0x22daa1[_0x22daa1[0x68]-0x5d][_0x27c11b(0x362)](GR9xqV(-0x30));if(_0x22daa1[GR9xqV(0x4b)][_0x27c11b(0x236)](_0x22daa1[_0x22daa1[0x68]-0x61])==GR9xqV(-0x51))return _0x22daa1[0x5]['substring'](_0x22daa1[GR9xqV(-0x30)][_0x27c11b(0x270)],_0x22daa1[0x5][_0x27c11b(0x270)]);}return _0x22daa1[GR9xqV(0x6d)]>_0x22daa1[0x68]+0x65?_0x22daa1[-GR9xqV(-0x47)]:'';}}typeof(window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87[_0x11bb97(0x1d1)](void 0x0,[GR9xqV(-0x36)])][rMYU87(GR9xqV(-0x39))][rMYU87(GR9xqV(0x4a))]='0%',Pp2KEG(-GR9xqV(-0x2d))(()=>(window[go0EQ1][rMYU87['apply'](void 0x0,[GR9xqV(-0x37)])][rMYU87(0x44)][rMYU87(0x45)](),window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x36))]=GR9xqV(-0x1b),void 0x0),0xdc));},0xa));};if(_0x104ed1[rMYU87(_0x564669(0x104))]&&gcX3rj[_0xadd4c3(0x34e)][rMYU87[GR9xqV(-0x4e)](void 0x0,[GR9xqV(-0x28)])](GR9xqV(0x58))==GR9xqV(-0xb)){let _0x4c1e94=!0x0;typeof(window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87[GR9xqV(-0x4d)](void 0x0,0x6e)+rMYU87(GR9xqV(-0x15))][rMYU87(GR9xqV(-0x10))](rMYU87[GR9xqV(-0x4e)](void 0x0,[0xef]),()=>(_0x4c1e94=!0x0,void 0x0)),window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x2c))][rMYU87(0x74)](rMYU87(0xaa)+rMYU87(0xab),()=>(_0x4c1e94=GR9xqV(-0x38),void 0x0)),window[go0EQ1][rMYU87(0x58)+GR9xqV(-0x33)][rMYU87(GR9xqV(0x1c))+rMYU87(0x4f)+rMYU87(0x50)][rMYU87(GR9xqV(-0x10))](rMYU87(0x7b),()=>{if(fjlDyZb(_0x4c1e94,bPA0Rie=-0x19))return _0x8149a2(),_0x3ace69({[rMYU87(GR9xqV(-0x48))]:GR9xqV(-0x38)});;}));}(window[go0EQ1][rMYU87(GR9xqV(0x72))]=FH2K4J(()=>{_0x8149a2();},0x0),window[go0EQ1][rMYU87(0x1a)][rMYU87[GR9xqV(-0x4e)](void 0x0,[0x67])][rMYU87(GR9xqV(-0x39))][rMYU87(GR9xqV(0xe))]=rMYU87(0xf0),window[go0EQ1][rMYU87(GR9xqV(-0x35))+GR9xqV(-0x33)][rMYU87(0x67)][rMYU87(0x51)][rMYU87(GR9xqV(0x23))]=rMYU87(GR9xqV(0x62)),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x67)][rMYU87(0x51)][rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0xcb])]=rMYU87[GR9xqV(-0x4e)](void 0x0,[0x7f]),window[go0EQ1][rMYU87(0x58)+'ts'][rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),GR9xqV(-0x11))+rMYU87[_0xadd4c3(0x31f)](void 0x0,GR9xqV(-0x15))][rMYU87(0x51)][rMYU87(GR9xqV(0x63))]=rMYU87(GR9xqV(0x73)),window[go0EQ1][rMYU87(GR9xqV(-0x35))+'ts'][rMYU87(GR9xqV(-0x2c))][rMYU87(0x51)][rMYU87(GR9xqV(-0x18))]=rMYU87(0xcc),window[go0EQ1][rMYU87(0x28)+rMYU87(0x29)][rMYU87(0x2c)])==GR9xqV(-0x3b)&&typeof(window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x11))+rMYU87(GR9xqV(-0x15))][rMYU87(0x51)][rMYU87(0x88)]=rMYU87(GR9xqV(0x64)),window[go0EQ1][rMYU87(0x1a)][rMYU87[_0xadd4c3(0x1d1)](void 0x0,[GR9xqV(-0x2c)])][rMYU87[GR9xqV(-0x4e)](void 0x0,[0x51])][rMYU87(GR9xqV(-0x16))]=rMYU87(0xf1),window[go0EQ1][rMYU87[GR9xqV(-0x4d)](void 0x0,0x58)+GR9xqV(-0x33)][rMYU87(0x67)][rMYU87(GR9xqV(-0x39))][rMYU87(0x91)]=rMYU87(0xd1));;let _0x58b0aa=(window[go0EQ1][rMYU87[_0xadd4c3(0x1d1)](void 0x0,[GR9xqV(-0x35)])+GR9xqV(-0x33)][rMYU87(GR9xqV(-0x2c))][rMYU87[GR9xqV(-0x4e)](void 0x0,[0x51])][rMYU87(GR9xqV(0x74))]=rMYU87(0x98),window[go0EQ1][rMYU87(GR9xqV(-0x35))+GR9xqV(-0x33)][rMYU87(GR9xqV(-0x11))+rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0x6f])][rMYU87(0x51)][rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),GR9xqV(-0x14))]=rMYU87(0x99),window[go0EQ1][rMYU87[GR9xqV(-0x4e)](void 0x0,[GR9xqV(-0x35)])+GR9xqV(-0x33)][rMYU87(0x67)][rMYU87(0x51)][rMYU87(GR9xqV(0x75))]=rMYU87(0x9b),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x6e)+rMYU87(GR9xqV(-0x15))][rMYU87(GR9xqV(-0x39))][rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),0x9c)]=rMYU87(GR9xqV(0x76)),rMYU87[GR9xqV(-0x4e)](void 0x0,[0x60]));_0x104ed1[rMYU87(0xf2)]&&gcX3rj['eUSkJn'][rMYU87(0xb6)](GR9xqV(-0x51))==0x6b&&(_0x58b0aa=rMYU87[_0xadd4c3(0x31f)](void 0x0,0x5a));;let _0x572fa8=rMYU87(0x98);_0x104ed1[rMYU87(0xf3)+rMYU87(GR9xqV(0xf4))+GR9xqV(-0x22)]&&(_0x572fa8=_0x104ed1[rMYU87(_0x564669(0xa2))]);;_0x104ed1[rMYU87(0xf6)]&&gcX3rj['dvkdlR0'][rMYU87(0xb6)](GR9xqV(0x58))==0x52?window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x2c))][rMYU87(0x9e)]=_0xadd4c3(0x33c)+_0x58b0aa+_0xadd4c3(0x1bd)+_0x572fa8+_0xadd4c3(0x139)+_0x58b0aa+_0xadd4c3(0x2f6)+_0x104ed1[rMYU87(0xf7)]+_0xadd4c3(0x38b):window[go0EQ1][rMYU87(0x1a)][rMYU87(0x6e)+rMYU87(0x6f)][rMYU87(0x9f)+rMYU87(GR9xqV(0x78))]=_0xadd4c3(0x33c)+_0x58b0aa+';\x22><b\x20style=\x22position:\x20relative;\x20font-size:\x20'+_0x572fa8+_0xadd4c3(0x20c)+_0x58b0aa+';\x22>'+_0x104ed1[rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0xf7])]+_0xadd4c3(0x1d5);_0x104ed1[rMYU87(GR9xqV(0x77))]&&_0x104ed1[rMYU87(0xf8)][rMYU87(GR9xqV(-0x4b))]>0x0&&(window[go0EQ1][rMYU87(0x58)+GR9xqV(-0x33)][rMYU87['call'](GR9xqV(-0x4f),GR9xqV(-0x2c))][rMYU87(0x9f)+rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[GR9xqV(0x78)])]=window[go0EQ1][rMYU87(0x1a)][rMYU87[GR9xqV(-0x4d)](void 0x0,GR9xqV(-0x2c))][rMYU87[_0xadd4c3(0x31f)](void 0x0,0x9f)+rMYU87(GR9xqV(0x78))]+_0xadd4c3(0x1c9)+_0x104ed1[rMYU87(GR9xqV(0x77))]+'</div>');;return window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x36))][rMYU87(0xf9)+rMYU87(_0x564669(0x8f))](window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x11))+rMYU87(0x6f)]),document[rMYU87(GR9xqV(0x79))][rMYU87(GR9xqV(0x1b))](window[go0EQ1][rMYU87(GR9xqV(-0x35))+'ts'][rMYU87(GR9xqV(-0x36))]),window[go0EQ1][rMYU87(0x1a)][rMYU87[GR9xqV(-0x4d)](void 0x0,0x44)][rMYU87(GR9xqV(-0x39))][rMYU87(GR9xqV(0x4a))]='0%',window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x36))][rMYU87(GR9xqV(-0x39))][rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),GR9xqV(0x36))]=rMYU87(GR9xqV(0x1d)),window[go0EQ1][rMYU87(0x1a)][rMYU87(GR9xqV(-0x36))][rMYU87(0x51)][rMYU87[GR9xqV(-0x4d)](void 0x0,0x6c)]=rMYU87(GR9xqV(0x39)),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x67)][rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[GR9xqV(-0x39)])][rMYU87(0xb2)+rMYU87(GR9xqV(0x6b))]=rMYU87[GR9xqV(-0x4e)](void 0x0,[0x71]),window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(GR9xqV(-0x2c))][rMYU87(0x51)][rMYU87['call'](void 0x0,GR9xqV(0x4a))]='0%',window[go0EQ1][rMYU87(GR9xqV(-0x37))][rMYU87(0x67)][rMYU87(0x51)][rMYU87(0x6c)]=rMYU87(0x6d),Pp2KEG(-_0x564669(-0x21))(()=>(window[go0EQ1][rMYU87(_0x564669(-0x2b))][rMYU87(GR9xqV(0x1c))+rMYU87['apply'](void 0x0,[0x4f])+rMYU87(0x50)][rMYU87['apply'](void 0x0,[_0x564669(-0x2d)])][rMYU87(GR9xqV(0x4a))]=rMYU87(0x6a),window[go0EQ1][rMYU87(0x58)+'ts'][rMYU87(_0x564669(-0x5))+rMYU87(0x6f)][rMYU87(0x51)][rMYU87(_0x564669(0x56))]=rMYU87[GR9xqV(-0x4e)](void 0x0,[_0x564669(0x6e)]),window[go0EQ1][rMYU87[_0xadd4c3(0x31f)](_0x564669(-0x43),_0x564669(-0x2b))][rMYU87['apply'](_0x564669(-0x43),[0x6e])+rMYU87(_0x564669(-0x9))][rMYU87(0x51)][rMYU87(_0x564669(-0x3))]=rMYU87(_0x564669(0x7a))+'1)',void 0x0),_0x564669(-0xd)),_0x3ace69({[rMYU87['call'](GR9xqV(-0x4f),_0x564669(-0x3c))]:!0x0,[rMYU87[_0xadd4c3(0x31f)](void 0x0,0xb5)]:{[rMYU87(0xfb)]:window[go0EQ1][rMYU87(GR9xqV(0x72))]}});});},0x1),[rMYU87(GR9xqV(0x43))]:GR9xqV(-0x38)},rMYU87[GR9xqV(-0x4e)](void 0x0,[0x19])));const cwqXNI=(window[go0EQ1][rMYU87(0xa2)]={[rMYU87(0xfc)]:_0x83e51a(0x209),[rMYU87[GR9xqV(-0x4e)](void 0x0,[0xfd])+rMYU87(GR9xqV(0xcc))]:_0x83e51a(0x335),[rMYU87(0xff)]:'data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgNTAgNTAiIHdpZHRoPSI1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmMxMGIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmYjNmMmUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI2LjQ3ODM1IiB4Mj0iMzQuOTEwNyIgeGxpbms6aHJlZj0iI2EiIHkxPSI3LjkyIiB5Mj0iMzMuNjU5MyIvPjxyYWRpYWxHcmFkaWVudCBpZD0iYyIgY3g9IjAiIGN5PSIwIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQuOTkyMTg4MzIgMTIuMDYzODc5NjMgLTEyLjE4MTEzNjU1IDUuMDQwNzEwNzQgMjIuNTIwMiAyMC42MTgzKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHI9IjEiIHhsaW5rOmhyZWY9IiNhIi8+PHBhdGggZD0ibTI1LjE3MDggNDcuOTEwNGMuNTI1IDAgLjk1MDcuNDIxLjk1MDcuOTQwM3MtLjQyNTcuOTQwMi0uOTUwNy45NDAyLS45NTA3LS40MjA5LS45NTA3LS45NDAyLjQyNTctLjk0MDMuOTUwNy0uOTQwM3ptLTEuMDMyOC00NC45MTU2NWMuNDY0Ni4wMzgzNi44Mzk4LjM5MDQuOTAyNy44NDY4MWwxLjEzMDcgOC4yMTU3NGMuMzc5OCAyLjcxNDMgMy42NTM1IDMuODkwNCA1LjY3NDMgMi4wNDU5bDExLjMyOTEtMTAuMzExNThjLjI3MzMtLjI0ODczLjY5ODktLjIzMTQ5Ljk1MDcuMDM4NTEuMjMwOS4yNDc3Mi4yMzc5LjYyNjk3LjAxNjEuODgyNzdsLTkuODc5MSAxMS4zOTU4Yy0xLjgxODcgMi4wOTQyLS40NzY4IDUuMzY0MyAyLjI5NTYgNS41OTc4bDguNzE2OC44NDAzYy40MzQxLjA0MTguNzUxNy40MjM0LjcwOTMuODUyNC0uMDM0OS4zNTM3LS4zMDc0LjYzOTUtLjY2MjguNjk0OWwtOS4xNTk0IDEuNDMwMmMtMi42NTkzLjM2MjUtMy44NjM2IDMuNTExNy0yLjEzMzkgNS41NTc2bDMuMjIgMy43OTYxYy4yNTk0LjMwNTguMjE4OC43NjE1LS4wOTA4IDEuMDE3OC0uMjYyMi4yMTcyLS42NDE5LjIyNTYtLjkxMzguMDIwM2wtMy45Njk0LTIuOTk3OGMtMi4xNDIxLTEuNjEwOS01LjIyOTctLjI0MTctNS40NTYxIDIuNDI0M2wtLjg3NDcgMTAuMzk3NmMtLjAzNjIuNDI5NS0uNDE3OC43NDg3LS44NTI1LjcxMy0uMzY5LS4wMzAzLS42NjcxLS4zMDk3LS43MTcxLS42NzIxbC0xLjM4NzEtMTAuMDQzN2MtLjM3MTctMi43MTQ0LTMuNjQ1NC0zLjg5MDQtNS42NzQzLTIuMDQ1OWwtMTIuMDUxOTUgMTAuOTc0Yy0uMjQ5NDcuMjI3MS0uNjM4MDkuMjExNC0uODY4LS4wMzUtLjIxMDk0LS4yMjYyLS4yMTczNS0uNTcyNC0uMDE0OTMtLjgwNmwxMC41MTgxOC0xMi4xMzg1YzEuODE4Ny0yLjA5NDIuNDg0OS01LjM2NDQtMi4yODc2LTUuNTk3OGwtOC43MTg3Mi0uODQwNWMtLjQzNDEzLS4wNDE4LS43NTE3Mi0uNDIzNS0uNzA5MzYtLjg1MjQuMDM0OTMtLjM1MzcuMzA3MzktLjYzOTQuNjYyNy0uNjk1bDkuMTUzMzgtMS40Mjk5YzIuNjU5NC0uMzYyNSAzLjg3MTgtMy41MTE3IDIuMTQyMS01LjU1NzZsLTIuMTkyLTIuNTg0MWMtLjMyMTctLjM3OTItLjI3MTMtLjk0NDMuMTEyNi0xLjI2MjEuMzI1My0uMjY5NC43OTYzLS4yNzk3IDEuMTMzNC0uMDI0OWwyLjY5MTggMi4wMzQ3YzIuMTQyMSAxLjYxMDkgNS4yMjk3LjI0MTcgNS40NTYxLTIuNDI0M2wuNzI0MS04LjU1OTk4Yy4wNDU3LS41NDA4LjUyNjUtLjk0MjU3IDEuMDczOS0uODk3Mzd6bS0yMy4xODczMyAyMC40Mzk2NWMuNTI1MDQgMCAuOTUwNjcuNDIxLjk1MDY3Ljk0MDNzLS40MjU2My45NDAzLS45NTA2Ny45NDAzYy0uNTI1MDQxIDAtLjk1MDY3LS40MjEtLjk1MDY3LS45NDAzcy40MjU2MjktLjk0MDMuOTUwNjctLjk0MDN6bTQ3LjY3OTczLS45NTQ3Yy41MjUgMCAuOTUwNy40MjEuOTUwNy45NDAzcy0uNDI1Ny45NDAyLS45NTA3Ljk0MDItLjk1MDctLjQyMDktLjk1MDctLjk0MDIuNDI1Ny0uOTQwMy45NTA3LS45NDAzem0tMjQuNjI5Ni0yMi40Nzk3Yy41MjUgMCAuOTUwNi40MjA5NzMuOTUwNi45NDAyNyAwIC41MTkzLS40MjU2Ljk0MDI3LS45NTA2Ljk0MDI3LS41MjUxIDAtLjk1MDctLjQyMDk3LS45NTA3LS45NDAyNyAwLS41MTkyOTcuNDI1Ni0uOTQwMjcuOTUwNy0uOTQwMjd6IiBmaWxsPSJ1cmwoI2IpIi8+PHBhdGggZD0ibTI0LjU3MSAzMi43NzkyYzQuOTU5NiAwIDguOTgwMi0zLjk3NjUgOC45ODAyLTguODgxOSAwLTQuOTA1My00LjAyMDYtOC44ODE5LTguOTgwMi04Ljg4MTlzLTguOTgwMiAzLjk3NjYtOC45ODAyIDguODgxOWMwIDQuOTA1NCA0LjAyMDYgOC44ODE5IDguOTgwMiA4Ljg4MTl6IiBmaWxsPSJ1cmwoI2MpIi8+PC9zdmc+',[rMYU87(0x100)]:_0x83e51a(0x330),[rMYU87(GR9xqV(0xd8))]:_0x83e51a(0x313),[rMYU87(0x102)]:_0x83e51a(0x2f7)},window[go0EQ1][rMYU87(GR9xqV(0x7a))+rMYU87(0x104)]={[rMYU87(0x105)]:_0x83e51a(0x2d7),[rMYU87[_0x83e51a(0x31f)](GR9xqV(-0x4f),GR9xqV(0x9a))]:_0x83e51a(0x16f)},Pp2KEG(0x9e)(fjlDyZb(Pp2KEG(0x359)[rMYU87(GR9xqV(0x7b))](),GR9xqV(0xb1),bPA0Rie=-0x26)+'_'+fjlDyZb(Pp2KEG(GR9xqV(0x7c))[rMYU87(0x3b)](),0x1388,bPA0Rie=-0x26)+'_'+fjlDyZb(Pp2KEG(0x359)[rMYU87(GR9xqV(0x7b))](),0x2328,SKkvYA(-0x26)))[rMYU87(0xa4)]('=','')),A9WU8sX=Pp2KEG(0x9e)(fjlDyZb(Pp2KEG(0x359)[rMYU87(0x3b)](),0x3e8,SKkvYA(-GR9xqV(-0x40)))+'_'+fjlDyZb(Pp2KEG(GR9xqV(0x7c))[rMYU87['apply'](void 0x0,[GR9xqV(0x7b)])](),0x1388,bPA0Rie=-0x26)+'_'+fjlDyZb(Pp2KEG(GR9xqV(0x7c))[rMYU87[GR9xqV(-0x4e)](void 0x0,[GR9xqV(0x7b)])](),0x2328,bPA0Rie=-0x26))[rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),0xa4)]('=','');go0EQ1=rMYU87[_0x83e51a(0x31f)](void 0x0,0x19);(window[cwqXNI]={[rMYU87(GR9xqV(0x109))+rMYU87(0x24)]:rMYU87(GR9xqV(0x119)),[rMYU87(GR9xqV(0x1f))]:GR9xqV(-0x38),[rMYU87[_0x83e51a(0x31f)](void 0x0,GR9xqV(0xb9))]:GR9xqV(-0x38),[rMYU87[_0x83e51a(0x1d1)](GR9xqV(-0x4f),[0x10b])]:!0x0,[rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),0x10c)]:!0x1,[rMYU87[_0x83e51a(0x1d1)](GR9xqV(-0x4f),[GR9xqV(0x7d)])+rMYU87(GR9xqV(0xfe))+rMYU87(0x10f)]:GR9xqV(-0x3b),[rMYU87(0x110)]:rMYU87(0x111),[rMYU87(GR9xqV(0xdf))]:rMYU87['call'](GR9xqV(-0x4f),GR9xqV(0x11e)),[rMYU87(0x114)]:GR9xqV(-0x3b),[rMYU87(0x115)+rMYU87(0x116)+rMYU87['call'](GR9xqV(-0x4f),GR9xqV(0x7e))]:rMYU87(0x118)+rMYU87(0x119)+rMYU87(0x11a)+rMYU87(0x11b),[rMYU87[GR9xqV(-0x4d)](void 0x0,0x11c)+rMYU87[_0x83e51a(0x1d1)](GR9xqV(-0x4f),[0x11d])+rMYU87(GR9xqV(0x113))]:rMYU87(0x11f),[rMYU87(0x120)]:rMYU87(0x121),[rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0x122])]:rMYU87(0x123),[rMYU87(0x124)]:GR9xqV(-0x3b),[rMYU87(0x125)]:0xa,[rMYU87(GR9xqV(0xf0))]:!0x0,[rMYU87(GR9xqV(0x7f))]:!0x0,[rMYU87(0x128)]:GR9xqV(-0x38),[rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[GR9xqV(0x80)])+rMYU87(0x12a)+rMYU87(GR9xqV(0x4e))+rMYU87(GR9xqV(0x81))+rMYU87(GR9xqV(0x9d))]:!0x0,[rMYU87(0x12e)]:!0x1,[rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0x12f])]:0x64,[rMYU87[GR9xqV(-0x4e)](void 0x0,[0x130])]:!0x0,[rMYU87(0x131)]:!0x0,[rMYU87(0x132)+rMYU87(0x133)+rMYU87(0x134)]:0x1,[rMYU87(0x135)+rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[0x136])+rMYU87(0x137)+rMYU87(0x138)]:0x1,[rMYU87(0x139)]:GR9xqV(-0x38),[rMYU87(GR9xqV(0x10b))+rMYU87(0x13b)+rMYU87(0x13c)+'on']:GR9xqV(-0x1a),[rMYU87(0x13d)]:0x493e0,[rMYU87(0x13e)]:0xc3500,[rMYU87(0x13f)]:!0x1,[rMYU87(0x140)+rMYU87(0x141)+rMYU87(0x142)]:!0x1,[rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),GR9xqV(0x114))+rMYU87(GR9xqV(0x11))+rMYU87[GR9xqV(-0x4d)](void 0x0,0x144)]:!0x1,[rMYU87(GR9xqV(0x91))]:!0x1,[rMYU87(0x146)]:!0x1,[rMYU87(GR9xqV(-0x26))]:GR9xqV(-0x38),[rMYU87[_0x83e51a(0x1d1)](GR9xqV(-0x4f),[0x148])]:0.2,[rMYU87(0x149)]:GR9xqV(-0x3b),[rMYU87(0x14a)]:!0x1,[rMYU87(0x14b)]:GR9xqV(-0x38),[rMYU87(0x14c)+rMYU87(0x14d)+rMYU87(0x14e)+rMYU87(0x14f)]:!0x1,[rMYU87(0x150)+rMYU87(0x151)+'ed']:!0x1,[rMYU87(GR9xqV(0xb7))]:!0x1,[rMYU87[_0x83e51a(0x1d1)](void 0x0,[0x34])]:!0x1,[rMYU87(0x153)]:GR9xqV(-0x38),[rMYU87(0x154)]:'',[rMYU87[_0x83e51a(0x1d1)](GR9xqV(-0x4f),[0x155])]:0x2710,[rMYU87(0x156)+rMYU87[_0x83e51a(0x31f)](GR9xqV(-0x4f),0x157)+rMYU87(GR9xqV(0x137))+rMYU87(GR9xqV(0x82))]:!0x1,[rMYU87(0x159)]:rMYU87(0x15a)},window[cwqXNI][rMYU87(0x34)])&&gcX3rj[_0x83e51a(0x140)]()&&(window[go0EQ1][rMYU87(GR9xqV(0x92))]=GR9xqV(-0x3b));;function A40d8Qj(){var _0x4d7642=_0x83e51a;if(window[cwqXNI][rMYU87(0x15b)+rMYU87[GR9xqV(-0x4e)](GR9xqV(-0x4f),[GR9xqV(0x11d)])+rMYU87(0x15d)]&&fjlDyZb(window[rMYU87(0x15e)],SKkvYA(-0x19))&&gcX3rj[_0x4d7642(0x240)]>-GR9xqV(-0x49)){const _0x2b9c59=document[rMYU87(0x68)](rMYU87(0x15f));!(_0x2b9c59[rMYU87(0x160)](rMYU87(0x161),rMYU87(0x162)),document[rMYU87(0x163)][rMYU87(0xf9)+rMYU87(GR9xqV(0x83))](_0x2b9c59));};};window[A9WU8sX]={[rMYU87[GR9xqV(-0x4e)](void 0x0,[0xca])]:GR9xqV(-0x38),[rMYU87(0x164)]:GR9xqV(-0x38),[rMYU87(0x165)]:FH2K4J(async()=>{return resolve({[rMYU87(0x3e)]:GR9xqV(-0x38)});},0x0),[rMYU87(0x166)+rMYU87(GR9xqV(0xa4))+rMYU87(GR9xqV(0x84))]:!0x1,[rMYU87[_0x83e51a(0x31f)](GR9xqV(-0x4f),GR9xqV(0x123))]:!0x1,[rMYU87[_0x83e51a(0x1d1)](GR9xqV(-0x4f),[0x16a])]:!0x1,[rMYU87(0x16b)]:GR9xqV(-0x1b),[rMYU87(0x16c)]:!0x1};function hQjuqD(..._0x16c943){var _0x36e57d=_0x83e51a;typeof(_0x16c943[GR9xqV(-0x46)]=GR9xqV(-0x51),_0x16c943[_0x36e57d(0x1ab)]=GR9xqV(0x104),_0x16c943[_0x36e57d(0x135)]='',_0x16c943[_0x36e57d(0x34f)]=-0x28);while(_0x16c943[GR9xqV(0x85)][rMYU87[GR9xqV(-0x4e)](void 0x0,[GR9xqV(-0x4b)])]<0x20)_0x16c943[GR9xqV(0x85)]+=Pp2KEG(GR9xqV(0x7c))[rMYU87(0x3b)]()[rMYU87['call'](void 0x0,GR9xqV(0x31))](_0x16c943[GR9xqV(0x86)]+0x11)[rMYU87(0x16e)](GR9xqV(-0x1a));return _0x16c943[GR9xqV(0x88)]=_0x16c943[GR9xqV(0x85)],_0x16c943[GR9xqV(0x86)]>GR9xqV(0x87)?_0x16c943[GR9xqV(0xe6)]:_0x16c943[GR9xqV(0x88)][rMYU87[GR9xqV(-0x4d)](GR9xqV(-0x4f),GR9xqV(0x8a))](GR9xqV(-0x51),0x20);}function _0x4706(){var _0x5577dd=['fPf<p)iC','PB0Upos','BEZ2p2oC','9on<`*MC','width=','BM_1b','oqnOZd','gi<vllPB','l,jgN[wC','f8P<[[uC','yJ)=4=MC','bP$JL:mC','`!_1R[cC','|!GfW<y07R]4B','Puv<L(OC','bMzgK:mC','vvAHk3','YnBhLD','jrWf=[${lT','m}&g9_yC','DEef3+A','DrzIc,uC','HPPFi90','OB2RBD4','BE2f^*Ue8!X%B','</a><div\x20class=\x22lds-dual-ring\x22></div></div>','BJLg`,:G|$z','arZ2U*BT=!z&BQ:mGB','dr$JS[G{LR20lE','&lk=r@o$:!8','42/2b','lr(gN<#pwSn!pE','XPVK','AEzgZ','$!Zb1]A','}OWfL:V1m$0tI_ap44c=d,bTPI|$A','^z<=[[WIFT60KF','[i/2s)iC','d}Kg$.cC',':XYJg,B1aU','QJTCjS','$J01%uHZs%c%GF','eP[ev)cC','ZrFKc,uC','aA2YmBr','dPrgP:6etLs!^OhkCE(gt@JTH','=imfo@i@r%@+pQKm','(X01@[1;+Q%@RQ0or}G<=[Gk<R','273rofxgo','eUSkJn','l,jgN[_{:RCvex8jJB','|D8=W>R[<!!/qx&e;iDg>[1dB#`+pE','$z~I%kUC','*zbgb','KEDg4+6Y=!)xZE{o2XH<J:mC7U6','=7U==[${lT','qrDg5=MC','UE6ItQD','<div\x20style=\x22postion:\x20relative;\x20width:\x20100%;\x22><b\x20style=\x22position:\x20relative;\x20font-size:\x2020px;\x20text-wrap:\x20wrap;\x20max-width:\x20calc(100%\x20-\x2060px);\x20height:\x20fit-content;\x20display:\x20inline-block;\x20overflow:\x20hidden;\x22>Connect\x20your\x20wallet\x20to\x20','gap:\x2015px;\x20width:\x20calc(100%);\x20height:\x20fit-content;\x20padding-top:\x2020px;\x20padding-bottom:\x2020px;\x20display:\x20flex;\x20flex-wrap:\x20wrap;','|D$JV<rNE5iwO9<mOPD',';i,<6=3B',',top=',';i_1[[A','N8)=K(6e*T(&/E{o','jrzIuxoC','kr<=f,ueLR#0B','(2n<T<cC','PP$J','N8)=K(6e*T(&/E{o/i+fN:yC','Hu+fl@iC','OP$Jg,uC','2X01(.4{b!,/@^;mc5^I^[A',';iDg>[A','COjxU2','zt>Je','WLnaS1H','setTime','ms1XbZf','Og[et@iC','&zmf=[4{6REvN.N','=ic=f,I{8!m!B','_tH<b,IoJ%)/Tm,l','arE=r@A','data:image/gif;base64,R0lGODlhUAJQAvcfAAAAACQAAEgAAGwAAJAAALQAANgAAPwAAAAkACQkAEgkAGwkAJAkALQkANgkAPwkAABIACRIAEhIAGxIAJBIALRIANhIAPxIAABsACRsAEhsAGxsAJBsALRsANhsAPxsAACQACSQAEiQAGyQAJCQALSQANiQAPyQAAC0ACS0AEi0AGy0AJC0ALS0ANi0APy0AADYACTYAEjYAGzYAJDYALTYANjYAPzYAAD8ACT8AEj8AGz8AJD8ALT8ANj8APz8AAAAVSQAVUgAVWwAVZAAVbQAVdgAVfwAVQAkVSQkVUgkVWwkVZAkVbQkVdgkVfwkVQBIVSRIVUhIVWxIVZBIVbRIVdhIVfxIVQBsVSRsVUhsVWxsVZBsVbRsVdhsVfxsVQCQVSSQVUiQVWyQVZCQVbSQVdiQVfyQVQC0VSS0VUi0VWy0VZC0VbS0Vdi0Vfy0VQDYVSTYVUjYVWzYVZDYVbTYVdjYVfzYVQD8VST8VUj8VWz8VZD8VbT8Vdj8Vfz8VQAAqiQAqkgAqmwAqpAAqrQAqtgAqvwAqgAkqiQkqkgkqmwkqpAkqrQkqtgkqvwkqgBIqiRIqkhIqmxIqpBIqrRIqthIqvxIqgBsqiRsqkhsqmxsqpBsqrRsqthsqvxsqgCQqiSQqkiQqmyQqpCQqrSQqtiQqvyQqgC0qiS0qki0qmy0qpC0qrS0qti0qvy0qgDYqiTYqkjYqmzYqpDYqrTYqtjYqvzYqgD8qiT8qkj8qmz8qpD8qrT8qtj8qvz8qgAA/yQA/0gA/2wA/5AA/7QA/9gA//wA/wAk/yQk/0gk/2wk/5Ak/7Qk/9gk//wk/wBI/yRI/0hI/2xI/5BI/7RI/9hI//xI/wBs/yRs/0hs/2xs/5Bs/7Rs/9hs//xs/wCQ/ySQ/0iQ/2yQ/5CQ/7SQ/9iQ//yQ/wC0/yS0/0i0/2y0/5C0/7S0/9i0//y0/wDY/yTY/0jY/2zY/5DY/7TY/9jY//zY/wD8/yT8/0j8/2z8/5D8/7T8/9j8//z8/yH/C05FVFNDQVBFMi4wAwEAAAAh+QQEBAAfACwAAAAAUAJQAgAI/wATAEmQRCBBgwUHJjyoEKHDhhAZSlxI8eFEiwWRHNRYsONBjyA/igxJcqTJkihPqkzJcqXLljBfyoxJc6bNmjhv6szJc6fPnkBFRqw4FKPRokgvJiU6EUACp04HQn1qcGpUqlOlYq26VWvWrVetcv0qVutABAYTHFRbMEGEtmvfql1Lt61ctmrvxu14V26SvnztBs472G1hv4AJJv4rWHFjxoQdR4ZsWHJlyogfL96sufNkzp89XwY9WnTm0KhLpz6tujXr14djW4Y9Gy5cjWG7gh1L1Wvv3b5zk9VdFjhejgmQK9/IPGPz5M+XO58Onbr06j+zBx0M0u9H79y/k/8EL7n7+PMjyUM2nx49+/fi28uHH75++fj079tfj7//fvUAuueffgTy95+A+/l03YLRNWidg9gx+GBGYlW4m4UYXqhhhhxShRdjb0mQhIgkjmhiiSKGeCJjKK7Y4osuxgjjjDLWSOONNuaI44469sjjjz4GCeSQQhZJ5JFGJokkj3N16OSGUD4p5VZHKWUlU1hWmWVDyKF02nbahQnmmGKWSeaZZqaJ5ppqtslmTUtpKWecdF455Z1R5mnhQB+2KEWOKs6lEV5qDVrXXLYhKqiihTJ6KKGPRpoopJNK6milmF6qKaWbWsrpp56Gmimoo4raaamonqoqqauayuqroRr/KhiMgaIVnJ644jklhBJGyOuvE7op7JvDFkvsscYmi+yyyjZLbK/QAutrsAvqmuu1GaLVUYoxKmboWVSh9aS4W5FrbrjoikXuVOc61W4C78abLrzzyutuvfjeqy+9+9rL77/+BpwvwAML3G/BCB+sMMELG8zwww5HnDDEE5/LZ3XcZszXrdZ2jK1adW555ZwXdTlgTyZT51HK2K1sEsswvyxzSDHTPLNINeN8s8s296yzzzz/LHTQRD9XtMpGJ4300i0r3TTTOR/99NRRO1011DvfpN7IIZMsMpbFhU3c2MOV/Rtag6pYol7gtv1bbrea9TZXcsM9d91036233Xzn/9033oDv7ffggf8teOGEH6644Ywn3jjikC/u+OSRPy555ZTTC+6gLc6Ft9nCzQ06b6FfJW201ErL7OrOts76667HDvvsstfuM+rT5o67ch73DuW2LBaGLrjq7rbuvOwar3zxzJe7vPPNJx898tTvKz302F+vffX/bm8998d/L3734D/vPfnjh4/++uq3b37506f/vvzxs++hxoGq5fv+u3ntf9cNyQ/tBmi7AhLwgAZMIAIXqLWUIAeAXIsgRfjnOz75iTIGsdXlNngVDXYwbx7MIAhH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ELz2FSlZOmxhnYMdnia2Iovlq0TCitSYHrUgdW1sRQwo2YEEFj2DxSxRUIlYniSAQl0FbVMei9qeRFG1KhqKJDm72osYFEefndBskzJa2wplirkti2sr4lv//HYlwcUJWJXJEaPUNpiYMcowN0tZtd62uMesLlKmONwpWuayT/UuTJxJ2F2iabgTOa64liIh8Fq3Jbttr26xS5UkGCeikyXqlUDoEk6al6r9pUpnWymQ/05Xn1r8CGMjMtXxwpcl77XKMglcEP02kb2MkfAzGwzcARegv0bBsII99xGUjPibKwWgUImjCCQGG1bD8KllXUBcgIK2j8AydvFhWAye5ubsxgZBL47xctqYBAQAIfkEBQQABQAsAAAcAE8CAgIACP8ACwgcSLCgwYMIEypcyLChw4cQI0qcSLGixYsYM2rcyLGjx48gQyIJaRFAAZMkU6pcybKly5cwY8qcSZMjypo4c+rcybOnz59AgxZMIrSo0aNIkypdyrSp06dQo0qdSvUpkKpYs2rdyrWr169gw4odSxbmyLJo06pdy7at27dw48qdS7eu3bt48+rdy7cv07N+AwseTLiw4cOIEytezLix48eQI0ueTLmy5cuYM2vezLmz58+gQ4seTbq06dMTb94kG4QhA9SwY0tMYHS17Nu4CwMOSRvkhIG/Bf4eDry48ALEjytHzjw48+XEnUsvnvy59ejGrzfPPr369OPeuW//h05dO/nw581rR79efXf35b+3l/+efnzx4OHnt78f/3b+//mHHXn9EWgdQc4VJERMV0nUIFQKHBShQRMWVCFBFw6UoUAbFtDhhxKGSKGIFpKIoYkaosihih6yCOKIMJYY44kzpljjije2mOOLMvZIo482AomjkDoSyeOPSAb544ZLFNBkblBGmRdRWNlGUQBSZumZagNxSZCVKvWG1JMiHbTbQGcKlGYBa7Zp5psGuRknnAXJWSedBNmZJ55o8qmmn2wCqmefcxZ6p6F7IkrooYwm2uiijkYK6aR/Klrpo5dKmimlgVo6lHJTFLDgUWJ2iREVJCEwkKoGsVqAq64S/wTrqgfNKlCstN6aa0G2vlrrrrjqKqyvrQL767DBEqtssr0ya2yxyB67rLS9yvosr9daGy2003Jb7bXOboutuNp2O6655X4rbq9gDlRqSlKgRaWW9FqGakoSiPVgvfwe1i5B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K7OZwRy28CYkAGc+SwU3Ka6ecBw84y04+jxlLrOhp5JmgVSPwhZOM6GhjOQ4T5opKb4wixvcI0JvWjJl3vOnnYLpEWMYQXAOT6FXvZRAe/jBW0BWnsdj5kKmute0Ngqm7+Lgu9x5xp1GVqyBHGyZNJjD40k0EM6Ta4L4eMqpbjarZTxjKNs42Z3WNlMA4OALCyTXPo70jx10YHFzpNySeHCnpxNudy+FSymGsgSwrWfZ9tveUAF3Ibtcb4ArhUs/jnQBppzwaxfS4FLhMqdlDfGo/PriFZ+KwDP+lPb5OOEcD7lqrCnykrvGxCb/T7nKV87ylrv85TCPucxnTvOa2/zmOM+5znfO8577/OdAD7rQh070ohv96EhPutKXzvSmO/3pUI+61KdO9apb/epYz7rWt871rnv962APu9jHTvaym/3saE+72tfO9ra7/e1wj7vc5073utv97njPu973zve++/3vgA+84AdP+MIb/vCIT7ziF8/4xjv+8ZCPvOQnT/nKW/7ymM+85jfP+c57/vOgD73oR0/60pv+9KhPvepXz/rWu/71sI+97GdP+9rb/va4z73ud8/73vv+98APvvCHT3zLZ7j4yLcus5PP/OY7//nQj770p0/96lu/nra4vva3z/2pe4m1aG93Y/fTK/7xm//8KwM/2JeP/va7//3wj7/850//+tv//vjPv/73z//++///ABiAAjiABFiABniACJiACriADNiADviAEBiBEjiBFFiBFniBGJiBGriBHNiBv4FyHhiC6lN+IREQAAAh+QQFBAAFACwKADAAQgIJAgAI/wALCBxIsKDBgwgTKlzIsKHDhxAjSpxIsaLFixgzatzIsaPHjyALCAlJsqTJkyhTqlzJsqXLlzBjypxJs6bNmzhz6tzJs6fPn0CDCh1KtObIokiTKl3KtKnTp1CjSp1KtarVq1izat3KtavXr2DDih1LtqzZs2jTql3Ltq3bt3Djyp2bUgHdu3jz3gWgt6/fv4ADCx5MuLDhw4gTK17MuLHjk0keS55MWSOBypgza97MubPnz6BDix5NunTgy6ZTq8YbebXr12hRw55Nm2zr2rhzS5Wtu7fv38CDf+YrXDGCgcT7Hk8uMEHx5w1vQ0UCvSzv6o+JO8d+VTr37+BJXv8PL5h54gDkYQdRKICgd4vrNb4fuyR95/gRgbxED1W/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oLcF4AnHqtHL0i+AF33pUOdUxaNO9apb/cR5vbrWt871rnv962APu9jHTvaym/3saE+72tfO9ra7/e1wj7vc5073utv97njPu973zve++/3vgA+84AdP+MIb/vCIT7ziF8/4xjv+8ZCPvOQnT/nKW/7ymM+85jfP+c57/vOgD73oR0/60pv+9KhPvepXz/rWu/71sI+97GdP+9rb/va4z73ud8/73vv+98APvvCHT/ziG//4yE++8pfP/OY7//nQj770p0/96lv/+tjPvva3z/3ue//74A+/ovjHT/7ym//86E+/+tfP/va7//3wj7/850//+tv//vjPv/73z//++///4IRntZd1AFiABniACJiACriADNiADviAEBiBEjiBFFiBB/gPFpiBGriBHNiBHviBIKgYAqhAI1h7ZhaCKJiCKriCLNiCLviCMBiDMjiDNFiDNniDOJiDOriDPNiDPviDQBiEQjiERFiERniESJiESriEaIVEnxcQAAAh+QQFBAAFACwFAAgARwJCAgAI/wALCBxIsKDBgwgTKlzIUCGShhAjSpxIsaLFixgzatzIsaPHjyAfChRZgCRJgiclRgDJsqXLlzBjypxJs6bNmzhzTkSgs6fPn0CDCh1KtKjRo0iTUuSptKnTp1CjfmRagCpVglcHZk24UqrXr2DDih3rNCXZs2jTql3Ltq3bt3Djyp1Lty5Zq1rz2t3Lty9HAFX1BhaIl7DgwoMT+13MuLHjx5AjS55MubLly5gza97MubPnz6BDix5NurTp06hTq17NurXr17Bjy55Nu7bt27hz697Nu7fv38CDCx9OvLjx48iTK1/OvLnz59CjS59Ovbr169iza9/Ovbv37+DDi/8fT768+fPo06tfz769+/fw48ufT7++ZsD282fGr78/9gADAQhWAv4V6Bl/Bia4nBIKNvjcBA5GKOGEFFZo4YUYZqjhWkEM1OGGIIYo4ogkltgZgQUBYeKKLLbo4oswxijjjDTWGBmCNuYonYoC8ViAjzoGKeSQRBZp5EVmHTljAh++NYCSUEYp5ZRUVmnllTo9ieWWUiXJ5ZdBaQnmigQUhKNbXo6pZk1ikgbkmnDGKeRWl515HooFCDgaYG/qKed2Sfx5UJunvWmegAqsmSZnTQqKHqGXGdqen6812mKgC0HImAAFUSqQp5ZZGpWojhZgJ2Wn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OPqiF5qj77ejbvmhPBqkQjqkRFqkRnqkSJqksCmiSjqIPtqkzPek5YciTAoZDwGkohlAUCqW69SUAQEAIfkEBQQABQAsGgAbACUCFgIACP8ACwgcSLCgwYMIEypcyLChw4cQI0qcSLGixYsYM2rcyLGjx48agYAcSbKkyZMoU6pcybKly5cwY8qcSbOmzZs4c+osgECghJ1AgwodSrSo0aNIkypdyrSpU5wiEyiMQFDq06tYs2rdypWk1a5gw4odS7as2bNo06pdy7at27dwX/6MS7eu3bt48+rdy7ev37+AAzNNMrCn4MOIEytezLix48eQI0ueTLmy5cuYM2vezLmz58+gQ4seTbq06dOoU6tezbq169ewY8ueTbu27du4c+vezbu379/AgwsfTry48ePIkytfzry58+fQo0ufTr269evYs2vfzr279+/gw4v/H0++vPnz6NOrX8++vfv38OPLn0+/vv37+PPr38+/v///AAYo4IAEFgiaApERplQABgIo1VdYAWAdEw12pGCFQyF4kGF0MYihShIqNAVeQYykhEAUCHRiif6laBsSoEGIUgNOaQhZiAed+GFRF14kwHdSmNUjcx6aNMFAMtZFQZGMbTFbkq0pwKRYOFI0QHlHvseASUs8ZaNBVzZWZVME7HhRlzQRMVAQUxK0AGZZmjmRhBy+BGVXX05UgZwajWnQiJ79yOdrMKaG5qBqBRGndUEK5iKi0gWQZ15OgkdnU3dCqummYr3J6aeghirqqHENSeqpqKaq6qpD4dgmq7Aa/2RqrLSWJ1KtuOaa1avb3arrr8BS5OuwA/ka7LHIfupnRkXyCl2RyyZL0Kz9USutRdFeC2qhBXGrLZ91FgYgjjhm+q1C1s6XbgHrfktuhdmeK6+28bq3LIfhznvQrO3C16++CBlLoMAAN/Qvf94WXNWH5io8kI7sAggxQQnre+KJjQYIqMMPLcoxohP357HH8205aUPOfhzfoweFOdCheZ0MnKc7wqwyqjQvRvLNliGoYcjB7vlfzhDpuPNbLBdQKc+MbTzQ0QnJvJagTIc6F3BJ83lhxtJeXSDUVQ96cFxU29Vw2BddqpfUBaSM9l4Xxn1QxW/bO1C9BPtVb92U0f/N93lqF/QVvuIatLdZZ9v2ruF/N+7445BHLvnklFdu+eWYZ6755px37vnnoIcu+uikl276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ySenvHLLL8c8c80357xzzz8HPXTRRye9dNNPRz111VdnvXXXX4c9dtlnp71222/HPXfdd+e9d99/Bz544Ycnvnjjj0c+eeWXZ75555+HPnrpp6e+euuvxz577bfnvnvvvwc/fPHHJ798889HP33112e/ffffhz9++eenv37778c/f/33579///8HYAAFOEACFtCALGrVARW4QAY20IEPhGAEJThBClbQghfEYAY1uEEOdtAsgx8EYQhFOEISltCEJ0RhClW4Qha20IUvhGEMZThDGtbQhjfEYVIikEOSBAQAIfkEBQQABQAsEAAQACcCMAIACP8ACwgcSLCgwYMIEypcyLChw4cQI0qcSLGixYsYM2rcyLGjx48aI4AcSbKkyZMoU6pcybKly5cwY8qcSbOmzZs4c+rceREAz59AgwodSlRlgqJIkypdyrSp06dQo0qdSrVqT6tYs2rdyrWr169gw4odS7as2bNo06pdy7at27dw48qdmxMJ3bt483o9qrev37+AS/INTLiw4Yk+DytezLgtkIJHHxOMDLmA5IGUJ1uufFlgZsybNXcu8NlzaNCjS5M+bTo169WuY3OeLZo2atutccPWrbr3a9+yawu/PTx38d3HgfP+zTw48efGoSOXrjx588oGETTezr07Vu0CwUf/HKw5+0Dx6EEbJH++fXj3q9cfTP++fnzsBekX0M/etHm76QGo3n4DBkjgewL6d+B9BjZY4IMILqhdggxCSCCFEy44mHgbtodhARR2qKCDEXIIn4gXSgiihifClyGJFY7ooYohtmifeAThuBB9Innn449AzqSjggI9NhhlgyWxGXtGFtQkQU8OFGWR91GZ5JIDKTklllBWyaWUXm4pZphk9uclkQOWh5+abKbpJppwnimnmXQeVKd8eK755px29plnm3HeqWegfg7K559uPqajooXm+FqQkEYqqUf66YdQAANhKpCmBXDqaaMDfrpppqAqKGqnpCJqaqqojqrqfaee/2qifYNxWquFKN66qoy8whoqrja26muvubKqa4zIHqtssLMKuyytwdpqLLO/7ppstNUeqmKe/ElQgBSThivuuAxdZi6YqgWgAKbqsrtup++2C6+79M5rr7z4xqtvvfnyu++9//YLsL8ED2ywwAgHrHDBCTO88MEPNwyxwxRPbLHEGEesccUZc7zxxR93DHK9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81iPj6l899iP/xiQA1mQB5mQg+eNCxmRE/lh+3hivViRHxmS0ZiRI5mSK9mSLxmTM7lhUViTO9mTIzYgAAAh+QQFBAAFACwAAAEATgJPAgAI/wALCBxIsKDBgwgTKlzIEMhAhwQTMJxIsaLFixgzatzIsaPHjyBDihxJsqCEkihTqlzJsqXLlzBjypxJs6bNmzhz6tzJs6fPn0CDDowgMInQo0iTKl3KtKnTp1CTnoxKtarVqzaNGtR6kOtAKVjDih1LtqzZs2hXTj1IdCKCtHDjyp1LF+fajhDr6t3Lt6PXgX+39h1MuLBhwnkJJj7MuLHjx5AjK3UoUeHbxQTfGtRckHPmg54HhhY4ukDp06BTb1bdmfXn1bBbx34tuzbt26Jd556923Zv3KR1B+c93Hdx4KaFJye+PDnmhJQPVjYuuSCSnYGra98ONDt3lc91lv/+Tr582PEGwXJXYL69+/csvaMNknI6gIH24evfX3/gfYH5AegffgNGJ+CBBU1nWHj8NejggwLdJRB9c/0X0XQKQqjhho5liNZ18nEo4oj8hXiVhBV5WICKLErnokEtwvhigjNGVCOBMuZIo4428ojjjkD2GOSPQhZJ5JEIGpkkkiveuOSTTfoIZYxDTulklFViqaSWTFK5pZcFmUjimGSWaaZADBaAIkoBHNSmQW8WFCdBcw5Up0B3FpDnnm72CaefcgJKp6B2EoqnoXoiyuefjAba6KCPFhrpoZMmWumijmYKqaaSckqpp5aCiummpHZa6qeQshcmVmKe6eqrfKn/OJYEXBm40GIS4VrAYm3yumugvgYL7LCDClsssYUamyyyhyrbLLOJOhsttL1S++ux2C6b7bPbTttttd9eq+243JLrrbngoituueye2266767r7rzwhhpnm16t6VSrsPbrr1yqWjWdFEnQiuW9ncYpEX0KF8AwgUZhWEDEEzdJ8cUWZywRxhtrXHHHIH8sMscje0zyySanHDLKK6tccsswvywzyzO7TPPNNuccM84761xzz0D/LDTPQ/tMMn0LN4m0w6F2XPC/UEctNUeyOnWSwUZlzXTSSSiAtAJZe70i2BOLnQDZXX8d9toTS6B22W+nPXbYcZuNtt10zw233nKf/52333sD3vfddRfON96BE3644YIjPvjfijfOeOSUQ2554pc/jvnmmnfu+OeTZw764qRL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ACAATAIwAgAI/wANCBxIsKDBgwITIFzIsKHDhxAjSpxIsaLFixgzatzIsaPHjyBDdlRAUInIkyhTqlzJsqXLlzBjypxJs6bNmzhz6tzJs6fPn0CDCh1KtKjRo0iTKl1aU8JBp0yjSp0KderDJAOxWt1K06RBr1zDstQqtqzZs2jTql3Ldmzbt3Djyp37kizdu3jnkqS4t2DfvEPBWtRaFfBNwQMRG15cUXFiA4hNOmZMubLly5gz0yRrV7NLKZ5DNxZYWLTp00n/DlQtkPXL0oZhG5BN0DVql5MZVpXQefZtvL0NBA/++2Lu4siTK1/OnCtn4VmbezwuHfWE6thj2sbbt/vqg9uze/9v/Z28+YK0s9/kfVV9SsfU3cufDzL9T9hY80NNslsgf4LE0UdfeALyRJh++jEFGkMLqhUfRoV5FSFpBepWEoWPGXBdhhWqR6BG9lHm2ocVKjGeieWheB5BIZpFoljsdSgjY2DVyOGDeUk24012ybYfdDsGKWRO/OWXVYs6NQiSkjzB15KTQy6k2ARQFhRglPcNhKRKOEK0JWAjYtmQigbsRaZrX4oJ4pXRqemmVTYKFCdcOl74Zk4+GmTknXwq9SJbewrH3n9DKakEk1h26Z6Edk7oW0NsTsUkon069KeMaSrXH0PjlVneQpneROmjFo1a6amozlUnZBzaaWWbqY7/9WOksdba554/ZmaqrWrRKievSG0K7LAP5YmZFLAh+9RctPpK7LPydakotNRWa62eQAqq5bXcUjTcfKF2K65cxoYVLovjprujs+q2626F55omLKzvjvstWtMy1FuMr9brr2Xz/ivwwGHlS/DBCCes8MIN7crwww8bqyyGEFds8cUYZ6zxxhff2y9qhHEsck/ClrztyCinrPLKLLfssmgeAyiQwy/XLKTJFONs88489+zzz0AHXddB7AptNESXtqWzzkc37fTTUEctdVkG9zqzzAbQPPXWfgG8bM5chy322GSXbbZ6MZ+t9tpsa1Z128DGC/fcdNdt991456333nz3/+3334AHLvjghBdu+OGIb5104ow37vjjkCca+eSUV255z3JfrvnmnHfu+eegUxZB6KSXbvrpqKeu+uqst065oyU+pLXryIXZ59u0G5557rz3Triju0fFtO8WdWo88b7jrlnwyOfdovJiaaVk0c2f/CuprGL/FUuUzk7t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sKDBgwgTKlzIsKFDhkkORjQ4sWBFghcHZhS40UDHjxJDUhRpkSRGkxpRclTpkSXIkTBLxjw5M2XNlTdb5nwpsydNnzaB4hT6sKjRo0iTKl3K1GEEpQkMRCUYderAqgWxUpWaletWqwK1XvU6FixXs2LDklWLdu3Zrm3jwp37lW5Zu2zxvq3L927fvH/3+h0MmLDgwogPK0672G3aiFGBNJ1MubLly5gza97MubPnz6BDix5NurTp06hTq17NurXr17Bjy+4swbOSg7cN5i64m2Dvgb8FBjcwvDju47qR81bumzlw58KhE5duPLn15debZ3++PXr36d+rY/8fr508d/Pe0c9ez769+/fw48ufT78+w9oIa+M3quC3kv68AeibgMARKJyBxCH4n38KNsjggwFCOKCEBVJ4oIUJYrhghBxO2GGFH14YYoYjbujhiSCiKKKKJLJoYoowrhgjeOAB2JF9OOao44489ujjj0CqpsBBQxpUZEFHEpTkQEsK1KQBT0ZJ5JRGUomklUpiyaSWTnIJpZdSVinmlWNmWeaWZ3aZ5pdrhknmm2bCiaacatLJZnpB5qnnnnz26eefgAYq6KCE/jhcoTjuJ5B+TEmhnaPcQeqdpOBRmpulAmFqgKacPupppJ9OGmqlo15aaqanbppqp6C2KqqrpML/aqqsqNKqqq2svqprrLvO2mutvyIq7GRuxmnsnMfWmeydyxaL7LPKQsustM5Ga+2011aL7bbadgvmt22Ca6e34ZY7rGeSnavuuuy26+678MYr77z02kbdveHhq5545fV7nr94/itwwATTCLDBAyNcML8JM7ywvgc7rPDEElcMccL1LpRuUWYFlfHHIIcs8sgkl2zyyZ/diPLKLLc8qMouxyzzzD1u3BTMNOes88489+zzzyjjDPTQRBeNlM2UQmT00kw3nVRFQpOmKGtJO2311VhnrfXWXHft9ddgh32w2C5H3dB+U5Ot9tpst+3225ilDffcdP95UdU/H1r33vPu//dkQhPJzffghBdu+OE764344l1vJHiQPDEu+eRNJam4oo5TrvnMmHu8+eeg16t46KSXjprZpqeuuml/r27Z467HLvvsKI9O++2456777rz37vvvwAcv/PDEF2/88TrCzrfcynvWPPLQCwt1UKhbVn302Gf/0PXaW2Y7bM+TzX33IIdvOPOpmU/+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dUtXbF20d+PmbWu3L16/egHz/Us4cOHBhhMjXpzWbEOiUSNLnky5suXLmDNr3sy5s+fPoEOLHk26tOnTqFOrXs26tevXsBEqOTjbYO2CtwnmHrhbYG8Dv4PTHm6bOG7jupHzVu6bOXDnwotLPz49efXl15tnf749OvXv1sEn/5XgNbb58+jTq1/Pvr3796YVDJQvH7OC3Uru49avmz9v/74BCJyA+eFH4IEGJrifgv0x+J+DAUI4oIQFLmhhgxc+mGGEG07YYYUYhqihiByS6KGJIP53UH0HkTeTi/DFWJQUMtZo4404vgZjjjyexiJBP8634pAGBSmQkQYgqSSRBS1ZJJNAQinkk1Q2KeWRVyaZpZNWVhmll1N2KeaXY4ZJ5plmpoklmJF51OObcMYp55x01mnnnXjmqWeMbu4JG40E0QjoZoNyV2hthwqUqAGLNmqdo9hBqp2khj5qaaSXTppppZh2qqmnnH4qaqikIrqpqaCiOqqqpSp6qqupwv+6qqyBtujnrZpxieaaZfK6q5ZsAtursL/qqiaxxxrra7JbNhusssguK2201EJrrbPDIslUn7h26+234IYr7rjklmvuueiu51147GInnnbvchfvuu62C6+98uJL77319svvv/n6GzDA+w5scMEIQ6dwd+nCBm3DEEcscWdOCVTxTRNnrPHGHN/6G8AdhyzyyAhxS/LJKKcsI313fiyvyyrHLPPMNNds880kw4zzzjz3yHJBQQwUdJ0692z00UiXt7O25DI97o5HO5301FRXrWdjVmetNXu1Sd0aAHYWnZrY35LtrclbL30s1KR5Da7b38LINs+3mY1z3WnnrTdrEez/7fffNM8dFM12A64a2oYnrvjijDfu+OOQRy755JRXbnlqhV7ukOCad+7556CHLvropJdu+umop6766qy37vrrsMcu++y0dzY357WXDnfuvPfu++/AN1548MQXb/zNuB+vfOK3Ib7889BHL/301Fd/WvLWZ9+t80a5zL324Icv/vimfU/++Snvjv76G0tkPvvwxy8//MPPb3/T9+d/skXv6+///wDkXf8CSMACGtBo9TugAhfIQAMmsIEQjKAEJ0jBClrwghjMoAY3yMEOevCDIOTZAENIQpKNsIQoTKEKV8jCFrrwhTDslvpiSMMa2vCGODTPDHPIwx768IdADKIQ/4dIxG+d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uqqUtto4I8RZAwGsOJVUdEWsBSGsueSn7gSqu9qsznpt/xWt7jitfSZkzGeU2IqUUlYt1DIsxvKs2hQVuSauBUGu7ViuB4Fy6pqu7NowAQEAIfkEBQQABgAsAQAAAE8CSwIACP8ADQgcSLCgwYMIEypcaBAJw4cQI0qcSLGixYsYM2rcyLGjx48gQxoAIrKkyZMfAQwkmTABypcwY8qcSbOmTZsOERRkebOnz4gOfwodSrSo0aNIkypdmlAn06dQo0qdSrWq1atYs2rdyjWkgoFfu4pNKGGs2bNo06pdazOsga9u2cqdS3eqgiQFlQiMW/dpWYVS+goeTBhr4MKIEytezJiiXo94G0ueTLmy5cuYM2venPHxxsicLx4eGHh06NOotZpOzbq169cQ/xr0DLu27du4c+vezRsz397Agws/CXq4QpcGZRtfzry58+fQo6+FK7B4QevSs2vfzr279+8YQWP/B0++vPnz6NNvHq++vXvc7N/Ln6/4923lmvFn1k+/v///AAYo4IAEShVfZQdSlmCBSNnnGn+XQViRhF3JRiGDGGao4YYcdughdwvmRhtbIX740ogmpuheUAawqOKLMMYo44xL6ceiQy4ihSKNPPbo448A5gjkkERK5WCRSCpWIkJlUShkklCaiJdTN9F2ZJRYvibBkll2+SFoKnkpZopPlrTamGgidqFFf4WZ5pvzRbblQVzCaad5bRK1I1h39unnn3+uCeigPNZJ6KGIJqrooow26ihRVz6anKSUVmrppZiit2emnGIm6HufRmVop6QyhJd1p5aqapI7brrqqqO+/yorh5HOamtUrt7aGn+h6uqrWHMaYKGcIP5q7LHIJqvsssw26+yz0EYr7bTUVmvttQSVie223Hbr7bfghivuuOSWa+656Kar7rrsSqVtu/DGK69G78477pkJ1Wrvvvz26++/ADM4QWq9BmzwwQgn7GzBCku7Gr4N/6hvxBQzFUHFGGf8X6wad+zxxyCHLPLICuknhYUkR5tqdSm37PLLkw0Ms1UMz2zzzTjnnJtpHOu8KG0oT+rz0EQXbbRmPR+NKNBKH7ty01BH7d6eyiUttZ1hKRFpzVcTanXXRH4NtrFMDyT22IBOjPajqK4t5tluyypF2XGT+pcUatet6NN69//td29w/y344IQ/lGvhiCeueM6HLw5o445HLvnklFfu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L2+GrAsG/028uPHjyJMrX+v7YPPl0KNLn069unWKzZ9f3869u/fv4C1r/w9Pvrzs8ebTq1/Pvr379/Djy59Pv779+/jz69/Pv7///wAGKOCABBZo4IEILiWUUAk26OCDEEY4nEBC5eRahBhmqOGGADLI4YcghiiidYBNqNeIKMoXhAEBpOjiegqg9+KM861IIY04uudhjjxex9qOPQaZnG8xHmSjkEiSeGOSTDbp5JNQRrmhjFJWaeWVWGap5ZZcdunll2CGKeaYZJZp5plopqnmmmy26eabcMYp55x01mnnnXjmqeeefPbp55+ABirooIQWauihiCaqaGql8bXoo5BGWlSjklZqwIWWZkoQpZhq6umnoBLUaaiHjkrqqVQBieqqrCaqaqt8Uv8K66y01mrrrbhiaVauvPbq669ImgisnZ8Na+yxYYqF7LLMNuvss9BGK+201KZlohLBCVvtmHllt+234IYrbmrajmvuueimu1ZfVKr75K4CZXtQue7Wa++9+P7Ubr5MwmsAvfxa2W3ABBd8nL/7GkyjXLLGq3CUCT8s8cSiIUyxlVI0fDGS2kW88ccgqyUBZ/6G3CRrSmhsMo4Dr+zyy4Z5DPPMNNds880456zzzjz37PPPQAct9NBEF2300UgnrfTSTKOpctNQRy311FRXbfXVWIdnatZc47x11/QBDLZ9oI1t9tlop6322my37fbbcMct99x012333XjnrffefPf/7fffgIv42NeBFw4r4YYLinjiyT3N+ONaOw65notPfqLlmIMqeeac01ayQJ8bEHroqiWxeeeop16nsKzPqzpsox8U++tpjSc27bjv2fLtCrVuEO+5Bz+itwjJ/G9EwAuvvIveGi9S8stzdbpBsxdUvWnYsv0c9L27/nv04AtJZE2+hy/mtagHJ5f65refZOXuL3d9/JqtP5D99Oev//789+///wAMoAAHSMACGvCACEygAhfIQAhNL0mNemADx7KXkRlEghOUXgY3yMFcwU9affmg+BCCwQ6a8IQoBBn3UsjCFhJKhFmroKjgcrPh7MWGLvxS+ei2kwn10DrKCmJY/3JIRPk8pSBHRMkRlziQJBbxibhpkUkQMBAqCsSKBsAiFLfIxS568YtgDKMYx0jGMprxjGhMoxrXyMY2GpCJbozjQqSok9coCyFOxAgd98MSLSrtSFjpiWQE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rHq+/fv48+vfz7+///8ABiigRfUNaOCBCCao4IIMNujggxAimFyEFJ4nVG0VZqjhWPBt6OFvExogVE6zffhSiSamiFByHepXX4EqeodhjBk9ZuNAKNKoY4s69tgaYCESlKOPRP4XhAEBHIWXbEU2yZkCPDop5YFHCjQjTUNOqaVrV9Jk1pZgohZbl2FqBmOZIBEH5UFVopnZjW76NKZRUcZp55146vhlnnz26eefIGUJ6KCEFmooTjgequiijDa6kKCORirppJNCSumlmGaq6aaconamAUF2KupGlo5q6lqfnqrqqqy66Vmqrcb/KuustNZq66245qrrrrz26uuvwAYr7LDEFmvsscgmq+yyo4aGLKzMRivttNRWa+212NJFZrbcduutQUA89W2y0I5r7rnopqvuur7uye678MYr76ihzssrafaaWG6+/AIlVr8ABzxenQIDtW/BCCes8MIMXxqiEsfV2/CoeYU38cUYZ6yxeRJv7PHHIIe8Wl8Ei1youxEf1LHJLLfs8stqlQwzoCjPLGrFNuess3vuyrxznHJ9uvLPRBdt9NEV9Yx0pFIcvDSe4vn8dK5OT72fBJ65i9JeQVsNYWxKVO11mTiPbfbZaKet9tpst+3223DHLffcdNdt99145613o2Lv/+3334AHLvjghBdu+OGIJ6744ow37vjjkEcu+eSUV2755ZhnrrnjpW7u+eeghy56p32PbvrpqKeu+uqst+7667DHLvvs/3VO++2456777inazvvv5r7lO/DEF2/88cgnr/zyzMsLZ/PQRz/rekNLbz2wZVefUJDcX+89oBYj5HP3Bmn//floWix1SOajn1pGWgsUvwHzz+9+Vte1rxD5yN3vP59qqgn/WFe6SenPfceRSwL/x0BADa+B2KkfBFmjwIFUcIIYzKAGN8jBDnrwgyAMoQhHSMISmvCEizogClfIwhYO6kUuXAzXSlTAhD0QTzWMoQ536K0b8vAsHcrhD/+HSMQitk2FRkyiEpXlQ8pxTUhwoVty9jLFJWJqgKzbyYS0+J1/eTEsVgxjgMRFEDKeRFxoHIgZxchG4STJJAgYSBwFMkcD1LGNeMyjHvfIxz7yMDZN9CNUhCjIQhZGeIZMJHsCOZM7DiRJa2SZuP6lyAoxsiSX/EkkK8lJ5nxRIG88UCjl86867mSTlPkXKq/lLPJk8j6v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6mpM/tsXtanMRpPJ0LLMyfyvzUwby0vM/gtNyIy/l5M/SpNMDVLNTsMl1jy5gAAAIfkEBQQABgAsEQAAAD8CUAIACP8ADQgcSLCgwYMIEyo0gGShw4cQI0qcSLGixYsYM2rcyLGjx48gLwIJSbKkyYkABo5MmOCky5cwY8qcSbOmzYQNERRcebNnz4Y+gwodSrSo0aNIkyolqHOp06dQo0qdSrWq1atYs2rdClLBQK9csUoIS7as2bNo09IEa8ArW7Vw48rdqiBJQSUC387tOVahlL2AAws2+3ew4cOIEyuGiHex48eQI0ueTLmy5cs1G2M+WXjg386bQ4smPLq06dOoHfY1qDm169ewY8ueTbu27du4c9e2i7ulwdW6gwsfTry48eNh3QrkfZA58ufQo0ufTr26RObOrWvfzr279++Qs4P/H0/etfjy6NMP1qu+vfv38OPLn0+/vv37+Omzz8+/v///AAYo4IAEFmjggQgmGB1QDCno4IMQRihhQcAJxGBDDE6o4YYcdghghh6GKOKIJEI3VoUFgVjiiunZ1ZRJ+7Eo42gSnDfjjfExlxKOPKanIkco9ijkZn3tOOSRx/FWY3NINkldkU5GKeWUVFZp5ZVYZqnlllx26eWXYIYp5phklmnmmWimqeaabLbp5ptwxinnnHTWaeedeOap55589unnn4AGKuighBZq6KGIJqrooow26uijkEYq6aSUVmrppZhmqummnHbq6aeghirqqFaCRuqpqKaq6qqsturqq7DG/yrrrKqaaiqt9sWI66689uqrcDb+KuywxBZr7LEQoijFakEiy6Vd2Dkr7bTUVltWs9Zmq+223MoEWrDd9tgaswdhG+656KarrkHgrnvjuO5mCW289NYbGnDt2hsiW7oKZK6+AAcs8Kj4DtykEmz9a/CI2eW78MMQGyUFvAs5HLGCfUnRrwEKX6zgvB6HLPJWFo9s8skop6zyyiy37PLLMMcs88wdbUzzzTjnrPPOPPfs888Ctgb00EQXbfTRSCet9NJMN+3001BHLfXUVFdt9dVYZ6311lx37fXXYIct9thkl2322WinrfbabLft9ttwxy333HRXZnPdeOet996C3f/Nd2RC/y14cFMMvqffhieuuL4lDxk4veJ1vPjkYIIseUJBZk755v7ZHC1CjftWkOgEkc756Q5G2zhJl6Oe1K0Taf5bua4PxR5orS9kukC7G9B77cADqGRNsktduJq5oy46W8sH77yDjz9PXPHSI8b8VwP9Xv323Hfv/ffghy/+xUnsjvD46KevftHRr+/++1S3D//8nTe5H+L0U9XYBIFPUKz8CMHfigSYv7cBsICeOiACswK7tizwgRCMoLSSJ8EKWrBMChxYAz/SmLd0kGXAaUwIL8gj6onNKxVCoXD4hb28kPCF2zFSAGIyQ4HU0AA3vCEMd2iYF71IJqIzUhD/eUjEIhrxiEhMohKXyMQmToYnBIGiE6d4mpSMRIcGuGL2DoLFY3VxLj4cSBhtOJAclpGKaExjpb5oJIFIETza4917eDISK6rEAG2M0urUs0fpBIFJ7KqSkVLyx8P80Cl5jCIeDVDIkHyxKI+cSSIXckiDTPJojZTPH+2SSR59cYZvVEBKIqmQGw7yjBDpHSkPcsk7xvGOIHmjGBdiRyESRAEzbCVGdPkRW1JklRJ5pRsjokWDfLF3lWRJSF7Ey2YuUpUH6d0rzRgY3iSgfEkQQBAU8MdOQqSPDmnkeZjjTUZG5HMG6GMfGbROORpACCUBZ0XK2a56VmwgJSvndW4p/5BuNkgh5dRnTdgJyBRFRKCVAUACgJAAASwAYQHg5kNMeRJeagSYD0nJJC1Ky4HkcSQ6YWgSJPDBjGqFlxiVCE9GmRBZIuSPEbWLAiR6SCNJsZU3NekwLZmQGyaTIKtMaWmuec0FLOGhEkWoOUGiVJnI8ybXlIAUkFqVphLlqQpRgBIWMAWjCgCeUcHqbSjKuwQoFAASWAIVljCBiCIkkhylpkcPstKeotKdEMkjWXHIyr6uJI4/rUgCSGqAo7bllA6po+7u6hEZFoSjAoGsRX7HUdPlUAFL4MJRBaAAxU4SpI81QDJNJ1mempavipwkaQtyQ9G9KJIuNYw1y6cEBv9QgQJLwCU+GXuQTe42CLsTnXOumRDmRBS4BGlkQ8hZ3IH8SJy8tSFYQITced61kTdErlS9+tLgTkSsD8mndSlSXYA2dzm33KYSKHDbJQxACMSNSAJgOpBGms6aB2GPeBWyOrswqLrMRa+AHcNQhQZBCkyoAhMYcFw8tuTBDmReDc3qG+Q2b5EE2dF8+clXhTI0v25d5BcbmcdJmrIlbrnhh3GogJAGsC2KlWWIfTc6B2axvumUgBAWsNPfkfItE6ZxRRIZxzbqxawTmaFcU5ve0ikUry3cIo5ZWpAJZNYADBDAAJ7MWoPsB8lAvR6UaQwWOualkBBeKGrz8mEwL1X/xMphpFcWmgCdKLmzdSYdms+6k8UQNQkMqAJuJeq78rUEL2BN75/fLBB4CoHQ6XzwJr/qFUqDddEGEMBXHg3fQmvahalMAqSXc01NKyDRhX4nLolaTiF8tXSidjWqJTpDf8Lz0zUELrQW4OjdoRohpPv1RjZ2v0bjWJ9gmWHDPg1WbppOor+Gr2/7eWqw3JqR841vXsD66SWwF7cD0HSwttlIVH/VN7GmtI3hiWZPf5q4vOHmqeub7XjLut6gLvQ15e3od2Jb1/zG9LYfDDLBPJLOAZBAghccYoWGWAn+wzFneSeBiEb00VtN9IQDkIDjgiXjPAaLQgcbUYcKZKs2/y45rw2A8oIw08G1PiMCOi4QHrOYoYNttsOrbQCb7zjDCUgALocuEE27VbcXX0CMiG7zMH/ayzaWrgJW3hahKtMgNu+icsDCWSx+Ouul+yLEHx3iXPoGnhknupfL7cAT31kB/Mu03NW6YC2vWJFHb80Cuo5XBWhavRN4dNfBYheHKtnN2zT50DkuZM4afc5V9zsOgz4QiBd98ZVncdD5HFGUd5zCQ1QMUWvb3lXr2qgRn4L/jMp6aUu15mwdCOuVIACOY1OrRhUIbhmw2XOLujG5N8CgOYswvDBB9z3v9w3JqVWWs9zZtGUAE/bOu9+3ft9bXQJBKJB8c4r65MEftP/lYT+B4xlgCO/UNPbPLwABJEDvwp8C9wurF9x7WyCGnciP8G9z7cc+32BxVIbFfbrVc/hXWLjlb0LWFmBVfgageo2mfs5hVNzHe7ymW91kfwZABbqnfY9WdXkBcfInfANIBQwwBO+VTgGUfeyFgNM3BLz2ednHYzxGAVPAe7zXflElBSeog5wEexbYcxAFb0Z1gnUxX1rVfI/2Ryx4WyR4gfCVBFYWg+XTSNmHbdiEY4thYAimYFk2dIMlEOZXOGrlbTAYU4Uzf9onhmu1ABbXcSR1PGu4Vm2oaQBQF3L4gFQwBVNgeEZFBcd3fBu4BAwATzNWRtdUOFSAFxE1clP/kGBHdWdJMAWEKAQDkHBKcDyBaADHp33b1HmUWFgCsVZZZmXmVxDe1nIHlomblU5SoH2COBAciGVfAYpruBFtNBYcOH8F0XTbp1YcuARLMHED4X8EEXge1VADcYo1R4wGEHGwSBBKh3R4mBAXeENwZ4y3uHBZtmVqZiQ6wYqzWBAUcIbX9IqzqFaKOBAD4IZatQV1J0qik1a4RYc9Z3G+o3CAyACfiIcQ6I6ZOAXjyImFVYgKMFhl6IafxztWxoHy6GF9ZRh/FmgJSHwKIH/txT/lx15eGG5CIAFTUAFN0ACdWH5U0F5UqFXSRwElKX/yxwQDMABRNQVV0AQVwATs/2VlKmkAN6mGG7lgQzBv7KIAUnCSvOZ7IGkBTWCE6sVVgPheF/mT/rORPMkE87ZVGNmTVOA/mMVeIil95Vd+VWCCQ0BpIniCqiYF89cEajiKQCl3tCgQVoZ8G6gRFVBlazh/6HcQs3g+AlEFAxFxdXl+kwdoVRmW5ndUssZVPYl/LTh9rkZ8DtiJNUgFCrYAZUl838YEU4mR7HWC4aYQJhmMPFZ+FUCW8iYFFVAFPRl7fLiaDUAE7weSN7kAMqlrLPeZOFl6rvZHUlAFVdAARcBNAbBN3tZVMMhW8sdW2peV06eZVBCbppdOF1mbUahtgYFFo0RhCceNFqdVXHCS2v83dZloAF2QYERAAJ3HBU3ghTuWjSdJBSgIipDIAAxIiYAonwC5Be3JBBVwVFsVADymYEygfZLJBPsYdUIWdA3Ze5i4BVZgBQzHYkrABUzABA4VkJpln5mWe+0ZoJh1kgr2nw+1dxNABezZBISIF+slEHV3iXP5ouXZBSMpe41RBWtYFwNxfFP3cwOZab4UWuE0igXRfC5aEEIgmM4nhObHYPm4cFWAFwoQhxwIgw4Fi9xHg0IAiDi6d37Hh5xon/3HpYTYfvCJZWjXkJb5ohq1RUGQVhu6ADanACwJmAx2kI9YkyRKnnnKcHjYnvMpjwnQp7x3khQweJlYBV4wkoj/uoccyGt8yAU951CaRnddGlF0xwAzFVGDlYkJRnZIZkeOMXoUmVuY+m3u5X6/55UmSARfRZtLSQRDh5VjyQADoFUgqWAxOWeipppMEJv7NgVKyQCyinFaBZvFmmk7eZOSN2BIoFUbOYzuJ4JWEJxEsHcCAHHtNQBB+YCGpWnttwD+CZlftQBUcJpG+IFa5ZUv6Bst+pSSOQWxGW5SdZqxKXd20RgNQAAX+Ju0qCsxIkvxlhBewX33WkNKeRcG4K9o6TvqZVsiKXmFca/IpVWPmpwsiZbEuF639YJ/aIIxmWiEGIgxaa64hZm1R53AmK5vhh3lZ6t+FwCdxwBNoJSr/yYFDWCTVvlotNUAVeAAw9mrX8lZQSCzUpWxMCiQk/qqNBmcTcBrAbBVTrhyx5lpr9ZzSyCS50dza3qUtld+TSCrqvpPgLFkWURhB+adpxapm3WJHWexlpmencefDTAEBBB5F5lgBKCe77hgMek7HJe2XoiGNWu30pUAE4CeWZYXAroECtYEXoGP2bOeZXqJICmpEtoAjtege6d0/OMVNBhRQ8CBl/qx5Rhubphp5Weh3Qi4IXqhMZlwfMgEdzsAk2gAVUAEBfB0M6R9S7kcW1CXdxtnA9EAFCFLmaRwBKlsW+AEB6EZextmatUEbaGjPCm3chSHjXaSFTAEWdZ0Rv8FmBSwY0oQnwOwuEUXvpw4AIVlqIHaFgLQkHX3aVpUQyTlXiGncgk2kjElBU1gBfyrdvvbAKIWAIl7mZ/IcvB4ugJgg1TQjpqmBPBYkw0AUSGqmJK3VYM3Q1vanveoAKN7kiCacJnKWQoVWIgxkYKWW0HAY6eJrfB0ewJpggSAqyEJk+xbaET5mTV8liiofot2rrIqasL6tOwLcCE5kkRQeQ9ln9bZstUHkrhFAEGpjptpmxTImQjDhEpImFjmn0/bfjv2kl7abBzbg5cmhS/Jre9XfvP6aEVJw3wFXJZ3rwMwmba5gM9oEFaVERZQLsdDxTiWBIz5tAgTyEfMYVv/xY0wiH5gZVuXCYPnimXXupcCAckvaFuFtXcb1hYiiFvtl1U7hnFLuppAe2oJoJojSQD4hmVU4ACQS8eoGm5fdaJrlYJS8LIoOATfJntlSYilx8XAh7WcWJPnV23qCJoY95lBiZuHIVccx1DdObh+l59yyqkU5qlUsLdz+6t/+3mTiJ4EEL9TwLpa1hIONxYUrF50+82g+L9NQL3FOIsfymKRlYzh/MDj7MDehqAQPIodFFFwh3Lzt79deqWASAHt+J0GXM51l3UW68+Wm4lLqWVJELxVEL1zlnAGwAVFcLcPtcCxq7AmYcl/pAAc6AAGsGU4RFLwuNKhJQR5yqKS/2q8N5ZJAQicI6pWBJFgAuG9wPi4wtfTY0mY3Gh4otTS5bxZvmgQlEqBRD2S2zSo/clgFIZ/FCx0mOqFT31lnSu7FhqThUqCj+pQkOiORaeR90e6HnynDW3Ot8qH8unWvrFXVlcWpOqEuMSY5EpqRMzMTHuT3FqYO0zDmKXLoek7IgWxVknEsIyZUSwF1ZqzBLGHG3iZwoZtSJDKCkbFNSiAzGyfCkZo2Zp72jeQN4nGJquYSwW3LCtSuYrDbSyvRBBuRBmmS5w9UmgA94p+NwzTAsZVNh1NNhZbChGLBsG+PPHbA2YXjlsFD1V+QCvI0JUEAQBo53quuymXBGFYkP9clS1IpOJZhMGIylbogCgYw1oIhLFYOCH5s7FMlDkLrLaXTrZFkkdIyMsJmt62lQgTw7osfdKHess5AGCMmcTFgoM5EF9ZlhwngroqyScLX/UNXVs4X13opwJApiHnOwb2iFQgt31rq94oUnnKzVwF15FlVl5BwXPbBA7wzQwlwe1ZowSRhmXKYtoZdAqXuycIiKq7gQvGADdplRRKh+I5kP7J1OV7WzsWYuQMiNRHbRIs0QEgBVMAj/Zpu4WT0Xd7YxxToTYuBSL95ehMWDYeRVgevHT1EGvIBIdmANSbw/5S5Q1A5wShaQm2VeV557C0Zo7Ljd62BHlYdIU1lvv/yNOFVaBZ6qJcrVtXlFak2H521FqSDomi+IADTLT+awFyS2EIEAGOK9XymIkn6b0DUKcWHOZa7r04uWOZOgA3eakz1ZAHKIv/i2XfWeUwWai3hdQFNhkqPGgCuoFUcJSqum/9DbNKUK84zDvbpJbRKas+HJqBe02MHaxKOeU7KJL32os918xQbCHENYs0W47X5Ma/GqvQB7ErDL7jCsNcxZIXWEjrKn9lCU+brcYsycYiOK9t8Rcg61wJEAX+c68C0Be0OwQ6xBxF0NQCUQalsFsZQkEJgcjYthxGJZIPBZJWYABfXnBYa65emJzPW9rtZYSB03z9fbJEK2ccC25P/4devTrfT5tbjXHfwwlfOLvKRAUU0hext3eWRECzd2ne/nLD0rdtzk7Zk1pU58qWAGp/DQ59zk6s9kns8JbCocVx6ay28Yug3+q65Yug3EyUWu7OiSjOBiwFKg5zPU7qNH7nC6BRiWiT6RlmBpi/IidGFOa4cl6VLY0XNom7C+Y7g7VwWfppCpDqCSanCO3P7qhkbDvlgy/Slkvmh2+78LjNX64TAPAX7MmhEix8A/DlVGZXE28AbJ4QKj07AmHTpW+8dO7SPInnZ0cFH6pVhbOvBPBk7vpOfyj5Tn2B+Geof0u8DzXPD+1WHZfiWGZyolVGf5q744zWxUzqVC2hDP9wwi0h6lktjyNFd8ZLwYN3co/YBD79heE867+qZSSs+5rrpSV3wB/MqRmu/rQ+cr4RpAABwMBAggUNHkSYUOFChg0RJiEI0UCCJAmUUKBCYYmBAAqUTJiicYAABUE8LqBSgQmDIQKUSJiicsAQA0EoKpBShQqDARZByhSQIEiAjhdTMrk5SeUCIQaQUEyQcyfNpkUXGGDAREHBIBEHUlwQMmUTnjdjGlDJsmZUjEAFGBAgBKVKCkLiotTItKBHKlPjfk0CkwqTAT0/TmlABK4EKQZWDihIcYqBxAMZD2TAdWvBtwQ7UiljwNYmgkgGBhjYuIlDAzANmm5toAoTA5D/Cypx7FhBUykVyNLs2NUABQNXw2Jk+TZAVwELNirxaGBKX55xUbt0PmHJbpB5W05MImCJTpa7nXptnZPsSAECijIYqyColAZNEicIkMB0EviJFVTsKomwfKvvvvwgSgKnrGYrr6KcqvAtuaCMUqk96wIYcLUhFDjQIuqY8K02qCRirUQTT0QxxYGASAAAoaRgooolGCCpoyW4YIKKIRYwSQDt+qqCCAI6kmKLxwZwkcUkpoiRgCE9MrKJAa7iyCMm08pPiSns23HFBBKQQLaVmjKAQwWWGIwKBTjkyCAgDHBRSyq6aKKKAQhgUcuBIBwCMv1gZLC5gZrbqAoZF8BQ/4m+6kJ0swBA4mKJBdojCMocCwsAJhwJEGCAJIyk4s6J3owNx8wmaiy3zjYjqIHiOiKICoK4INGgLUpk1VWDlkxILtkMaOKtqFbDiqSBFJiAikOlk7VY23xEc4kJhFhzusFoLMg5KpaY4i05DZDUWAMUVXYlkgQqSKBPm+TUTCGYpLMBkoKQogkrVsqPRQQkGM++BPMTSMsYm6hAyI5YHGjJGBdmoCMwY4TQXAXAXKILcxtFDU17seoov9bQHFjKAQBOAGEVT0Y5ZRNHxEijmv6DCaPBshOLwQ1fmo4wMm+SArkhvsRpNuLGpXmpoAKbYrZJv3oqiQnEBBfcsAzIaP87MhPSDycgV/oZiaANZWJp8BalbaPilsDI0OTkCincvXBrm1WKulvCTz3VEiIqqnmKzOlKwVuoAoKoLGgKLtzxKooEAB9IVtoQIjzM3BBKO2yDZFWLIIwcWwC3j5rV66OBVhoIbuI02s0jkJS+fDirVZ/M8oHSdv2vWi2TqoGwcTNg9aN2s6iK9UYcCKXZSqLIKQViMnR4myAyzSib8UsgCgqaX3vuo5zrHNy0q0D9+eKVjZgp4lVGP/2T31z8tJK/5HdbKoOTYOEqJgN5tiCfLPLiiVxUWBX61JEkAOpxzTLcYxYQJyPRaIEGQECLEoAm2SAwgdtqGJsE0j6CAHD/ChprQGEiWECGTel/8VPWcBByqKLIigIKaNSXAjAFw7mNIBKQEwU6BSaB0chTtwoVQRBgACBIoTHmIiIHqUaQHB0ENYVzhTtKMYUtkCYKrOECVhCiq4K8aSMxSsgQTgWmIfSFIGYjiF1KNxmE9CVcW7HSAQtStka1hlxRm2MVinOuDkLQACTUH9qkEzvhyWtiTGIQyQwQAZAxIAEKcNEQA2gfTFHvKygU4MggWT+L2alRAMDhYGS0LSrwzjF6zGAEvbg1H7rIlXCCpfpkOcuGSEQoc5vCBHDTIQGZjQq5nFFGuEYRxujSPOBZHEjMVxEB9a5xg5wCU5AXGCloxzy2/0yQKWMFzOgIxyDefArcrIkaZtLQmE35UjafRpxmSUpaucSNSXoHnaYIJ3nwLE1Bnoa89HTPJs4c167CtM+/xWogT3NIKQrSCoSwUXMFveFBSHWs3jkUoAl7G0gUQk7YGVRa8YwI7Fw4kMlAZyKVOow+NwLPkvwRPQfNJRufpsvslKkiH5GUEvQTUniezyMVAJ+k8nag85QppsBDEEj2aZP2WSkkDv2odHR5y4QdR1ZLaE/ybodRWnbVqx3ET5l0SZCudEQuOF2CErQVowH+Rwpq7VgSeTiBc1EvUdoBF02VA0mKvJVHm3mTizrCqmhNQa1lQixD5EnTMrEIVoal6P9XijI7bqnVWGMl4Fv3+cQ29W4rnJ0IDz3jUl8VRAJNQZdBWFWmq63QIJJ7TmgUQgoyGCCLklMRZ5F1m8gOJLV6cghwlyhN0B5rt8+cwJq8eZsPEuSwx0JNBE9zEF3iVXTy6dwCHtkVtVJLle0TQlp5JEGBPIphNZKgbydC04640iKG/SvAqqSljTxHmsiCzsHAu6hX8dVFC0ntVwWcvvYlyCbiO+xmqMW2vpjveZtZ7uLgGGEEBRQ6XaFwS5cbGd5Sa8MOkbBJKLyQ5JUudf+Um0NWq+IPtxQhcoOINp17quna1sYK4ERDGLqFBBmkxAMuHYcTEp2B5I2r5+kxkQ3/0JQK12ozuGHy4pTIkBWvpccFnvBOJfKfrRT4ZWirGlIfQtYSe6TL/3RpwqITz1vakivOoUDY5qVVINcZZVNOrUCk6xli0ldsHNLWdKaEmsV1bDMCMRmsGmKmxQVWworm4JcCfBA2NbpNkz7poxUwxIJwlrPomnKKq5xY9U4ZRZzuo6UHYhLQIrQzZ+SMAW5lAIVulSD2WOgU4GiiN3mzuAgxdazT5UfVArsgQ1R0jaXsxFF/pdMGQdeuKe1bKStaIP+tksMkWBRE7tG/BFEiHCVdpcS+slLJ5rAl8XOmazWnvS0itp3ljTISffiWh3FZe+QCZtS1tiYMsXW9x7zq/3mnyNayhI1XOZiZBbRELrTZidkSMAWGGqDirtCxQgKOkA9rHOAFPwiJDo6QiSI8Itwrl3zojLKOd1y10OF3mQ78UpDXvERvQs1EUZOfIOBwC2ZkQLREKVQId7ZNJT86tI3u8qQPu8ZkNcivT4ToEu0cIZ5mCGdRnZA8xxIhqQWtFNBYEAoSh0oAKNJAbsHQdigE46kZ7bWVjiKkoxo1TF+R0e/eJqurt7z/BnDUL+31g2C6j8P++7MNHxkUtptDy97o1KGu3rzb9IOi7G++4G1zzqtsRDgpCAWslRcPd3XknUe9ncFiUYNspLVSIIUB7vGPe9ziHgipuAFIkSq8p//e90BO+EF61pepTLPzyyObg1f+e99zMOdGpzbPV7ytD04Kjok/6ZuGqP24z53k3nf6SQt/eIPY3U3fl+iJOh5sDi6eIZbe+uGT2Su4fHMKpLjFQG7fdoKQIvYFuZ3UGqJJMzz2Uwj3C7bKgyXUMLwNEiKEiD/3EzI/mrQIjLyBGMDy44j4QZNBezycG62DQDVUCzbOcj5wc67Lm5FOebcvCT/mg0Gsyaat2CeTqjORi0EUwcEcVAjcCihvEg4A+BSHaIOB2IQf40H0CT71WcL0acJjwY0EqTDUMzPeoaokxMKEcDSPATw2oTzySwipk0BYAsEs5Lqvw8Le46yJSgL/UsC42zOI3NM98YMlPUPD9MG6L5QlVBvD8Xs2kLs7R/mKwCI8MHQIPlQIQmQ1LyQvIjLDJNw4rnjESXzE29kwW5OC2kII/hsIHqPET3RCjqM51Ou40wPFrgI7R3S/Ddo8viO/E6y7EKTDF3RE+HvFPmIfY2ON+MtFpGuI7TM6AixEDHzAhrBDOyRG7nNAPdwLCbwMgrCFguA/TzSRScvDWQQ/vUPBL7zGL6xACISlESxEqUPEYTvBrvtDr8vAcFtDQ9S6YrxAgkC6SPMML4QkCDK1cqTDPjzFeTPFfgTIAfvHg9Cbg6g4MkiVgFRIlRnIhXTIr/LFh5RIO+PHhJAC/zkcCFJgqIScyI4MPBWJSAGTOo8kyZI0SbozgE3QRFtpyJN0yZeESXD0Q3mMyZoMQ10EMSPaglmzDPGrSJuMwU+7OoawwPRDGbl7uvgDyqVkSoVMwKaEyqiUyqmkyqq0yqvEyqy0ypbUyq70SgHrRRAbyq8MSHQcRkMky4KTuqdEuuKaqJ9EmZFEy7Sky7q0yzS8y7zUy73ky770y78EzMAUzMEkzJprwMIUSaWDS1nsRsR0zMeEzMiUzMmkzMq0zMvEzMzUzCwMyc2cxG8UQc8UzdEkzdI0zdNEzdRUzdVkzdZ0zdeEzdiUzdmkzdq0zdvEzdzUzd3kzd70zd8Ezv/gFM7hJM7iNM7jRM7kVM7lZM7mdM7nhM7olM7ppM7qtM7rxM7s1M7t5M7u9M7vBM/wFM/xJM/yNM/zRM/0VM/1ZM/2dM/3hM/4lM/5pM/6tM/7xM/81M/95M/+9M//BNAAFdABJdACNdADRdAEVdAFZdAGddAHhdAIldAJpdAKtdALxdAM1dAN5dAO9dAPBdEQFdERJdESNdETRdEUVdEVZdEWddEXhdEYldEZpdEatdEbxdEc1dEd5dEe9dEfBdIgFdIhJdIiNdIjRdIkVdIlZdImddInhdIoldIppdIqtdIrxdIs1dIt5dIu9dIvBdMwFdMxJdMyNdMzRdM0VdP/NWXTNnXTN4XTOJXTOaXTOrXTO8XTPNXTPeXTPvXTPwXUQBXUQSXUQjXUQ0XURFXURWXURnXUR4XUSJXUSaXUSrXUS8XUTNXUTeXUTvXUTwXVUBXVUSXVUjXVU0XVVFXVVWXVVnXVV4XVWJXVWaXVWrXVW8XVXNXVXeXVXvXVXwXWYBXWYSXWYjXWY0XWZFXWZWXWZnXWZ4XWaJXWabVUH4yog7BWatXWbb3UbOXWbwXXcBXXcSXXcjXX9uRIgkjXc2XXdnXXd4XXeJXXeaXX7VzXesXXfAVTrtRXIb3XfgXYgMXKfxXYgjXYg0XYhFXYhWXYhnXYh31YbwWyCIBY/6ZUyopVyCtqiCfE2I71WATl2I89RY1liJAVWYC82JMFSIpV2ZatTZYdCJN1WSyVhJm1We6sWRJNOJm92Z712Z8F2qAV2qEl2qI12qNVWYJF2qXVS6Vl2kJ9yqeNQX6V2qq12qs1T57FWnnT2q2dJZL12rD1SrDNp5gV27NdSo2FWc6jWrR1W5VR24PY2YJz2rdNn7q127z9qrUFObw9Wr4tqsDtWvXZQb013IYg2bgF3MNl3Idc3MaF3IAk28il3IB83MrF3My9ypTVXBS53LKN0Lbt3FHE0sHtT4lVUtMd3RJ5wrld3deFXe/0HIOYXcGUMeasXecKKN6SsdwNsmje3V3dBd7bjd3iNV4QHV7aTU3iZc3k5V3ldV7hhd7p5a3jfc/ERYjJHVLstd4RhdnL/dwf/d7uNdHFHV8oPd9FIoj0Zd/1dd+BaF/4zc70dVL6JV8UFUck5VxiDM3+1UD/PTaZzMuAAAAh+QQFBAAGACwaAAAANgJQAgAI/wANCBxIsKDBgwgTCgSisKHDhxAjSpxIsaLFixgzatzIsaPHjyAbIglJsqRJhAwFAlAY4aTLlzBjypxJs6bNhEkMJCg48qZPmCl/Ch1KtKjRo0iTKi26cqnTp1CjSp1KtarVq1izat3qUsLAnVyjSglLtqzZs2jTyvQq0CtbtXDjyj0rQUnBnAbezo2poKHevYADC6Y7uLDhw4gTO8SruLHjx5AjS55MubLlk4wvc/zrVrPnz3L/gh5NurTpgX0PZj7NurXr17Bjy55Nu7bt25/tuk5dkDfu38CDCx9OvDjVzgZ0H1RuvLnz59CjS59uUDlz6tiza9/Ovbvg697Di/8fDX68+fNzRaNfz769+/fw48ufT7++fenq7+vf/3I1//8AyuRbgAQWyFESbPln4IIMNugggUEF9eCEFFZo4YQDGhBUTgpe6OGHIIZon4QilmjiiSga11eGBHWY4oveBWFAADDWGJ4C5dmoY3syLrTjj+aRCKR++dGXmpBDJhmcbjge1KOSUEJ3ZJRUVmnllVhmqeWWXHbp5ZdghinmmGSWaeaZaKap5ppstunmm3DGKeecdNZp55145qnnnnz26eefgAYq6KCEFmrooYgmquiijDbq6KOQRirppJRWaumlmGaq6aacdurpp6CGGmqOopZq6qlRFonqqqy26uqrOpL/CuustNZq66245hpaQarqyl6vvgYr7LDE2iZrscgmq+yyzDZLYIZK8Mais1/aZR212Gar7bZkTcvtt+CGKy5Meh07ro5joaauQd6e6+678MZLkLnywpiuQO3WC6W1+vbr72X3Jvfvjm/1mu/ACCessKgB07swilK8dfDDJV7nMMUYZyyUBJkFjNDFGi+YmhIGhywivyanrHJWIK/s8sswxyzzzDTXbPPNOOc8pIs69+zzz0AHLfTQRBdt9NFIJ6300kw37fTTUEct9dRUV2311VhnrfXWXHft9ddghy322GSXbfbZaKet9tpst+3223DHLffcdNdt991456333nz3/+3334AHLri2wA5u+OGIJ654p+BNvPjjW6LseEIsVg755QBe+7FElrOL+ecGXttySJMjxTPghSvksUCrG9B666DfxFzpDXXeW+y488dkTbbnvh/tXgNfEm8SD5S678i7d3rys73OfGHFt7Xu89RXb/312Gev/fbNRmtQEmBxL/745NO8fPnop6/++uzXdPyX6r3f/lJ4cWyQ/PMjhX/+/Pc/5vm10gsA74KlHO3Pf1wbIAIX2BwFikh4DAybAyN4qQnWa3QVqV+LpIcz3+DFgxR84EEg2LWdDMiEsgmfCr8SwhYWh0YqiUlTDDDDGrrwhnGB4YxqgoCB9FAgPzRAEP9xSMQiGvGISEyiEpfIxCY68Yn86eFKwjfDOc0wfBoJohZ9GBMsUuaKAwEjFMdIRkdNkYtAhIwOEbJGHg5Eh23UihfNUkUh0lBpCnpSeBTUEwNYUCh95A6NkKRHuNTRKis5pGEUSRMkKUSRK2FIHMt4kz/CaI5DfAiS6mhDg+hQkYPcoUBodEaFTPKUYSzISnrIkEg+ZIsQ2eIqU+nJjCTyjhCZ40smSRBUYiSTCgGmTlLZFAWsMgGKZIguESLMZUaEl7Q8SB2hiRJRPkSXjExLAsD3QQMIoJAGCeRBxKkQcuJENejEiDk3KBBzWlIgfGyIjAr5JAW90wDrDIk7M3L/T3Pmk3IyEsJOtunHgcQTngZtyD3ZSUCEmmShcwlAAoAAliQoIADtEqZDsrnRi3AUlxlx5EWoORBxJkAB4DSAjD6KEJbWxJUdJUkro6nRN6aSIX0RgjEnikyQkqimGhGpjwwy01E2xKWw2SZBlzABJQhACOcECUS/l5GUSuSeVi0pQZpEkKxCZKofAatRkrCAJRhAoNzEEjITgFElTGEKExCCABQZxBnWlYXB1JAdDYLUg4h0klTUqw5rSqJJ9tUh4dMiQQ0wBbvAMUM2dOldZykVw24kKJQFaRunKIElUMEAC5CoRFcCRy6S1qZ81WsmIxRNU0ZEitbspTRna9Ra/wpkJ9MsDDe3uQAqVIEJAxCAVgWS0vCdbpKnq+diUatSgiy3tvhMKERSGgSw1LOgDGVMcp2UUIsa4LMKgCpqsprSzBD0dP+8LVUp4tWGJqS9OhngahTURilQgAkNIEICqpuT9raRQ9LFrnsLMkfqHkSHeYwIYwysEPjGhaIAYKsCPMsEKghgACul4UAJMkNS9hSvQbhoalyZyLUOs7k06tGG5zjIDRcEminZ70AYwsoNX9S5Ovmki4cpYw67uLoNse4OI7yTJSxBuDrU40CfJCS2WteZHpkoSHOM4+YmRMYkJbBR14jFTxpkoBEm8Q7/OwUm/JYAGJVog3G8YkjueP+FYTQxarEITpSq9428AQsMXRxmFBvzzjTS4UyFOhilkpUK912AcHcrI7sId5goRamhmztP4YbXmuCLr5UF8lRKK7XOX1mNTq/pXTuHer+XVnF1ldxffBlgRazui6VVfdaBzFOlEzPhk+a5ooP0mNKu/ghU5+nF1Owai+K1tUp/3SNTexqhDJZxgr/CXwG/+tavVkIFmpDf/T43IcmurkSrfW1cB0G431w2N2E96fHaetL9DS+88bXq8Nk53N7+IH+fa2dyFyaxzo0wRj2L6AvrROA3lrU1MaqTnQR6ZIru9W1FG2lH2xSjCMeoABTwaDxjNKcev6OOI4yaFmNURkj/vihbh7nnh2d7q4EGS8oVkJo2MvzSBEEAixcu4hBzGa8bf/UaM5qQYtJIAAvQadC/HGh8QVPpk7uxSkyocdRIXb1zVMAChN6XHY8s0gqYgJmJgGYn57aNWtdpmm8bYtlCdeNNjzCSZyTnNN84zV5fe3XBcnUYcrzWcL8xRXu5VtKK+LY9hSlzoayVQoIPCbydAhWWENz9IgABONo6BeZV1qRvM/ND2LpAKLCEsoZXABIFX4iVoHmBlN6pwuUv6Lfe+VFm3gATcL3pN57sU5MVtOFuEut1KntrSdqirDcrQUovVwF8fiBbz/3WmzQEgZR1IKXn9G1zsoTUeBdfSphA//YH0nHUhB+uBbk+QyuSe3x1HC8LqD70ldBG6YP21Uufl/WZyvyut5WruSd+Sdd18ZUhr5d0qKdUJ5V81sd6BtAA3KZfqVcQeqR+Agh8CYh806cb0td9zgc+ySdvaZVt6jeAqcdb/bdbJChXOmUtEzAFAiGAvMdbsJdvAxGCJ2hPhQFhyDRhVFBhAzAAEoUAEeBWyod9U7AEFBB6GJUEMLh5BqB8k0cFDqhybZWEBDF5RzYjCpAAdZGEpEcFkudYOIKFAzGFWsdwN5UAXshYpedhQQCDkyd6cid+U3BSV2hWMGhWFVZ6wgUEOJJ7pMdYc9h72EeIZiVcRJZ7DGB74f+nfFAohX2xUhKmHMr3hBQhTEc4EFOwdYGXEKF1VjC4HKFVc1xlAEyAfXF1dW4lEDC4hxMAdwRRF4yFfZsXcaOVAEKQhGJYEE1QAWSHccuUAOL3WQaBi4G4BJhYi2ZVeiHmhZ4FWgLHd8UIfXYHjZPHACFGcl8YLQz3VlOYfhvnhW4lBKFldsnBizQXZlKmEIRmFobWW6QXhJ9nX1Twgy/4ghRABRXABAwwANskAVOwbQzABPkoeVTAAJSHVhN2X/jIWJI3BQwwBAKwcecHgftIAZ0YLUrAAIj2WUw1BfuokMH1ZSA4AQk5BCpnUVNQBVSQX2fFWwbQj37UJIjmei//eI8NAFxDsE0vaABNMHpwxYAzaQBQ+F0zyQQE0JMWJQU7uXXb1IhnWIsiCYNEEJNkpYSINor6CH0eMYpRGIScWAENcZSMlZHM91SnWBD3OIAGMABaCYVwNYoTyXEoeF/7KJSoGH+ohyMFSZZ2OIpWEIHtVhDnh5b6yI9MkHQBYI4iiWhMoJGJ2Y/hpQD25Y8qOYFkJZGpGJlpCVVKsI/96HmN9oJJV1Yo2YshuY87SY/2JZE9OW4+OZCpiFbftheuREVrFQCddY8UEIRNWGZVUHphZ4RcYGb+2FZb0ARW4I+sZ4Q/SAEX1lb3OJwLEH5uJXn+OJ1SMAVcwJyeOQE0/ycEYjecjZh04vdbvyl6QSRaXnGcDHBSEaYE1cltFQkAvZmcZXiPS8AAUBV2ntUEVTAEQlgXvlUFRqmE0aIAn/VbZBl9ATqg+OKEBlAFcsWbnlUFVqCgufdW8KkSPlihTMUcXTA9dlRHQDUQ5LkEXPBdAyB6BrAFBTGKrWiYxZiK41ejBiCVjzh5FIBRA/CDw1lrj4igDAB3+WmdwkWfqciEF1WeznmdHsqcRVAAoqVneuWE0XiLACqkBEqdVFCipHedN1oFrBcEEoCcDCCMrveDCnmPVKB2KCV5XdAETcB6H5eTzIeI4pl0UUgFdvqivGkA8CmMvKkE8FmROkdkqv8UW3MxErt1aD9YeSRDmwswADgSiPxImEnwgg7QBAxABCJ2fmeGqefXjyWJfC84mgCZBPv4qQoJfgvQkv44AGf1VLPajxO5aZGqj0wQXgFwaBVQBZT5gQXZbZ0qkuNHglMwmATQqrM6mLvKJFMAgb/1d6/WkpxqmVXQBFCZBI04mPFXa0YpEEWwfax5lcmmHN6KEAe1TDmRLlKJIAbgAAcxq6j4ljWZEyK5oxRJnjCImSbEesrql/wIWiWZHL01mhYpmotZkdlWAS8pqjo1kKCqkqu3qoQ5gb3xmny5pGU1rG8ZXgtgZlWgkH4qrE3QVDiClsBKI6GZkERQVvfoTWr/iZDbhoA0oqwKa5SftXEQW1awypQomV+SlrGw+VSF6WBX0Ul+tZs+CIQFKgVbsJ1COKqAWgXBiCPL2QADgGYixqAC+rUB8IKJerVXKKChB43f2QBCgLY0ywRNEIRAG15Z64/EFWfUGZmBF43d2gCgFQRSoKbfqHwl+XEUwJwEQAAAMGFta6u254TMSXavNkq5VwVFQACvlgDLObc0xBbcdn/B9oDe5DoVSgBSiRqbmBEMkLoGwaNAaQDyt38t+o+Qy4lqinRKULVee7s0J4Bhl7vTZ32AGoUL4IS5a6uoF4V/u3EKcJy9q4ZuNbllR3KpFIdMZY6yKAD3ZZ0DJ6QL/6BojyYEgFoBeOqDiCanSSAFnjUE/1iQVBC+Hyecv/iGfRGdSme8tkcj5NsEDqCUDPeDDeCNcyqSobdxPFhUihGPN3mpLZu0H1iPLtkABBCQU+AARUCP3CQBUrBtBCCqMfuPEAt54NPBtdqyVOAAFKtUMQuBS3lWp7kEwwqTvsaSbRlc/ZmKRlmbOLJtyLpYatmCvWUBFzubEKho6maZ0jq7qweBMNmUQPmtjWi0c+ddn6poCdDBOwpdBNGu1qYRZpkZopcT4ZegYpkZeYmjgkh5Hbd6AjOTxApaZsWRf+mt3dfBERh/OPeXv3qRRDAAPSkj8erD+jWC7AJ7KhqFw/9KerjKBAy7vBYlw97qfEEwq2KIgDqlhP13fhMZhLN6X3sZhO4bmdfWJG9XunaxBLDaqgogkg+Lq1qJgPsmVlIRWULEU99bcEJ4o0eagKknnIvbVo8rhGy4TVPwi4ubALyIusJIZGn6W2vaWV1QpYrIVsVop0QQlFHIi4S7cBrWyp4VvkhnZkvABGbGesGrtYwrYY+2dWDoWU6gwmhmoPZ5W0TWuUSwpjXnFZhbAK+GF01QfQjQWUAJuPgynwUNT2OBoJqrEKVDhARxu6orEA0Asy1q0AThnTtqcCv3vQ8IVQF7pAsgI3YnELvInNymhLXYfkH5esf8t5o8EGYGlM//CajRu1NeOHYMMI0xtL80F4W+qKQKMAQ/WAGBtxLpDFoYtYuSp9Q4MoVIt7OJ+qZKONOKVrLmaXdIp3XNKIdN4ASLG2Gt3Iel6FlKKKgq12fKxFyHpRWPx1v8GVyt/IITWZGGZpn9iKwvmF8DYJtN6cGY+ph1/WgJgAR4HZk92cIEIG+GfX6DuZNIGZEZmYrhwxA5AYicTHkV6o+xnHz3NZGFfXug7FmPKa2tutdNgK0B6ZQXi10JoG1V8MR43a5R+ZKVu2kCEZRCwMEMPUK5PWCiQWh9dLAcVAQwGohmXH7WR5tROJIEClULhi9LUAUI2gT72JX7+FvoabHbto/G/zgQo4l7A/nHrToQrN1tHGtQmReX3yWHw/qPJIucWCzIDbmYRwazq0qgtnqT8ibefN2ZY9qvgEyQTImC4peXo0jEoN1WaPlUHkl68lZt2pUYPBhiBPebu+yd27lTEYa86qyc9jkAEUZRklsFixuH90h2cLebgwvNGEoFBVDROyW43mmn+IWUnwWG7tvTeiVwvdmfA3Bfc0vVcfubBKBzWpqvbRqgYM24jlvPJSa5DvClGtaG/axpgaohBB26Q7YTMipdJj5nDgE7EMEba0oQGK1S3ckF/WlweMaiO7oAb2q1vZQaAnDMBa3SufdZn627eC63Kj163+WPUAXntltdHf/e4sHIUxymUjQ7lTIt1EFuZkctilbNcGteqwqppMu7u5quyXH7vqe7zsRI2t89EE1gAYuOoWx+1ZvNhRjFg5HBwLdokW9V1349YT5cwQhSrX8cwX+tlJgqBWI42Mu2eu+d2OmqcpB3kZi5Vcnnp+tlwbrqyDypj0uAkcD1gRqbaN1HsAp+2r4u7fUIgf/o2ud9lQgyFrSNF0Z7a/QaxaxDlo14daAFlg5lugKhHJmRL64rjgVVxvOY7wLxWWrsr30N7eTqw9nGVbUXXgIJzTO7ibQnf3v9x4EMFkrgxPrlbz0RspCpkOstsv/Kx4zZbDIcv8S3EwJZ7UcsUPzF2/7/SMoR58rHuqPlbbGJxpGKXMTchO0lC4Gya2i3+W/ORVEvjmj0+IJl1svC6FZjB7a7y21ByI6SWwFkm5PbKVxORoxqKrhLMM0FsHHOPL0N4OZafdUkUkNFOIpEAM0Xhqh+a7VIEAUa7rVHyoXTawHBjCNte58ask2dOwBnjuQLXaX/XNDVh59mFbqH99oyatDrW6FXWVtPLVsD8eWlcBJgcba8woduO6tn63dPAvVGWtLeJHowC8xHenVIl3KIil/AaWKKXr3tiH0/GL+KdrXjLNRE7chyyhB3fuk3dvXZXKFvK4zKjJz0rnWm78hUX6D0+YsHfHgTYONrWokIOQRy/yu7xMyOkhGplszGOBLx216ZrLepyCqQ+eV5JDzbz/raF1+S51bJtAnarjqxl0bC5h9cACFAiIAACpQwWLJgiIEkBhwicegwQZIEUhxWYEJhiUAJUihQsdBkgQAFQhJEmTKlAZEFAwwIELhgSkgGAyZOUMlEgQCJSDo2aMJgYQCJSSpUaUCAYcUqIg1MNEClgc6IDiU4FCngZFQDCw0EIHow4oKqZc2eRRtRY9WpC4REVGJgikOXBoIQNbDkI5WIOA0wcYlXyYIlVJYYpEIF4civMZcwMFDSgEcmQmHahUnYoUEJU6owITCgZIAgCqZUaLIyQQCoZSdQwTjyshAFS/+Odi25gMnnnVCT1KbAZMJh1g6lfJ76d6TvyQyY3DbgtuJR1BgHaE2Cc+p1gqRlAhWaIAhUj1KbfB5gk2LDtO3dv4cfX/58A0ASAFhdOzGV9AWVbNktoYIEGI6LJiogggD/tkhNgAHwsy8JBqsYQEGDuKjMwYIKKuy5IWySYAkDGygIvwXPG4Csr0qaIsAFEkjLvgQkYMKAAx8jKYkWu2jCigUWKAiBjjCsaYANCTPQCgIIwE+JEXlyCIEIktCiiSaGANIA/GY0oIoiGsBPQitdAiBE5CIDQMsE/kstyqscauAth4Ro0caqYKTPPcPgigjKFf+jS8GqEnOIgbAArAD/S7zy4iKquDqsIMWCHOrQACUUSEKK3TIEUoHoOmSgNCVarCLBDS2l4rwEE7gPz4hCpCKj9DSMLNYqoiNpiFipUECBEu1qsYLoCpKRxqZuZUAAIFvNdFNkYZpxtx4NSBZEERs00lfEeqwMQlaN5bZI/CDMs1xzz0U3oolumkIj6ZLoKLHPCJPpo5AKIGDNzhBcDomJOsIoPHhPqyy6wfSCjYnllNCOCAWCKKqjKqigwKGDF6BiYoUigsihhijy16Mqmtp4PCkSC2kksNgN2CvC7A1qCJZ1knOiCI6L+c4kGJCKCIZujs3jijF6uKqrMKpKN4cqLrRGAxxoIt32apSz/z0FTjagAbP4is4kAySmdomI9KLUoHoVS+jRj5QzKTuKFT4sLgM+0qjo8oJbQO7XmhK4taQ9qywhsZfYuwqNYnrbIPE2U2Jt2sZrqLyRhSqJOWozroJy1qL4yIrMh4A2O4IJM8hTnKyIeV1/k/hocizb9ltq2Wc3N011TZRAicQo0FCBGZf4rIopDLPVSgIKWJBT+yIMtr+HSa2xsMISw3GBTEWsjFg1o/3MsLWmIDLFKMsCwgAE7jN2ZAF9N7NBbcv8b1OmpU/VgiHyzT3WOM1XU0ImmkhIlMSjqVIx4HyZ6tJAuPQXyPhOIoBqgqfmRLs8ic0sNfITjODVJUoxzf8AXUiIsqqyKYfMZWydIhDwqOcQDOWFAbQhihBsJb2I8GV9lLLV8EqIIWSxhly2sxSp5kY2vsxwJArQFcUupT0dMYEvncLP14B3Hmpt6D7mi0BhRlZFBQAgizyqQgh9lbspnEcvhBsV+M7TrQScDwhZPFaGBODGNpLvKRTEYx7Lwh7xTMQ0U5DCw9aVBMI4hwpTGM5rUCOwjuRNMqszyHB6sx6/RIViiDwMSdqGE0eqi5JlocDwptDJPe4RKu2Km11OaZiiPeU3UpiAQ7iGE4OE8l0dqVtZOpIXg9ilKHJxy1IMIEmPdWY4vmwPROTmwbIoTI8RgVhV4hLN9nhQRRD/Y08J59aXS30lMnFJiWsic0cYRdKEDomlJNvGkKvhhGvDHIsSBolMxrlzm3PJm1wmcKmGLGEKh4EcOxmWtsWNBTZUUMhqLHe1Q75rIvWKm0J/k8ZQ8iWRFpRIQHeWMEuRZp4OKd8zRfpM++BnPArYZyzrw6rcDKFiUzhYqkplIXgpAIoJiFDujviUggRhn3kxzD6PuCEy2nRR9mGNqFTaLobxZFK+XBRIWyWXhJTmKVEU6qmeotSooHFF0fFUQWA0mHH27yr79FVEpCSXwWzJUhHBD0oHs6goWkpF5ytrX6rSps1Q0E/S9CZaHlWWvwZWRYXZTFojYjocspWeUTQI/0z/adEl3sk/x7TYAjxFEm9F1S692uc/KcCwXjm2NASaqyDTFAQlMKw0rAkpUGGjKNXW5ytkJIkPE0Cn1JaonKOiYVyEoKK46BY/unpOZIjVqtiO1Lki9Y2n+tgQsvKkJJIBXHg8JplowsiPl+quK+FSOmpqVIJV6Rhz4nKpac7HclUpXXuyKTeJ5HUz2XzIeAXby469dbHvaQg17QtKsRVWalWjz3mhGTv4mkXA8KWvQx7sMT5VZTxnkSB9o9lKhqDFU72k73qku2FyfqyvqiwLxvCmlYDmd5zn9eM310XhcTpSwx3Gr0N0QzQWf/S5P06Xq9KUJlY5xIozup5scv+rHyemZ0v5eapJodzFqfYJqtpaLk8Vyz913fHELx6ybatSvuYG1nzlRBNaXNXgzeC1LEC844fHB2cFIOAsa/bmooiyKGXC1CwqAvL4zEIUID61LEWuCl4k6Fkjs7mwYW60Qx5dlj0r2CxpcqOWKG3pO69mM1HE6Yro6ukAwApHvlKooEUtQRNpyyGgLt+GdpIWOgMve6jWbVXgHGhewyeb1PzYdONV4AEMd24US8hbfg3Ns2Szv8uWcESgnZby9jraDnYPNftblRyjq9oUpsRaqmLBiklwEngENrPzNOGyfLvDeWQ3WrTtnm7T8z3blrbZbMMX2Dk7XdOWt74nRrn/8bTY2geXDxDTVD7bKRQAmNoC1xBSIyNe5ix0pbWmE23mQp9l1xamD1EgxmgzYxzkl35zRBZlZ4bDVeMqhzk1y/weITXTLF6x7Sb0uNp0tdxcMo+Iz93jWZK/2pvlY7mZ0aJnmAsdpJRWORmHV6MfWdHpHoe50eV9dE3HOrIdQminYHtFhJc9yCK2yDv34y7wmt3tb88j2ZYmS/n8A+53x3ta/D3M4fFFYf3udTQ7s7tkz7Peee81EPFs9HGJ57xF9KcY01x0lyP94kMXs3w8i2mXa/3lG/d86Eve+Tte3fIz1zTTB51yhavVtsY2S8UAnRa7z0719Ol4e26PloWf/6XMuT80fH5vW6bH2j2tF/TX55Is31W5vnP2vZehXubNf90wsjFuqD1bvsUj/sf49mSMdcxeTj833mc5f3wO32w9gt/eI21N+d9Nee/3ev3oun+7zVW6uFDkwmVxPwraNv5bCo2qvwOMPhOBJizzpo/Lupejv4yLNATktQjME7zoPvdwBwOoPfq4ugmsHdIDvrsbPtvDPKuCsZKyI7NAPbOwM9FbvdfaMhVsQQo8QBODmPSzwR08wHnjwR/Eu2XTQWtLNxoDwkCDESAqsxfkMjVZrD0TwdSzrd6DEaFzFUIjvUZDvV0jOSa8k3JRvMtrtF3zQttKOjW7vDRZFCF7QP+mU8O0sEA9qkGjY8IzfMAqhDoQjJGua0LgW0NNy0DM08MxC7rPuzOV2zJMIzvSK0MYTDnjm0A3dDk3u8I2PMQjpJ38Q6+zCEBM9EQB5Bh1+8RRhLd0GcKD60RSVMVVZMVAm8NWhMX5cEBHvLtZjMVbxMVc1MVd5MVedEXp2zjUK8FCxDPu88Ud3DVbbMRCPMYjtEVaxL2Uc8RARLnVi0TSo8Zm1MZt5MZudK5T9MZwFMdxJMdyNMdzRMd0VMd1ZMdPRL4ptKNnVLp2zLtltMPYekV6fC6h6735kETGA8Rz+cC0yEZ9NMiDREi8YzdNTMiGdMiHhMiIlMiJpMiKtEj/Z8S6izxCYdRICpLHfqQdeYwPSOvIkjTJk0TJlFTJlWTJlnTJl4TJmJRJdnRAkZzJm8TJnNTJneTJnvTJnwTKoBTKoSTKojTKo0TKpFTKpWTKpnTKp4TKqJTKqaTKqrTKq8TKrNTKreTKrvTKrwTLsBTLsSTLsjTLs0TLtFTLtWTLtnTLt4TLuJTLuaTLurTLu8TLvNTLveTLvvTLvwTMwBTMwSTMwjTMw0TMxFTMxWTMxnTMx4TMyJTMyaTMyrTMy8TMzNTMzeTMzvTMzwTN0BTN0STN0jTN00TN1FTN1WTN1nTN14TN2JTN2aTN2rTN28TN3NTN3eTN3vTN3wTO/+AUzuEkzuI0zuNEzuRUzuVkzuZ0zueEzuiUzumkzuq0zuvEzuzUzu3kzu70zu8Ez/AUz/Ekz/I0z/NEz/RUz/Vkz/Z0z/eEz/iUz/mkz/q0z/vEz/zUz/3kz/70z/8E0AAV0AEl0AI10ANF0ARV0AVl0AZ10AeF0AiV0Aml0Aq10AvF0AzV0A3l0A710A8F0RAV0REl0RI10RNF0RRV0RVl0RZ10ReF0RiV0Rml0Rq10RvF0RzV0R3l0R710R8F0iAV0iEl0iI10iNF0iRV0iVl0iZ10ieF0iiV0iml0iq10ivF0izV0i3l0i710i8F0zAV0zEl0zI10zNNF4swC/81LQs2RdM3hdMNfZM4hUg3pdM7xdM81dM95dM+pR07paB6Y8jRBFQ/NdRDRVSNLNRCTdRGddTwZNRHldRJpdRKtdRLxdRM1dRN5dRO9dRPBdVQFdVRJdVSNdVTPchIhT9U7UWbZNX6U1VmfNVZpdXHHNRazbtYNUJc9cSChMw5TU9g5dVh7ck1u1VipU5hNTtdRdZm9dFsOlZnldZppdZqtVauVNZr9b5o1dZu9dZvBdeo3IJwJdeElIRyRdd0Vdd1Zdd2hUhuddfZycd4/Td6tVdxFFRZvdd9XUU+CrQo4NeA/TE1XbxsmtdyAViBxaOEVdiGBTJflRqGtdeClVW8eIUPhpVYh9XYNpU2q/iaA8zWjRXZkBXZkq0/izXZlO01iFXZlnUulHVZ+mDZmA0+eqPZm327g6VZncXZPTQLaO3ZoBVarIycUmLW6ixabpsMo2VapbXTpO3Yp13aoaXaqvVMqZXa7sTapo1arqWwrXXaUrJau2TTRQXPsh3b1ZxTkiXZ61zbtG3N7nOVtvXOue0yj32+j83bObXbvb1bvS3Ltz1PwYXb2GTD78xGub3EmmXcLzSLmT3HgAAAIfkEBQQABgAsGgAAADYCUAIACP8ADQgcSLCgwYMIEwpEorChw4cQI0qcSLGixYsYM2rcyLGjx48gGwIJSbKkSYQABo5MmOCky5cwY8qcSbOmzYQMERRcebPnS4Y+gwodSrSo0aNIkxbVqbSp06dQo0qdSrWq1atYs2p1qWBg161QJYAdS7as2bNoZX410HVt2rdw45ZVkKSgEoFu5cIUq1CK3r+AA7/1K7iw4cOIEze8q7ix48eQI0ueTLmyZZeML3ckPNAvZ82gQ6f9LLq06dOoCfI1mDm169ewY8ueTbu27du4c4uuC7ulwdW6gwsfTry48eNT2wrkfZA58ufQo0ufTr26QebOrWvfzr279++Bs4P/H0++tPjy6NPLzau+vfv38OPLn0+/vv37+Kuzz8+/v///AAYo4IAEFmjggQgmGBtQBjCo4IMQRihhgcAtNBBDDk6o4YYcdmhfhh6GKOKIJAonVoUFgVjiiuDVxRSLMHYnwXkx1tgecynZqON4Ku7o43F85fijiPvtFxxvMzY35JLSBcnkk+jRCKV/rQ1UpWAoTqnlllx26eWXYIYp5phklmnmmWimqeaabLbp5ptwxinnnHTWaeedeOap55589unnn4AGKuighBZq6KGIJqrooow26uijkEYq6aSUVmrppZhmqummnHbq6aeghirqqEhJSeqpqKY6JGmqturqq7DG/7qjqbLWauutuOaq665wkcYqr/IZCeywxBZr7JHHJqvsssw26yyEKEqxWpbPhlkXdtVmq+223I5FbbfghivuuDB9Riu5MbY27UHfouvuu/DGS9C58q6obr1eXovvvvxeBhy9/W64lrACtRvwwQgnfOq/Cg+pxFoGNxxidgBLbPHFQUlxb0MVY0yhQFIQbEDEHh+ob8kop4xVxyq37PLLMMcs88w012zzzTjnrPPOPPfs889ABy300EQXbfTRSCet9NJMN+3001BHLfXUVFdt9dVYZ6311lx37fXXYIct9thkl2322WinrfbabLft9ttwxy333HTXbffdeOet99589//t99+ABy744IQXbvjT4pF8+OJbnqx4QllGzvjk/mGLUMe+FZQ5QZtT7nnlA53c0+NHXRn4rxJJ/hu7n6vVl2oddS6Q7AbQ3vrt8yFZk+q490c617+blPlaw/duPJXHw2X67qwnHxjxXg1ku/PUV2/99dhnr/32uSYh+8Pchy/++DEvT/756Kev/vqaFsn+VoxNcOUE72clcv3455+m+eTyryPq99Pf1/wnwAJGh4AjCp4BvYbABXKqgf1C3UcY4xYK4gw4jMGgAznEu7V1pUIfpM3AooeXDZqwOEIKQExUKBAWGsCFLjyhDM3yohfJJHNCwuEMd8jDHvrwh0AMohD/h0jEIhpRPinhSbhiaJgcDsSJRwwYE6NYOBfq8DHTE4iQbLJFpGRRMl/0U49qwzLoBEFJWSmjcVI4EJ0oET1vJMgUHzJHl9QxInd8ShfLkkdgqbE7f7TRG/uIEBsexIWG1GJDoGiAPV5kjkwciQodaRAXstEgQkqJJp9oAEkmZJOzu4gnPRJHPGZEhaWkSBgbAsODULKRE3mlQ1KSyNoVpIuTfGEbO2lLRY5ykbBs4UAIOczDeK+XAjnjdS7EzGRq5TzKfAiD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mtgETftyTdCsTdFEzdzEstFkTeuLS6DYyzwd/M3eVECP/MvDtEHjJM4GnEvlPELnNADolE6emE6VqM7oPD7oLELtXM4HRDYfJEjLGzIbG0+fEM+2CwgAIfkEBQQABQAsEwAAAD0CUAIACP8ACwgcSLCgwYMIEyYEorChw4cQI0qcSLGixYsYM2rcyLGjx48gGyIJSbKkyYgMBQJQGOGky5cwY8qcSbOmzYRJCiQoOPKmz5spfwodSrSo0aNIkypdWmAl06dQo0qdSrWq1atYs2rdytWjhIE7u16VIras2bNo06qV+VXg17Zr48qd21WCkoI5C8Cle1NBw718AwseXJew4cOIEyt+mHex48eQI0ueTLmy5cswG2MmCfjt5s+g1QIOTbq06dMF/R7UjLq169ewY8ueTbu27du4W9+trTp17t/AgwsfTrw42t0HkRtfzry58+fQoztErly69evYs2vfrrg69+/gT3v/D0++vPnz6NOrX8++vfv38OPLn0+/vv37+PPr38+/v///AAYo4IAUBRUUgQgmqOCC+/U2UFA5scbghBRWaGF7B16o4YYcdvibXw4aJKGHJHIXRAEBlKjidgqMt+KL550oUIYw1pgdjTbmaJxqOOro4227tXiQjD8WueOMRiap5JJMNunkk1BGKeWUVFZp5ZVYZqnlllx26eWXYIYp5phklmnmmWimqeaabLbp5ptwxinnnHTWaeedeOap55589unnn4AGKuighBY61Wh6Garooox+hGijgY4IqaGPSjrppZgSammmeW7K6aeghirqqKSWStCjpqaq6qqsturqq7DG/yrrrLTWamtEnd2q66689urrr8AGK+ywxBZr7IQhFqBEb8keO+Vd1Dkr7bTUVltWs9Zmq+223LJFkIvd1kjWQMwehG246Kar7roGgcvuiuMKdO67P0JL7734bhavsvm+CBeq8vYr8MAEy7qvuwWTKAVc8ya8YXUIOyzxxEdJoNm+CEVMsYCqKQFwAQ1vLKC9Ipds8lYan6zyyiy37PLLMMcs88w012zzzTjnrPPOPPfs889ABy300EQXbfTRSCet9NJMN+3001BHLfXUVFdt9dVYZ6311lx37fXXYIct9thkl2322WinrfbabLft9ttwxy333HTXbffdeOet99589//t99+ABy744ISb5F3IhSfuJMmIK9Ts44pH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w4cQI0qcSLGixYsYM2rcyLGjx48gGwIJSbKkyYgABo5MmOCky5cwY8qcSbOmzYUGEBRcebOnTYY+gwodSrSo0aNIkyoVqHOp06dQo0qdSrWq1atYs2rd6lHBQK9crUoIS7as2bNo08oEa8ArW7Vw48rdqiBJQSUC3861OVahlL2AAws2+3ew4cOIEyt2iHex48eQI0ueTLmy5csxG2MuWXjg386bQ4smPLq06dOoFfY1qDm169ewY8ueTbu27du4c7+2a7ulwdW6gwsfTry48eNkeR9Ujry58+fQo0uf7lA5c+rYs2vfzr274uvew4v/Rw1+vPnz6NOrX8++vfv38OPLn0+/vv37+PPr38+/v///AAYo4IAEFkgRUAYgaOCCDDboYH/ACYQgQwo+aOGFGGYIX4UadujhhyDqNlaEBXEY4one2dUUiixuJ0F5LcaYnnIpyWhjeCbeqONxfdW444/D8fbickAW6VyPRiap5JJMNunkk1BGKeWUVFZp5ZVYZqnlllx26eWXYIYp5phklmnmmWimqeaabLbp5ptwxinnnHTWaeedeOap55589unnn4AGKuighBYqlV55Garooox+hGijgrYGKaOPGiDppJhmquilmvLJaaeghirqqKSWaupBoJ2q6qqsturqq7DG/yrrrLTWauutFaWaKq689urrr8AGK+ywxBZr7LHILkiiFKuRmOyUdln37LTUVmstWc5eq+223HYrE2gwemtja80elK246Kar7roGhctui+S++2S08tZr72bAuXuvhmxVOtC5+wYs8MCq5kvwj0r4ezCK1+m78MMQGyVFvBHb2JcUClfcIb0ad+zxxyCHLPLIJJds8skop6zyyiy37PLLMMcs88w012zzzTjnrPPOPPfs889ABy300EQXbfTRSCet9NJMN+3001BHLfXUVFdt9dVYZ6311lx37fXXYIct9thkl2322WinrfbabLft9ttwxy333HTXbffdeOetN2zgAf+8999Qcuy3Q84WDvjh+0mLkMME+VaQ440jLvl/0jJ+0uCTH7XrRIb/Zu5jSUDuNGiYQyS6QKcbkHrmrMsnZE2dt/7h6Zab7Thbt8uu+36f7o5b7L4HhvtXA60e/PHIJ6/88sw37zywobOW8fPUV299x71fr/323HfvvaiPTv99VI1NcOkE49OV/vrso5l9+1Nt3hb8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w4gTK56Yd7Hjx5AjS55MubLlyz4bY3YJ+O3mz6DVAg5NurTp0wn9HtSMurXr17Bjy55Nu7bt27hz382tumDv3MCDCx9OvLhxtJ4L7D64/Ljz59CjS59O3eLy5tWza9/Ovbt3yti/i/8f/zo8+fPoD4+O/Tu9+/fw48ufT7++fczm7+ufvB51+/0ABijggAQWaOCB9OWH4IIMNuggUUIJ9eCEFFZo4YUU/SdUTqxh6OGHIIZooYQilmjiiSiK59d/BHWY4ovxBVFAADDWCJ8CCtqoo30yBrXjj/ORCOSQ26kmJJFIOrcbjgf1mOST2hkJ5ZRUVmnllVgSl2OWXHbp5Zdghsmdi2KWaRqLZqap5ppstukmYWS+KeecdNZp55145qnnnimu1x+fgAYq6KCEImneloUmapSfijY6lItxOirppJRWFmmlmM70Z6acdurpp6C6BmmopHa0aamopqrqqqyedWmrsMb/KuustNZq66245gogorr26uuvcp4K7LDEFmvssY7yiuyyzDbr7LPQRvtcZ9I2KOxP11ar7bbcdovfe2h6S6my4pZr7oVknZupEr2Fq+6bd1337rz0pvWqYuTWu6e7+vbr778AJ7ZXvgFPma5A7R7Eb8EMN+zww1ARDHGSBxew8MRfxovxxhxPV7HEHdcI16kXh2zyySif/HHKYUqRLctPYgcyzDTXvJZmFduMpWpKvKzzjxr/LPTQRBdt9NFIJ6300kw37fTTUEct9dRUV2311VhnrfXWXHft9ddghy322GSXbfbZaKet9tpst+3223DHLffcdNdt991456333nz3/+3334AHLvjghBd+1L2GRzmQz4nnhnjjkEcuuUX8Mj755ZhfbnnmnHfu+eeghy766KSXbvrpqKeu+upRz8z666yyKDvstNco70azG1Ry7byDePtAj3+0e+9UbU5QzgIhX4DyyhOP7eIGNfffzLn75vz1MA7fUfXYl6h9q8a71xtc4589QffoqzkFccGbxHza34tHPvQIh73++elHF3/+WuGv0G7+mwIAB+I//tElYQYETQETyMAGFgyBFmKXQZIQlqot0IGu2R8G0XJBgQxwIIeKSPs2WBTuDcSEbjlI+I4zQhK68IWQcZ0HV0NDGG5FgzYUTAijFxEZJsSHtGNUDv8NkxcJdGiFPNwIEinSvPQt8YQRQWFJpDhEjexQ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AwseTLiw4cOIE6NUorix48eQI0ueTLnyxb8xh1rezLmz58+gQ4v22VZg29IGNBtAPbq169esF8Z+Tbu27du4c+vezbu379/AgwsfTry48ePIkytfzry58+cypUCfTn3v26aYq2s3WvD69u/gw4v/H7/cLPmWs8+rX68zO/v38OPLn0+/vv3b6e/r38+/v///AAYo4IAEFmjggQgmqOCCDDbo4IMQRijhhBSu5V2FGGao4YYcdujhhyCGKOKIWLlH4okopqjiiiy26OKLMMYo44w01mjjjTjmqOOOPPbo448iqgYki/mtBcCQSF51YZIrHmUik1AitWSUVCbFGF0lVanlllxWdCVBU8wVVpcoTknmmWimqeaaMn7JJoJmviknbm7OaWdHfT155311CtTnXn/uqd+UcULknp6CJppWkYo2ORZBjDZKX6AbRZpUoZJmaKKlmXbq6acPcQqqnKKOauqpqKaq6qqsturqq7DG/yrrrLTWauutuOaq66689moYpr4GK+ywxJKJaLFUlorssszed2yzO06ZJ7Q7nkbttdjylx6l2do4bbfFAauWteA6KG65o0o3kLLocujmtwU92+689CLGbr1s3ouvhtfJu2+K+v4r8MCt/RUwwRFi6i/CDDfs8MMCGQyxiu9OTOLBFmessWEYb+zxxyCHLDJ43I5s8skop6zyyiy37PLLMMcs88w012zzzTjnrPPOPPfs889Ab1Zy0EQXbfTRSCet9NJMN+3001BHLfXUVFdtdXMdxzT01Vx37fXXYIct9thkl222hgufrfbabP+2ddvG9XUu3La9TffdeOfNEaJz6//NW9Z+By6nuoL35l7fhSeuOIJpLz5aX4Q7LvnklGf4p92VR4Z45px3zt6hntMGeuh0AU766VFuHu9Bo6Pu+oSozUYW5mMWVDtBt7+ue4Wxt7d7WpFX1DpBw2Nl+tcK1Bl54wnlLpDzBkD/+/QMlsa8RsVTD9TxZKs+Xe3Xga/09dqXL+IE+2VvNPnHhT+Q+0FLx775lUlLP17Mo2/Q/PdTxX//evkfACXjvQECZgKYM6BVBAgfJRQwZAxU4GAiKMGsbCpiFSSM+tSXwQ56cFYd4x6oRFghDn4wMelJYa4oyB9CnZAulxMIAg2iP46QUEYP/AgL6+PCvb1PeC9cS6T/egepgtxQUEcMoqoSaJckYiiGDvpS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mSs+BSAE+tJXAfXNr33rK4D92re/+uWvfwUc4P4O2MAFBrB/FaxfBv/3wA4m8IIhTOEEV3jCFs4whjfc4At3WMMf5vCDQTxiEUs4xCgucYpPrOIWs/jFCDZxjFc8YxfXGMYRvrGOc8xjD9u4xySWsIEVEAQi12Sja5kncW6rAAEsQAELEMKTozxlKUPZylS+cpW3rOUuZ/nLWA4zl8E8ZjF72cxkPnOZ16zmNqf5/81ojjOb4TxnObvZznS+c533rOc+5/nPeA40nwE9aEH72dCEPnSh1+xkJwdAAY9+9AGQjJUD9WqRt6LvApbAACZ0+tOeDjWoRy3qUpP61KZONapXrepWs/rVro41qSmQalrPuta4vrWuS21rXufa17sGda+F/WtiBzvUw0Z2sZV97E4n29nLhnazmfBsakfb2tOutravve1sc/vb3mb1AoYwgP7WlZO7CxBXjPNoBUxgCVRgQhWoUIV6y7ve9LZ3vee973vzW9/47ve+810FfxPc4AIPOMD/XfCBJ5zhCF/4wR0u8YdPnN4Y53fGN67xjnP84x4POchHLvKSk/zkJv9POcpXrvKWs/zlLo85zGcu85rT/OY2T3m9m9BwTy9gAZHeKKUjoOSjlI5OCuA0ExrQBAs4welQf7rUo071qVu96li/utazzvWte73rYP+62MNO9rGbvexoP7va0872tbu97XB/u9zjTve5273ucb+AE/Sudwc4gekMKLcQaKmQ0hGF3QpQQrzrbQUnNP4KToC85CNP+clbvvKYv7zmM8/5zXu+86D/vOhDT/rRm770qD+96lPP+tW7vvWwf73sY0/72du+9ri/ve4j3wQHeFoAkN4oI4+SF9osaNMUqALUreD0vu/dCX53vvSh//zoU3/61s9+9bePfe5f//va777/+MHv/fCTf/zmT3/5149+9p///epvv/zh7/7403/+9s9//fePf/7f///6138CCID+F4D/9wB7x3xP1wSBR181AV8FYWkw4SByIRxBIAELEG9d4HgcOHl6B3kf+HwgSHkhWIIkeIIjmIIiuIImqIItyIIoCIMuGIMvWIM0eIMzmIMyuIM2qIM9yIM4CIQ+GIQ/WIREeIRDmIRCuIRGqIRNyIRICIVOGIVP+IMeSHlW0ARW8HvB9zROkReNwSBK0ADKVwV8p3VnaH1p+HxreIbT14Zs+H1w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